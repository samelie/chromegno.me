(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){

; require("/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/lodash/lodash.min.js");
require("/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/jquery/jquery.min.js");
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = __browserify_shim_require__('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

; browserify_shim__define__module__export__(typeof Backbone != "undefined" ? Backbone : window.Backbone);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/jquery/jquery.min.js":3,"/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/lodash/lodash.min.js":4}],2:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

; browserify_shim__define__module__export__(typeof FastClick != "undefined" ? FastClick : window.FastClick);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);

; browserify_shim__define__module__export__(typeof $ != "undefined" ? $ : window.$);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
/**
 * @license
 * lodash 3.10.0 (Custom Build) lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 * Build: `lodash modern -o ./lodash.js`
 */
;(function(){function n(n,t){if(n!==t){var r=null===n,e=n===w,u=n===n,o=null===t,i=t===w,f=t===t;if(n>t&&!o||!u||r&&!i&&f||e&&f)return 1;if(n<t&&!r||!f||o&&!e&&u||i&&u)return-1}return 0}function t(n,t,r){for(var e=n.length,u=r?e:-1;r?u--:++u<e;)if(t(n[u],u,n))return u;return-1}function r(n,t,r){if(t!==t)return p(n,r);r-=1;for(var e=n.length;++r<e;)if(n[r]===t)return r;return-1}function e(n){return typeof n=="function"||false}function u(n){return null==n?"":n+""}function o(n,t){for(var r=-1,e=n.length;++r<e&&-1<t.indexOf(n.charAt(r)););
return r}function i(n,t){for(var r=n.length;r--&&-1<t.indexOf(n.charAt(r)););return r}function f(t,r){return n(t.a,r.a)||t.b-r.b}function a(n){return Nn[n]}function c(n){return Tn[n]}function l(n,t,r){return t?n=Bn[n]:r&&(n=Dn[n]),"\\"+n}function s(n){return"\\"+Dn[n]}function p(n,t,r){var e=n.length;for(t+=r?0:-1;r?t--:++t<e;){var u=n[t];if(u!==u)return t}return-1}function h(n){return!!n&&typeof n=="object"}function _(n){return 160>=n&&9<=n&&13>=n||32==n||160==n||5760==n||6158==n||8192<=n&&(8202>=n||8232==n||8233==n||8239==n||8287==n||12288==n||65279==n);
}function v(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;)n[r]===t&&(n[r]=z,o[++u]=r);return o}function g(n){for(var t=-1,r=n.length;++t<r&&_(n.charCodeAt(t)););return t}function y(n){for(var t=n.length;t--&&_(n.charCodeAt(t)););return t}function d(n){return Ln[n]}function m(_){function Nn(n){if(h(n)&&!(Oo(n)||n instanceof zn)){if(n instanceof Ln)return n;if(nu.call(n,"__chain__")&&nu.call(n,"__wrapped__"))return Mr(n)}return new Ln(n)}function Tn(){}function Ln(n,t,r){this.__wrapped__=n,this.__actions__=r||[],
this.__chain__=!!t}function zn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=Ru,this.__views__=[]}function Bn(){this.__data__={}}function Dn(n){var t=n?n.length:0;for(this.data={hash:gu(null),set:new lu};t--;)this.push(n[t])}function Mn(n,t){var r=n.data;return(typeof t=="string"||ge(t)?r.set.has(t):r.hash[t])?0:-1}function qn(n,t){var r=-1,e=n.length;for(t||(t=Be(e));++r<e;)t[r]=n[r];return t}function Pn(n,t){for(var r=-1,e=n.length;++r<e&&false!==t(n[r],r,n););
return n}function Kn(n,t){for(var r=-1,e=n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function Vn(n,t){for(var r=-1,e=n.length,u=-1,o=[];++r<e;){var i=n[r];t(i,r,n)&&(o[++u]=i)}return o}function Gn(n,t){for(var r=-1,e=n.length,u=Be(e);++r<e;)u[r]=t(n[r],r,n);return u}function Jn(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function Xn(n,t,r,e){var u=-1,o=n.length;for(e&&o&&(r=n[++u]);++u<o;)r=t(r,n[u],u,n);return r}function Hn(n,t){for(var r=-1,e=n.length;++r<e;)if(t(n[r],r,n))return true;
return false}function Qn(n,t,r,e){return n!==w&&nu.call(e,r)?n:t}function nt(n,t,r){for(var e=-1,u=zo(t),o=u.length;++e<o;){var i=u[e],f=n[i],a=r(f,t[i],i,n,t);(a===a?a===f:f!==f)&&(f!==w||i in n)||(n[i]=a)}return n}function tt(n,t){return null==t?n:et(t,zo(t),n)}function rt(n,t){for(var r=-1,e=null==n,u=!e&&Er(n),o=u?n.length:0,i=t.length,f=Be(i);++r<i;){var a=t[r];f[r]=u?Cr(a,o)?n[a]:w:e?w:n[a]}return f}function et(n,t,r){r||(r={});for(var e=-1,u=t.length;++e<u;){var o=t[e];r[o]=n[o]}return r}function ut(n,t,r){
var e=typeof n;return"function"==e?t===w?n:Bt(n,t,r):null==n?Fe:"object"==e?bt(n):t===w?ze(n):xt(n,t)}function ot(n,t,r,e,u,o,i){var f;if(r&&(f=u?r(n,e,u):r(n)),f!==w)return f;if(!ge(n))return n;if(e=Oo(n)){if(f=kr(n),!t)return qn(n,f)}else{var a=ru.call(n),c=a==K;if(a!=Z&&a!=B&&(!c||u))return Fn[a]?Rr(n,a,t):u?n:{};if(f=Ir(c?{}:n),!t)return tt(f,n)}for(o||(o=[]),i||(i=[]),u=o.length;u--;)if(o[u]==n)return i[u];return o.push(n),i.push(f),(e?Pn:_t)(n,function(e,u){f[u]=ot(e,t,r,u,n,o,i)}),f}function it(n,t,r){
if(typeof n!="function")throw new Ge(L);return su(function(){n.apply(w,r)},t)}function ft(n,t){var e=n?n.length:0,u=[];if(!e)return u;var o=-1,i=xr(),f=i==r,a=f&&t.length>=F&&gu&&lu?new Dn(t):null,c=t.length;a&&(i=Mn,f=false,t=a);n:for(;++o<e;)if(a=n[o],f&&a===a){for(var l=c;l--;)if(t[l]===a)continue n;u.push(a)}else 0>i(t,a,0)&&u.push(a);return u}function at(n,t){var r=true;return Su(n,function(n,e,u){return r=!!t(n,e,u)}),r}function ct(n,t,r,e){var u=e,o=u;return Su(n,function(n,i,f){i=+t(n,i,f),(r(i,u)||i===e&&i===o)&&(u=i,
o=n)}),o}function lt(n,t){var r=[];return Su(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function st(n,t,r,e){var u;return r(n,function(n,r,o){return t(n,r,o)?(u=e?r:n,false):void 0}),u}function pt(n,t,r,e){e||(e=[]);for(var u=-1,o=n.length;++u<o;){var i=n[u];h(i)&&Er(i)&&(r||Oo(i)||pe(i))?t?pt(i,t,r,e):Jn(e,i):r||(e[e.length]=i)}return e}function ht(n,t){Nu(n,t,Re)}function _t(n,t){return Nu(n,t,zo)}function vt(n,t){return Tu(n,t,zo)}function gt(n,t){for(var r=-1,e=t.length,u=-1,o=[];++r<e;){var i=t[r];
ve(n[i])&&(o[++u]=i)}return o}function yt(n,t,r){if(null!=n){r!==w&&r in Br(n)&&(t=[r]),r=0;for(var e=t.length;null!=n&&r<e;)n=n[t[r++]];return r&&r==e?n:w}}function dt(n,t,r,e,u,o){if(n===t)n=true;else if(null==n||null==t||!ge(n)&&!h(t))n=n!==n&&t!==t;else n:{var i=dt,f=Oo(n),a=Oo(t),c=D,l=D;f||(c=ru.call(n),c==B?c=Z:c!=Z&&(f=xe(n))),a||(l=ru.call(t),l==B?l=Z:l!=Z&&xe(t));var s=c==Z,a=l==Z,l=c==l;if(!l||f||s){if(!e&&(c=s&&nu.call(n,"__wrapped__"),a=a&&nu.call(t,"__wrapped__"),c||a)){n=i(c?n.value():n,a?t.value():t,r,e,u,o);
break n}if(l){for(u||(u=[]),o||(o=[]),c=u.length;c--;)if(u[c]==n){n=o[c]==t;break n}u.push(n),o.push(t),n=(f?yr:mr)(n,t,i,r,e,u,o),u.pop(),o.pop()}else n=false}else n=dr(n,t,c)}return n}function mt(n,t,r){var e=t.length,u=e,o=!r;if(null==n)return!u;for(n=Br(n);e--;){var i=t[e];if(o&&i[2]?i[1]!==n[i[0]]:!(i[0]in n))return false}for(;++e<u;){var i=t[e],f=i[0],a=n[f],c=i[1];if(o&&i[2]){if(a===w&&!(f in n))return false}else if(i=r?r(a,c,f):w,i===w?!dt(c,a,r,true):!i)return false}return true}function wt(n,t){var r=-1,e=Er(n)?Be(n.length):[];
return Su(n,function(n,u,o){e[++r]=t(n,u,o)}),e}function bt(n){var t=Ar(n);if(1==t.length&&t[0][2]){var r=t[0][0],e=t[0][1];return function(n){return null==n?false:n[r]===e&&(e!==w||r in Br(n))}}return function(n){return mt(n,t)}}function xt(n,t){var r=Oo(n),e=Wr(n)&&t===t&&!ge(t),u=n+"";return n=Dr(n),function(o){if(null==o)return false;var i=u;if(o=Br(o),!(!r&&e||i in o)){if(o=1==n.length?o:yt(o,Et(n,0,-1)),null==o)return false;i=Zr(n),o=Br(o)}return o[i]===t?t!==w||i in o:dt(t,o[i],w,true)}}function At(n,t,r,e,u){
if(!ge(n))return n;var o=Er(t)&&(Oo(t)||xe(t)),i=o?w:zo(t);return Pn(i||t,function(f,a){if(i&&(a=f,f=t[a]),h(f)){e||(e=[]),u||(u=[]);n:{for(var c=a,l=e,s=u,p=l.length,_=t[c];p--;)if(l[p]==_){n[c]=s[p];break n}var p=n[c],v=r?r(p,_,c,n,t):w,g=v===w;g&&(v=_,Er(_)&&(Oo(_)||xe(_))?v=Oo(p)?p:Er(p)?qn(p):[]:me(_)||pe(_)?v=pe(p)?ke(p):me(p)?p:{}:g=false),l.push(_),s.push(v),g?n[c]=At(v,_,r,l,s):(v===v?v!==p:p===p)&&(n[c]=v)}}else c=n[a],l=r?r(c,f,a,n,t):w,(s=l===w)&&(l=f),l===w&&(!o||a in n)||!s&&(l===l?l===c:c!==c)||(n[a]=l);
}),n}function jt(n){return function(t){return null==t?w:t[n]}}function kt(n){var t=n+"";return n=Dr(n),function(r){return yt(r,n,t)}}function It(n,t){for(var r=n?t.length:0;r--;){var e=t[r];if(e!=u&&Cr(e)){var u=e;pu.call(n,e,1)}}}function Rt(n,t){return n+yu(ku()*(t-n+1))}function Ot(n,t,r,e,u){return u(n,function(n,u,o){r=e?(e=false,n):t(r,n,u,o)}),r}function Et(n,t,r){var e=-1,u=n.length;for(t=null==t?0:+t||0,0>t&&(t=-t>u?0:u+t),r=r===w||r>u?u:+r||0,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Be(u);++e<u;)r[e]=n[e+t];
return r}function Ct(n,t){var r;return Su(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function Ut(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function Wt(t,r,e){var u=wr(),o=-1;return r=Gn(r,function(n){return u(n)}),t=wt(t,function(n){return{a:Gn(r,function(t){return t(n)}),b:++o,c:n}}),Ut(t,function(t,r){var u;n:{for(var o=-1,i=t.a,f=r.a,a=i.length,c=e.length;++o<a;)if(u=n(i[o],f[o])){if(o>=c)break n;o=e[o],u*="asc"===o||true===o?1:-1;break n}u=t.b-r.b}return u})}function $t(n,t){
var r=0;return Su(n,function(n,e,u){r+=+t(n,e,u)||0}),r}function St(n,t){var e=-1,u=xr(),o=n.length,i=u==r,f=i&&o>=F,a=f&&gu&&lu?new Dn(void 0):null,c=[];a?(u=Mn,i=false):(f=false,a=t?[]:c);n:for(;++e<o;){var l=n[e],s=t?t(l,e,n):l;if(i&&l===l){for(var p=a.length;p--;)if(a[p]===s)continue n;t&&a.push(s),c.push(l)}else 0>u(a,s,0)&&((t||f)&&a.push(s),c.push(l))}return c}function Ft(n,t){for(var r=-1,e=t.length,u=Be(e);++r<e;)u[r]=n[t[r]];return u}function Nt(n,t,r,e){for(var u=n.length,o=e?u:-1;(e?o--:++o<u)&&t(n[o],o,n););
return r?Et(n,e?0:o,e?o+1:u):Et(n,e?o+1:0,e?u:o)}function Tt(n,t){var r=n;r instanceof zn&&(r=r.value());for(var e=-1,u=t.length;++e<u;)var o=t[e],r=o.func.apply(o.thisArg,Jn([r],o.args));return r}function Lt(n,t,r){var e=0,u=n?n.length:e;if(typeof t=="number"&&t===t&&u<=Eu){for(;e<u;){var o=e+u>>>1,i=n[o];(r?i<=t:i<t)&&null!==i?e=o+1:u=o}return u}return zt(n,t,Fe,r)}function zt(n,t,r,e){t=r(t);for(var u=0,o=n?n.length:0,i=t!==t,f=null===t,a=t===w;u<o;){var c=yu((u+o)/2),l=r(n[c]),s=l!==w,p=l===l;
(i?p||e:f?p&&s&&(e||null!=l):a?p&&(e||s):null==l?0:e?l<=t:l<t)?u=c+1:o=c}return xu(o,Ou)}function Bt(n,t,r){if(typeof n!="function")return Fe;if(t===w)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,o){return n.call(t,r,e,u,o)};case 5:return function(r,e,u,o,i){return n.call(t,r,e,u,o,i)}}return function(){return n.apply(t,arguments)}}function Dt(n){var t=new ou(n.byteLength);return new hu(t).set(new hu(n)),
t}function Mt(n,t,r){for(var e=r.length,u=-1,o=bu(n.length-e,0),i=-1,f=t.length,a=Be(f+o);++i<f;)a[i]=t[i];for(;++u<e;)a[r[u]]=n[u];for(;o--;)a[i++]=n[u++];return a}function qt(n,t,r){for(var e=-1,u=r.length,o=-1,i=bu(n.length-u,0),f=-1,a=t.length,c=Be(i+a);++o<i;)c[o]=n[o];for(i=o;++f<a;)c[i+f]=t[f];for(;++e<u;)c[i+r[e]]=n[o++];return c}function Pt(n,t){return function(r,e,u){var o=t?t():{};if(e=wr(e,u,3),Oo(r)){u=-1;for(var i=r.length;++u<i;){var f=r[u];n(o,f,e(f,u,r),r)}}else Su(r,function(t,r,u){
n(o,t,e(t,r,u),u)});return o}}function Kt(n){return le(function(t,r){var e=-1,u=null==t?0:r.length,o=2<u?r[u-2]:w,i=2<u?r[2]:w,f=1<u?r[u-1]:w;for(typeof o=="function"?(o=Bt(o,f,5),u-=2):(o=typeof f=="function"?f:w,u-=o?1:0),i&&Ur(r[0],r[1],i)&&(o=3>u?w:o,u=1);++e<u;)(i=r[e])&&n(t,i,o);return t})}function Vt(n,t){return function(r,e){var u=r?Bu(r):0;if(!Sr(u))return n(r,e);for(var o=t?u:-1,i=Br(r);(t?o--:++o<u)&&false!==e(i[o],o,i););return r}}function Zt(n){return function(t,r,e){var u=Br(t);e=e(t);for(var o=e.length,i=n?o:-1;n?i--:++i<o;){
var f=e[i];if(false===r(u[f],f,u))break}return t}}function Yt(n,t){function r(){return(this&&this!==Zn&&this instanceof r?e:n).apply(t,arguments)}var e=Jt(n);return r}function Gt(n){return function(t){var r=-1;t=$e(Ce(t));for(var e=t.length,u="";++r<e;)u=n(u,t[r],r);return u}}function Jt(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:
return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=$u(n.prototype),t=n.apply(r,t);return ge(t)?t:r}}function Xt(n){function t(r,e,u){return u&&Ur(r,e,u)&&(e=w),r=gr(r,n,w,w,w,w,w,e),r.placeholder=t.placeholder,r}return t}function Ht(n,t){return le(function(r){var e=r[0];return null==e?e:(r.push(t),n.apply(w,r))})}function Qt(n,t){return function(r,e,u){if(u&&Ur(r,e,u)&&(e=w),e=wr(e,u,3),1==e.length){
u=r=Oo(r)?r:zr(r);for(var o=e,i=-1,f=u.length,a=t,c=a;++i<f;){var l=u[i],s=+o(l);n(s,a)&&(a=s,c=l)}if(u=c,!r.length||u!==t)return u}return ct(r,e,n,t)}}function nr(n,r){return function(e,u,o){return u=wr(u,o,3),Oo(e)?(u=t(e,u,r),-1<u?e[u]:w):st(e,u,n)}}function tr(n){return function(r,e,u){return r&&r.length?(e=wr(e,u,3),t(r,e,n)):-1}}function rr(n){return function(t,r,e){return r=wr(r,e,3),st(t,r,n,true)}}function er(n){return function(){for(var t,r=arguments.length,e=n?r:-1,u=0,o=Be(r);n?e--:++e<r;){
var i=o[u++]=arguments[e];if(typeof i!="function")throw new Ge(L);!t&&Ln.prototype.thru&&"wrapper"==br(i)&&(t=new Ln([],true))}for(e=t?-1:r;++e<r;){var i=o[e],u=br(i),f="wrapper"==u?zu(i):w;t=f&&$r(f[0])&&f[1]==(E|k|R|C)&&!f[4].length&&1==f[9]?t[br(f[0])].apply(t,f[3]):1==i.length&&$r(i)?t[u]():t.thru(i)}return function(){var n=arguments,e=n[0];if(t&&1==n.length&&Oo(e)&&e.length>=F)return t.plant(e).value();for(var u=0,n=r?o[u].apply(this,n):e;++u<r;)n=o[u].call(this,n);return n}}}function ur(n,t){
return function(r,e,u){return typeof e=="function"&&u===w&&Oo(r)?n(r,e):t(r,Bt(e,u,3))}}function or(n){return function(t,r,e){return(typeof r!="function"||e!==w)&&(r=Bt(r,e,3)),n(t,r,Re)}}function ir(n){return function(t,r,e){return(typeof r!="function"||e!==w)&&(r=Bt(r,e,3)),n(t,r)}}function fr(n){return function(t,r,e){var u={};return r=wr(r,e,3),_t(t,function(t,e,o){o=r(t,e,o),e=n?o:e,t=n?t:o,u[e]=t}),u}}function ar(n){return function(t,r,e){return t=u(t),(n?t:"")+pr(t,r,e)+(n?"":t)}}function cr(n){
var t=le(function(r,e){var u=v(e,t.placeholder);return gr(r,n,w,e,u)});return t}function lr(n,t){return function(r,e,u,o){var i=3>arguments.length;return typeof e=="function"&&o===w&&Oo(r)?n(r,e,u,i):Ot(r,wr(e,o,4),u,i,t)}}function sr(n,t,r,e,u,o,i,f,a,c){function l(){for(var m=arguments.length,b=m,j=Be(m);b--;)j[b]=arguments[b];if(e&&(j=Mt(j,e,u)),o&&(j=qt(j,o,i)),_||y){var b=l.placeholder,k=v(j,b),m=m-k.length;if(m<c){var I=f?qn(f):w,m=bu(c-m,0),E=_?k:w,k=_?w:k,C=_?j:w,j=_?w:j;return t|=_?R:O,t&=~(_?O:R),
g||(t&=~(x|A)),j=[n,t,r,C,E,j,k,I,a,m],I=sr.apply(w,j),$r(n)&&Du(I,j),I.placeholder=b,I}}if(b=p?r:this,I=h?b[n]:n,f)for(m=j.length,E=xu(f.length,m),k=qn(j);E--;)C=f[E],j[E]=Cr(C,m)?k[C]:w;return s&&a<j.length&&(j.length=a),this&&this!==Zn&&this instanceof l&&(I=d||Jt(n)),I.apply(b,j)}var s=t&E,p=t&x,h=t&A,_=t&k,g=t&j,y=t&I,d=h?w:Jt(n);return l}function pr(n,t,r){return n=n.length,t=+t,n<t&&mu(t)?(t-=n,r=null==r?" ":r+"",Ue(r,vu(t/r.length)).slice(0,t)):""}function hr(n,t,r,e){function u(){for(var t=-1,f=arguments.length,a=-1,c=e.length,l=Be(c+f);++a<c;)l[a]=e[a];
for(;f--;)l[a++]=arguments[++t];return(this&&this!==Zn&&this instanceof u?i:n).apply(o?r:this,l)}var o=t&x,i=Jt(n);return u}function _r(n){var t=Pe[n];return function(n,r){return(r=r===w?0:+r||0)?(r=au(10,r),t(n*r)/r):t(n)}}function vr(n){return function(t,r,e,u){var o=wr(e);return null==e&&o===ut?Lt(t,r,n):zt(t,r,o(e,u,1),n)}}function gr(n,t,r,e,u,o,i,f){var a=t&A;if(!a&&typeof n!="function")throw new Ge(L);var c=e?e.length:0;if(c||(t&=~(R|O),e=u=w),c-=u?u.length:0,t&O){var l=e,s=u;e=u=w}var p=a?w:zu(n);
return r=[n,t,r,e,u,l,s,o,i,f],p&&(e=r[1],t=p[1],f=e|t,u=t==E&&e==k||t==E&&e==C&&r[7].length<=p[8]||t==(E|C)&&e==k,(f<E||u)&&(t&x&&(r[2]=p[2],f|=e&x?0:j),(e=p[3])&&(u=r[3],r[3]=u?Mt(u,e,p[4]):qn(e),r[4]=u?v(r[3],z):qn(p[4])),(e=p[5])&&(u=r[5],r[5]=u?qt(u,e,p[6]):qn(e),r[6]=u?v(r[5],z):qn(p[6])),(e=p[7])&&(r[7]=qn(e)),t&E&&(r[8]=null==r[8]?p[8]:xu(r[8],p[8])),null==r[9]&&(r[9]=p[9]),r[0]=p[0],r[1]=f),t=r[1],f=r[9]),r[9]=null==f?a?0:n.length:bu(f-c,0)||0,(p?Lu:Du)(t==x?Yt(r[0],r[2]):t!=R&&t!=(x|R)||r[4].length?sr.apply(w,r):hr.apply(w,r),r);
}function yr(n,t,r,e,u,o,i){var f=-1,a=n.length,c=t.length;if(a!=c&&(!u||c<=a))return false;for(;++f<a;){var l=n[f],c=t[f],s=e?e(u?c:l,u?l:c,f):w;if(s!==w){if(s)continue;return false}if(u){if(!Hn(t,function(n){return l===n||r(l,n,e,u,o,i)}))return false}else if(l!==c&&!r(l,c,e,u,o,i))return false}return true}function dr(n,t,r){switch(r){case M:case q:return+n==+t;case P:return n.name==t.name&&n.message==t.message;case V:return n!=+n?t!=+t:n==+t;case Y:case G:return n==t+""}return false}function mr(n,t,r,e,u,o,i){var f=zo(n),a=f.length,c=zo(t).length;
if(a!=c&&!u)return false;for(c=a;c--;){var l=f[c];if(!(u?l in t:nu.call(t,l)))return false}for(var s=u;++c<a;){var l=f[c],p=n[l],h=t[l],_=e?e(u?h:p,u?p:h,l):w;if(_===w?!r(p,h,e,u,o,i):!_)return false;s||(s="constructor"==l)}return s||(r=n.constructor,e=t.constructor,!(r!=e&&"constructor"in n&&"constructor"in t)||typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)?true:false}function wr(n,t,r){var e=Nn.callback||Se,e=e===Se?ut:e;return r?e(n,t,r):e}function br(n){for(var t=n.name,r=Wu[t],e=r?r.length:0;e--;){
var u=r[e],o=u.func;if(null==o||o==n)return u.name}return t}function xr(n,t,e){var u=Nn.indexOf||Vr,u=u===Vr?r:u;return n?u(n,t,e):u}function Ar(n){n=Oe(n);for(var t=n.length;t--;){var r=n[t][1];n[t][2]=r===r&&!ge(r)}return n}function jr(n,t){var r=null==n?w:n[t];return ye(r)?r:w}function kr(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&nu.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ir(n){return n=n.constructor,typeof n=="function"&&n instanceof n||(n=Ve),
new n}function Rr(n,t,r){var e=n.constructor;switch(t){case J:return Dt(n);case M:case q:return new e(+n);case X:case H:case Q:case nn:case tn:case rn:case en:case un:case on:return t=n.buffer,new e(r?Dt(t):t,n.byteOffset,n.length);case V:case G:return new e(n);case Y:var u=new e(n.source,kn.exec(n));u.lastIndex=n.lastIndex}return u}function Or(n,t,r){return null==n||Wr(t,n)||(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),t=Zr(t)),t=null==n?n:n[t],null==t?w:t.apply(n,r)}function Er(n){return null!=n&&Sr(Bu(n));
}function Cr(n,t){return n=typeof n=="number"||On.test(n)?+n:-1,t=null==t?Cu:t,-1<n&&0==n%1&&n<t}function Ur(n,t,r){if(!ge(r))return false;var e=typeof t;return("number"==e?Er(r)&&Cr(t,r.length):"string"==e&&t in r)?(t=r[t],n===n?n===t:t!==t):false}function Wr(n,t){var r=typeof n;return"string"==r&&dn.test(n)||"number"==r?true:Oo(n)?false:!yn.test(n)||null!=t&&n in Br(t)}function $r(n){var t=br(n);return t in zn.prototype?(t=Nn[t],n===t?true:(t=zu(t),!!t&&n===t[0])):false}function Sr(n){return typeof n=="number"&&-1<n&&0==n%1&&n<=Cu;
}function Fr(n,t){return n===w?t:Eo(n,t,Fr)}function Nr(n,t){n=Br(n);for(var r=-1,e=t.length,u={};++r<e;){var o=t[r];o in n&&(u[o]=n[o])}return u}function Tr(n,t){var r={};return ht(n,function(n,e,u){t(n,e,u)&&(r[e]=n)}),r}function Lr(n){for(var t=Re(n),r=t.length,e=r&&n.length,u=!!e&&Sr(e)&&(Oo(n)||pe(n)),o=-1,i=[];++o<r;){var f=t[o];(u&&Cr(f,e)||nu.call(n,f))&&i.push(f)}return i}function zr(n){return null==n?[]:Er(n)?ge(n)?n:Ve(n):Ee(n)}function Br(n){return ge(n)?n:Ve(n)}function Dr(n){if(Oo(n))return n;
var t=[];return u(n).replace(mn,function(n,r,e,u){t.push(e?u.replace(An,"$1"):r||n)}),t}function Mr(n){return n instanceof zn?n.clone():new Ln(n.__wrapped__,n.__chain__,qn(n.__actions__))}function qr(n,t,r){return n&&n.length?((r?Ur(n,t,r):null==t)&&(t=1),Et(n,0>t?0:t)):[]}function Pr(n,t,r){var e=n?n.length:0;return e?((r?Ur(n,t,r):null==t)&&(t=1),t=e-(+t||0),Et(n,0,0>t?0:t)):[]}function Kr(n){return n?n[0]:w}function Vr(n,t,e){var u=n?n.length:0;if(!u)return-1;if(typeof e=="number")e=0>e?bu(u+e,0):e;else if(e)return e=Lt(n,t),
e<u&&(t===t?t===n[e]:n[e]!==n[e])?e:-1;return r(n,t,e||0)}function Zr(n){var t=n?n.length:0;return t?n[t-1]:w}function Yr(n){return qr(n,1)}function Gr(n,t,e,u){if(!n||!n.length)return[];null!=t&&typeof t!="boolean"&&(u=e,e=Ur(n,t,u)?w:t,t=false);var o=wr();if((null!=e||o!==ut)&&(e=o(e,u,3)),t&&xr()==r){t=e;var i;e=-1,u=n.length;for(var o=-1,f=[];++e<u;){var a=n[e],c=t?t(a,e,n):a;e&&i===c||(i=c,f[++o]=a)}n=f}else n=St(n,e);return n}function Jr(n){if(!n||!n.length)return[];var t=-1,r=0;n=Vn(n,function(n){
return Er(n)?(r=bu(n.length,r),true):void 0});for(var e=Be(r);++t<r;)e[t]=Gn(n,jt(t));return e}function Xr(n,t,r){return n&&n.length?(n=Jr(n),null==t?n:(t=Bt(t,r,4),Gn(n,function(n){return Xn(n,t,w,true)}))):[]}function Hr(n,t){var r=-1,e=n?n.length:0,u={};for(!e||t||Oo(n[0])||(t=[]);++r<e;){var o=n[r];t?u[o]=t[r]:o&&(u[o[0]]=o[1])}return u}function Qr(n){return n=Nn(n),n.__chain__=true,n}function ne(n,t,r){return t.call(r,n)}function te(n,t,r){var e=Oo(n)?Kn:at;return r&&Ur(n,t,r)&&(t=w),(typeof t!="function"||r!==w)&&(t=wr(t,r,3)),
e(n,t)}function re(n,t,r){var e=Oo(n)?Vn:lt;return t=wr(t,r,3),e(n,t)}function ee(n,t,r,e){var u=n?Bu(n):0;return Sr(u)||(n=Ee(n),u=n.length),r=typeof r!="number"||e&&Ur(t,r,e)?0:0>r?bu(u+r,0):r||0,typeof n=="string"||!Oo(n)&&be(n)?r<=u&&-1<n.indexOf(t,r):!!u&&-1<xr(n,t,r)}function ue(n,t,r){var e=Oo(n)?Gn:wt;return t=wr(t,r,3),e(n,t)}function oe(n,t,r){if(r?Ur(n,t,r):null==t){n=zr(n);var e=n.length;return 0<e?n[Rt(0,e-1)]:w}r=-1,n=je(n);var e=n.length,u=e-1;for(t=xu(0>t?0:+t||0,e);++r<t;){var e=Rt(r,u),o=n[e];
n[e]=n[r],n[r]=o}return n.length=t,n}function ie(n,t,r){var e=Oo(n)?Hn:Ct;return r&&Ur(n,t,r)&&(t=w),(typeof t!="function"||r!==w)&&(t=wr(t,r,3)),e(n,t)}function fe(n,t){var r;if(typeof t!="function"){if(typeof n!="function")throw new Ge(L);var e=n;n=t,t=e}return function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=w),r}}function ae(n,t,r){function e(t,r){r&&iu(r),a=p=h=w,t&&(_=ho(),c=n.apply(s,f),p||a||(f=s=w))}function u(){var n=t-(ho()-l);0>=n||n>t?e(h,a):p=su(u,n)}function o(){e(g,p);
}function i(){if(f=arguments,l=ho(),s=this,h=g&&(p||!y),false===v)var r=y&&!p;else{a||y||(_=l);var e=v-(l-_),i=0>=e||e>v;i?(a&&(a=iu(a)),_=l,c=n.apply(s,f)):a||(a=su(o,e))}return i&&p?p=iu(p):p||t===v||(p=su(u,t)),r&&(i=true,c=n.apply(s,f)),!i||p||a||(f=s=w),c}var f,a,c,l,s,p,h,_=0,v=false,g=true;if(typeof n!="function")throw new Ge(L);if(t=0>t?0:+t||0,true===r)var y=true,g=false;else ge(r)&&(y=!!r.leading,v="maxWait"in r&&bu(+r.maxWait||0,t),g="trailing"in r?!!r.trailing:g);return i.cancel=function(){p&&iu(p),a&&iu(a),
_=0,a=p=h=w},i}function ce(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],o=r.cache;return o.has(u)?o.get(u):(e=n.apply(this,e),r.cache=o.set(u,e),e)}if(typeof n!="function"||t&&typeof t!="function")throw new Ge(L);return r.cache=new ce.Cache,r}function le(n,t){if(typeof n!="function")throw new Ge(L);return t=bu(t===w?n.length-1:+t||0,0),function(){for(var r=arguments,e=-1,u=bu(r.length-t,0),o=Be(u);++e<u;)o[e]=r[t+e];switch(t){case 0:return n.call(this,o);case 1:return n.call(this,r[0],o);
case 2:return n.call(this,r[0],r[1],o)}for(u=Be(t+1),e=-1;++e<t;)u[e]=r[e];return u[t]=o,n.apply(this,u)}}function se(n,t){return n>t}function pe(n){return h(n)&&Er(n)&&nu.call(n,"callee")&&!cu.call(n,"callee")}function he(n,t,r,e){return e=(r=typeof r=="function"?Bt(r,e,3):w)?r(n,t):w,e===w?dt(n,t,r):!!e}function _e(n){return h(n)&&typeof n.message=="string"&&ru.call(n)==P}function ve(n){return ge(n)&&ru.call(n)==K}function ge(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function ye(n){
return null==n?false:ve(n)?uu.test(Qe.call(n)):h(n)&&Rn.test(n)}function de(n){return typeof n=="number"||h(n)&&ru.call(n)==V}function me(n){var t;if(!h(n)||ru.call(n)!=Z||pe(n)||!(nu.call(n,"constructor")||(t=n.constructor,typeof t!="function"||t instanceof t)))return false;var r;return ht(n,function(n,t){r=t}),r===w||nu.call(n,r)}function we(n){return ge(n)&&ru.call(n)==Y}function be(n){return typeof n=="string"||h(n)&&ru.call(n)==G}function xe(n){return h(n)&&Sr(n.length)&&!!Sn[ru.call(n)]}function Ae(n,t){
return n<t}function je(n){var t=n?Bu(n):0;return Sr(t)?t?qn(n):[]:Ee(n)}function ke(n){return et(n,Re(n))}function Ie(n){return gt(n,Re(n))}function Re(n){if(null==n)return[];ge(n)||(n=Ve(n));for(var t=n.length,t=t&&Sr(t)&&(Oo(n)||pe(n))&&t||0,r=n.constructor,e=-1,r=typeof r=="function"&&r.prototype===n,u=Be(t),o=0<t;++e<t;)u[e]=e+"";for(var i in n)o&&Cr(i,t)||"constructor"==i&&(r||!nu.call(n,i))||u.push(i);return u}function Oe(n){n=Br(n);for(var t=-1,r=zo(n),e=r.length,u=Be(e);++t<e;){var o=r[t];
u[t]=[o,n[o]]}return u}function Ee(n){return Ft(n,zo(n))}function Ce(n){return(n=u(n))&&n.replace(En,a).replace(xn,"")}function Ue(n,t){var r="";if(n=u(n),t=+t,1>t||!n||!mu(t))return r;do t%2&&(r+=n),t=yu(t/2),n+=n;while(t);return r}function We(n,t,r){var e=n;return(n=u(n))?(r?Ur(e,t,r):null==t)?n.slice(g(n),y(n)+1):(t+="",n.slice(o(n,t),i(n,t)+1)):n}function $e(n,t,r){return r&&Ur(n,t,r)&&(t=w),n=u(n),n.match(t||Wn)||[]}function Se(n,t,r){return r&&Ur(n,t,r)&&(t=w),h(n)?Ne(n):ut(n,t)}function Fe(n){
return n}function Ne(n){return bt(ot(n,true))}function Te(n,t,r){if(null==r){var e=ge(t),u=e?zo(t):w;((u=u&&u.length?gt(t,u):w)?u.length:e)||(u=false,r=t,t=n,n=this)}u||(u=gt(t,zo(t)));var o=true,e=-1,i=ve(n),f=u.length;false===r?o=false:ge(r)&&"chain"in r&&(o=r.chain);for(;++e<f;){r=u[e];var a=t[r];n[r]=a,i&&(n.prototype[r]=function(t){return function(){var r=this.__chain__;if(o||r){var e=n(this.__wrapped__);return(e.__actions__=qn(this.__actions__)).push({func:t,args:arguments,thisArg:n}),e.__chain__=r,e}return t.apply(n,Jn([this.value()],arguments));
}}(a))}return n}function Le(){}function ze(n){return Wr(n)?jt(n):kt(n)}_=_?Yn.defaults(Zn.Object(),_,Yn.pick(Zn,$n)):Zn;var Be=_.Array,De=_.Date,Me=_.Error,qe=_.Function,Pe=_.Math,Ke=_.Number,Ve=_.Object,Ze=_.RegExp,Ye=_.String,Ge=_.TypeError,Je=Be.prototype,Xe=Ve.prototype,He=Ye.prototype,Qe=qe.prototype.toString,nu=Xe.hasOwnProperty,tu=0,ru=Xe.toString,eu=Zn._,uu=Ze("^"+Qe.call(nu).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ou=_.ArrayBuffer,iu=_.clearTimeout,fu=_.parseFloat,au=Pe.pow,cu=Xe.propertyIsEnumerable,lu=jr(_,"Set"),su=_.setTimeout,pu=Je.splice,hu=_.Uint8Array,_u=jr(_,"WeakMap"),vu=Pe.ceil,gu=jr(Ve,"create"),yu=Pe.floor,du=jr(Be,"isArray"),mu=_.isFinite,wu=jr(Ve,"keys"),bu=Pe.max,xu=Pe.min,Au=jr(De,"now"),ju=_.parseInt,ku=Pe.random,Iu=Ke.NEGATIVE_INFINITY,Ru=Ke.POSITIVE_INFINITY,Ou=4294967294,Eu=2147483647,Cu=9007199254740991,Uu=_u&&new _u,Wu={};
Nn.support={},Nn.templateSettings={escape:_n,evaluate:vn,interpolate:gn,variable:"",imports:{_:Nn}};var $u=function(){function n(){}return function(t){if(ge(t)){n.prototype=t;var r=new n;n.prototype=w}return r||{}}}(),Su=Vt(_t),Fu=Vt(vt,true),Nu=Zt(),Tu=Zt(true),Lu=Uu?function(n,t){return Uu.set(n,t),n}:Fe,zu=Uu?function(n){return Uu.get(n)}:Le,Bu=jt("length"),Du=function(){var n=0,t=0;return function(r,e){var u=ho(),o=S-(u-t);if(t=u,0<o){if(++n>=$)return r}else n=0;return Lu(r,e)}}(),Mu=le(function(n,t){
return h(n)&&Er(n)?ft(n,pt(t,false,true)):[]}),qu=tr(),Pu=tr(true),Ku=le(function(n){for(var t=n.length,e=t,u=Be(l),o=xr(),i=o==r,f=[];e--;){var a=n[e]=Er(a=n[e])?a:[];u[e]=i&&120<=a.length&&gu&&lu?new Dn(e&&a):null}var i=n[0],c=-1,l=i?i.length:0,s=u[0];n:for(;++c<l;)if(a=i[c],0>(s?Mn(s,a):o(f,a,0))){for(e=t;--e;){var p=u[e];if(0>(p?Mn(p,a):o(n[e],a,0)))continue n}s&&s.push(a),f.push(a)}return f}),Vu=le(function(t,r){r=pt(r);var e=rt(t,r);return It(t,r.sort(n)),e}),Zu=vr(),Yu=vr(true),Gu=le(function(n){return St(pt(n,false,true));
}),Ju=le(function(n,t){return Er(n)?ft(n,t):[]}),Xu=le(Jr),Hu=le(function(n){var t=n.length,r=2<t?n[t-2]:w,e=1<t?n[t-1]:w;return 2<t&&typeof r=="function"?t-=2:(r=1<t&&typeof e=="function"?(--t,e):w,e=w),n.length=t,Xr(n,r,e)}),Qu=le(function(n){return n=pt(n),this.thru(function(t){t=Oo(t)?t:[Br(t)];for(var r=n,e=-1,u=t.length,o=-1,i=r.length,f=Be(u+i);++e<u;)f[e]=t[e];for(;++o<i;)f[e++]=r[o];return f})}),no=le(function(n,t){return rt(n,pt(t))}),to=Pt(function(n,t,r){nu.call(n,r)?++n[r]:n[r]=1}),ro=nr(Su),eo=nr(Fu,true),uo=ur(Pn,Su),oo=ur(function(n,t){
for(var r=n.length;r--&&false!==t(n[r],r,n););return n},Fu),io=Pt(function(n,t,r){nu.call(n,r)?n[r].push(t):n[r]=[t]}),fo=Pt(function(n,t,r){n[r]=t}),ao=le(function(n,t,r){var e=-1,u=typeof t=="function",o=Wr(t),i=Er(n)?Be(n.length):[];return Su(n,function(n){var f=u?t:o&&null!=n?n[t]:w;i[++e]=f?f.apply(n,r):Or(n,t,r)}),i}),co=Pt(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),lo=lr(Xn,Su),so=lr(function(n,t,r,e){var u=n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r},Fu),po=le(function(n,t){
if(null==n)return[];var r=t[2];return r&&Ur(t[0],t[1],r)&&(t.length=1),Wt(n,pt(t),[])}),ho=Au||function(){return(new De).getTime()},_o=le(function(n,t,r){var e=x;if(r.length)var u=v(r,_o.placeholder),e=e|R;return gr(n,e,t,r,u)}),vo=le(function(n,t){t=t.length?pt(t):Ie(n);for(var r=-1,e=t.length;++r<e;){var u=t[r];n[u]=gr(n[u],x,n)}return n}),go=le(function(n,t,r){var e=x|A;if(r.length)var u=v(r,go.placeholder),e=e|R;return gr(t,e,n,r,u)}),yo=Xt(k),mo=Xt(I),wo=le(function(n,t){return it(n,1,t)}),bo=le(function(n,t,r){
return it(n,t,r)}),xo=er(),Ao=er(true),jo=le(function(n,t){if(t=pt(t),typeof n!="function"||!Kn(t,e))throw new Ge(L);var r=t.length;return le(function(e){for(var u=xu(e.length,r);u--;)e[u]=t[u](e[u]);return n.apply(this,e)})}),ko=cr(R),Io=cr(O),Ro=le(function(n,t){return gr(n,C,w,w,w,pt(t))}),Oo=du||function(n){return h(n)&&Sr(n.length)&&ru.call(n)==D},Eo=Kt(At),Co=Kt(function(n,t,r){return r?nt(n,t,r):tt(n,t)}),Uo=Ht(Co,function(n,t){return n===w?t:n}),Wo=Ht(Eo,Fr),$o=rr(_t),So=rr(vt),Fo=or(Nu),No=or(Tu),To=ir(_t),Lo=ir(vt),zo=wu?function(n){
var t=null==n?w:n.constructor;return typeof t=="function"&&t.prototype===n||typeof n!="function"&&Er(n)?Lr(n):ge(n)?wu(n):[]}:Lr,Bo=fr(true),Do=fr(),Mo=le(function(n,t){if(null==n)return{};if("function"!=typeof t[0])return t=Gn(pt(t),Ye),Nr(n,ft(Re(n),t));var r=Bt(t[0],t[1],3);return Tr(n,function(n,t,e){return!r(n,t,e)})}),qo=le(function(n,t){return null==n?{}:"function"==typeof t[0]?Tr(n,Bt(t[0],t[1],3)):Nr(n,pt(t))}),Po=Gt(function(n,t,r){return t=t.toLowerCase(),n+(r?t.charAt(0).toUpperCase()+t.slice(1):t);
}),Ko=Gt(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Vo=ar(),Zo=ar(true),Yo=Gt(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Go=Gt(function(n,t,r){return n+(r?" ":"")+(t.charAt(0).toUpperCase()+t.slice(1))}),Jo=le(function(n,t){try{return n.apply(w,t)}catch(r){return _e(r)?r:new Me(r)}}),Xo=le(function(n,t){return function(r){return Or(r,n,t)}}),Ho=le(function(n,t){return function(r){return Or(n,r,t)}}),Qo=_r("ceil"),ni=_r("floor"),ti=Qt(se,Iu),ri=Qt(Ae,Ru),ei=_r("round");return Nn.prototype=Tn.prototype,
Ln.prototype=$u(Tn.prototype),Ln.prototype.constructor=Ln,zn.prototype=$u(Tn.prototype),zn.prototype.constructor=zn,Bn.prototype["delete"]=function(n){return this.has(n)&&delete this.__data__[n]},Bn.prototype.get=function(n){return"__proto__"==n?w:this.__data__[n]},Bn.prototype.has=function(n){return"__proto__"!=n&&nu.call(this.__data__,n)},Bn.prototype.set=function(n,t){return"__proto__"!=n&&(this.__data__[n]=t),this},Dn.prototype.push=function(n){var t=this.data;typeof n=="string"||ge(n)?t.set.add(n):t.hash[n]=true;
},ce.Cache=Bn,Nn.after=function(n,t){if(typeof t!="function"){if(typeof n!="function")throw new Ge(L);var r=n;n=t,t=r}return n=mu(n=+n)?n:0,function(){return 1>--n?t.apply(this,arguments):void 0}},Nn.ary=function(n,t,r){return r&&Ur(n,t,r)&&(t=w),t=n&&null==t?n.length:bu(+t||0,0),gr(n,E,w,w,w,w,t)},Nn.assign=Co,Nn.at=no,Nn.before=fe,Nn.bind=_o,Nn.bindAll=vo,Nn.bindKey=go,Nn.callback=Se,Nn.chain=Qr,Nn.chunk=function(n,t,r){t=(r?Ur(n,t,r):null==t)?1:bu(yu(t)||1,1),r=0;for(var e=n?n.length:0,u=-1,o=Be(vu(e/t));r<e;)o[++u]=Et(n,r,r+=t);
return o},Nn.compact=function(n){for(var t=-1,r=n?n.length:0,e=-1,u=[];++t<r;){var o=n[t];o&&(u[++e]=o)}return u},Nn.constant=function(n){return function(){return n}},Nn.countBy=to,Nn.create=function(n,t,r){var e=$u(n);return r&&Ur(n,t,r)&&(t=w),t?tt(e,t):e},Nn.curry=yo,Nn.curryRight=mo,Nn.debounce=ae,Nn.defaults=Uo,Nn.defaultsDeep=Wo,Nn.defer=wo,Nn.delay=bo,Nn.difference=Mu,Nn.drop=qr,Nn.dropRight=Pr,Nn.dropRightWhile=function(n,t,r){return n&&n.length?Nt(n,wr(t,r,3),true,true):[]},Nn.dropWhile=function(n,t,r){
return n&&n.length?Nt(n,wr(t,r,3),true):[]},Nn.fill=function(n,t,r,e){var u=n?n.length:0;if(!u)return[];for(r&&typeof r!="number"&&Ur(n,t,r)&&(r=0,e=u),u=n.length,r=null==r?0:+r||0,0>r&&(r=-r>u?0:u+r),e=e===w||e>u?u:+e||0,0>e&&(e+=u),u=r>e?0:e>>>0,r>>>=0;r<u;)n[r++]=t;return n},Nn.filter=re,Nn.flatten=function(n,t,r){var e=n?n.length:0;return r&&Ur(n,t,r)&&(t=false),e?pt(n,t):[]},Nn.flattenDeep=function(n){return n&&n.length?pt(n,true):[]},Nn.flow=xo,Nn.flowRight=Ao,Nn.forEach=uo,Nn.forEachRight=oo,Nn.forIn=Fo,
Nn.forInRight=No,Nn.forOwn=To,Nn.forOwnRight=Lo,Nn.functions=Ie,Nn.groupBy=io,Nn.indexBy=fo,Nn.initial=function(n){return Pr(n,1)},Nn.intersection=Ku,Nn.invert=function(n,t,r){r&&Ur(n,t,r)&&(t=w),r=-1;for(var e=zo(n),u=e.length,o={};++r<u;){var i=e[r],f=n[i];t?nu.call(o,f)?o[f].push(i):o[f]=[i]:o[f]=i}return o},Nn.invoke=ao,Nn.keys=zo,Nn.keysIn=Re,Nn.map=ue,Nn.mapKeys=Bo,Nn.mapValues=Do,Nn.matches=Ne,Nn.matchesProperty=function(n,t){return xt(n,ot(t,true))},Nn.memoize=ce,Nn.merge=Eo,Nn.method=Xo,Nn.methodOf=Ho,
Nn.mixin=Te,Nn.modArgs=jo,Nn.negate=function(n){if(typeof n!="function")throw new Ge(L);return function(){return!n.apply(this,arguments)}},Nn.omit=Mo,Nn.once=function(n){return fe(2,n)},Nn.pairs=Oe,Nn.partial=ko,Nn.partialRight=Io,Nn.partition=co,Nn.pick=qo,Nn.pluck=function(n,t){return ue(n,ze(t))},Nn.property=ze,Nn.propertyOf=function(n){return function(t){return yt(n,Dr(t),t+"")}},Nn.pull=function(){var n=arguments,t=n[0];if(!t||!t.length)return t;for(var r=0,e=xr(),u=n.length;++r<u;)for(var o=0,i=n[r];-1<(o=e(t,i,o));)pu.call(t,o,1);
return t},Nn.pullAt=Vu,Nn.range=function(n,t,r){r&&Ur(n,t,r)&&(t=r=w),n=+n||0,r=null==r?1:+r||0,null==t?(t=n,n=0):t=+t||0;var e=-1;t=bu(vu((t-n)/(r||1)),0);for(var u=Be(t);++e<t;)u[e]=n,n+=r;return u},Nn.rearg=Ro,Nn.reject=function(n,t,r){var e=Oo(n)?Vn:lt;return t=wr(t,r,3),e(n,function(n,r,e){return!t(n,r,e)})},Nn.remove=function(n,t,r){var e=[];if(!n||!n.length)return e;var u=-1,o=[],i=n.length;for(t=wr(t,r,3);++u<i;)r=n[u],t(r,u,n)&&(e.push(r),o.push(u));return It(n,o),e},Nn.rest=Yr,Nn.restParam=le,
Nn.set=function(n,t,r){if(null==n)return n;var e=t+"";t=null!=n[e]||Wr(t,n)?[e]:Dr(t);for(var e=-1,u=t.length,o=u-1,i=n;null!=i&&++e<u;){var f=t[e];ge(i)&&(e==o?i[f]=r:null==i[f]&&(i[f]=Cr(t[e+1])?[]:{})),i=i[f]}return n},Nn.shuffle=function(n){return oe(n,Ru)},Nn.slice=function(n,t,r){var e=n?n.length:0;return e?(r&&typeof r!="number"&&Ur(n,t,r)&&(t=0,r=e),Et(n,t,r)):[]},Nn.sortBy=function(n,t,r){if(null==n)return[];r&&Ur(n,t,r)&&(t=w);var e=-1;return t=wr(t,r,3),n=wt(n,function(n,r,u){return{a:t(n,r,u),
b:++e,c:n}}),Ut(n,f)},Nn.sortByAll=po,Nn.sortByOrder=function(n,t,r,e){return null==n?[]:(e&&Ur(t,r,e)&&(r=w),Oo(t)||(t=null==t?[]:[t]),Oo(r)||(r=null==r?[]:[r]),Wt(n,t,r))},Nn.spread=function(n){if(typeof n!="function")throw new Ge(L);return function(t){return n.apply(this,t)}},Nn.take=function(n,t,r){return n&&n.length?((r?Ur(n,t,r):null==t)&&(t=1),Et(n,0,0>t?0:t)):[]},Nn.takeRight=function(n,t,r){var e=n?n.length:0;return e?((r?Ur(n,t,r):null==t)&&(t=1),t=e-(+t||0),Et(n,0>t?0:t)):[]},Nn.takeRightWhile=function(n,t,r){
return n&&n.length?Nt(n,wr(t,r,3),false,true):[]},Nn.takeWhile=function(n,t,r){return n&&n.length?Nt(n,wr(t,r,3)):[]},Nn.tap=function(n,t,r){return t.call(r,n),n},Nn.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new Ge(L);return false===r?e=false:ge(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),ae(n,t,{leading:e,maxWait:+t,trailing:u})},Nn.thru=ne,Nn.times=function(n,t,r){if(n=yu(n),1>n||!mu(n))return[];var e=-1,u=Be(xu(n,4294967295));for(t=Bt(t,r,1);++e<n;)4294967295>e?u[e]=t(e):t(e);
return u},Nn.toArray=je,Nn.toPlainObject=ke,Nn.transform=function(n,t,r,e){var u=Oo(n)||xe(n);return t=wr(t,e,4),null==r&&(u||ge(n)?(e=n.constructor,r=u?Oo(n)?new e:[]:$u(ve(e)?e.prototype:w)):r={}),(u?Pn:_t)(n,function(n,e,u){return t(r,n,e,u)}),r},Nn.union=Gu,Nn.uniq=Gr,Nn.unzip=Jr,Nn.unzipWith=Xr,Nn.values=Ee,Nn.valuesIn=function(n){return Ft(n,Re(n))},Nn.where=function(n,t){return re(n,bt(t))},Nn.without=Ju,Nn.wrap=function(n,t){return t=null==t?Fe:t,gr(t,R,w,[n],[])},Nn.xor=function(){for(var n=-1,t=arguments.length;++n<t;){
var r=arguments[n];if(Er(r))var e=e?Jn(ft(e,r),ft(r,e)):r}return e?St(e):[]},Nn.zip=Xu,Nn.zipObject=Hr,Nn.zipWith=Hu,Nn.backflow=Ao,Nn.collect=ue,Nn.compose=Ao,Nn.each=uo,Nn.eachRight=oo,Nn.extend=Co,Nn.iteratee=Se,Nn.methods=Ie,Nn.object=Hr,Nn.select=re,Nn.tail=Yr,Nn.unique=Gr,Te(Nn,Nn),Nn.add=function(n,t){return(+n||0)+(+t||0)},Nn.attempt=Jo,Nn.camelCase=Po,Nn.capitalize=function(n){return(n=u(n))&&n.charAt(0).toUpperCase()+n.slice(1)},Nn.ceil=Qo,Nn.clone=function(n,t,r,e){return t&&typeof t!="boolean"&&Ur(n,t,r)?t=false:typeof t=="function"&&(e=r,
r=t,t=false),typeof r=="function"?ot(n,t,Bt(r,e,1)):ot(n,t)},Nn.cloneDeep=function(n,t,r){return typeof t=="function"?ot(n,true,Bt(t,r,1)):ot(n,true)},Nn.deburr=Ce,Nn.endsWith=function(n,t,r){n=u(n),t+="";var e=n.length;return r=r===w?e:xu(0>r?0:+r||0,e),r-=t.length,0<=r&&n.indexOf(t,r)==r},Nn.escape=function(n){return(n=u(n))&&hn.test(n)?n.replace(sn,c):n},Nn.escapeRegExp=function(n){return(n=u(n))&&bn.test(n)?n.replace(wn,l):n||"(?:)"},Nn.every=te,Nn.find=ro,Nn.findIndex=qu,Nn.findKey=$o,Nn.findLast=eo,
Nn.findLastIndex=Pu,Nn.findLastKey=So,Nn.findWhere=function(n,t){return ro(n,bt(t))},Nn.first=Kr,Nn.floor=ni,Nn.get=function(n,t,r){return n=null==n?w:yt(n,Dr(t),t+""),n===w?r:n},Nn.gt=se,Nn.gte=function(n,t){return n>=t},Nn.has=function(n,t){if(null==n)return false;var r=nu.call(n,t);if(!r&&!Wr(t)){if(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),null==n)return false;t=Zr(t),r=nu.call(n,t)}return r||Sr(n.length)&&Cr(t,n.length)&&(Oo(n)||pe(n))},Nn.identity=Fe,Nn.includes=ee,Nn.indexOf=Vr,Nn.inRange=function(n,t,r){
return t=+t||0,r===w?(r=t,t=0):r=+r||0,n>=xu(t,r)&&n<bu(t,r)},Nn.isArguments=pe,Nn.isArray=Oo,Nn.isBoolean=function(n){return true===n||false===n||h(n)&&ru.call(n)==M},Nn.isDate=function(n){return h(n)&&ru.call(n)==q},Nn.isElement=function(n){return!!n&&1===n.nodeType&&h(n)&&!me(n)},Nn.isEmpty=function(n){return null==n?true:Er(n)&&(Oo(n)||be(n)||pe(n)||h(n)&&ve(n.splice))?!n.length:!zo(n).length},Nn.isEqual=he,Nn.isError=_e,Nn.isFinite=function(n){return typeof n=="number"&&mu(n)},Nn.isFunction=ve,Nn.isMatch=function(n,t,r,e){
return r=typeof r=="function"?Bt(r,e,3):w,mt(n,Ar(t),r)},Nn.isNaN=function(n){return de(n)&&n!=+n},Nn.isNative=ye,Nn.isNull=function(n){return null===n},Nn.isNumber=de,Nn.isObject=ge,Nn.isPlainObject=me,Nn.isRegExp=we,Nn.isString=be,Nn.isTypedArray=xe,Nn.isUndefined=function(n){return n===w},Nn.kebabCase=Ko,Nn.last=Zr,Nn.lastIndexOf=function(n,t,r){var e=n?n.length:0;if(!e)return-1;var u=e;if(typeof r=="number")u=(0>r?bu(e+r,0):xu(r||0,e-1))+1;else if(r)return u=Lt(n,t,true)-1,n=n[u],(t===t?t===n:n!==n)?u:-1;
if(t!==t)return p(n,u,true);for(;u--;)if(n[u]===t)return u;return-1},Nn.lt=Ae,Nn.lte=function(n,t){return n<=t},Nn.max=ti,Nn.min=ri,Nn.noConflict=function(){return Zn._=eu,this},Nn.noop=Le,Nn.now=ho,Nn.pad=function(n,t,r){n=u(n),t=+t;var e=n.length;return e<t&&mu(t)?(e=(t-e)/2,t=yu(e),e=vu(e),r=pr("",e,r),r.slice(0,t)+n+r):n},Nn.padLeft=Vo,Nn.padRight=Zo,Nn.parseInt=function(n,t,r){return(r?Ur(n,t,r):null==t)?t=0:t&&(t=+t),n=We(n),ju(n,t||(In.test(n)?16:10))},Nn.random=function(n,t,r){r&&Ur(n,t,r)&&(t=r=w);
var e=null==n,u=null==t;return null==r&&(u&&typeof n=="boolean"?(r=n,n=1):typeof t=="boolean"&&(r=t,u=true)),e&&u&&(t=1,u=false),n=+n||0,u?(t=n,n=0):t=+t||0,r||n%1||t%1?(r=ku(),xu(n+r*(t-n+fu("1e-"+((r+"").length-1))),t)):Rt(n,t)},Nn.reduce=lo,Nn.reduceRight=so,Nn.repeat=Ue,Nn.result=function(n,t,r){var e=null==n?w:n[t];return e===w&&(null==n||Wr(t,n)||(t=Dr(t),n=1==t.length?n:yt(n,Et(t,0,-1)),e=null==n?w:n[Zr(t)]),e=e===w?r:e),ve(e)?e.call(n):e},Nn.round=ei,Nn.runInContext=m,Nn.size=function(n){var t=n?Bu(n):0;
return Sr(t)?t:zo(n).length},Nn.snakeCase=Yo,Nn.some=ie,Nn.sortedIndex=Zu,Nn.sortedLastIndex=Yu,Nn.startCase=Go,Nn.startsWith=function(n,t,r){return n=u(n),r=null==r?0:xu(0>r?0:+r||0,n.length),n.lastIndexOf(t,r)==r},Nn.sum=function(n,t,r){if(r&&Ur(n,t,r)&&(t=w),t=wr(t,r,3),1==t.length){n=Oo(n)?n:zr(n),r=n.length;for(var e=0;r--;)e+=+t(n[r])||0;n=e}else n=$t(n,t);return n},Nn.template=function(n,t,r){var e=Nn.templateSettings;r&&Ur(n,t,r)&&(t=r=w),n=u(n),t=nt(tt({},r||t),e,Qn),r=nt(tt({},t.imports),e.imports,Qn);
var o,i,f=zo(r),a=Ft(r,f),c=0;r=t.interpolate||Cn;var l="__p+='";r=Ze((t.escape||Cn).source+"|"+r.source+"|"+(r===gn?jn:Cn).source+"|"+(t.evaluate||Cn).source+"|$","g");var p="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,u,f,a){return e||(e=u),l+=n.slice(c,a).replace(Un,s),r&&(o=true,l+="'+__e("+r+")+'"),f&&(i=true,l+="';"+f+";\n__p+='"),e&&(l+="'+((__t=("+e+"))==null?'':__t)+'"),c=a+t.length,t}),l+="';",(t=t.variable)||(l="with(obj){"+l+"}"),l=(i?l.replace(fn,""):l).replace(an,"$1").replace(cn,"$1;"),
l="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(o?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+l+"return __p}",t=Jo(function(){return qe(f,p+"return "+l).apply(w,a)}),t.source=l,_e(t))throw t;return t},Nn.trim=We,Nn.trimLeft=function(n,t,r){var e=n;return(n=u(n))?n.slice((r?Ur(e,t,r):null==t)?g(n):o(n,t+"")):n},Nn.trimRight=function(n,t,r){var e=n;return(n=u(n))?(r?Ur(e,t,r):null==t)?n.slice(0,y(n)+1):n.slice(0,i(n,t+"")+1):n;
},Nn.trunc=function(n,t,r){r&&Ur(n,t,r)&&(t=w);var e=U;if(r=W,null!=t)if(ge(t)){var o="separator"in t?t.separator:o,e="length"in t?+t.length||0:e;r="omission"in t?u(t.omission):r}else e=+t||0;if(n=u(n),e>=n.length)return n;if(e-=r.length,1>e)return r;if(t=n.slice(0,e),null==o)return t+r;if(we(o)){if(n.slice(e).search(o)){var i,f=n.slice(0,e);for(o.global||(o=Ze(o.source,(kn.exec(o)||"")+"g")),o.lastIndex=0;n=o.exec(f);)i=n.index;t=t.slice(0,null==i?e:i)}}else n.indexOf(o,e)!=e&&(o=t.lastIndexOf(o),
-1<o&&(t=t.slice(0,o)));return t+r},Nn.unescape=function(n){return(n=u(n))&&pn.test(n)?n.replace(ln,d):n},Nn.uniqueId=function(n){var t=++tu;return u(n)+t},Nn.words=$e,Nn.all=te,Nn.any=ie,Nn.contains=ee,Nn.eq=he,Nn.detect=ro,Nn.foldl=lo,Nn.foldr=so,Nn.head=Kr,Nn.include=ee,Nn.inject=lo,Te(Nn,function(){var n={};return _t(Nn,function(t,r){Nn.prototype[r]||(n[r]=t)}),n}(),false),Nn.sample=oe,Nn.prototype.sample=function(n){return this.__chain__||null!=n?this.thru(function(t){return oe(t,n)}):oe(this.value());
},Nn.VERSION=b,Pn("bind bindKey curry curryRight partial partialRight".split(" "),function(n){Nn[n].placeholder=Nn}),Pn(["drop","take"],function(n,t){zn.prototype[n]=function(r){var e=this.__filtered__;if(e&&!t)return new zn(this);r=null==r?1:bu(yu(r)||0,0);var u=this.clone();return e?u.__takeCount__=xu(u.__takeCount__,r):u.__views__.push({size:r,type:n+(0>u.__dir__?"Right":"")}),u},zn.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),Pn(["filter","map","takeWhile"],function(n,t){
var r=t+1,e=r!=T;zn.prototype[n]=function(n,t){var u=this.clone();return u.__iteratees__.push({iteratee:wr(n,t,1),type:r}),u.__filtered__=u.__filtered__||e,u}}),Pn(["first","last"],function(n,t){var r="take"+(t?"Right":"");zn.prototype[n]=function(){return this[r](1).value()[0]}}),Pn(["initial","rest"],function(n,t){var r="drop"+(t?"":"Right");zn.prototype[n]=function(){return this.__filtered__?new zn(this):this[r](1)}}),Pn(["pluck","where"],function(n,t){var r=t?"filter":"map",e=t?bt:ze;zn.prototype[n]=function(n){
return this[r](e(n))}}),zn.prototype.compact=function(){return this.filter(Fe)},zn.prototype.reject=function(n,t){return n=wr(n,t,1),this.filter(function(t){return!n(t)})},zn.prototype.slice=function(n,t){n=null==n?0:+n||0;var r=this;return r.__filtered__&&(0<n||0>t)?new zn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==w&&(t=+t||0,r=0>t?r.dropRight(-t):r.take(t-n)),r)},zn.prototype.takeRightWhile=function(n,t){return this.reverse().takeWhile(n,t).reverse()},zn.prototype.toArray=function(){return this.take(Ru);
},_t(zn.prototype,function(n,t){var r=/^(?:filter|map|reject)|While$/.test(t),e=/^(?:first|last)$/.test(t),u=Nn[e?"take"+("last"==t?"Right":""):t];u&&(Nn.prototype[t]=function(){function t(n){return e&&i?u(n,1)[0]:u.apply(w,Jn([n],o))}var o=e?[1]:arguments,i=this.__chain__,f=this.__wrapped__,a=!!this.__actions__.length,c=f instanceof zn,l=o[0],s=c||Oo(f);return s&&r&&typeof l=="function"&&1!=l.length&&(c=s=false),l={func:ne,args:[t],thisArg:w},a=c&&!a,e&&!i?a?(f=f.clone(),f.__actions__.push(l),n.call(f)):u.call(w,this.value())[0]:!e&&s?(f=a?f:new zn(this),
f=n.apply(f,o),f.__actions__.push(l),new Ln(f,i)):this.thru(t)})}),Pn("join pop push replace shift sort splice split unshift".split(" "),function(n){var t=(/^(?:replace|split)$/.test(n)?He:Je)[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:join|pop|replace|shift)$/.test(n);Nn.prototype[n]=function(){var n=arguments;return e&&!this.__chain__?t.apply(this.value(),n):this[r](function(r){return t.apply(r,n)})}}),_t(zn.prototype,function(n,t){var r=Nn[t];if(r){var e=r.name;(Wu[e]||(Wu[e]=[])).push({
name:t,func:r})}}),Wu[sr(w,A).name]=[{name:"wrapper",func:w}],zn.prototype.clone=function(){var n=new zn(this.__wrapped__);return n.__actions__=qn(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=qn(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=qn(this.__views__),n},zn.prototype.reverse=function(){if(this.__filtered__){var n=new zn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},zn.prototype.value=function(){
var n,t=this.__wrapped__.value(),r=this.__dir__,e=Oo(t),u=0>r,o=e?t.length:0;n=o;for(var i=this.__views__,f=0,a=-1,c=i.length;++a<c;){var l=i[a],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=xu(n,f+s);break;case"takeRight":f=bu(f,n-s)}}if(n={start:f,end:n},i=n.start,f=n.end,n=f-i,i=u?f:i-1,f=this.__iteratees__,a=f.length,c=0,l=xu(n,this.__takeCount__),!e||o<F||o==n&&l==n)return Tt(u&&e?t.reverse():t,this.__actions__);e=[];n:for(;n--&&c<l;){for(i+=r,u=-1,o=t[i];++u<a;){
var p=f[u],s=p.type,p=p.iteratee(o);if(s==T)o=p;else if(!p){if(s==N)continue n;break n}}e[c++]=o}return e},Nn.prototype.chain=function(){return Qr(this)},Nn.prototype.commit=function(){return new Ln(this.value(),this.__chain__)},Nn.prototype.concat=Qu,Nn.prototype.plant=function(n){for(var t,r=this;r instanceof Tn;){var e=Mr(r);t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},Nn.prototype.reverse=function(){function n(n){return r&&0>r.__dir__?n:n.reverse()}var t=this.__wrapped__;
if(t instanceof zn){var r=t;return this.__actions__.length&&(r=new zn(this)),r=r.reverse(),r.__actions__.push({func:ne,args:[n],thisArg:w}),new Ln(r,this.__chain__)}return this.thru(n)},Nn.prototype.toString=function(){return this.value()+""},Nn.prototype.run=Nn.prototype.toJSON=Nn.prototype.valueOf=Nn.prototype.value=function(){return Tt(this.__wrapped__,this.__actions__)},Nn.prototype.collect=Nn.prototype.map,Nn.prototype.head=Nn.prototype.first,Nn.prototype.select=Nn.prototype.filter,Nn.prototype.tail=Nn.prototype.rest,
Nn}var w,b="3.10.0",x=1,A=2,j=4,k=8,I=16,R=32,O=64,E=128,C=256,U=30,W="...",$=150,S=16,F=200,N=1,T=2,L="Expected a function",z="__lodash_placeholder__",B="[object Arguments]",D="[object Array]",M="[object Boolean]",q="[object Date]",P="[object Error]",K="[object Function]",V="[object Number]",Z="[object Object]",Y="[object RegExp]",G="[object String]",J="[object ArrayBuffer]",X="[object Float32Array]",H="[object Float64Array]",Q="[object Int8Array]",nn="[object Int16Array]",tn="[object Int32Array]",rn="[object Uint8Array]",en="[object Uint8ClampedArray]",un="[object Uint16Array]",on="[object Uint32Array]",fn=/\b__p\+='';/g,an=/\b(__p\+=)''\+/g,cn=/(__e\(.*?\)|\b__t\))\+'';/g,ln=/&(?:amp|lt|gt|quot|#39|#96);/g,sn=/[&<>"'`]/g,pn=RegExp(ln.source),hn=RegExp(sn.source),_n=/<%-([\s\S]+?)%>/g,vn=/<%([\s\S]+?)%>/g,gn=/<%=([\s\S]+?)%>/g,yn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,dn=/^\w*$/,mn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g,wn=/^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,bn=RegExp(wn.source),xn=/[\u0300-\u036f\ufe20-\ufe23]/g,An=/\\(\\)?/g,jn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,kn=/\w*$/,In=/^0[xX]/,Rn=/^\[object .+?Constructor\]$/,On=/^\d+$/,En=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Cn=/($^)/,Un=/['\n\r\u2028\u2029\\]/g,Wn=RegExp("[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?=[A-Z\\xc0-\\xd6\\xd8-\\xde][a-z\\xdf-\\xf6\\xf8-\\xff]+)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+|[A-Z\\xc0-\\xd6\\xd8-\\xde]+|[0-9]+","g"),$n="Array ArrayBuffer Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Math Number Object RegExp Set String _ clearTimeout isFinite parseFloat parseInt setTimeout TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap".split(" "),Sn={};
Sn[X]=Sn[H]=Sn[Q]=Sn[nn]=Sn[tn]=Sn[rn]=Sn[en]=Sn[un]=Sn[on]=true,Sn[B]=Sn[D]=Sn[J]=Sn[M]=Sn[q]=Sn[P]=Sn[K]=Sn["[object Map]"]=Sn[V]=Sn[Z]=Sn[Y]=Sn["[object Set]"]=Sn[G]=Sn["[object WeakMap]"]=false;var Fn={};Fn[B]=Fn[D]=Fn[J]=Fn[M]=Fn[q]=Fn[X]=Fn[H]=Fn[Q]=Fn[nn]=Fn[tn]=Fn[V]=Fn[Z]=Fn[Y]=Fn[G]=Fn[rn]=Fn[en]=Fn[un]=Fn[on]=true,Fn[P]=Fn[K]=Fn["[object Map]"]=Fn["[object Set]"]=Fn["[object WeakMap]"]=false;var Nn={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a",
"\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y",
"\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss"},Tn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},Ln={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},zn={"function":true,object:true},Bn={0:"x30",1:"x31",2:"x32",3:"x33",4:"x34",5:"x35",6:"x36",7:"x37",8:"x38",9:"x39",A:"x41",B:"x42",C:"x43",D:"x44",E:"x45",F:"x46",a:"x61",b:"x62",c:"x63",d:"x64",e:"x65",f:"x66",n:"x6e",r:"x72",t:"x74",u:"x75",v:"x76",x:"x78"},Dn={"\\":"\\",
"'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Mn=zn[typeof exports]&&exports&&!exports.nodeType&&exports,qn=zn[typeof module]&&module&&!module.nodeType&&module,Pn=zn[typeof self]&&self&&self.Object&&self,Kn=zn[typeof window]&&window&&window.Object&&window,Vn=qn&&qn.exports===Mn&&Mn,Zn=Mn&&qn&&typeof global=="object"&&global&&global.Object&&global||Kn!==(this&&this.window)&&Kn||Pn||this,Yn=m();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=Yn, define(function(){
return Yn})):Mn&&qn?Vn?(qn.exports=Yn)._=Yn:Mn._=Yn:Zn._=Yn}).call(this);
; browserify_shim__define__module__export__(typeof _ != "undefined" ? _ : window._);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
(function (global){

; require("/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/backbone/backbone.js");
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
// MarionetteJS (Backbone.Marionette)
// ----------------------------------
// v2.4.2
//
// Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://marionettejs.com


/*!
 * Includes BabySitter
 * https://github.com/marionettejs/backbone.babysitter/
 *
 * Includes Wreqr
 * https://github.com/marionettejs/backbone.wreqr/
 */


(function(root, factory) {

  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return (root.Marionette = root.Mn = factory(root, Backbone, _));
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = __browserify_shim_require__('backbone');
    var _ = __browserify_shim_require__('underscore');
    module.exports = factory(root, Backbone, _);
  } else {
    root.Marionette = root.Mn = factory(root, root.Backbone, root._);
  }

}(this, function(root, Backbone, _) {
  'use strict';

  /* istanbul ignore next */
  // Backbone.BabySitter
  // -------------------
  // v0.1.7
  //
  // Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
  // Distributed under MIT license
  //
  // http://github.com/marionettejs/backbone.babysitter
  (function(Backbone, _) {
    "use strict";
    var previousChildViewContainer = Backbone.ChildViewContainer;
    // BabySitter.ChildViewContainer
    // -----------------------------
    //
    // Provide a container to store, retrieve and
    // shut down child views.
    Backbone.ChildViewContainer = function(Backbone, _) {
      // Container Constructor
      // ---------------------
      var Container = function(views) {
        this._views = {};
        this._indexByModel = {};
        this._indexByCustom = {};
        this._updateLength();
        _.each(views, this.add, this);
      };
      // Container Methods
      // -----------------
      _.extend(Container.prototype, {
        // Add a view to this container. Stores the view
        // by `cid` and makes it searchable by the model
        // cid (and model itself). Optionally specify
        // a custom key to store an retrieve the view.
        add: function(view, customIndex) {
          var viewCid = view.cid;
          // store the view
          this._views[viewCid] = view;
          // index it by model
          if (view.model) {
            this._indexByModel[view.model.cid] = viewCid;
          }
          // index by custom
          if (customIndex) {
            this._indexByCustom[customIndex] = viewCid;
          }
          this._updateLength();
          return this;
        },
        // Find a view by the model that was attached to
        // it. Uses the model's `cid` to find it.
        findByModel: function(model) {
          return this.findByModelCid(model.cid);
        },
        // Find a view by the `cid` of the model that was attached to
        // it. Uses the model's `cid` to find the view `cid` and
        // retrieve the view using it.
        findByModelCid: function(modelCid) {
          var viewCid = this._indexByModel[modelCid];
          return this.findByCid(viewCid);
        },
        // Find a view by a custom indexer.
        findByCustom: function(index) {
          var viewCid = this._indexByCustom[index];
          return this.findByCid(viewCid);
        },
        // Find by index. This is not guaranteed to be a
        // stable index.
        findByIndex: function(index) {
          return _.values(this._views)[index];
        },
        // retrieve a view by its `cid` directly
        findByCid: function(cid) {
          return this._views[cid];
        },
        // Remove a view
        remove: function(view) {
          var viewCid = view.cid;
          // delete model index
          if (view.model) {
            delete this._indexByModel[view.model.cid];
          }
          // delete custom index
          _.any(this._indexByCustom, function(cid, key) {
            if (cid === viewCid) {
              delete this._indexByCustom[key];
              return true;
            }
          }, this);
          // remove the view from the container
          delete this._views[viewCid];
          // update the length
          this._updateLength();
          return this;
        },
        // Call a method on every view in the container,
        // passing parameters to the call method one at a
        // time, like `function.call`.
        call: function(method) {
          this.apply(method, _.tail(arguments));
        },
        // Apply a method on every view in the container,
        // passing parameters to the call method one at a
        // time, like `function.apply`.
        apply: function(method, args) {
          _.each(this._views, function(view) {
            if (_.isFunction(view[method])) {
              view[method].apply(view, args || []);
            }
          });
        },
        // Update the `.length` attribute on this container
        _updateLength: function() {
          this.length = _.size(this._views);
        }
      });
      // Borrowing this code from Backbone.Collection:
      // http://backbonejs.org/docs/backbone.html#section-106
      //
      // Mix in methods from Underscore, for iteration, and other
      // collection related features.
      var methods = [ "forEach", "each", "map", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "toArray", "first", "initial", "rest", "last", "without", "isEmpty", "pluck", "reduce" ];
      _.each(methods, function(method) {
        Container.prototype[method] = function() {
          var views = _.values(this._views);
          var args = [ views ].concat(_.toArray(arguments));
          return _[method].apply(_, args);
        };
      });
      // return the public API
      return Container;
    }(Backbone, _);
    Backbone.ChildViewContainer.VERSION = "0.1.7";
    Backbone.ChildViewContainer.noConflict = function() {
      Backbone.ChildViewContainer = previousChildViewContainer;
      return this;
    };
    return Backbone.ChildViewContainer;
  })(Backbone, _);

  /* istanbul ignore next */
  // Backbone.Wreqr (Backbone.Marionette)
  // ----------------------------------
  // v1.3.3
  //
  // Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
  // Distributed under MIT license
  //
  // http://github.com/marionettejs/backbone.wreqr
  (function(Backbone, _) {
    "use strict";
    var previousWreqr = Backbone.Wreqr;
    var Wreqr = Backbone.Wreqr = {};
    Backbone.Wreqr.VERSION = "1.3.3";
    Backbone.Wreqr.noConflict = function() {
      Backbone.Wreqr = previousWreqr;
      return this;
    };
    // Handlers
    // --------
    // A registry of functions to call, given a name
    Wreqr.Handlers = function(Backbone, _) {
      "use strict";
      // Constructor
      // -----------
      var Handlers = function(options) {
        this.options = options;
        this._wreqrHandlers = {};
        if (_.isFunction(this.initialize)) {
          this.initialize(options);
        }
      };
      Handlers.extend = Backbone.Model.extend;
      // Instance Members
      // ----------------
      _.extend(Handlers.prototype, Backbone.Events, {
        // Add multiple handlers using an object literal configuration
        setHandlers: function(handlers) {
          _.each(handlers, function(handler, name) {
            var context = null;
            if (_.isObject(handler) && !_.isFunction(handler)) {
              context = handler.context;
              handler = handler.callback;
            }
            this.setHandler(name, handler, context);
          }, this);
        },
        // Add a handler for the given name, with an
        // optional context to run the handler within
        setHandler: function(name, handler, context) {
          var config = {
            callback: handler,
            context: context
          };
          this._wreqrHandlers[name] = config;
          this.trigger("handler:add", name, handler, context);
        },
        // Determine whether or not a handler is registered
        hasHandler: function(name) {
          return !!this._wreqrHandlers[name];
        },
        // Get the currently registered handler for
        // the specified name. Throws an exception if
        // no handler is found.
        getHandler: function(name) {
          var config = this._wreqrHandlers[name];
          if (!config) {
            return;
          }
          return function() {
            return config.callback.apply(config.context, arguments);
          };
        },
        // Remove a handler for the specified name
        removeHandler: function(name) {
          delete this._wreqrHandlers[name];
        },
        // Remove all handlers from this registry
        removeAllHandlers: function() {
          this._wreqrHandlers = {};
        }
      });
      return Handlers;
    }(Backbone, _);
    // Wreqr.CommandStorage
    // --------------------
    //
    // Store and retrieve commands for execution.
    Wreqr.CommandStorage = function() {
      "use strict";
      // Constructor function
      var CommandStorage = function(options) {
        this.options = options;
        this._commands = {};
        if (_.isFunction(this.initialize)) {
          this.initialize(options);
        }
      };
      // Instance methods
      _.extend(CommandStorage.prototype, Backbone.Events, {
        // Get an object literal by command name, that contains
        // the `commandName` and the `instances` of all commands
        // represented as an array of arguments to process
        getCommands: function(commandName) {
          var commands = this._commands[commandName];
          // we don't have it, so add it
          if (!commands) {
            // build the configuration
            commands = {
              command: commandName,
              instances: []
            };
            // store it
            this._commands[commandName] = commands;
          }
          return commands;
        },
        // Add a command by name, to the storage and store the
        // args for the command
        addCommand: function(commandName, args) {
          var command = this.getCommands(commandName);
          command.instances.push(args);
        },
        // Clear all commands for the given `commandName`
        clearCommands: function(commandName) {
          var command = this.getCommands(commandName);
          command.instances = [];
        }
      });
      return CommandStorage;
    }();
    // Wreqr.Commands
    // --------------
    //
    // A simple command pattern implementation. Register a command
    // handler and execute it.
    Wreqr.Commands = function(Wreqr, _) {
      "use strict";
      return Wreqr.Handlers.extend({
        // default storage type
        storageType: Wreqr.CommandStorage,
        constructor: function(options) {
          this.options = options || {};
          this._initializeStorage(this.options);
          this.on("handler:add", this._executeCommands, this);
          Wreqr.Handlers.prototype.constructor.apply(this, arguments);
        },
        // Execute a named command with the supplied args
        execute: function(name) {
          name = arguments[0];
          var args = _.rest(arguments);
          if (this.hasHandler(name)) {
            this.getHandler(name).apply(this, args);
          } else {
            this.storage.addCommand(name, args);
          }
        },
        // Internal method to handle bulk execution of stored commands
        _executeCommands: function(name, handler, context) {
          var command = this.storage.getCommands(name);
          // loop through and execute all the stored command instances
          _.each(command.instances, function(args) {
            handler.apply(context, args);
          });
          this.storage.clearCommands(name);
        },
        // Internal method to initialize storage either from the type's
        // `storageType` or the instance `options.storageType`.
        _initializeStorage: function(options) {
          var storage;
          var StorageType = options.storageType || this.storageType;
          if (_.isFunction(StorageType)) {
            storage = new StorageType();
          } else {
            storage = StorageType;
          }
          this.storage = storage;
        }
      });
    }(Wreqr, _);
    // Wreqr.RequestResponse
    // ---------------------
    //
    // A simple request/response implementation. Register a
    // request handler, and return a response from it
    Wreqr.RequestResponse = function(Wreqr, _) {
      "use strict";
      return Wreqr.Handlers.extend({
        request: function(name) {
          if (this.hasHandler(name)) {
            return this.getHandler(name).apply(this, _.rest(arguments));
          }
        }
      });
    }(Wreqr, _);
    // Event Aggregator
    // ----------------
    // A pub-sub object that can be used to decouple various parts
    // of an application through event-driven architecture.
    Wreqr.EventAggregator = function(Backbone, _) {
      "use strict";
      var EA = function() {};
      // Copy the `extend` function used by Backbone's classes
      EA.extend = Backbone.Model.extend;
      // Copy the basic Backbone.Events on to the event aggregator
      _.extend(EA.prototype, Backbone.Events);
      return EA;
    }(Backbone, _);
    // Wreqr.Channel
    // --------------
    //
    // An object that wraps the three messaging systems:
    // EventAggregator, RequestResponse, Commands
    Wreqr.Channel = function(Wreqr) {
      "use strict";
      var Channel = function(channelName) {
        this.vent = new Backbone.Wreqr.EventAggregator();
        this.reqres = new Backbone.Wreqr.RequestResponse();
        this.commands = new Backbone.Wreqr.Commands();
        this.channelName = channelName;
      };
      _.extend(Channel.prototype, {
        // Remove all handlers from the messaging systems of this channel
        reset: function() {
          this.vent.off();
          this.vent.stopListening();
          this.reqres.removeAllHandlers();
          this.commands.removeAllHandlers();
          return this;
        },
        // Connect a hash of events; one for each messaging system
        connectEvents: function(hash, context) {
          this._connect("vent", hash, context);
          return this;
        },
        connectCommands: function(hash, context) {
          this._connect("commands", hash, context);
          return this;
        },
        connectRequests: function(hash, context) {
          this._connect("reqres", hash, context);
          return this;
        },
        // Attach the handlers to a given message system `type`
        _connect: function(type, hash, context) {
          if (!hash) {
            return;
          }
          context = context || this;
          var method = type === "vent" ? "on" : "setHandler";
          _.each(hash, function(fn, eventName) {
            this[type][method](eventName, _.bind(fn, context));
          }, this);
        }
      });
      return Channel;
    }(Wreqr);
    // Wreqr.Radio
    // --------------
    //
    // An object that lets you communicate with many channels.
    Wreqr.radio = function(Wreqr, _) {
      "use strict";
      var Radio = function() {
        this._channels = {};
        this.vent = {};
        this.commands = {};
        this.reqres = {};
        this._proxyMethods();
      };
      _.extend(Radio.prototype, {
        channel: function(channelName) {
          if (!channelName) {
            throw new Error("Channel must receive a name");
          }
          return this._getChannel(channelName);
        },
        _getChannel: function(channelName) {
          var channel = this._channels[channelName];
          if (!channel) {
            channel = new Wreqr.Channel(channelName);
            this._channels[channelName] = channel;
          }
          return channel;
        },
        _proxyMethods: function() {
          _.each([ "vent", "commands", "reqres" ], function(system) {
            _.each(messageSystems[system], function(method) {
              this[system][method] = proxyMethod(this, system, method);
            }, this);
          }, this);
        }
      });
      var messageSystems = {
        vent: [ "on", "off", "trigger", "once", "stopListening", "listenTo", "listenToOnce" ],
        commands: [ "execute", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ],
        reqres: [ "request", "setHandler", "setHandlers", "removeHandler", "removeAllHandlers" ]
      };
      var proxyMethod = function(radio, system, method) {
        return function(channelName) {
          var messageSystem = radio._getChannel(channelName)[system];
          return messageSystem[method].apply(messageSystem, _.rest(arguments));
        };
      };
      return new Radio();
    }(Wreqr, _);
    return Backbone.Wreqr;
  })(Backbone, _);

  var previousMarionette = root.Marionette;
  var previousMn = root.Mn;

  var Marionette = Backbone.Marionette = {};

  Marionette.VERSION = '2.4.2';

  Marionette.noConflict = function() {
    root.Marionette = previousMarionette;
    root.Mn = previousMn;
    return this;
  };

  Backbone.Marionette = Marionette;

  // Get the Deferred creator for later use
  Marionette.Deferred = Backbone.$.Deferred;

  /* jshint unused: false *//* global console */
  
  // Helpers
  // -------
  
  // Marionette.extend
  // -----------------
  
  // Borrow the Backbone `extend` method so we can use it as needed
  Marionette.extend = Backbone.Model.extend;
  
  // Marionette.isNodeAttached
  // -------------------------
  
  // Determine if `el` is a child of the document
  Marionette.isNodeAttached = function(el) {
    return Backbone.$.contains(document.documentElement, el);
  };
  
  // Merge `keys` from `options` onto `this`
  Marionette.mergeOptions = function(options, keys) {
    if (!options) { return; }
    _.extend(this, _.pick(options, keys));
  };
  
  // Marionette.getOption
  // --------------------
  
  // Retrieve an object, function or other value from a target
  // object or its `options`, with `options` taking precedence.
  Marionette.getOption = function(target, optionName) {
    if (!target || !optionName) { return; }
    if (target.options && (target.options[optionName] !== undefined)) {
      return target.options[optionName];
    } else {
      return target[optionName];
    }
  };
  
  // Proxy `Marionette.getOption`
  Marionette.proxyGetOption = function(optionName) {
    return Marionette.getOption(this, optionName);
  };
  
  // Similar to `_.result`, this is a simple helper
  // If a function is provided we call it with context
  // otherwise just return the value. If the value is
  // undefined return a default value
  Marionette._getValue = function(value, context, params) {
    if (_.isFunction(value)) {
      value = params ? value.apply(context, params) : value.call(context);
    }
    return value;
  };
  
  // Marionette.normalizeMethods
  // ----------------------
  
  // Pass in a mapping of events => functions or function names
  // and return a mapping of events => functions
  Marionette.normalizeMethods = function(hash) {
    return _.reduce(hash, function(normalizedHash, method, name) {
      if (!_.isFunction(method)) {
        method = this[method];
      }
      if (method) {
        normalizedHash[name] = method;
      }
      return normalizedHash;
    }, {}, this);
  };
  
  // utility method for parsing @ui. syntax strings
  // into associated selector
  Marionette.normalizeUIString = function(uiString, ui) {
    return uiString.replace(/@ui\.[a-zA-Z_$0-9]*/g, function(r) {
      return ui[r.slice(4)];
    });
  };
  
  // allows for the use of the @ui. syntax within
  // a given key for triggers and events
  // swaps the @ui with the associated selector.
  // Returns a new, non-mutated, parsed events hash.
  Marionette.normalizeUIKeys = function(hash, ui) {
    return _.reduce(hash, function(memo, val, key) {
      var normalizedKey = Marionette.normalizeUIString(key, ui);
      memo[normalizedKey] = val;
      return memo;
    }, {});
  };
  
  // allows for the use of the @ui. syntax within
  // a given value for regions
  // swaps the @ui with the associated selector
  Marionette.normalizeUIValues = function(hash, ui, properties) {
    _.each(hash, function(val, key) {
      if (_.isString(val)) {
        hash[key] = Marionette.normalizeUIString(val, ui);
      } else if (_.isObject(val) && _.isArray(properties)) {
        _.extend(val, Marionette.normalizeUIValues(_.pick(val, properties), ui));
        /* Value is an object, and we got an array of embedded property names to normalize. */
        _.each(properties, function(property) {
          var propertyVal = val[property];
          if (_.isString(propertyVal)) {
            val[property] = Marionette.normalizeUIString(propertyVal, ui);
          }
        });
      }
    });
    return hash;
  };
  
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-121
  Marionette.actAsCollection = function(object, listProperty) {
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck'];
  
    _.each(methods, function(method) {
      object[method] = function() {
        var list = _.values(_.result(this, listProperty));
        var args = [list].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  };
  
  var deprecate = Marionette.deprecate = function(message, test) {
    if (_.isObject(message)) {
      message = (
        message.prev + ' is going to be removed in the future. ' +
        'Please use ' + message.next + ' instead.' +
        (message.url ? ' See: ' + message.url : '')
      );
    }
  
    if ((test === undefined || !test) && !deprecate._cache[message]) {
      deprecate._warn('Deprecation warning: ' + message);
      deprecate._cache[message] = true;
    }
  };
  
  deprecate._warn = typeof console !== 'undefined' && (console.warn || console.log) || function() {};
  deprecate._cache = {};
  
  /* jshint maxstatements: 14, maxcomplexity: 7 */
  
  // Trigger Method
  // --------------
  
  Marionette._triggerMethod = (function() {
    // split the event name on the ":"
    var splitter = /(^|:)(\w)/gi;
  
    // take the event section ("section1:section2:section3")
    // and turn it in to uppercase name
    function getEventName(match, prefix, eventName) {
      return eventName.toUpperCase();
    }
  
    return function(context, event, args) {
      var noEventArg = arguments.length < 3;
      if (noEventArg) {
        args = event;
        event = args[0];
      }
  
      // get the method name from the event name
      var methodName = 'on' + event.replace(splitter, getEventName);
      var method = context[methodName];
      var result;
  
      // call the onMethodName if it exists
      if (_.isFunction(method)) {
        // pass all args, except the event name
        result = method.apply(context, noEventArg ? _.rest(args) : args);
      }
  
      // trigger the event, if a trigger method exists
      if (_.isFunction(context.trigger)) {
        if (noEventArg + args.length > 1) {
          context.trigger.apply(context, noEventArg ? args : [event].concat(_.drop(args, 0)));
        } else {
          context.trigger(event);
        }
      }
  
      return result;
    };
  })();
  
  // Trigger an event and/or a corresponding method name. Examples:
  //
  // `this.triggerMethod("foo")` will trigger the "foo" event and
  // call the "onFoo" method.
  //
  // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
  // call the "onFooBar" method.
  Marionette.triggerMethod = function(event) {
    return Marionette._triggerMethod(this, arguments);
  };
  
  // triggerMethodOn invokes triggerMethod on a specific context
  //
  // e.g. `Marionette.triggerMethodOn(view, 'show')`
  // will trigger a "show" event or invoke onShow the view.
  Marionette.triggerMethodOn = function(context) {
    var fnc = _.isFunction(context.triggerMethod) ?
                  context.triggerMethod :
                  Marionette.triggerMethod;
  
    return fnc.apply(context, _.rest(arguments));
  };
  
  // DOM Refresh
  // -----------
  
  // Monitor a view's state, and after it has been rendered and shown
  // in the DOM, trigger a "dom:refresh" event every time it is
  // re-rendered.
  
  Marionette.MonitorDOMRefresh = function(view) {
  
    // track when the view has been shown in the DOM,
    // using a Marionette.Region (or by other means of triggering "show")
    function handleShow() {
      view._isShown = true;
      triggerDOMRefresh();
    }
  
    // track when the view has been rendered
    function handleRender() {
      view._isRendered = true;
      triggerDOMRefresh();
    }
  
    // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
    function triggerDOMRefresh() {
      if (view._isShown && view._isRendered && Marionette.isNodeAttached(view.el)) {
        if (_.isFunction(view.triggerMethod)) {
          view.triggerMethod('dom:refresh');
        }
      }
    }
  
    view.on({
      show: handleShow,
      render: handleRender
    });
  };
  
  /* jshint maxparams: 5 */
  
  // Bind Entity Events & Unbind Entity Events
  // -----------------------------------------
  //
  // These methods are used to bind/unbind a backbone "entity" (e.g. collection/model)
  // to methods on a target object.
  //
  // The first parameter, `target`, must have the Backbone.Events module mixed in.
  //
  // The second parameter is the `entity` (Backbone.Model, Backbone.Collection or
  // any object that has Backbone.Events mixed in) to bind the events from.
  //
  // The third parameter is a hash of { "event:name": "eventHandler" }
  // configuration. Multiple handlers can be separated by a space. A
  // function can be supplied instead of a string handler name.
  
  (function(Marionette) {
    'use strict';
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function bindFromStrings(target, entity, evt, methods) {
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
  
        var method = target[methodName];
        if (!method) {
          throw new Marionette.Error('Method "' + methodName +
            '" was configured as an event handler, but does not exist.');
        }
  
        target.listenTo(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function bindToFunction(target, entity, evt, method) {
      target.listenTo(entity, evt, method);
    }
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function unbindFromStrings(target, entity, evt, methods) {
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
        var method = target[methodName];
        target.stopListening(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function unbindToFunction(target, entity, evt, method) {
      target.stopListening(entity, evt, method);
    }
  
    // generic looping function
    function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
      if (!entity || !bindings) { return; }
  
      // type-check bindings
      if (!_.isObject(bindings)) {
        throw new Marionette.Error({
          message: 'Bindings must be an object or function.',
          url: 'marionette.functions.html#marionettebindentityevents'
        });
      }
  
      // allow the bindings to be a function
      bindings = Marionette._getValue(bindings, target);
  
      // iterate the bindings and bind them
      _.each(bindings, function(methods, evt) {
  
        // allow for a function as the handler,
        // or a list of event names as a string
        if (_.isFunction(methods)) {
          functionCallback(target, entity, evt, methods);
        } else {
          stringCallback(target, entity, evt, methods);
        }
  
      });
    }
  
    // Export Public API
    Marionette.bindEntityEvents = function(target, entity, bindings) {
      iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
    };
  
    Marionette.unbindEntityEvents = function(target, entity, bindings) {
      iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
    };
  
    // Proxy `bindEntityEvents`
    Marionette.proxyBindEntityEvents = function(entity, bindings) {
      return Marionette.bindEntityEvents(this, entity, bindings);
    };
  
    // Proxy `unbindEntityEvents`
    Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
      return Marionette.unbindEntityEvents(this, entity, bindings);
    };
  })(Marionette);
  

  // Error
  // -----
  
  var errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];
  
  Marionette.Error = Marionette.extend.call(Error, {
    urlRoot: 'http://marionettejs.com/docs/v' + Marionette.VERSION + '/',
  
    constructor: function(message, options) {
      if (_.isObject(message)) {
        options = message;
        message = options.message;
      } else if (!options) {
        options = {};
      }
  
      var error = Error.call(this, message);
      _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));
  
      this.captureStackTrace();
  
      if (options.url) {
        this.url = this.urlRoot + options.url;
      }
    },
  
    captureStackTrace: function() {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Marionette.Error);
      }
    },
  
    toString: function() {
      return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');
    }
  });
  
  Marionette.Error.extend = Marionette.extend;
  
  // Callbacks
  // ---------
  
  // A simple way of managing a collection of callbacks
  // and executing them at a later point in time, using jQuery's
  // `Deferred` object.
  Marionette.Callbacks = function() {
    this._deferred = Marionette.Deferred();
    this._callbacks = [];
  };
  
  _.extend(Marionette.Callbacks.prototype, {
  
    // Add a callback to be executed. Callbacks added here are
    // guaranteed to execute, even if they are added after the
    // `run` method is called.
    add: function(callback, contextOverride) {
      var promise = _.result(this._deferred, 'promise');
  
      this._callbacks.push({cb: callback, ctx: contextOverride});
  
      promise.then(function(args) {
        if (contextOverride) { args.context = contextOverride; }
        callback.call(args.context, args.options);
      });
    },
  
    // Run all registered callbacks with the context specified.
    // Additional callbacks can be added after this has been run
    // and they will still be executed.
    run: function(options, context) {
      this._deferred.resolve({
        options: options,
        context: context
      });
    },
  
    // Resets the list of callbacks to be run, allowing the same list
    // to be run multiple times - whenever the `run` method is called.
    reset: function() {
      var callbacks = this._callbacks;
      this._deferred = Marionette.Deferred();
      this._callbacks = [];
  
      _.each(callbacks, function(cb) {
        this.add(cb.cb, cb.ctx);
      }, this);
    }
  });
  
  // Controller
  // ----------
  
  // A multi-purpose object to use as a controller for
  // modules and routers, and as a mediator for workflow
  // and coordination of other objects, views, and more.
  Marionette.Controller = function(options) {
    this.options = options || {};
  
    if (_.isFunction(this.initialize)) {
      this.initialize(this.options);
    }
  };
  
  Marionette.Controller.extend = Marionette.extend;
  
  // Controller Methods
  // --------------
  
  // Ensure it can trigger events with Backbone.Events
  _.extend(Marionette.Controller.prototype, Backbone.Events, {
    destroy: function() {
      Marionette._triggerMethod(this, 'before:destroy', arguments);
      Marionette._triggerMethod(this, 'destroy', arguments);
  
      this.stopListening();
      this.off();
      return this;
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod,
  
    // A handy way to merge options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption
  
  });
  
  // Object
  // ------
  
  // A Base Class that other Classes should descend from.
  // Object borrows many conventions and utilities from Backbone.
  Marionette.Object = function(options) {
    this.options = _.extend({}, _.result(this, 'options'), options);
  
    this.initialize.apply(this, arguments);
  };
  
  Marionette.Object.extend = Marionette.extend;
  
  // Object Methods
  // --------------
  
  // Ensure it can trigger events with Backbone.Events
  _.extend(Marionette.Object.prototype, Backbone.Events, {
  
    //this is a noop method intended to be overridden by classes that extend from this base
    initialize: function() {},
  
    destroy: function() {
      this.triggerMethod('before:destroy');
      this.triggerMethod('destroy');
      this.stopListening();
  
      return this;
    },
  
    // Import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod,
  
    // A handy way to merge options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  /* jshint maxcomplexity: 16, maxstatements: 45, maxlen: 120 */
  
  // Region
  // ------
  
  // Manage the visual regions of your composite application. See
  // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/
  
  Marionette.Region = Marionette.Object.extend({
    constructor: function(options) {
  
      // set options temporarily so that we can get `el`.
      // options will be overriden by Object.constructor
      this.options = options || {};
      this.el = this.getOption('el');
  
      // Handle when this.el is passed in as a $ wrapped element.
      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;
  
      if (!this.el) {
        throw new Marionette.Error({
          name: 'NoElError',
          message: 'An "el" must be specified for a region.'
        });
      }
  
      this.$el = this.getEl(this.el);
      Marionette.Object.call(this, options);
    },
  
    // Displays a backbone view instance inside of the region.
    // Handles calling the `render` method for you. Reads content
    // directly from the `el` attribute. Also calls an optional
    // `onShow` and `onDestroy` method on your view, just after showing
    // or just before destroying the view, respectively.
    // The `preventDestroy` option can be used to prevent a view from
    // the old view being destroyed on show.
    // The `forceShow` option can be used to force a view to be
    // re-rendered if it's already shown in the region.
    show: function(view, options) {
      if (!this._ensureElement()) {
        return;
      }
  
      this._ensureViewIsIntact(view);
  
      var showOptions     = options || {};
      var isDifferentView = view !== this.currentView;
      var preventDestroy  = !!showOptions.preventDestroy;
      var forceShow       = !!showOptions.forceShow;
  
      // We are only changing the view if there is a current view to change to begin with
      var isChangingView = !!this.currentView;
  
      // Only destroy the current view if we don't want to `preventDestroy` and if
      // the view given in the first argument is different than `currentView`
      var _shouldDestroyView = isDifferentView && !preventDestroy;
  
      // Only show the view given in the first argument if it is different than
      // the current view or if we want to re-show the view. Note that if
      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.
      var _shouldShowView = isDifferentView || forceShow;
  
      if (isChangingView) {
        this.triggerMethod('before:swapOut', this.currentView, this, options);
      }
  
      if (this.currentView) {
        delete this.currentView._parent;
      }
  
      if (_shouldDestroyView) {
        this.empty();
  
      // A `destroy` event is attached to the clean up manually removed views.
      // We need to detach this event when a new view is going to be shown as it
      // is no longer relevant.
      } else if (isChangingView && _shouldShowView) {
        this.currentView.off('destroy', this.empty, this);
      }
  
      if (_shouldShowView) {
  
        // We need to listen for if a view is destroyed
        // in a way other than through the region.
        // If this happens we need to remove the reference
        // to the currentView since once a view has been destroyed
        // we can not reuse it.
        view.once('destroy', this.empty, this);
        view.render();
  
        view._parent = this;
  
        if (isChangingView) {
          this.triggerMethod('before:swap', view, this, options);
        }
  
        this.triggerMethod('before:show', view, this, options);
        Marionette.triggerMethodOn(view, 'before:show', view, this, options);
  
        if (isChangingView) {
          this.triggerMethod('swapOut', this.currentView, this, options);
        }
  
        // An array of views that we're about to display
        var attachedRegion = Marionette.isNodeAttached(this.el);
  
        // The views that we're about to attach to the document
        // It's important that we prevent _getNestedViews from being executed unnecessarily
        // as it's a potentially-slow method
        var displayedViews = [];
  
        var attachOptions = _.extend({
          triggerBeforeAttach: this.triggerBeforeAttach,
          triggerAttach: this.triggerAttach
        }, showOptions);
  
        if (attachedRegion && attachOptions.triggerBeforeAttach) {
          displayedViews = this._displayedViews(view);
          this._triggerAttach(displayedViews, 'before:');
        }
  
        this.attachHtml(view);
        this.currentView = view;
  
        if (attachedRegion && attachOptions.triggerAttach) {
          displayedViews = this._displayedViews(view);
          this._triggerAttach(displayedViews);
        }
  
        if (isChangingView) {
          this.triggerMethod('swap', view, this, options);
        }
  
        this.triggerMethod('show', view, this, options);
        Marionette.triggerMethodOn(view, 'show', view, this, options);
  
        return this;
      }
  
      return this;
    },
  
    triggerBeforeAttach: true,
    triggerAttach: true,
  
    _triggerAttach: function(views, prefix) {
      var eventName = (prefix || '') + 'attach';
      _.each(views, function(view) {
        Marionette.triggerMethodOn(view, eventName, view, this);
      }, this);
    },
  
    _displayedViews: function(view) {
      return _.union([view], _.result(view, '_getNestedViews') || []);
    },
  
    _ensureElement: function() {
      if (!_.isObject(this.el)) {
        this.$el = this.getEl(this.el);
        this.el = this.$el[0];
      }
  
      if (!this.$el || this.$el.length === 0) {
        if (this.getOption('allowMissingEl')) {
          return false;
        } else {
          throw new Marionette.Error('An "el" ' + this.$el.selector + ' must exist in DOM');
        }
      }
      return true;
    },
  
    _ensureViewIsIntact: function(view) {
      if (!view) {
        throw new Marionette.Error({
          name: 'ViewNotValid',
          message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'
        });
      }
  
      if (view.isDestroyed) {
        throw new Marionette.Error({
          name: 'ViewDestroyedError',
          message: 'View (cid: "' + view.cid + '") has already been destroyed and cannot be used.'
        });
      }
    },
  
    // Override this method to change how the region finds the DOM
    // element that it manages. Return a jQuery selector object scoped
    // to a provided parent el or the document if none exists.
    getEl: function(el) {
      return Backbone.$(el, Marionette._getValue(this.options.parentEl, this));
    },
  
    // Override this method to change how the new view is
    // appended to the `$el` that the region is managing
    attachHtml: function(view) {
      this.$el.contents().detach();
  
      this.el.appendChild(view.el);
    },
  
    // Destroy the current view, if there is one. If there is no
    // current view, it does nothing and returns immediately.
    empty: function(options) {
      var view = this.currentView;
  
      var preventDestroy = Marionette._getValue(options, 'preventDestroy', this);
      // If there is no view in the region
      // we should not remove anything
      if (!view) { return; }
  
      view.off('destroy', this.empty, this);
      this.triggerMethod('before:empty', view);
      if (!preventDestroy) {
        this._destroyView();
      }
      this.triggerMethod('empty', view);
  
      // Remove region pointer to the currentView
      delete this.currentView;
  
      if (preventDestroy) {
        this.$el.contents().detach();
      }
  
      return this;
    },
  
    // call 'destroy' or 'remove', depending on which is found
    // on the view (if showing a raw Backbone view or a Marionette View)
    _destroyView: function() {
      var view = this.currentView;
  
      if (view.destroy && !view.isDestroyed) {
        view.destroy();
      } else if (view.remove) {
        view.remove();
  
        // appending isDestroyed to raw Backbone View allows regions
        // to throw a ViewDestroyedError for this view
        view.isDestroyed = true;
      }
    },
  
    // Attach an existing view to the region. This
    // will not call `render` or `onShow` for the new view,
    // and will not replace the current HTML for the `el`
    // of the region.
    attachView: function(view) {
      this.currentView = view;
      return this;
    },
  
    // Checks whether a view is currently present within
    // the region. Returns `true` if there is and `false` if
    // no view is present.
    hasView: function() {
      return !!this.currentView;
    },
  
    // Reset the region by destroying any existing view and
    // clearing out the cached `$el`. The next time a view
    // is shown via this region, the region will re-query the
    // DOM for the region's `el`.
    reset: function() {
      this.empty();
  
      if (this.$el) {
        this.el = this.$el.selector;
      }
  
      delete this.$el;
      return this;
    }
  
  },
  
  // Static Methods
  {
  
    // Build an instance of a region by passing in a configuration object
    // and a default region class to use if none is specified in the config.
    //
    // The config object should either be a string as a jQuery DOM selector,
    // a Region class directly, or an object literal that specifies a selector,
    // a custom regionClass, and any options to be supplied to the region:
    //
    // ```js
    // {
    //   selector: "#foo",
    //   regionClass: MyCustomRegion,
    //   allowMissingEl: false
    // }
    // ```
    //
    buildRegion: function(regionConfig, DefaultRegionClass) {
      if (_.isString(regionConfig)) {
        return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
      }
  
      if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
        return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
      }
  
      if (_.isFunction(regionConfig)) {
        return this._buildRegionFromRegionClass(regionConfig);
      }
  
      throw new Marionette.Error({
        message: 'Improper region configuration type.',
        url: 'marionette.region.html#region-configuration-types'
      });
    },
  
    // Build the region from a string selector like '#foo-region'
    _buildRegionFromSelector: function(selector, DefaultRegionClass) {
      return new DefaultRegionClass({el: selector});
    },
  
    // Build the region from a configuration object
    // ```js
    // { selector: '#foo', regionClass: FooRegion, allowMissingEl: false }
    // ```
    _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
      var RegionClass = regionConfig.regionClass || DefaultRegionClass;
      var options = _.omit(regionConfig, 'selector', 'regionClass');
  
      if (regionConfig.selector && !options.el) {
        options.el = regionConfig.selector;
      }
  
      return new RegionClass(options);
    },
  
    // Build the region directly from a given `RegionClass`
    _buildRegionFromRegionClass: function(RegionClass) {
      return new RegionClass();
    }
  });
  
  // Region Manager
  // --------------
  
  // Manage one or more related `Marionette.Region` objects.
  Marionette.RegionManager = Marionette.Controller.extend({
    constructor: function(options) {
      this._regions = {};
      this.length = 0;
  
      Marionette.Controller.call(this, options);
  
      this.addRegions(this.getOption('regions'));
    },
  
    // Add multiple regions using an object literal or a
    // function that returns an object literal, where
    // each key becomes the region name, and each value is
    // the region definition.
    addRegions: function(regionDefinitions, defaults) {
      regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);
  
      return _.reduce(regionDefinitions, function(regions, definition, name) {
        if (_.isString(definition)) {
          definition = {selector: definition};
        }
        if (definition.selector) {
          definition = _.defaults({}, definition, defaults);
        }
  
        regions[name] = this.addRegion(name, definition);
        return regions;
      }, {}, this);
    },
  
    // Add an individual region to the region manager,
    // and return the region instance
    addRegion: function(name, definition) {
      var region;
  
      if (definition instanceof Marionette.Region) {
        region = definition;
      } else {
        region = Marionette.Region.buildRegion(definition, Marionette.Region);
      }
  
      this.triggerMethod('before:add:region', name, region);
  
      region._parent = this;
      this._store(name, region);
  
      this.triggerMethod('add:region', name, region);
      return region;
    },
  
    // Get a region by name
    get: function(name) {
      return this._regions[name];
    },
  
    // Gets all the regions contained within
    // the `regionManager` instance.
    getRegions: function() {
      return _.clone(this._regions);
    },
  
    // Remove a region by name
    removeRegion: function(name) {
      var region = this._regions[name];
      this._remove(name, region);
  
      return region;
    },
  
    // Empty all regions in the region manager, and
    // remove them
    removeRegions: function() {
      var regions = this.getRegions();
      _.each(this._regions, function(region, name) {
        this._remove(name, region);
      }, this);
  
      return regions;
    },
  
    // Empty all regions in the region manager, but
    // leave them attached
    emptyRegions: function() {
      var regions = this.getRegions();
      _.invoke(regions, 'empty');
      return regions;
    },
  
    // Destroy all regions and shut down the region
    // manager entirely
    destroy: function() {
      this.removeRegions();
      return Marionette.Controller.prototype.destroy.apply(this, arguments);
    },
  
    // internal method to store regions
    _store: function(name, region) {
      if (!this._regions[name]) {
        this.length++;
      }
  
      this._regions[name] = region;
    },
  
    // internal method to remove a region
    _remove: function(name, region) {
      this.triggerMethod('before:remove:region', name, region);
      region.empty();
      region.stopListening();
  
      delete region._parent;
      delete this._regions[name];
      this.length--;
      this.triggerMethod('remove:region', name, region);
    }
  });
  
  Marionette.actAsCollection(Marionette.RegionManager.prototype, '_regions');
  

  // Template Cache
  // --------------
  
  // Manage templates stored in `<script>` blocks,
  // caching them for faster access.
  Marionette.TemplateCache = function(templateId) {
    this.templateId = templateId;
  };
  
  // TemplateCache object-level methods. Manage the template
  // caches from these method calls instead of creating
  // your own TemplateCache instances
  _.extend(Marionette.TemplateCache, {
    templateCaches: {},
  
    // Get the specified template by id. Either
    // retrieves the cached version, or loads it
    // from the DOM.
    get: function(templateId, options) {
      var cachedTemplate = this.templateCaches[templateId];
  
      if (!cachedTemplate) {
        cachedTemplate = new Marionette.TemplateCache(templateId);
        this.templateCaches[templateId] = cachedTemplate;
      }
  
      return cachedTemplate.load(options);
    },
  
    // Clear templates from the cache. If no arguments
    // are specified, clears all templates:
    // `clear()`
    //
    // If arguments are specified, clears each of the
    // specified templates from the cache:
    // `clear("#t1", "#t2", "...")`
    clear: function() {
      var i;
      var args = _.toArray(arguments);
      var length = args.length;
  
      if (length > 0) {
        for (i = 0; i < length; i++) {
          delete this.templateCaches[args[i]];
        }
      } else {
        this.templateCaches = {};
      }
    }
  });
  
  // TemplateCache instance methods, allowing each
  // template cache object to manage its own state
  // and know whether or not it has been loaded
  _.extend(Marionette.TemplateCache.prototype, {
  
    // Internal method to load the template
    load: function(options) {
      // Guard clause to prevent loading this template more than once
      if (this.compiledTemplate) {
        return this.compiledTemplate;
      }
  
      // Load the template and compile it
      var template = this.loadTemplate(this.templateId, options);
      this.compiledTemplate = this.compileTemplate(template, options);
  
      return this.compiledTemplate;
    },
  
    // Load a template from the DOM, by default. Override
    // this method to provide your own template retrieval
    // For asynchronous loading with AMD/RequireJS, consider
    // using a template-loader plugin as described here:
    // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
    loadTemplate: function(templateId, options) {
      var template = Backbone.$(templateId).html();
  
      if (!template || template.length === 0) {
        throw new Marionette.Error({
          name: 'NoTemplateError',
          message: 'Could not find template: "' + templateId + '"'
        });
      }
  
      return template;
    },
  
    // Pre-compile the template before caching it. Override
    // this method if you do not need to pre-compile a template
    // (JST / RequireJS for example) or if you want to change
    // the template engine used (Handebars, etc).
    compileTemplate: function(rawTemplate, options) {
      return _.template(rawTemplate, options);
    }
  });
  
  // Renderer
  // --------
  
  // Render a template with data by passing in the template
  // selector and the data to render.
  Marionette.Renderer = {
  
    // Render a template with data. The `template` parameter is
    // passed to the `TemplateCache` object to retrieve the
    // template function. Override this method to provide your own
    // custom rendering and template handling for all of Marionette.
    render: function(template, data) {
      if (!template) {
        throw new Marionette.Error({
          name: 'TemplateNotFoundError',
          message: 'Cannot render the template since its false, null or undefined.'
        });
      }
  
      var templateFunc = _.isFunction(template) ? template : Marionette.TemplateCache.get(template);
  
      return templateFunc(data);
    }
  };
  

  /* jshint maxlen: 114, nonew: false */
  // View
  // ----
  
  // The core view class that other Marionette views extend from.
  Marionette.View = Backbone.View.extend({
    isDestroyed: false,
  
    constructor: function(options) {
      _.bindAll(this, 'render');
  
      options = Marionette._getValue(options, this);
  
      // this exposes view options to the view initializer
      // this is a backfill since backbone removed the assignment
      // of this.options
      // at some point however this may be removed
      this.options = _.extend({}, _.result(this, 'options'), options);
  
      this._behaviors = Marionette.Behaviors(this);
  
      Backbone.View.call(this, this.options);
  
      Marionette.MonitorDOMRefresh(this);
    },
  
    // Get the template for this view
    // instance. You can set a `template` attribute in the view
    // definition or pass a `template: "whatever"` parameter in
    // to the constructor options.
    getTemplate: function() {
      return this.getOption('template');
    },
  
    // Serialize a model by returning its attributes. Clones
    // the attributes to allow modification.
    serializeModel: function(model) {
      return model.toJSON.apply(model, _.rest(arguments));
    },
  
    // Mix in template helper methods. Looks for a
    // `templateHelpers` attribute, which can either be an
    // object literal, or a function that returns an object
    // literal. All methods and attributes from this object
    // are copies to the object passed in.
    mixinTemplateHelpers: function(target) {
      target = target || {};
      var templateHelpers = this.getOption('templateHelpers');
      templateHelpers = Marionette._getValue(templateHelpers, this);
      return _.extend(target, templateHelpers);
    },
  
    // normalize the keys of passed hash with the views `ui` selectors.
    // `{"@ui.foo": "bar"}`
    normalizeUIKeys: function(hash) {
      var uiBindings = _.result(this, '_uiBindings');
      return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, 'ui'));
    },
  
    // normalize the values of passed hash with the views `ui` selectors.
    // `{foo: "@ui.bar"}`
    normalizeUIValues: function(hash, properties) {
      var ui = _.result(this, 'ui');
      var uiBindings = _.result(this, '_uiBindings');
      return Marionette.normalizeUIValues(hash, uiBindings || ui, properties);
    },
  
    // Configure `triggers` to forward DOM events to view
    // events. `triggers: {"click .foo": "do:foo"}`
    configureTriggers: function() {
      if (!this.triggers) { return; }
  
      // Allow `triggers` to be configured as a function
      var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));
  
      // Configure the triggers, prevent default
      // action and stop propagation of DOM events
      return _.reduce(triggers, function(events, value, key) {
        events[key] = this._buildViewTrigger(value);
        return events;
      }, {}, this);
    },
  
    // Overriding Backbone.View's delegateEvents to handle
    // the `triggers`, `modelEvents`, and `collectionEvents` configuration
    delegateEvents: function(events) {
      this._delegateDOMEvents(events);
      this.bindEntityEvents(this.model, this.getOption('modelEvents'));
      this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
  
      _.each(this._behaviors, function(behavior) {
        behavior.bindEntityEvents(this.model, behavior.getOption('modelEvents'));
        behavior.bindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
      }, this);
  
      return this;
    },
  
    // internal method to delegate DOM events and triggers
    _delegateDOMEvents: function(eventsArg) {
      var events = Marionette._getValue(eventsArg || this.events, this);
  
      // normalize ui keys
      events = this.normalizeUIKeys(events);
      if (_.isUndefined(eventsArg)) {this.events = events;}
  
      var combinedEvents = {};
  
      // look up if this view has behavior events
      var behaviorEvents = _.result(this, 'behaviorEvents') || {};
      var triggers = this.configureTriggers();
      var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};
  
      // behavior events will be overriden by view events and or triggers
      _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);
  
      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
    },
  
    // Overriding Backbone.View's undelegateEvents to handle unbinding
    // the `triggers`, `modelEvents`, and `collectionEvents` config
    undelegateEvents: function() {
      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
  
      this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
      this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
  
      _.each(this._behaviors, function(behavior) {
        behavior.unbindEntityEvents(this.model, behavior.getOption('modelEvents'));
        behavior.unbindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
      }, this);
  
      return this;
    },
  
    // Internal helper method to verify whether the view hasn't been destroyed
    _ensureViewIsIntact: function() {
      if (this.isDestroyed) {
        throw new Marionette.Error({
          name: 'ViewDestroyedError',
          message: 'View (cid: "' + this.cid + '") has already been destroyed and cannot be used.'
        });
      }
    },
  
    // Default `destroy` implementation, for removing a view from the
    // DOM and unbinding it. Regions will call this method
    // for you. You can specify an `onDestroy` method in your view to
    // add custom code that is called after the view is destroyed.
    destroy: function() {
      if (this.isDestroyed) { return this; }
  
      var args = _.toArray(arguments);
  
      this.triggerMethod.apply(this, ['before:destroy'].concat(args));
  
      // mark as destroyed before doing the actual destroy, to
      // prevent infinite loops within "destroy" event handlers
      // that are trying to destroy other views
      this.isDestroyed = true;
      this.triggerMethod.apply(this, ['destroy'].concat(args));
  
      // unbind UI elements
      this.unbindUIElements();
  
      this.isRendered = false;
  
      // remove the view from the DOM
      this.remove();
  
      // Call destroy on each behavior after
      // destroying the view.
      // This unbinds event listeners
      // that behaviors have registered for.
      _.invoke(this._behaviors, 'destroy', args);
  
      return this;
    },
  
    bindUIElements: function() {
      this._bindUIElements();
      _.invoke(this._behaviors, this._bindUIElements);
    },
  
    // This method binds the elements specified in the "ui" hash inside the view's code with
    // the associated jQuery selectors.
    _bindUIElements: function() {
      if (!this.ui) { return; }
  
      // store the ui hash in _uiBindings so they can be reset later
      // and so re-rendering the view will be able to find the bindings
      if (!this._uiBindings) {
        this._uiBindings = this.ui;
      }
  
      // get the bindings result, as a function or otherwise
      var bindings = _.result(this, '_uiBindings');
  
      // empty the ui so we don't have anything to start with
      this.ui = {};
  
      // bind each of the selectors
      _.each(bindings, function(selector, key) {
        this.ui[key] = this.$(selector);
      }, this);
    },
  
    // This method unbinds the elements specified in the "ui" hash
    unbindUIElements: function() {
      this._unbindUIElements();
      _.invoke(this._behaviors, this._unbindUIElements);
    },
  
    _unbindUIElements: function() {
      if (!this.ui || !this._uiBindings) { return; }
  
      // delete all of the existing ui bindings
      _.each(this.ui, function($el, name) {
        delete this.ui[name];
      }, this);
  
      // reset the ui element to the original bindings configuration
      this.ui = this._uiBindings;
      delete this._uiBindings;
    },
  
    // Internal method to create an event handler for a given `triggerDef` like
    // 'click:foo'
    _buildViewTrigger: function(triggerDef) {
      var hasOptions = _.isObject(triggerDef);
  
      var options = _.defaults({}, (hasOptions ? triggerDef : {}), {
        preventDefault: true,
        stopPropagation: true
      });
  
      var eventName = hasOptions ? options.event : triggerDef;
  
      return function(e) {
        if (e) {
          if (e.preventDefault && options.preventDefault) {
            e.preventDefault();
          }
  
          if (e.stopPropagation && options.stopPropagation) {
            e.stopPropagation();
          }
        }
  
        var args = {
          view: this,
          model: this.model,
          collection: this.collection
        };
  
        this.triggerMethod(eventName, args);
      };
    },
  
    setElement: function() {
      var ret = Backbone.View.prototype.setElement.apply(this, arguments);
  
      // proxy behavior $el to the view's $el.
      // This is needed because a view's $el proxy
      // is not set until after setElement is called.
      _.invoke(this._behaviors, 'proxyViewProperties', this);
  
      return ret;
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: function() {
      var ret = Marionette._triggerMethod(this, arguments);
  
      this._triggerEventOnBehaviors(arguments);
      this._triggerEventOnParentLayout(arguments[0], _.rest(arguments));
  
      return ret;
    },
  
    _triggerEventOnBehaviors: function(args) {
      var triggerMethod = Marionette._triggerMethod;
      var behaviors = this._behaviors;
      // Use good ol' for as this is a very hot function
      for (var i = 0, length = behaviors && behaviors.length; i < length; i++) {
        triggerMethod(behaviors[i], args);
      }
    },
  
    _triggerEventOnParentLayout: function(eventName, args) {
      var layoutView = this._parentLayoutView();
      if (!layoutView) {
        return;
      }
  
      // invoke triggerMethod on parent view
      var eventPrefix = Marionette.getOption(layoutView, 'childViewEventPrefix');
      var prefixedEventName = eventPrefix + ':' + eventName;
  
      Marionette._triggerMethod(layoutView, [prefixedEventName, this].concat(args));
  
      // call the parent view's childEvents handler
      var childEvents = Marionette.getOption(layoutView, 'childEvents');
      var normalizedChildEvents = layoutView.normalizeMethods(childEvents);
  
      if (!!normalizedChildEvents && _.isFunction(normalizedChildEvents[eventName])) {
        normalizedChildEvents[eventName].apply(layoutView, [this].concat(args));
      }
    },
  
    // This method returns any views that are immediate
    // children of this view
    _getImmediateChildren: function() {
      return [];
    },
  
    // Returns an array of every nested view within this view
    _getNestedViews: function() {
      var children = this._getImmediateChildren();
  
      if (!children.length) { return children; }
  
      return _.reduce(children, function(memo, view) {
        if (!view._getNestedViews) { return memo; }
        return memo.concat(view._getNestedViews());
      }, children);
    },
  
    // Internal utility for building an ancestor
    // view tree list.
    _getAncestors: function() {
      var ancestors = [];
      var parent  = this._parent;
  
      while (parent) {
        ancestors.push(parent);
        parent = parent._parent;
      }
  
      return ancestors;
    },
  
    // Returns the containing parent view.
    _parentLayoutView: function() {
      var ancestors = this._getAncestors();
      return _.find(ancestors, function(parent) {
        return parent instanceof Marionette.LayoutView;
      });
    },
  
    // Imports the "normalizeMethods" to transform hashes of
    // events=>function references/names to a hash of events=>function references
    normalizeMethods: Marionette.normalizeMethods,
  
    // A handy way to merge passed-in options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  // Item View
  // ---------
  
  // A single item view implementation that contains code for rendering
  // with underscore.js templates, serializing the view's model or collection,
  // and calling several methods on extended views, such as `onRender`.
  Marionette.ItemView = Marionette.View.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.View.prototype.constructor which allows overriding
    constructor: function() {
      Marionette.View.apply(this, arguments);
    },
  
    // Serialize the model or collection for the view. If a model is
    // found, the view's `serializeModel` is called. If a collection is found,
    // each model in the collection is serialized by calling
    // the view's `serializeCollection` and put into an `items` array in
    // the resulting data. If both are found, defaults to the model.
    // You can override the `serializeData` method in your own view definition,
    // to provide custom serialization for your view's data.
    serializeData: function() {
      if (!this.model && !this.collection) {
        return {};
      }
  
      var args = [this.model || this.collection];
      if (arguments.length) {
        args.push.apply(args, arguments);
      }
  
      if (this.model) {
        return this.serializeModel.apply(this, args);
      } else {
        return {
          items: this.serializeCollection.apply(this, args)
        };
      }
    },
  
    // Serialize a collection by serializing each of its models.
    serializeCollection: function(collection) {
      return collection.toJSON.apply(collection, _.rest(arguments));
    },
  
    // Render the view, defaulting to underscore.js templates.
    // You can override this in your view definition to provide
    // a very specific rendering for your view. In general, though,
    // you should override the `Marionette.Renderer` object to
    // change how Marionette renders views.
    render: function() {
      this._ensureViewIsIntact();
  
      this.triggerMethod('before:render', this);
  
      this._renderTemplate();
      this.isRendered = true;
      this.bindUIElements();
  
      this.triggerMethod('render', this);
  
      return this;
    },
  
    // Internal method to render the template with the serialized data
    // and template helpers via the `Marionette.Renderer` object.
    // Throws an `UndefinedTemplateError` error if the template is
    // any falsely value but literal `false`.
    _renderTemplate: function() {
      var template = this.getTemplate();
  
      // Allow template-less item views
      if (template === false) {
        return;
      }
  
      if (!template) {
        throw new Marionette.Error({
          name: 'UndefinedTemplateError',
          message: 'Cannot render the template since it is null or undefined.'
        });
      }
  
      // Add in entity data and template helpers
      var data = this.mixinTemplateHelpers(this.serializeData());
  
      // Render and add to el
      var html = Marionette.Renderer.render(template, data, this);
      this.attachElContent(html);
  
      return this;
    },
  
    // Attaches the content of a given view.
    // This method can be overridden to optimize rendering,
    // or to render in a non standard way.
    //
    // For example, using `innerHTML` instead of `$el.html`
    //
    // ```js
    // attachElContent: function(html) {
    //   this.el.innerHTML = html;
    //   return this;
    // }
    // ```
    attachElContent: function(html) {
      this.$el.html(html);
  
      return this;
    }
  });
  
  /* jshint maxstatements: 20, maxcomplexity: 7 */
  
  // Collection View
  // ---------------
  
  // A view that iterates over a Backbone.Collection
  // and renders an individual child view for each model.
  Marionette.CollectionView = Marionette.View.extend({
  
    // used as the prefix for child view events
    // that are forwarded through the collectionview
    childViewEventPrefix: 'childview',
  
    // flag for maintaining the sorted order of the collection
    sort: true,
  
    // constructor
    // option to pass `{sort: false}` to prevent the `CollectionView` from
    // maintaining the sorted order of the collection.
    // This will fallback onto appending childView's to the end.
    //
    // option to pass `{comparator: compFunction()}` to allow the `CollectionView`
    // to use a custom sort order for the collection.
    constructor: function(options) {
      this.once('render', this._initialEvents);
      this._initChildViewStorage();
  
      Marionette.View.apply(this, arguments);
  
      this.on({
        'before:show':   this._onBeforeShowCalled,
        'show':          this._onShowCalled,
        'before:attach': this._onBeforeAttachCalled,
        'attach':        this._onAttachCalled
      });
      this.initRenderBuffer();
    },
  
    // Instead of inserting elements one by one into the page,
    // it's much more performant to insert elements into a document
    // fragment and then insert that document fragment into the page
    initRenderBuffer: function() {
      this._bufferedChildren = [];
    },
  
    startBuffering: function() {
      this.initRenderBuffer();
      this.isBuffering = true;
    },
  
    endBuffering: function() {
      // Only trigger attach if already shown and attached, otherwise Region#show() handles this.
      var canTriggerAttach = this._isShown && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      this.isBuffering = false;
  
      if (this._isShown) {
        this._triggerMethodMany(this._bufferedChildren, this, 'before:show');
      }
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = this._getNestedViews();
        this._triggerMethodMany(nestedViews, this, 'before:attach');
      }
  
      this.attachBuffer(this, this._createBuffer());
  
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = this._getNestedViews();
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      if (this._isShown) {
        this._triggerMethodMany(this._bufferedChildren, this, 'show');
      }
      this.initRenderBuffer();
    },
  
    _triggerMethodMany: function(targets, source, eventName) {
      var args = _.drop(arguments, 3);
  
      _.each(targets, function(target) {
        Marionette.triggerMethodOn.apply(target, [target, eventName, target, source].concat(args));
      });
    },
  
    // Configured the initial events that the collection view
    // binds to.
    _initialEvents: function() {
      if (this.collection) {
        this.listenTo(this.collection, 'add', this._onCollectionAdd);
        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
        this.listenTo(this.collection, 'reset', this.render);
  
        if (this.getOption('sort')) {
          this.listenTo(this.collection, 'sort', this._sortViews);
        }
      }
    },
  
    // Handle a child added to the collection
    _onCollectionAdd: function(child, collection, opts) {
      var index;
      if (opts.at !== undefined) {
        index = opts.at;
      } else {
        index = _.indexOf(this._filteredSortedModels(), child);
      }
  
      if (this._shouldAddChild(child, index)) {
        this.destroyEmptyView();
        var ChildView = this.getChildView(child);
        this.addChild(child, ChildView, index);
      }
    },
  
    // get the child view by model it holds, and remove it
    _onCollectionRemove: function(model) {
      var view = this.children.findByModel(model);
      this.removeChildView(view);
      this.checkEmpty();
    },
  
    _onBeforeShowCalled: function() {
      // Reset attach event flags at the top of the Region#show() event lifecycle; if the Region's
      // show() options permit onBeforeAttach/onAttach events, these flags will be set true again.
      this._triggerBeforeAttach = this._triggerAttach = false;
      this.children.each(function(childView) {
        Marionette.triggerMethodOn(childView, 'before:show', childView);
      });
    },
  
    _onShowCalled: function() {
      this.children.each(function(childView) {
        Marionette.triggerMethodOn(childView, 'show', childView);
      });
    },
  
    // If during Region#show() onBeforeAttach was fired, continue firing it for child views
    _onBeforeAttachCalled: function() {
      this._triggerBeforeAttach = true;
    },
  
    // If during Region#show() onAttach was fired, continue firing it for child views
    _onAttachCalled: function() {
      this._triggerAttach = true;
    },
  
    // Render children views. Override this method to
    // provide your own implementation of a render function for
    // the collection view.
    render: function() {
      this._ensureViewIsIntact();
      this.triggerMethod('before:render', this);
      this._renderChildren();
      this.isRendered = true;
      this.triggerMethod('render', this);
      return this;
    },
  
    // Reorder DOM after sorting. When your element's rendering
    // do not use their index, you can pass reorderOnSort: true
    // to only reorder the DOM after a sort instead of rendering
    // all the collectionView
    reorder: function() {
      var children = this.children;
      var models = this._filteredSortedModels();
      var modelsChanged = _.find(models, function(model) {
        return !children.findByModel(model);
      });
  
      // If the models we're displaying have changed due to filtering
      // We need to add and/or remove child views
      // So render as normal
      if (modelsChanged) {
        this.render();
      } else {
        // get the DOM nodes in the same order as the models
        var els = _.map(models, function(model, index) {
          var view = children.findByModel(model);
          view._index = index;
          return view.el;
        });
  
        // since append moves elements that are already in the DOM,
        // appending the elements will effectively reorder them
        this.triggerMethod('before:reorder');
        this._appendReorderedChildren(els);
        this.triggerMethod('reorder');
      }
    },
  
    // Render view after sorting. Override this method to
    // change how the view renders after a `sort` on the collection.
    // An example of this would be to only `renderChildren` in a `CompositeView`
    // rather than the full view.
    resortView: function() {
      if (Marionette.getOption(this, 'reorderOnSort')) {
        this.reorder();
      } else {
        this.render();
      }
    },
  
    // Internal method. This checks for any changes in the order of the collection.
    // If the index of any view doesn't match, it will render.
    _sortViews: function() {
      var models = this._filteredSortedModels();
  
      // check for any changes in sort order of views
      var orderChanged = _.find(models, function(item, index) {
        var view = this.children.findByModel(item);
        return !view || view._index !== index;
      }, this);
  
      if (orderChanged) {
        this.resortView();
      }
    },
  
    // Internal reference to what index a `emptyView` is.
    _emptyViewIndex: -1,
  
    // Internal method. Separated so that CompositeView can append to the childViewContainer
    // if necessary
    _appendReorderedChildren: function(children) {
      this.$el.append(children);
    },
  
    // Internal method. Separated so that CompositeView can have
    // more control over events being triggered, around the rendering
    // process
    _renderChildren: function() {
      this.destroyEmptyView();
      this.destroyChildren({checkEmpty: false});
  
      if (this.isEmpty(this.collection)) {
        this.showEmptyView();
      } else {
        this.triggerMethod('before:render:collection', this);
        this.startBuffering();
        this.showCollection();
        this.endBuffering();
        this.triggerMethod('render:collection', this);
  
        // If we have shown children and none have passed the filter, show the empty view
        if (this.children.isEmpty()) {
          this.showEmptyView();
        }
      }
    },
  
    // Internal method to loop through collection and show each child view.
    showCollection: function() {
      var ChildView;
  
      var models = this._filteredSortedModels();
  
      _.each(models, function(child, index) {
        ChildView = this.getChildView(child);
        this.addChild(child, ChildView, index);
      }, this);
    },
  
    // Allow the collection to be sorted by a custom view comparator
    _filteredSortedModels: function() {
      var models;
      var viewComparator = this.getViewComparator();
  
      if (viewComparator) {
        if (_.isString(viewComparator) || viewComparator.length === 1) {
          models = this.collection.sortBy(viewComparator, this);
        } else {
          models = _.clone(this.collection.models).sort(_.bind(viewComparator, this));
        }
      } else {
        models = this.collection.models;
      }
  
      // Filter after sorting in case the filter uses the index
      if (this.getOption('filter')) {
        models = _.filter(models, function(model, index) {
          return this._shouldAddChild(model, index);
        }, this);
      }
  
      return models;
    },
  
    // Internal method to show an empty view in place of
    // a collection of child views, when the collection is empty
    showEmptyView: function() {
      var EmptyView = this.getEmptyView();
  
      if (EmptyView && !this._showingEmptyView) {
        this.triggerMethod('before:render:empty');
  
        this._showingEmptyView = true;
        var model = new Backbone.Model();
        this.addEmptyView(model, EmptyView);
  
        this.triggerMethod('render:empty');
      }
    },
  
    // Internal method to destroy an existing emptyView instance
    // if one exists. Called when a collection view has been
    // rendered empty, and then a child is added to the collection.
    destroyEmptyView: function() {
      if (this._showingEmptyView) {
        this.triggerMethod('before:remove:empty');
  
        this.destroyChildren();
        delete this._showingEmptyView;
  
        this.triggerMethod('remove:empty');
      }
    },
  
    // Retrieve the empty view class
    getEmptyView: function() {
      return this.getOption('emptyView');
    },
  
    // Render and show the emptyView. Similar to addChild method
    // but "add:child" events are not fired, and the event from
    // emptyView are not forwarded
    addEmptyView: function(child, EmptyView) {
      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
      // Region#show() handles this.
      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      // get the emptyViewOptions, falling back to childViewOptions
      var emptyViewOptions = this.getOption('emptyViewOptions') ||
                            this.getOption('childViewOptions');
  
      if (_.isFunction(emptyViewOptions)) {
        emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex);
      }
  
      // build the empty view
      var view = this.buildChildView(child, EmptyView, emptyViewOptions);
  
      view._parent = this;
  
      // Proxy emptyView events
      this.proxyChildEvents(view);
  
      // trigger the 'before:show' event on `view` if the collection view has already been shown
      if (this._isShown) {
        Marionette.triggerMethodOn(view, 'before:show', view);
      }
  
      // Store the `emptyView` like a `childView` so we can properly
      // remove and/or close it later
      this.children.add(view);
  
      // Trigger `before:attach` following `render` to avoid adding logic and event triggers
      // to public method `renderChildView()`.
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        view.once('render', function() {
          this._triggerMethodMany(nestedViews, this, 'before:attach');
        }, this);
      }
  
      // Render it and show it
      this.renderChildView(view, this._emptyViewIndex);
  
      // Trigger `attach`
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      // call the 'show' method if the collection view has already been shown
      if (this._isShown) {
        Marionette.triggerMethodOn(view, 'show', view);
      }
    },
  
    // Retrieve the `childView` class, either from `this.options.childView`
    // or from the `childView` in the object definition. The "options"
    // takes precedence.
    // This method receives the model that will be passed to the instance
    // created from this `childView`. Overriding methods may use the child
    // to determine what `childView` class to return.
    getChildView: function(child) {
      var childView = this.getOption('childView');
  
      if (!childView) {
        throw new Marionette.Error({
          name: 'NoChildViewError',
          message: 'A "childView" must be specified'
        });
      }
  
      return childView;
    },
  
    // Render the child's view and add it to the
    // HTML for the collection view at a given index.
    // This will also update the indices of later views in the collection
    // in order to keep the children in sync with the collection.
    addChild: function(child, ChildView, index) {
      var childViewOptions = this.getOption('childViewOptions');
      childViewOptions = Marionette._getValue(childViewOptions, this, [child, index]);
  
      var view = this.buildChildView(child, ChildView, childViewOptions);
  
      // increment indices of views after this one
      this._updateIndices(view, true, index);
  
      this.triggerMethod('before:add:child', view);
      this._addChildView(view, index);
      this.triggerMethod('add:child', view);
  
      view._parent = this;
  
      return view;
    },
  
    // Internal method. This decrements or increments the indices of views after the
    // added/removed view to keep in sync with the collection.
    _updateIndices: function(view, increment, index) {
      if (!this.getOption('sort')) {
        return;
      }
  
      if (increment) {
        // assign the index to the view
        view._index = index;
      }
  
      // update the indexes of views after this one
      this.children.each(function(laterView) {
        if (laterView._index >= view._index) {
          laterView._index += increment ? 1 : -1;
        }
      });
    },
  
    // Internal Method. Add the view to children and render it at
    // the given index.
    _addChildView: function(view, index) {
      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
      // Region#show() handles this.
      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      // set up the child view event forwarding
      this.proxyChildEvents(view);
  
      // trigger the 'before:show' event on `view` if the collection view has already been shown
      if (this._isShown && !this.isBuffering) {
        Marionette.triggerMethodOn(view, 'before:show', view);
      }
  
      // Store the child view itself so we can properly remove and/or destroy it later
      this.children.add(view);
  
      // Trigger `before:attach` following `render` to avoid adding logic and event triggers
      // to public method `renderChildView()`.
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        view.once('render', function() {
          this._triggerMethodMany(nestedViews, this, 'before:attach');
        }, this);
      }
  
      this.renderChildView(view, index);
  
      // Trigger `attach`
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      // Trigger `show`
      if (this._isShown && !this.isBuffering) {
        Marionette.triggerMethodOn(view, 'show', view);
      }
    },
  
    // render the child view
    renderChildView: function(view, index) {
      view.render();
      this.attachHtml(this, view, index);
      return view;
    },
  
    // Build a `childView` for a model in the collection.
    buildChildView: function(child, ChildViewClass, childViewOptions) {
      var options = _.extend({model: child}, childViewOptions);
      return new ChildViewClass(options);
    },
  
    // Remove the child view and destroy it.
    // This function also updates the indices of
    // later views in the collection in order to keep
    // the children in sync with the collection.
    removeChildView: function(view) {
  
      if (view) {
        this.triggerMethod('before:remove:child', view);
  
        // call 'destroy' or 'remove', depending on which is found
        if (view.destroy) {
          view.destroy();
        } else if (view.remove) {
          view.remove();
        }
  
        delete view._parent;
        this.stopListening(view);
        this.children.remove(view);
        this.triggerMethod('remove:child', view);
  
        // decrement the index of views after this one
        this._updateIndices(view, false);
      }
  
      return view;
    },
  
    // check if the collection is empty
    isEmpty: function() {
      return !this.collection || this.collection.length === 0;
    },
  
    // If empty, show the empty view
    checkEmpty: function() {
      if (this.isEmpty(this.collection)) {
        this.showEmptyView();
      }
    },
  
    // You might need to override this if you've overridden attachHtml
    attachBuffer: function(collectionView, buffer) {
      collectionView.$el.append(buffer);
    },
  
    // Create a fragment buffer from the currently buffered children
    _createBuffer: function() {
      var elBuffer = document.createDocumentFragment();
      _.each(this._bufferedChildren, function(b) {
        elBuffer.appendChild(b.el);
      });
      return elBuffer;
    },
  
    // Append the HTML to the collection's `el`.
    // Override this method to do something other
    // than `.append`.
    attachHtml: function(collectionView, childView, index) {
      if (collectionView.isBuffering) {
        // buffering happens on reset events and initial renders
        // in order to reduce the number of inserts into the
        // document, which are expensive.
        collectionView._bufferedChildren.splice(index, 0, childView);
      } else {
        // If we've already rendered the main collection, append
        // the new child into the correct order if we need to. Otherwise
        // append to the end.
        if (!collectionView._insertBefore(childView, index)) {
          collectionView._insertAfter(childView);
        }
      }
    },
  
    // Internal method. Check whether we need to insert the view into
    // the correct position.
    _insertBefore: function(childView, index) {
      var currentView;
      var findPosition = this.getOption('sort') && (index < this.children.length - 1);
      if (findPosition) {
        // Find the view after this one
        currentView = this.children.find(function(view) {
          return view._index === index + 1;
        });
      }
  
      if (currentView) {
        currentView.$el.before(childView.el);
        return true;
      }
  
      return false;
    },
  
    // Internal method. Append a view to the end of the $el
    _insertAfter: function(childView) {
      this.$el.append(childView.el);
    },
  
    // Internal method to set up the `children` object for
    // storing all of the child views
    _initChildViewStorage: function() {
      this.children = new Backbone.ChildViewContainer();
    },
  
    // Handle cleanup and other destroying needs for the collection of views
    destroy: function() {
      if (this.isDestroyed) { return this; }
  
      this.triggerMethod('before:destroy:collection');
      this.destroyChildren({checkEmpty: false});
      this.triggerMethod('destroy:collection');
  
      return Marionette.View.prototype.destroy.apply(this, arguments);
    },
  
    // Destroy the child views that this collection view
    // is holding on to, if any
    destroyChildren: function(options) {
      var destroyOptions = options || {};
      var shouldCheckEmpty = true;
      var childViews = this.children.map(_.identity);
  
      if (!_.isUndefined(destroyOptions.checkEmpty)) {
        shouldCheckEmpty = destroyOptions.checkEmpty;
      }
  
      this.children.each(this.removeChildView, this);
  
      if (shouldCheckEmpty) {
        this.checkEmpty();
      }
      return childViews;
    },
  
    // Return true if the given child should be shown
    // Return false otherwise
    // The filter will be passed (child, index, collection)
    // Where
    //  'child' is the given model
    //  'index' is the index of that model in the collection
    //  'collection' is the collection referenced by this CollectionView
    _shouldAddChild: function(child, index) {
      var filter = this.getOption('filter');
      return !_.isFunction(filter) || filter.call(this, child, index, this.collection);
    },
  
    // Set up the child view event forwarding. Uses a "childview:"
    // prefix in front of all forwarded events.
    proxyChildEvents: function(view) {
      var prefix = this.getOption('childViewEventPrefix');
  
      // Forward all child view events through the parent,
      // prepending "childview:" to the event name
      this.listenTo(view, 'all', function() {
        var args = _.toArray(arguments);
        var rootEvent = args[0];
        var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));
  
        args[0] = prefix + ':' + rootEvent;
        args.splice(1, 0, view);
  
        // call collectionView childEvent if defined
        if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
          childEvents[rootEvent].apply(this, args.slice(1));
        }
  
        this.triggerMethod.apply(this, args);
      });
    },
  
    _getImmediateChildren: function() {
      return _.values(this.children._views);
    },
  
    getViewComparator: function() {
      return this.getOption('viewComparator');
    }
  });
  
  /* jshint maxstatements: 17, maxlen: 117 */
  
  // Composite View
  // --------------
  
  // Used for rendering a branch-leaf, hierarchical structure.
  // Extends directly from CollectionView and also renders an
  // a child view as `modelView`, for the top leaf
  Marionette.CompositeView = Marionette.CollectionView.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.CollectionView.prototype.constructor which allows overriding
    // option to pass '{sort: false}' to prevent the CompositeView from
    // maintaining the sorted order of the collection.
    // This will fallback onto appending childView's to the end.
    constructor: function() {
      Marionette.CollectionView.apply(this, arguments);
    },
  
    // Configured the initial events that the composite view
    // binds to. Override this method to prevent the initial
    // events, or to add your own initial events.
    _initialEvents: function() {
  
      // Bind only after composite view is rendered to avoid adding child views
      // to nonexistent childViewContainer
  
      if (this.collection) {
        this.listenTo(this.collection, 'add', this._onCollectionAdd);
        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
        this.listenTo(this.collection, 'reset', this._renderChildren);
  
        if (this.getOption('sort')) {
          this.listenTo(this.collection, 'sort', this._sortViews);
        }
      }
    },
  
    // Retrieve the `childView` to be used when rendering each of
    // the items in the collection. The default is to return
    // `this.childView` or Marionette.CompositeView if no `childView`
    // has been defined
    getChildView: function(child) {
      var childView = this.getOption('childView') || this.constructor;
  
      return childView;
    },
  
    // Serialize the model for the view.
    // You can override the `serializeData` method in your own view
    // definition, to provide custom serialization for your view's data.
    serializeData: function() {
      var data = {};
  
      if (this.model) {
        data = _.partial(this.serializeModel, this.model).apply(this, arguments);
      }
  
      return data;
    },
  
    // Renders the model and the collection.
    render: function() {
      this._ensureViewIsIntact();
      this._isRendering = true;
      this.resetChildViewContainer();
  
      this.triggerMethod('before:render', this);
  
      this._renderTemplate();
      this._renderChildren();
  
      this._isRendering = false;
      this.isRendered = true;
      this.triggerMethod('render', this);
      return this;
    },
  
    _renderChildren: function() {
      if (this.isRendered || this._isRendering) {
        Marionette.CollectionView.prototype._renderChildren.call(this);
      }
    },
  
    // Render the root template that the children
    // views are appended to
    _renderTemplate: function() {
      var data = {};
      data = this.serializeData();
      data = this.mixinTemplateHelpers(data);
  
      this.triggerMethod('before:render:template');
  
      var template = this.getTemplate();
      var html = Marionette.Renderer.render(template, data, this);
      this.attachElContent(html);
  
      // the ui bindings is done here and not at the end of render since they
      // will not be available until after the model is rendered, but should be
      // available before the collection is rendered.
      this.bindUIElements();
      this.triggerMethod('render:template');
    },
  
    // Attaches the content of the root.
    // This method can be overridden to optimize rendering,
    // or to render in a non standard way.
    //
    // For example, using `innerHTML` instead of `$el.html`
    //
    // ```js
    // attachElContent: function(html) {
    //   this.el.innerHTML = html;
    //   return this;
    // }
    // ```
    attachElContent: function(html) {
      this.$el.html(html);
  
      return this;
    },
  
    // You might need to override this if you've overridden attachHtml
    attachBuffer: function(compositeView, buffer) {
      var $container = this.getChildViewContainer(compositeView);
      $container.append(buffer);
    },
  
    // Internal method. Append a view to the end of the $el.
    // Overidden from CollectionView to ensure view is appended to
    // childViewContainer
    _insertAfter: function(childView) {
      var $container = this.getChildViewContainer(this, childView);
      $container.append(childView.el);
    },
  
    // Internal method. Append reordered childView'.
    // Overidden from CollectionView to ensure reordered views
    // are appended to childViewContainer
    _appendReorderedChildren: function(children) {
      var $container = this.getChildViewContainer(this);
      $container.append(children);
    },
  
    // Internal method to ensure an `$childViewContainer` exists, for the
    // `attachHtml` method to use.
    getChildViewContainer: function(containerView, childView) {
      if (!!containerView.$childViewContainer) {
        return containerView.$childViewContainer;
      }
  
      var container;
      var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
      if (childViewContainer) {
  
        var selector = Marionette._getValue(childViewContainer, containerView);
  
        if (selector.charAt(0) === '@' && containerView.ui) {
          container = containerView.ui[selector.substr(4)];
        } else {
          container = containerView.$(selector);
        }
  
        if (container.length <= 0) {
          throw new Marionette.Error({
            name: 'ChildViewContainerMissingError',
            message: 'The specified "childViewContainer" was not found: ' + containerView.childViewContainer
          });
        }
  
      } else {
        container = containerView.$el;
      }
  
      containerView.$childViewContainer = container;
      return container;
    },
  
    // Internal method to reset the `$childViewContainer` on render
    resetChildViewContainer: function() {
      if (this.$childViewContainer) {
        this.$childViewContainer = undefined;
      }
    }
  });
  
  // Layout View
  // -----------
  
  // Used for managing application layoutViews, nested layoutViews and
  // multiple regions within an application or sub-application.
  //
  // A specialized view class that renders an area of HTML and then
  // attaches `Region` instances to the specified `regions`.
  // Used for composite view management and sub-application areas.
  Marionette.LayoutView = Marionette.ItemView.extend({
    regionClass: Marionette.Region,
  
    options: {
      destroyImmediate: false
    },
  
    // used as the prefix for child view events
    // that are forwarded through the layoutview
    childViewEventPrefix: 'childview',
  
    // Ensure the regions are available when the `initialize` method
    // is called.
    constructor: function(options) {
      options = options || {};
  
      this._firstRender = true;
      this._initializeRegions(options);
  
      Marionette.ItemView.call(this, options);
    },
  
    // LayoutView's render will use the existing region objects the
    // first time it is called. Subsequent calls will destroy the
    // views that the regions are showing and then reset the `el`
    // for the regions to the newly rendered DOM elements.
    render: function() {
      this._ensureViewIsIntact();
  
      if (this._firstRender) {
        // if this is the first render, don't do anything to
        // reset the regions
        this._firstRender = false;
      } else {
        // If this is not the first render call, then we need to
        // re-initialize the `el` for each region
        this._reInitializeRegions();
      }
  
      return Marionette.ItemView.prototype.render.apply(this, arguments);
    },
  
    // Handle destroying regions, and then destroy the view itself.
    destroy: function() {
      if (this.isDestroyed) { return this; }
      // #2134: remove parent element before destroying the child views, so
      // removing the child views doesn't retrigger repaints
      if (this.getOption('destroyImmediate') === true) {
        this.$el.remove();
      }
      this.regionManager.destroy();
      return Marionette.ItemView.prototype.destroy.apply(this, arguments);
    },
  
    showChildView: function(regionName, view) {
      return this.getRegion(regionName).show(view);
    },
  
    getChildView: function(regionName) {
      return this.getRegion(regionName).currentView;
    },
  
    // Add a single region, by name, to the layoutView
    addRegion: function(name, definition) {
      var regions = {};
      regions[name] = definition;
      return this._buildRegions(regions)[name];
    },
  
    // Add multiple regions as a {name: definition, name2: def2} object literal
    addRegions: function(regions) {
      this.regions = _.extend({}, this.regions, regions);
      return this._buildRegions(regions);
    },
  
    // Remove a single region from the LayoutView, by name
    removeRegion: function(name) {
      delete this.regions[name];
      return this.regionManager.removeRegion(name);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this.regionManager.get(region);
    },
  
    // Get all regions
    getRegions: function() {
      return this.regionManager.getRegions();
    },
  
    // internal method to build regions
    _buildRegions: function(regions) {
      var defaults = {
        regionClass: this.getOption('regionClass'),
        parentEl: _.partial(_.result, this, 'el')
      };
  
      return this.regionManager.addRegions(regions, defaults);
    },
  
    // Internal method to initialize the regions that have been defined in a
    // `regions` attribute on this layoutView.
    _initializeRegions: function(options) {
      var regions;
      this._initRegionManager();
  
      regions = Marionette._getValue(this.regions, this, [options]) || {};
  
      // Enable users to define `regions` as instance options.
      var regionOptions = this.getOption.call(options, 'regions');
  
      // enable region options to be a function
      regionOptions = Marionette._getValue(regionOptions, this, [options]);
  
      _.extend(regions, regionOptions);
  
      // Normalize region selectors hash to allow
      // a user to use the @ui. syntax.
      regions = this.normalizeUIValues(regions, ['selector', 'el']);
  
      this.addRegions(regions);
    },
  
    // Internal method to re-initialize all of the regions by updating the `el` that
    // they point to
    _reInitializeRegions: function() {
      this.regionManager.invoke('reset');
    },
  
    // Enable easy overriding of the default `RegionManager`
    // for customized region interactions and business specific
    // view logic for better control over single regions.
    getRegionManager: function() {
      return new Marionette.RegionManager();
    },
  
    // Internal method to initialize the region manager
    // and all regions in it
    _initRegionManager: function() {
      this.regionManager = this.getRegionManager();
      this.regionManager._parent = this;
  
      this.listenTo(this.regionManager, 'before:add:region', function(name) {
        this.triggerMethod('before:add:region', name);
      });
  
      this.listenTo(this.regionManager, 'add:region', function(name, region) {
        this[name] = region;
        this.triggerMethod('add:region', name, region);
      });
  
      this.listenTo(this.regionManager, 'before:remove:region', function(name) {
        this.triggerMethod('before:remove:region', name);
      });
  
      this.listenTo(this.regionManager, 'remove:region', function(name, region) {
        delete this[name];
        this.triggerMethod('remove:region', name, region);
      });
    },
  
    _getImmediateChildren: function() {
      return _.chain(this.regionManager.getRegions())
        .pluck('currentView')
        .compact()
        .value();
    }
  });
  

  // Behavior
  // --------
  
  // A Behavior is an isolated set of DOM /
  // user interactions that can be mixed into any View.
  // Behaviors allow you to blackbox View specific interactions
  // into portable logical chunks, keeping your views simple and your code DRY.
  
  Marionette.Behavior = Marionette.Object.extend({
    constructor: function(options, view) {
      // Setup reference to the view.
      // this comes in handle when a behavior
      // wants to directly talk up the chain
      // to the view.
      this.view = view;
      this.defaults = _.result(this, 'defaults') || {};
      this.options  = _.extend({}, this.defaults, options);
      // Construct an internal UI hash using
      // the views UI hash and then the behaviors UI hash.
      // This allows the user to use UI hash elements
      // defined in the parent view as well as those
      // defined in the given behavior.
      this.ui = _.extend({}, _.result(view, 'ui'), _.result(this, 'ui'));
  
      Marionette.Object.apply(this, arguments);
    },
  
    // proxy behavior $ method to the view
    // this is useful for doing jquery DOM lookups
    // scoped to behaviors view.
    $: function() {
      return this.view.$.apply(this.view, arguments);
    },
  
    // Stops the behavior from listening to events.
    // Overrides Object#destroy to prevent additional events from being triggered.
    destroy: function() {
      this.stopListening();
  
      return this;
    },
  
    proxyViewProperties: function(view) {
      this.$el = view.$el;
      this.el = view.el;
    }
  });
  
  /* jshint maxlen: 143 */
  // Behaviors
  // ---------
  
  // Behaviors is a utility class that takes care of
  // gluing your behavior instances to their given View.
  // The most important part of this class is that you
  // **MUST** override the class level behaviorsLookup
  // method for things to work properly.
  
  Marionette.Behaviors = (function(Marionette, _) {
    // Borrow event splitter from Backbone
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
  
    function Behaviors(view, behaviors) {
  
      if (!_.isObject(view.behaviors)) {
        return {};
      }
  
      // Behaviors defined on a view can be a flat object literal
      // or it can be a function that returns an object.
      behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));
  
      // Wraps several of the view's methods
      // calling the methods first on each behavior
      // and then eventually calling the method on the view.
      Behaviors.wrap(view, behaviors, _.keys(methods));
      return behaviors;
    }
  
    var methods = {
      behaviorTriggers: function(behaviorTriggers, behaviors) {
        var triggerBuilder = new BehaviorTriggersBuilder(this, behaviors);
        return triggerBuilder.buildBehaviorTriggers();
      },
  
      behaviorEvents: function(behaviorEvents, behaviors) {
        var _behaviorsEvents = {};
  
        _.each(behaviors, function(b, i) {
          var _events = {};
          var behaviorEvents = _.clone(_.result(b, 'events')) || {};
  
          // Normalize behavior events hash to allow
          // a user to use the @ui. syntax.
          behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, getBehaviorsUI(b));
  
          var j = 0;
          _.each(behaviorEvents, function(behaviour, key) {
            var match     = key.match(delegateEventSplitter);
  
            // Set event name to be namespaced using the view cid,
            // the behavior index, and the behavior event index
            // to generate a non colliding event namespace
            // http://api.jquery.com/event.namespace/
            var eventName = match[1] + '.' + [this.cid, i, j++, ' '].join('');
            var selector  = match[2];
  
            var eventKey  = eventName + selector;
            var handler   = _.isFunction(behaviour) ? behaviour : b[behaviour];
  
            _events[eventKey] = _.bind(handler, b);
          }, this);
  
          _behaviorsEvents = _.extend(_behaviorsEvents, _events);
        }, this);
  
        return _behaviorsEvents;
      }
    };
  
    _.extend(Behaviors, {
  
      // Placeholder method to be extended by the user.
      // The method should define the object that stores the behaviors.
      // i.e.
      //
      // ```js
      // Marionette.Behaviors.behaviorsLookup: function() {
      //   return App.Behaviors
      // }
      // ```
      behaviorsLookup: function() {
        throw new Marionette.Error({
          message: 'You must define where your behaviors are stored.',
          url: 'marionette.behaviors.html#behaviorslookup'
        });
      },
  
      // Takes care of getting the behavior class
      // given options and a key.
      // If a user passes in options.behaviorClass
      // default to using that. Otherwise delegate
      // the lookup to the users `behaviorsLookup` implementation.
      getBehaviorClass: function(options, key) {
        if (options.behaviorClass) {
          return options.behaviorClass;
        }
  
        // Get behavior class can be either a flat object or a method
        return Marionette._getValue(Behaviors.behaviorsLookup, this, [options, key])[key];
      },
  
      // Iterate over the behaviors object, for each behavior
      // instantiate it and get its grouped behaviors.
      parseBehaviors: function(view, behaviors) {
        return _.chain(behaviors).map(function(options, key) {
          var BehaviorClass = Behaviors.getBehaviorClass(options, key);
  
          var behavior = new BehaviorClass(options, view);
          var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));
  
          return [behavior].concat(nestedBehaviors);
        }).flatten().value();
      },
  
      // Wrap view internal methods so that they delegate to behaviors. For example,
      // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
      // i.e.
      //
      // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
      wrap: function(view, behaviors, methodNames) {
        _.each(methodNames, function(methodName) {
          view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
        });
      }
    });
  
    // Class to build handlers for `triggers` on behaviors
    // for views
    function BehaviorTriggersBuilder(view, behaviors) {
      this._view      = view;
      this._behaviors = behaviors;
      this._triggers  = {};
    }
  
    _.extend(BehaviorTriggersBuilder.prototype, {
      // Main method to build the triggers hash with event keys and handlers
      buildBehaviorTriggers: function() {
        _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this);
        return this._triggers;
      },
  
      // Internal method to build all trigger handlers for a given behavior
      _buildTriggerHandlersForBehavior: function(behavior, i) {
        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};
  
        triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));
  
        _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));
      },
  
      // Internal method to create and assign the trigger handler for a given
      // behavior
      _setHandlerForBehavior: function(behavior, i, eventName, trigger) {
        // Unique identifier for the `this._triggers` hash
        var triggerKey = trigger.replace(/^\S+/, function(triggerName) {
          return triggerName + '.' + 'behaviortriggers' + i;
        });
  
        this._triggers[triggerKey] = this._view._buildViewTrigger(eventName);
      }
    });
  
    function getBehaviorsUI(behavior) {
      return behavior._uiBindings || behavior.ui;
    }
  
    return Behaviors;
  
  })(Marionette, _);
  

  // App Router
  // ----------
  
  // Reduce the boilerplate code of handling route events
  // and then calling a single method on another object.
  // Have your routers configured to call the method on
  // your object, directly.
  //
  // Configure an AppRouter with `appRoutes`.
  //
  // App routers can only take one `controller` object.
  // It is recommended that you divide your controller
  // objects in to smaller pieces of related functionality
  // and have multiple routers / controllers, instead of
  // just one giant router and controller.
  //
  // You can also add standard routes to an AppRouter.
  
  Marionette.AppRouter = Backbone.Router.extend({
  
    constructor: function(options) {
      this.options = options || {};
  
      Backbone.Router.apply(this, arguments);
  
      var appRoutes = this.getOption('appRoutes');
      var controller = this._getController();
      this.processAppRoutes(controller, appRoutes);
      this.on('route', this._processOnRoute, this);
    },
  
    // Similar to route method on a Backbone Router but
    // method is called on the controller
    appRoute: function(route, methodName) {
      var controller = this._getController();
      this._addAppRoute(controller, route, methodName);
    },
  
    // process the route event and trigger the onRoute
    // method call, if it exists
    _processOnRoute: function(routeName, routeArgs) {
      // make sure an onRoute before trying to call it
      if (_.isFunction(this.onRoute)) {
        // find the path that matches the current route
        var routePath = _.invert(this.getOption('appRoutes'))[routeName];
        this.onRoute(routeName, routePath, routeArgs);
      }
    },
  
    // Internal method to process the `appRoutes` for the
    // router, and turn them in to routes that trigger the
    // specified method on the specified `controller`.
    processAppRoutes: function(controller, appRoutes) {
      if (!appRoutes) { return; }
  
      var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes
  
      _.each(routeNames, function(route) {
        this._addAppRoute(controller, route, appRoutes[route]);
      }, this);
    },
  
    _getController: function() {
      return this.getOption('controller');
    },
  
    _addAppRoute: function(controller, route, methodName) {
      var method = controller[methodName];
  
      if (!method) {
        throw new Marionette.Error('Method "' + methodName + '" was not found on the controller');
      }
  
      this.route(route, methodName, _.bind(method, controller));
    },
  
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    triggerMethod: Marionette.triggerMethod,
  
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  // Application
  // -----------
  
  // Contain and manage the composite application as a whole.
  // Stores and starts up `Region` objects, includes an
  // event aggregator as `app.vent`
  Marionette.Application = Marionette.Object.extend({
    constructor: function(options) {
      this._initializeRegions(options);
      this._initCallbacks = new Marionette.Callbacks();
      this.submodules = {};
      _.extend(this, options);
      this._initChannel();
      Marionette.Object.call(this, options);
    },
  
    // Command execution, facilitated by Backbone.Wreqr.Commands
    execute: function() {
      this.commands.execute.apply(this.commands, arguments);
    },
  
    // Request/response, facilitated by Backbone.Wreqr.RequestResponse
    request: function() {
      return this.reqres.request.apply(this.reqres, arguments);
    },
  
    // Add an initializer that is either run at when the `start`
    // method is called, or run immediately if added after `start`
    // has already been called.
    addInitializer: function(initializer) {
      this._initCallbacks.add(initializer);
    },
  
    // kick off all of the application's processes.
    // initializes all of the regions that have been added
    // to the app, and runs all of the initializer functions
    start: function(options) {
      this.triggerMethod('before:start', options);
      this._initCallbacks.run(options, this);
      this.triggerMethod('start', options);
    },
  
    // Add regions to your app.
    // Accepts a hash of named strings or Region objects
    // addRegions({something: "#someRegion"})
    // addRegions({something: Region.extend({el: "#someRegion"}) });
    addRegions: function(regions) {
      return this._regionManager.addRegions(regions);
    },
  
    // Empty all regions in the app, without removing them
    emptyRegions: function() {
      return this._regionManager.emptyRegions();
    },
  
    // Removes a region from your app, by name
    // Accepts the regions name
    // removeRegion('myRegion')
    removeRegion: function(region) {
      return this._regionManager.removeRegion(region);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this._regionManager.get(region);
    },
  
    // Get all the regions from the region manager
    getRegions: function() {
      return this._regionManager.getRegions();
    },
  
    // Create a module, attached to the application
    module: function(moduleNames, moduleDefinition) {
  
      // Overwrite the module class if the user specifies one
      var ModuleClass = Marionette.Module.getClass(moduleDefinition);
  
      var args = _.toArray(arguments);
      args.unshift(this);
  
      // see the Marionette.Module object for more information
      return ModuleClass.create.apply(ModuleClass, args);
    },
  
    // Enable easy overriding of the default `RegionManager`
    // for customized region interactions and business-specific
    // view logic for better control over single regions.
    getRegionManager: function() {
      return new Marionette.RegionManager();
    },
  
    // Internal method to initialize the regions that have been defined in a
    // `regions` attribute on the application instance
    _initializeRegions: function(options) {
      var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};
  
      this._initRegionManager();
  
      // Enable users to define `regions` in instance options.
      var optionRegions = Marionette.getOption(options, 'regions');
  
      // Enable region options to be a function
      if (_.isFunction(optionRegions)) {
        optionRegions = optionRegions.call(this, options);
      }
  
      // Overwrite current regions with those passed in options
      _.extend(regions, optionRegions);
  
      this.addRegions(regions);
  
      return this;
    },
  
    // Internal method to set up the region manager
    _initRegionManager: function() {
      this._regionManager = this.getRegionManager();
      this._regionManager._parent = this;
  
      this.listenTo(this._regionManager, 'before:add:region', function() {
        Marionette._triggerMethod(this, 'before:add:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'add:region', function(name, region) {
        this[name] = region;
        Marionette._triggerMethod(this, 'add:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'before:remove:region', function() {
        Marionette._triggerMethod(this, 'before:remove:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'remove:region', function(name) {
        delete this[name];
        Marionette._triggerMethod(this, 'remove:region', arguments);
      });
    },
  
    // Internal method to setup the Wreqr.radio channel
    _initChannel: function() {
      this.channelName = _.result(this, 'channelName') || 'global';
      this.channel = _.result(this, 'channel') || Backbone.Wreqr.radio.channel(this.channelName);
      this.vent = _.result(this, 'vent') || this.channel.vent;
      this.commands = _.result(this, 'commands') || this.channel.commands;
      this.reqres = _.result(this, 'reqres') || this.channel.reqres;
    }
  });
  
  /* jshint maxparams: 9 */
  
  // Module
  // ------
  
  // A simple module system, used to create privacy and encapsulation in
  // Marionette applications
  Marionette.Module = function(moduleName, app, options) {
    this.moduleName = moduleName;
    this.options = _.extend({}, this.options, options);
    // Allow for a user to overide the initialize
    // for a given module instance.
    this.initialize = options.initialize || this.initialize;
  
    // Set up an internal store for sub-modules.
    this.submodules = {};
  
    this._setupInitializersAndFinalizers();
  
    // Set an internal reference to the app
    // within a module.
    this.app = app;
  
    if (_.isFunction(this.initialize)) {
      this.initialize(moduleName, app, this.options);
    }
  };
  
  Marionette.Module.extend = Marionette.extend;
  
  // Extend the Module prototype with events / listenTo, so that the module
  // can be used as an event aggregator or pub/sub.
  _.extend(Marionette.Module.prototype, Backbone.Events, {
  
    // By default modules start with their parents.
    startWithParent: true,
  
    // Initialize is an empty function by default. Override it with your own
    // initialization logic when extending Marionette.Module.
    initialize: function() {},
  
    // Initializer for a specific module. Initializers are run when the
    // module's `start` method is called.
    addInitializer: function(callback) {
      this._initializerCallbacks.add(callback);
    },
  
    // Finalizers are run when a module is stopped. They are used to teardown
    // and finalize any variables, references, events and other code that the
    // module had set up.
    addFinalizer: function(callback) {
      this._finalizerCallbacks.add(callback);
    },
  
    // Start the module, and run all of its initializers
    start: function(options) {
      // Prevent re-starting a module that is already started
      if (this._isInitialized) { return; }
  
      // start the sub-modules (depth-first hierarchy)
      _.each(this.submodules, function(mod) {
        // check to see if we should start the sub-module with this parent
        if (mod.startWithParent) {
          mod.start(options);
        }
      });
  
      // run the callbacks to "start" the current module
      this.triggerMethod('before:start', options);
  
      this._initializerCallbacks.run(options, this);
      this._isInitialized = true;
  
      this.triggerMethod('start', options);
    },
  
    // Stop this module by running its finalizers and then stop all of
    // the sub-modules for this module
    stop: function() {
      // if we are not initialized, don't bother finalizing
      if (!this._isInitialized) { return; }
      this._isInitialized = false;
  
      this.triggerMethod('before:stop');
  
      // stop the sub-modules; depth-first, to make sure the
      // sub-modules are stopped / finalized before parents
      _.invoke(this.submodules, 'stop');
  
      // run the finalizers
      this._finalizerCallbacks.run(undefined, this);
  
      // reset the initializers and finalizers
      this._initializerCallbacks.reset();
      this._finalizerCallbacks.reset();
  
      this.triggerMethod('stop');
    },
  
    // Configure the module with a definition function and any custom args
    // that are to be passed in to the definition function
    addDefinition: function(moduleDefinition, customArgs) {
      this._runModuleDefinition(moduleDefinition, customArgs);
    },
  
    // Internal method: run the module definition function with the correct
    // arguments
    _runModuleDefinition: function(definition, customArgs) {
      // If there is no definition short circut the method.
      if (!definition) { return; }
  
      // build the correct list of arguments for the module definition
      var args = _.flatten([
        this,
        this.app,
        Backbone,
        Marionette,
        Backbone.$, _,
        customArgs
      ]);
  
      definition.apply(this, args);
    },
  
    // Internal method: set up new copies of initializers and finalizers.
    // Calling this method will wipe out all existing initializers and
    // finalizers.
    _setupInitializersAndFinalizers: function() {
      this._initializerCallbacks = new Marionette.Callbacks();
      this._finalizerCallbacks = new Marionette.Callbacks();
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod
  });
  
  // Class methods to create modules
  _.extend(Marionette.Module, {
  
    // Create a module, hanging off the app parameter as the parent object.
    create: function(app, moduleNames, moduleDefinition) {
      var module = app;
  
      // get the custom args passed in after the module definition and
      // get rid of the module name and definition function
      var customArgs = _.drop(arguments, 3);
  
      // Split the module names and get the number of submodules.
      // i.e. an example module name of `Doge.Wow.Amaze` would
      // then have the potential for 3 module definitions.
      moduleNames = moduleNames.split('.');
      var length = moduleNames.length;
  
      // store the module definition for the last module in the chain
      var moduleDefinitions = [];
      moduleDefinitions[length - 1] = moduleDefinition;
  
      // Loop through all the parts of the module definition
      _.each(moduleNames, function(moduleName, i) {
        var parentModule = module;
        module = this._getModule(parentModule, moduleName, app, moduleDefinition);
        this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
      }, this);
  
      // Return the last module in the definition chain
      return module;
    },
  
    _getModule: function(parentModule, moduleName, app, def, args) {
      var options = _.extend({}, def);
      var ModuleClass = this.getClass(def);
  
      // Get an existing module of this name if we have one
      var module = parentModule[moduleName];
  
      if (!module) {
        // Create a new module if we don't have one
        module = new ModuleClass(moduleName, app, options);
        parentModule[moduleName] = module;
        // store the module on the parent
        parentModule.submodules[moduleName] = module;
      }
  
      return module;
    },
  
    // ## Module Classes
    //
    // Module classes can be used as an alternative to the define pattern.
    // The extend function of a Module is identical to the extend functions
    // on other Backbone and Marionette classes.
    // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
    getClass: function(moduleDefinition) {
      var ModuleClass = Marionette.Module;
  
      if (!moduleDefinition) {
        return ModuleClass;
      }
  
      // If all of the module's functionality is defined inside its class,
      // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
      if (moduleDefinition.prototype instanceof ModuleClass) {
        return moduleDefinition;
      }
  
      return moduleDefinition.moduleClass || ModuleClass;
    },
  
    // Add the module definition and add a startWithParent initializer function.
    // This is complicated because module definitions are heavily overloaded
    // and support an anonymous function, module class, or options object
    _addModuleDefinition: function(parentModule, module, def, args) {
      var fn = this._getDefine(def);
      var startWithParent = this._getStartWithParent(def, module);
  
      if (fn) {
        module.addDefinition(fn, args);
      }
  
      this._addStartWithParent(parentModule, module, startWithParent);
    },
  
    _getStartWithParent: function(def, module) {
      var swp;
  
      if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
        swp = module.constructor.prototype.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      if (_.isObject(def)) {
        swp = def.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      return true;
    },
  
    _getDefine: function(def) {
      if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
        return def;
      }
  
      if (_.isObject(def)) {
        return def.define;
      }
  
      return null;
    },
  
    _addStartWithParent: function(parentModule, module, startWithParent) {
      module.startWithParent = module.startWithParent && startWithParent;
  
      if (!module.startWithParent || !!module.startWithParentIsConfigured) {
        return;
      }
  
      module.startWithParentIsConfigured = true;
  
      parentModule.addInitializer(function(options) {
        if (module.startWithParent) {
          module.start(options);
        }
      });
    }
  });
  

  return Marionette;
}));

; browserify_shim__define__module__export__(typeof Marionette != "undefined" ? Marionette : window.Marionette);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/Users/samelie/Documents/rad/gallery-viz/client/assets/vendor/backbone/backbone.js":1}],6:[function(require,module,exports){
(function (process,global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

; browserify_shim__define__module__export__(typeof Q != "undefined" ? Q : window.Q);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,require("FWaASH"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"FWaASH":9}],7:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){function f(a,e,b){a=document.createElement(a);a.id=e;a.style.cssText=b;return a}function l(a,e,b){var c=f("div",a,"padding:0 0 3px 3px;text-align:left;background:"+b),d=f("div",a+"Text","font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px;color:"+e);d.innerHTML=a.toUpperCase();c.appendChild(d);a=f("div",a+"Graph","width:74px;height:30px;background:"+e);c.appendChild(a);for(e=0;74>e;e++)a.appendChild(f("span","","width:1px;height:30px;float:left;opacity:0.9;background:"+
b));return c}function m(a){for(var b=c.children,d=0;d<b.length;d++)b[d].style.display=d===a?"block":"none";n=a}function p(a,b){a.appendChild(a.firstChild).style.height=Math.min(30,30-30*b)+"px"}var q=self.performance&&self.performance.now?self.performance.now.bind(performance):Date.now,k=q(),r=k,t=0,n=0,c=f("div","stats","width:80px;opacity:0.9;cursor:pointer");c.addEventListener("mousedown",function(a){a.preventDefault();m(++n%c.children.length)},!1);var d=0,u=Infinity,v=0,b=l("fps","#0ff","#002"),
A=b.children[0],B=b.children[1];c.appendChild(b);var g=0,w=Infinity,x=0,b=l("ms","#0f0","#020"),C=b.children[0],D=b.children[1];c.appendChild(b);if(self.performance&&self.performance.memory){var h=0,y=Infinity,z=0,b=l("mb","#f08","#201"),E=b.children[0],F=b.children[1];c.appendChild(b)}m(n);return{REVISION:14,domElement:c,setMode:m,begin:function(){k=q()},end:function(){var a=q();g=a-k;w=Math.min(w,g);x=Math.max(x,g);C.textContent=(g|0)+" MS ("+(w|0)+"-"+(x|0)+")";p(D,g/200);t++;if(a>r+1E3&&(d=Math.round(1E3*
t/(a-r)),u=Math.min(u,d),v=Math.max(v,d),A.textContent=d+" FPS ("+u+"-"+v+")",p(B,d/100),r=a,t=0,void 0!==h)){var b=performance.memory.usedJSHeapSize,c=performance.memory.jsHeapSizeLimit;h=Math.round(9.54E-7*b);y=Math.min(y,h);z=Math.max(z,h);E.textContent=h+" MB ("+y+"-"+z+")";p(F,b/c)}return a},update:function(){k=this.end()}}};"object"===typeof module&&(module.exports=Stats);

; browserify_shim__define__module__export__(typeof Stats != "undefined" ? Stats : window.Stats);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],8:[function(require,module,exports){
(function (global){
; var __browserify_shim_require__=require;(function browserifyShim(module, exports, require, define, browserify_shim__define__module__export__) {
// tween.js v.0.15.0 https://github.com/sole/tween.js
void 0===Date.now&&(Date.now=function(){return(new Date).valueOf()});var TWEEN=TWEEN||function(){var n=[];return{REVISION:"14",getAll:function(){return n},removeAll:function(){n=[]},add:function(t){n.push(t)},remove:function(t){var r=n.indexOf(t);-1!==r&&n.splice(r,1)},update:function(t){if(0===n.length)return!1;var r=0;for(t=void 0!==t?t:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();r<n.length;)n[r].update(t)?r++:n.splice(r,1);return!0}}}();TWEEN.Tween=function(n){var t=n,r={},i={},u={},o=1e3,e=0,a=!1,f=!1,c=!1,s=0,h=null,l=TWEEN.Easing.Linear.None,p=TWEEN.Interpolation.Linear,E=[],d=null,v=!1,I=null,w=null,M=null;for(var O in n)r[O]=parseFloat(n[O],10);this.to=function(n,t){return void 0!==t&&(o=t),i=n,this},this.start=function(n){TWEEN.add(this),f=!0,v=!1,h=void 0!==n?n:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now(),h+=s;for(var o in i){if(i[o]instanceof Array){if(0===i[o].length)continue;i[o]=[t[o]].concat(i[o])}r[o]=t[o],r[o]instanceof Array==!1&&(r[o]*=1),u[o]=r[o]||0}return this},this.stop=function(){return f?(TWEEN.remove(this),f=!1,null!==M&&M.call(t),this.stopChainedTweens(),this):this},this.stopChainedTweens=function(){for(var n=0,t=E.length;t>n;n++)E[n].stop()},this.delay=function(n){return s=n,this},this.repeat=function(n){return e=n,this},this.yoyo=function(n){return a=n,this},this.easing=function(n){return l=n,this},this.interpolation=function(n){return p=n,this},this.chain=function(){return E=arguments,this},this.onStart=function(n){return d=n,this},this.onUpdate=function(n){return I=n,this},this.onComplete=function(n){return w=n,this},this.onStop=function(n){return M=n,this},this.update=function(n){var f;if(h>n)return!0;v===!1&&(null!==d&&d.call(t),v=!0);var M=(n-h)/o;M=M>1?1:M;var O=l(M);for(f in i){var m=r[f]||0,N=i[f];N instanceof Array?t[f]=p(N,O):("string"==typeof N&&(N=m+parseFloat(N,10)),"number"==typeof N&&(t[f]=m+(N-m)*O))}if(null!==I&&I.call(t,O),1==M){if(e>0){isFinite(e)&&e--;for(f in u){if("string"==typeof i[f]&&(u[f]=u[f]+parseFloat(i[f],10)),a){var T=u[f];u[f]=i[f],i[f]=T}r[f]=u[f]}return a&&(c=!c),h=n+s,!0}null!==w&&w.call(t);for(var g=0,W=E.length;W>g;g++)E[g].start(n);return!1}return!0}},TWEEN.Easing={Linear:{None:function(n){return n}},Quadratic:{In:function(n){return n*n},Out:function(n){return n*(2-n)},InOut:function(n){return(n*=2)<1?.5*n*n:-.5*(--n*(n-2)-1)}},Cubic:{In:function(n){return n*n*n},Out:function(n){return--n*n*n+1},InOut:function(n){return(n*=2)<1?.5*n*n*n:.5*((n-=2)*n*n+2)}},Quartic:{In:function(n){return n*n*n*n},Out:function(n){return 1- --n*n*n*n},InOut:function(n){return(n*=2)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2)}},Quintic:{In:function(n){return n*n*n*n*n},Out:function(n){return--n*n*n*n*n+1},InOut:function(n){return(n*=2)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2)}},Sinusoidal:{In:function(n){return 1-Math.cos(n*Math.PI/2)},Out:function(n){return Math.sin(n*Math.PI/2)},InOut:function(n){return.5*(1-Math.cos(Math.PI*n))}},Exponential:{In:function(n){return 0===n?0:Math.pow(1024,n-1)},Out:function(n){return 1===n?1:1-Math.pow(2,-10*n)},InOut:function(n){return 0===n?0:1===n?1:(n*=2)<1?.5*Math.pow(1024,n-1):.5*(-Math.pow(2,-10*(n-1))+2)}},Circular:{In:function(n){return 1-Math.sqrt(1-n*n)},Out:function(n){return Math.sqrt(1- --n*n)},InOut:function(n){return(n*=2)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1)}},Elastic:{In:function(n){var t,r=.1,i=.4;return 0===n?0:1===n?1:(!r||1>r?(r=1,t=i/4):t=i*Math.asin(1/r)/(2*Math.PI),-(r*Math.pow(2,10*(n-=1))*Math.sin(2*(n-t)*Math.PI/i)))},Out:function(n){var t,r=.1,i=.4;return 0===n?0:1===n?1:(!r||1>r?(r=1,t=i/4):t=i*Math.asin(1/r)/(2*Math.PI),r*Math.pow(2,-10*n)*Math.sin(2*(n-t)*Math.PI/i)+1)},InOut:function(n){var t,r=.1,i=.4;return 0===n?0:1===n?1:(!r||1>r?(r=1,t=i/4):t=i*Math.asin(1/r)/(2*Math.PI),(n*=2)<1?-.5*r*Math.pow(2,10*(n-=1))*Math.sin(2*(n-t)*Math.PI/i):r*Math.pow(2,-10*(n-=1))*Math.sin(2*(n-t)*Math.PI/i)*.5+1)}},Back:{In:function(n){var t=1.70158;return n*n*((t+1)*n-t)},Out:function(n){var t=1.70158;return--n*n*((t+1)*n+t)+1},InOut:function(n){var t=2.5949095;return(n*=2)<1?.5*n*n*((t+1)*n-t):.5*((n-=2)*n*((t+1)*n+t)+2)}},Bounce:{In:function(n){return 1-TWEEN.Easing.Bounce.Out(1-n)},Out:function(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},InOut:function(n){return.5>n?.5*TWEEN.Easing.Bounce.In(2*n):.5*TWEEN.Easing.Bounce.Out(2*n-1)+.5}}},TWEEN.Interpolation={Linear:function(n,t){var r=n.length-1,i=r*t,u=Math.floor(i),o=TWEEN.Interpolation.Utils.Linear;return 0>t?o(n[0],n[1],i):t>1?o(n[r],n[r-1],r-i):o(n[u],n[u+1>r?r:u+1],i-u)},Bezier:function(n,t){var r,i=0,u=n.length-1,o=Math.pow,e=TWEEN.Interpolation.Utils.Bernstein;for(r=0;u>=r;r++)i+=o(1-t,u-r)*o(t,r)*n[r]*e(u,r);return i},CatmullRom:function(n,t){var r=n.length-1,i=r*t,u=Math.floor(i),o=TWEEN.Interpolation.Utils.CatmullRom;return n[0]===n[r]?(0>t&&(u=Math.floor(i=r*(1+t))),o(n[(u-1+r)%r],n[u],n[(u+1)%r],n[(u+2)%r],i-u)):0>t?n[0]-(o(n[0],n[0],n[1],n[1],-i)-n[0]):t>1?n[r]-(o(n[r],n[r],n[r-1],n[r-1],i-r)-n[r]):o(n[u?u-1:0],n[u],n[u+1>r?r:u+1],n[u+2>r?r:u+2],i-u)},Utils:{Linear:function(n,t,r){return(t-n)*r+n},Bernstein:function(n,t){var r=TWEEN.Interpolation.Utils.Factorial;return r(n)/r(t)/r(n-t)},Factorial:function(){var n=[1];return function(t){var r,i=1;if(n[t])return n[t];for(r=t;r>1;r--)i*=r;return n[t]=i}}(),CatmullRom:function(n,t,r,i,u){var o=.5*(r-n),e=.5*(i-t),a=u*u,f=u*a;return(2*t-2*r+o+e)*f+(-3*t+3*r-2*o-e)*a+o*u+t}}},"undefined"!=typeof module&&module.exports&&(module.exports=TWEEN);
; browserify_shim__define__module__export__(typeof TWEEN != "undefined" ? TWEEN : window.TWEEN);

}).call(global, undefined, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],10:[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":11,"./vendor/dat.gui":12}],11:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],12:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],13:[function(require,module,exports){
// vendor dependencies
var Marionette = require('marionette');

// constructor
var App = new Marionette.Application();

App.addInitializer(function() {

    // app dependencies in correct order

    // commons
    require('fastclick');

    require('./regions/app_regions');

    require('./entities/manifest_entity');

    require('./views/app_view');
    require('./views/shaders_view');
    require('./views/composer_view');
    require('./views/effect_view');
    require('./controllers/app_controller');
});

// export
module.exports = App;
},{"./controllers/app_controller":56,"./entities/manifest_entity":57,"./regions/app_regions":58,"./views/app_view":59,"./views/composer_view":60,"./views/effect_view":61,"./views/shaders_view":62,"fastclick":2,"marionette":5}],14:[function(require,module,exports){
var AudioAnalyser = function() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
    var offlineContext = null;
    var audioContext = null;
    var isPlaying = false;
    var sourceNode = null;
    var analyser = null;
    var theBuffer = null;
    var DEBUGCANVAS = null;
    var mediaStreamSource = null;
    var detectorElem,
        canvasElem,
        waveCanvas,
        pitchElem,
        noteElem,
        detuneElem,
        detuneAmount;

    audioContext = new AudioContext();
    offlineContext = new window.OfflineAudioContext(1, 2, 44100);

    function _onTrackLoaded() {
        if (isPlaying) {
            //stop playing and return
            sourceNode.stop(0);
            sourceNode = null;
            analyser = null;
            isPlaying = false;
            window.cancelAnimationFrame(rafID);
            return "start";
        }

        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = theBuffer;
        sourceNode.loop = true;

        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        sourceNode.connect(analyser);
        analyser.connect(audioContext.destination);
        sourceNode.start(0);
        isPlaying = true;
        isLiveInput = false;

        _updatePitch();

    }


    var rafID = null;
    var tracks = null;
    var buflen = 1024;
    var buf = new Float32Array(buflen);

    var noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    var MIN_SAMPLES = 0; // will be initialized when AudioContext is created.

    function _autoCorrelate(buf, sampleRate) {
        var SIZE = buf.length;
        var MAX_SAMPLES = Math.floor(SIZE / 2);
        var best_offset = -1;
        var best_correlation = 0;
        var rms = 0;
        var foundGoodCorrelation = false;
        var correlations = new Array(MAX_SAMPLES);

        for (var i = 0; i < SIZE; i++) {
            var val = buf[i];
            rms += val * val;
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) // not enough signal
            return -1;

        var lastCorrelation = 1;
        for (var offset = MIN_SAMPLES; offset < MAX_SAMPLES; offset++) {
            var correlation = 0;

            for (var i = 0; i < MAX_SAMPLES; i++) {
                correlation += Math.abs((buf[i]) - (buf[i + offset]));
            }
            correlation = 1 - (correlation / MAX_SAMPLES);
            correlations[offset] = correlation; // store it, for the tweaking we need to do below.
            if ((correlation > 0.9) && (correlation > lastCorrelation)) {
                foundGoodCorrelation = true;
                if (correlation > best_correlation) {
                    best_correlation = correlation;
                    best_offset = offset;
                }
            } else if (foundGoodCorrelation) {
                // short-circuit - we found a good correlation, then a bad one, so we'd just be seeing copies from here.
                // Now we need to tweak the offset - by interpolating between the values to the left and right of the
                // best offset, and shifting it a bit.  This is complex, and HACKY in this code (happy to take PRs!) -
                // we need to do a curve fit on correlations[] around best_offset in order to better determine precise
                // (anti-aliased) offset.

                // we know best_offset >=1, 
                // since foundGoodCorrelation cannot go to true until the second pass (offset=1), and 
                // we can't drop into this clause until the following pass (else if).
                var shift = (correlations[best_offset + 1] - correlations[best_offset - 1]) / correlations[best_offset];
                return sampleRate / (best_offset + (8 * shift));
            }
            lastCorrelation = correlation;
        }
        if (best_correlation > 0.01) {
            // console.log("f = " + sampleRate/best_offset + "Hz (rms: " + rms + " confidence: " + best_correlation + ")")
            return sampleRate / best_offset;
        }
        return -1;
        //  var best_frequency = sampleRate/best_offset;
    }

    function _noteFromPitch(frequency) {
        var noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
        return Math.round(noteNum) + 69;
    }


    function _updatePitch(time) {
        var cycles = new Array;
        analyser.getFloatTimeDomainData(buf);
        var ac = _autoCorrelate(buf, audioContext.sampleRate);
        if (ac == -1) {} else {
            pitch = ac;
            var note = _noteFromPitch(pitch);
            console.log(note);
        }

        rafID = window.requestAnimationFrame(_updatePitch);
    }

    function addTrack(url) {
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
            audioContext.decodeAudioData(request.response, function(buffer) {
                theBuffer = buffer;
                _onTrackLoaded();
            });
        }
        request.send();
    }

    return {
        addTrack: addTrack
    }
}

module.exports = AudioAnalyser;
},{}],15:[function(require,module,exports){
'use strict';
var SHADERS = require('../common/shaders');
var OPTIONS = require('../common/shader_options');
var SETTINGS = require('../common/shader_settings');

var Effects = function(scene, camera, renderer, fbo) {

	//var scene = new THREE.Scene();

	// create a camera, which defines where we're looking at.
	//var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

	/*var webGLRenderer = new THREE.WebGLRenderer();
	webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0));
	webGLRenderer.setSize(window.innerWidth, window.innerHeight);
	webGLRenderer.shadowMapEnabled = true;
	webGLRenderer.antialias = false;*/

	//el.appendChild(webGLRenderer.domElement);
	var _otherFbo;

	var effects = {
		bit: new THREE.ShaderPass(SHADERS.bit),
		pixelate: new THREE.ShaderPass(SHADERS.pixelate),
		bleach: new THREE.ShaderPass(SHADERS.bleach),
		blend: new THREE.ShaderPass(SHADERS.blend),
		color: new THREE.ShaderPass(SHADERS.color),
		copy: new THREE.ShaderPass(SHADERS.copy),
		dot: new THREE.ShaderPass(SHADERS.dot),
		edge: new THREE.ShaderPass(SHADERS.edge),
		glitch: new THREE.ShaderPass(SHADERS.glitch),
		kaleido: new THREE.ShaderPass(SHADERS.kaleido),
		twist: new THREE.ShaderPass(SHADERS.twist),
		rgbShift: new THREE.ShaderPass(SHADERS.rgbShift)
	};


	_.forIn(effects, function(effect, key) {
		if (OPTIONS[key]) {
			effect['enabled'] = OPTIONS[key]['enabled'];
		}
	});

	var renderPass = new THREE.RenderPass(scene, camera);
	var effectCopy = new THREE.ShaderPass(SHADERS.copy);
	effectCopy.renderToScreen = true;

	//effects.glitch['uniforms']['tDisp'].value = new THREE.ImageUtils.loadTexture('assets/img/hero.jpg');

	var composer = new THREE.EffectComposer(renderer, fbo);
	composer.addPass(renderPass);
	//composer.addPass(effects.blend);
	composer.addPass(effects.pixelate);
	composer.addPass(effects.bleach);
	composer.addPass(effects.bit);
	composer.addPass(effects.color);
	/*composer.addPass(effects.dot);
	composer.addPass(effects.edge);
	*/
	composer.addPass(effects.kaleido);
	composer.addPass(effects.twist);
	composer.addPass(effects.rgbShift);
	composer.addPass(effects.copy);

	/*function animate() {
		render();
		window.requestAnimationFrame(animate);
	}*/

	function _updateEffects() {
		//effects.blend['uniforms']['tDiffuse1'].value = fbo;
		if (_otherFbo) {
			//effects.blend['uniforms']['tDiffuse2'].value = _otherFbo;
		}
	}

	function render() {
		composer.render();
	}

	function setOtherFbo(f) {
		_otherFbo = f;

		_updateEffects();
	}

	function updateUniforms(uniforms) {
		var obj = uniforms['uniforms'];
		var effect = effects[uniforms['shader']];
		effect.enabled = obj['enabled'];
		_.forIn(obj, function(val, key) {
			if (_.isObject(val)) {
				if (effect['uniforms'][key]) {
					effect['uniforms'][key].value = val[key];
				}
			}
		});
	}

	return {
		updateUniforms: updateUniforms,
		setOtherFbo: setOtherFbo,
		render: render
	}

};

module.exports = Effects;
},{"../common/shader_options":24,"../common/shader_settings":25,"../common/shaders":26}],16:[function(require,module,exports){
var Simple1DNoise = (function(numPoints) {
    var PERLIN_AMP = 1;
    var PERLIN_SCALE = 1;
    var MAX_VERTICES = numPoints || NUM_POINTS;
    var MAX_VERTICES_MASK = MAX_VERTICES - 1;
    var mirror = 0;

    var lerp = function(a, b, t) {
        return a * (1 - t) + b * t;
    };

    var cosLerp = function(a, b, x) {
        var ft = x * 3.1415927
        var f = (1 - Math.cos(ft)) * .5
        return a * (1 - f) + b * f
    };
    var r = [];
    for (var i = 0; i < MAX_VERTICES; ++i) {
        r.push(Math.random());
    }
    var l = r.length;
    /*for (var i = 0; i < 10; i++) {
		r[l-i] = r[i];
	}*/
    r[0] = cosLerp(r[l - 1], r[1], 0.5);

    var getVal = function(x) {
        var scaledX = x * PERLIN_SCALE;
        var xFloor = Math.floor(scaledX);
        var t = scaledX - xFloor;
        var tRemapSmoothstep = t * t * (3 - 2 * t);

        /// Modulo using &
        var xMin = xFloor % MAX_VERTICES_MASK;
        var xMax = (xMin + 1) % MAX_VERTICES_MASK;

        var y = cosLerp(r[xMin], r[xMax], tRemapSmoothstep);

        return y * PERLIN_AMP;
    };

    // return the API
    return {
        getVal: getVal,
        setAmplitude: function(newAmplitude) {
            amplitude = newAmplitude;
        },
        setScale: function(newScale) {
            scale = newScale;
        }
    };
})(100);

module.exports = Simple1DNoise;
},{}],17:[function(require,module,exports){
/*var PlayerController = Object.create(require('./player_manager'));
PlayerController.init = function(){

};
*/
var PlayerController = function() {
	'use strict';
	if (!MediaSource) {
		throw new Error('NO MEDIASOURCE!');
	}

	var requestId;

	//booleans
	var updatedStarted, locked, starting = true;

	//playback info
	var segDuration = 0,
		playOffset = 0,
		enterFrameCounter = 0,
		previousCurrentTime = 0,
		segmentIndex = 0,
		totalSegments = 0,
		skipCount = 0,

		chapterIndex = 0,
		currentChapter = 0;

	//callback
	var onNewVo, needMoreSegments;
	////-----------------
	//SETUP
	////-----------------

	var videoElement;
	var mediaSource;
	var sourceBuffer;

	//ref to proto
	var _manifest;
	var playlist;
	var boundUpdate;

	function init(vEl) {

		videoElement = vEl;

		mediaSource = new MediaSource();
		var url = URL.createObjectURL(mediaSource);
		videoElement.src = url;

		mediaSource.addEventListener('sourceopen', _onSourceOpen, false);
		boundUpdate = onUpdate.bind(this);
		requestId = window.requestAnimationFrame(boundUpdate);
	}

	function _onSourceOpen(e) {
		mediaSource.removeEventListener('sourceopen', _onSourceOpen);
		sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42c01e"');
		sourceBuffer.addEventListener('updatestart', onBufferUpdateStart);
		sourceBuffer.addEventListener('updateend', onBufferUpdateEnd);
		starting = false;
		console.log("source open");
	}

	////-----------------
	//BUFFER HANDLERS
	////-----------------


	function onBufferUpdateStart() {
		updatedStarted = true;
	}

	function onBufferUpdateEnd() {
		/*sourceBuffer.removeEventListener('updateend', onBufferUpdateEnd);
		var currentVo = playlist[segmentIndex - 1];
		if (currentVo) {
			segDuration = currentVo['durationSec'];
			var dur = playOffset;
			if (dur === 0) {
				dur = currentVo['durationSec'];
			}
			mediaSource.duration = dur;
		}
		sourceBuffer.addEventListener('updateend', onBufferUpdateEnd);*/
		updatedStarted = false;
		locked = false;
	}	

	////-----------------
	//UPDATE
	////-----------------

	function onUpdate() {
		if (totalSegments > 0) {
			if (segmentIndex < totalSegments) {
				if (!updatedStarted || !locked) {
					//console.log(videoElement.currentTime ,(playOffset - segDuration * .8), segDuration);
					if (videoElement.currentTime >= (playOffset - segDuration * .8)) {
						locked = true;
						var data = currentChapter[segmentIndex];
						if (data) {
							var clip = data['clip'];
							playOffset += clip['duration'];
							segDuration = clip['duration'];
							console.warn(segDuration)
							playSegment(clip);
						} else {
							console.log('No more at', segmentIndex);
						}
					}
				}
			} else {
				console.error("No More videos");
				_onChapterComplete();
			}
		}

		previousCurrentTime = videoElement.currentTime;
		requestId = window.requestAnimationFrame(boundUpdate);
	}

	//----------
	//PLAY A VO
	//----------

	function playSegment(data) {
		var self = this;
		var url = 'assets/videos/'+data['relPath'];
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url);
		xhr.setRequestHeader("Range", "bytes=" + data['mediaRange']);
		xhr.send();
		xhr.responseType = 'arraybuffer';
		xhr.addEventListener("readystatechange", function() {
			if (xhr.readyState == xhr.DONE) { //wait for video to load
				if (!sourceBuffer || !mediaSource || starting) {
					return;
				}
				var segResp = new Uint8Array(xhr.response);
				var off;
				if (sourceBuffer.buffered.length > 0) {
					off = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
				}
				console.log(mediaSource.readyState);
				sourceBuffer.timestampOffset = off || 0;

				function __addInit(initRes) {
					sourceBuffer.removeEventListener('updateend', onBufferUpdateEnd);
					sourceBuffer.addEventListener('updateend', __onInitAdded);
					sourceBuffer.appendBuffer(initRes);
				}

				function __onInitAdded() {
					if (mediaSource.readyState === 'open') {
						sourceBuffer.removeEventListener('updateend', __onInitAdded);
						sourceBuffer.addEventListener('updateend', onBufferUpdateEnd);
						//var ts = sourceBuffer.timestampOffset - data['startTimeSec'];
						//sourceBuffer.timestampOffset = ts;
						console.log(segmentIndex, '/', totalSegments);
						console.log(mediaSource.readyState);
						sourceBuffer.appendBuffer(segResp);
						segmentIndex++;

						/*if (onNewVo) {
							onNewVo(data);
						}*/
					}
				}
				initialRequest(data, __addInit);
			}
		}, false);
	}


	function initialRequest(data, callback) {
		var url = 'assets/videos/'+data['relPath'];
		var xhr = new XMLHttpRequest();
		var range = "bytes=0-" + (data['firstOffset'] - 1);
		xhr.open('GET', url);
		xhr.setRequestHeader("Range", range);
		xhr.send();
		xhr.responseType = 'arraybuffer';
		try {
			xhr.addEventListener("readystatechange", function() {
				if (xhr.readyState == xhr.DONE) { // wait for video to load
					while(updatedStarted){}
					callback(new Uint8Array(xhr.response));
				}
			}, false);
		} catch (e) {
			log(e);
		}
	}

	//crash
	function resetMediasource() {
		window.cancelAnimationFrame(requestId);
		sourceBuffer.removeEventListener('updateend', onBufferUpdateEnd);
		sourceBuffer.removeEventListener('updatestart', onBufferUpdateStart);
		mediaSource.removeSourceBuffer(sourceBuffer);
		sourceBuffer = null;
		mediaSource.duration = 0;
		enterFrameCounter = 0;
		mediaSource = null;
		locked = updatedStarted = false;
		videoElement.play();
		videoElement.currentTime = 0;
		segDuration = playOffset = 0;
		//init();
		/*sourceBuffer.addEventListener('updateend', __onDurationSet);
        var duration = mediaSource.duration;

        function __onDurationSet(e) {
            sourceBuffer.removeEventListener('updateend', __onDurationSet);
            sourceBuffer.addEventListener('updateend', onBufferUpdateEnd);
            sourceBuffer.timestampOffset = 0;
            sourceBuffer.remove(0, duration);
            videoElement.currentTime = 0;
            segDuration = playOffset = 0;
            console.log("ZEROED");
        }*/

	}

	function _onChapterComplete(){
		chapterIndex++;
		if(chapterIndex > _manifest.length -1){
			chapterIndex = 0;
		}
		segmentIndex = 0;
		currentChapter = _manifest[chapterIndex];
		totalSegments = currentChapter.length;
	}
	///---------------
	//API
	///---------------

	function setOnNewVo(callback) {
		onNewVo = callback;
	}

	function setEntireManifest(manifest){
		_manifest = manifest;
		currentChapter = _manifest[chapterIndex];
		totalSegments = currentChapter.length;
	}

	return {
		init: init,
		setOnNewVo: setOnNewVo,
		setEntireManifest: setEntireManifest
	}
};

module.exports = PlayerController;
},{}],18:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var pixelRatio = 1;

		var width  = Math.floor( renderer.context.canvas.width  / pixelRatio ) || 1;
		var height = Math.floor( renderer.context.canvas.height / pixelRatio ) || 1;
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

THREE.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( !pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof THREE.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof THREE.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			var pixelRatio = this.renderer.getPixelRatio();

			renderTarget.width  = Math.floor( this.renderer.context.canvas.width  / pixelRatio );
			renderTarget.height = Math.floor( this.renderer.context.canvas.height / pixelRatio );

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		var renderTarget = this.renderTarget1.clone();

		renderTarget.width = width;
		renderTarget.height = height;

		this.reset( renderTarget );

	}

};

},{}],19:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


THREE.ClearMaskPass = function () {

	this.enabled = true;

};

THREE.ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};

module.exports = THREE.MaskPass;
},{}],20:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

module.exports = THREE.RenderPass;
},{}],21:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

        	defines: shader.defines || {},
		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;


	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};

module.exports = THREE.ShaderPass;
},{}],22:[function(require,module,exports){
'use strict';
var UTILS = require('./utils');
var EFFECTS = require('./effects_scene')

var Scene = function(renderer, clearColor, cameraZ) {
	var fbo;

	var _scene, _camera, _clearColor, _mesh;

	_clearColor = clearColor;

	_camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
	//_camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 1000);
	_camera.position.z = cameraZ;
	// Setup scene
	_scene = this.scene = new THREE.Scene();
	_scene.add(new THREE.AmbientLight(0x555555));

	var renderTargetParameters = {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBFormat,
		stencilBuffer: false
	};

	fbo = this.fbo = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetParameters);
	fbo.minFilter = THREE.LinearFilter;
	fbo.magFilter = THREE.LinearFilter;

	var fx = new EFFECTS(_scene, _camera, renderer, fbo);

	function render(rtt) {
		//renderer.setClearColor(_clearColor);
		fx.render();
		/*if (rtt) {
			renderer.render(_scene, _camera, fbo, true);
		} else {
			renderer.render(_scene, _camera);
		}*/
	}

	function createPlane(w, h, material) {
		var geometry = new THREE.PlaneGeometry(1280, 720, 4, 4);
		geometry.center();
		_mesh = new THREE.Mesh(geometry, material);
		//_mesh.position.z = -200;
		//_mesh.position.z = -400;
		//_mesh.position.x = ;
		_scene.add(_mesh);
	}

	function resize(w, h, scale) {
		_camera.aspect = w / h;
		_mesh.scale.x = _mesh.scale.y = scale;
		_camera.updateProjectionMatrix();
		//fbo.setSize(w, h);
	}

	function updateUniforms(uniforms){
		fx.updateUniforms(uniforms);
	}

	return {
		resize: resize,
		render: render,
		fx: fx,
		fbo: fbo,
		updateUniforms: updateUniforms,
		createPlane: createPlane
	}
};

module.exports = Scene;
},{"./effects_scene":15,"./utils":54}],23:[function(require,module,exports){
var SHADERS = require('./shaders');
module.exports = {
    mix: function() {
        var shader = SHADERS["mix"];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        return {
            shader: shader,
            uniforms: uniforms
        }
    },
    chroma: function() {
        var shader = SHADERS["chroma"];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        uniforms["enableChroma"].value = true;
        uniforms["enableColor"].value = true;
        uniforms["enableReflection"].value = true;
        uniforms["enableDisplacement"].value = true;
        uniforms["enableRipples"].value = true;

        uniforms["uDisplacementBias"].value = 1.0;
        uniforms["uDisplacementScale"].value = 20;

        uniforms["uAmbientColor"].value.convertGammaToLinear();
        uniforms["uDiffuseColor"].value.convertGammaToLinear();
        return {
            shader: shader,
            uniforms: uniforms
        }
    },
    fractal1: function() {
        var shader = SHADERS["fractal1"];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        uniforms["uAmbientColor"].value.convertGammaToLinear();
        uniforms["uDiffuseColor"].value.convertGammaToLinear();
        return {
            shader: shader,
            uniforms: uniforms
        }
    },
    cave: function() {
        var shader = SHADERS["cave"];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

        uniforms["uAmbientColor"].value.convertGammaToLinear();
        uniforms["uDiffuseColor"].value.convertGammaToLinear();
        return {
            shader: shader,
            uniforms: uniforms
        }
    }
};
},{"./shaders":26}],24:[function(require,module,exports){
module.exports = {
	bleach: {
		enabled: false,
		opacity: {
			opacity: 0.05,
			min: -4,
			max: 4
		}
	},
	blend: {
		enabled: false,
		mixRatio: 0.01,
		opacity: 0.01
	},
	brightness: {
		enabled: false,
		brightness: 0.01,
		contrast: 0.01
	},
	copy: {
		enabled: true,
	},
	pixelate: {
		enabled: false,
		xAmount: {
			xAmount: 0.01,
			min: 0,
			max: 1
		},
		yAmount: {
			yAmount: 0.01,
			min: 0,
			max: 1
		}
	},
	color: {
		enabled: false,
		uSaturation: {
			uSaturation: 1.01,
			min: 1,
			max: 10
		},
		uContrast: {
			uContrast: 1.01,
			min: -6,
			max: 6
		},
		uDesaturate: {
			uDesaturate: 0,
			min: 0,
			max: 4
		},
		uBrightness: {
			uBrightness: 0.05,
			min: -1,
			max: 1.3
		},
		uHue: {
			uHue: 0.05,
			min: 0,
			max: 4
		}
	},
	glitch: {
		enabled: false,
		"amount": {
			amount: 0.05,
			min: 0,
			max: 4
		},
		"angle": {
			angle: 0.05,
			min: 0,
			max: Math.PI * 2
		},
		"seed": {
			seed: 0.05,
			min: 0,
			max: 4
		},
		"seed_x": {
			seed_x: 0.05,
			min: 0,
			max: 4
		},
		"seed_y": {
			seed_y: 0.05,
			min: 0,
			max: 4
		},
		"distortion_x": {
			distortion_x: 0.05,
			min: 0,
			max: 4
		},
		"distortion_y": {
			distortion_y: 0.05,
			min: 0,
			max: 4
		},
		"col_s": {
			col_s: 0.05,
			min: 0,
			max: 4
		}
	},
	dot: {
		enabled: false,
		"angle": {
			angle: 0.01,
			min: 0,
			max: Math.PI * 2
		},
		"scale": {
			scale: 0.01,
			min: 0,
			max: 10
		}
	},
	bit: {
		enabled: false,
		"bitSize": {
			bitSize: 2.0,
			min: 1.3,
			max: 8
		}
	},
	kaleido: {
		enabled: false,
		"sides": {
			sides: 0.01,
			min: 0.01,
			max: 32
		},
		"angle": {
			angle: 0.01,
			min: 0,
			max: Math.PI * 2
		}
	},
	twist: {
		enabled: false,
		"radius": {
			radius: 0.141,
			min: 0.065,
			max: 0.42
		},
		"angle": {
			angle: 0.01,
			min: -Math.PI * .5,
			max: Math.PI * .5
		}
	},
	rgbShift: {
		enabled: false,
		"uRed": {
			uRed: 1,
			min: 1,
			max: 32
		},
		"uGreen": {
			uGreen: 1,
			min: 1,
			max: 32
		},
		"uBue": {
			uBue: 1,
			min: 1,
			max: 32
		}
	}
};
},{}],25:[function(require,module,exports){
module.exports = {
	bleach: {
		min: 0,
		max: 1
	},
	bokah: {
		"threshold": 0.51,
		"gain": 2.01,
		"bias": 0.51,
		"fringe": 0.71,
	},
	glitch: {
		"amount": 0.08,
		"angle": 0.02,
		"seed": 0.02,
		"seed_x": 0.02,
		"seed_y": 0.02,
		"distortion_x": 0.51,
		"distortion_y": 0.61,
		"col_s": 0.05
	},
	dot: {
		"angle": 1.57,
		"scale": 1.01
	},
	kaleido: {
		"sides": 0.01,
		"angle": 0.01,
	}
};
},{}],26:[function(require,module,exports){

THREE.CopyShader = require('./shaders/CopyShader');
THREE.MaskPass = require('./post/MaskPass');
THREE.RenderPass = require('./post/RenderPass');
THREE.ShaderPass = require('./post/ShaderPass');
require('./post/EffectComposer');
/*var source = glslify({
    vertex: '../../../glsl/displacement.vert',
    fragment: '../../../glsl/mega.frag',
    sourceOnly: true
});*/

/*var createShader = require('three-glslify')(THREE)
var myShader = createShader(source);
console.log(myShader);*/

module.exports = {
    'mix' : {
        uniforms: THREE.UniformsUtils.merge( [

            {

            "uMixRatio"   : { type: "f", value: 0.5 },
            "uThreshold"   : { type: "f", value: 0.5 },
            "uSaturation"   : { type: "f", value: 1. },

            "tOne"     : { type: "t", value: null },
            "tTwo"     : { type: "t", value: null },
            "tMix"     : { type: "t", value: null },

            }

            ] ),
            
            fragmentShader:"#define GLSLIFY 1\n            varying vec2 vUv;\n\n            uniform float uThreshold;\n            uniform float uMixRatio;\n            uniform float uSaturation;\n\n            uniform sampler2D tOne;\n            uniform sampler2D tTwo;\n            uniform sampler2D tMix;\n\n            vec3 changeSaturation(vec3 color, float saturation) {\n                float luma = dot(vec3(0.2125, 0.7154, 0.0721) * color, vec3(1.));\n                return mix(vec3(luma), color, saturation);\n            }\n\n            void main() {\n                vec4 texOne = texture2D(tOne, vUv);\n                vec4 texTwo = texture2D(tTwo, vUv);\n                vec4 texMix = texture2D(tMix, vUv);\n\n                vec3 textTwoCol = texTwo.rgb;\n                textTwoCol = changeSaturation(textTwoCol, uSaturation);\n\n                vec4 transitionTexel = texture2D(tMix, vUv);\n                float r = uMixRatio * (1.0 + uThreshold * 2.0) - uThreshold;\n                float mixf = clamp((transitionTexel.g - r) * (1.0 / uThreshold), 0.0, 1.0);\n                vec4 col = mix(texOne, vec4(textTwoCol, 1.0), mixf);\n                col *= 0.01 + 2.5 * pow(vUv.x * vUv.y * (1.0 - vUv.x) * (1.0 - vUv.y), 0.3);\n                gl_FragColor = col;\n                // gl_FragColor = texOne;\n            }",
            vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = vec2(uv.x, uv.y);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}"
    },
    'color' : {
        uniforms: THREE.UniformsUtils.merge( [


            {

            "tDiffuse"     : { type: "t", value: null },

            //color
            "uSaturation": { type: "f", value: 1 },
            "uContrast": { type: "f", value: 0 },
            "uDesaturate": { type: "f", value: 0 },
            "uBrightness": { type: "f", value: 0 },
            "uHue": { type: "f", value: 0 }
            }

            ] ),
            
            fragmentShader:"#define GLSLIFY 1\n\t\t\t/*\n\t\t\t ** Hue, saturation, luminance\n\t\t\t */\n\n\t\t\tvec3 toHue(vec3 rgb, float adjustment) {\n                const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\n                    0.595716, -0.274453, -0.321263,\n                    0.211456, -0.522591, 0.311135);\n                const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\n                    1.0, -0.2721, -0.6474,\n                    1.0, -1.107, 1.7046);\n\n                vec3 yiq = toYIQ * rgb;\n                float hue = atan(yiq.z, yiq.y) + adjustment;\n                float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n\n                vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n                return toRGB * color;\n            }\n\n\t\t\tvec3 RGBToHSL(vec3 color) {\n\t\t\t\tvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n\t\t\t\tfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n\t\t\t\tfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n\t\t\t\tfloat delta = fmax - fmin; //Delta RGB value\n\n\t\t\t\thsl.z = (fmax + fmin) / 2.0; // Luminance\n\n\t\t\t\tif (delta == 0.0) //This is a gray, no chroma...\n\t\t\t\t{\n\t\t\t\t\thsl.x = 0.0; // Hue\n\t\t\t\t\thsl.y = 0.0; // Saturation\n\t\t\t\t} else //Chromatic data...\n\t\t\t\t{\n\t\t\t\t\tif (hsl.z < 0.5)\n\t\t\t\t\t\thsl.y = delta / (fmax + fmin); // Saturation\n\t\t\t\t\telse\n\t\t\t\t\t\thsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n\t\t\t\t\tfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n\t\t\t\t\tfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n\t\t\t\t\tfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n\t\t\t\t\tif (color.r == fmax)\n\t\t\t\t\t\thsl.x = deltaB - deltaG; // Hue\n\t\t\t\t\telse if (color.g == fmax)\n\t\t\t\t\t\thsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n\t\t\t\t\telse if (color.b == fmax)\n\t\t\t\t\t\thsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n\t\t\t\t\tif (hsl.x < 0.0)\n\t\t\t\t\t\thsl.x += 1.0; // Hue\n\t\t\t\t\telse if (hsl.x > 1.0)\n\t\t\t\t\t\thsl.x -= 1.0; // Hue\n\t\t\t\t}\n\n\t\t\t\treturn hsl;\n\t\t\t}\n\n\t\t\tvec3 rgb2hsv(vec3 rgb) {\n\t\t\t\tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n\t\t\t\tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n\t\t\t\tfloat delta = Cmax - Cmin;\n\n\t\t\t\tvec3 hsv = vec3(0., 0., Cmax);\n\n\t\t\t\tif (Cmax > Cmin) {\n\t\t\t\t\thsv.y = delta / Cmax;\n\n\t\t\t\t\tif (rgb.r == Cmax)\n\t\t\t\t\t\thsv.x = (rgb.g - rgb.b) / delta;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (rgb.g == Cmax)\n\t\t\t\t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n\t\t\t\t\t}\n\t\t\t\t\thsv.x = fract(hsv.x / 6.);\n\t\t\t\t}\n\t\t\t\treturn hsv;\n\t\t\t}\n\n\t\t\tfloat chromaVal(vec3 color, vec3 keyColor, float tolerance, float slope) {\n\t\t\t\tfloat d = abs(length(abs(keyColor - color)));\n\t\t\t\tfloat edge0 = tolerance * (1.0 - slope);\n\t\t\t\tfloat alpha = smoothstep(edge0, tolerance, d);\n\t\t\t\treturn 1. - alpha;\n\t\t\t}\n\n\n\n\t\t\tvec3 changeSaturation(vec3 color, float saturation) {\n\t\t\t\tfloat luma = dot(vec3(0.2125, 0.7154, 0.0721) * color, vec3(1.));\n\t\t\t\treturn mix(vec3(luma), color, saturation);\n\t\t\t}\n\n\t\t\tvec3 Desaturate(vec3 color, float Desaturation) {\n\t\t\t\tvec3 grayXfer = vec3(0.3, 0.59, 0.11);\n\t\t\t\tvec3 gray = vec3(dot(grayXfer, color));\n\t\t\t\treturn vec3(mix(color, gray, Desaturation));\n\t\t\t}\n\n\n\t\t\t // define our varying texture coordinates\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D tDiffuse;\n\n\t\t\t //color\n\t\t\tuniform float uSaturation;\n\t\t\tuniform float uContrast;\n\t\t\tuniform float uDesaturate;\n\t\t\tuniform float uBrightness;\n\t\t\tuniform float uHue;\n\n\t\t\tvoid main(void) {\n\n\t\t\t\tvec3 color = texture2D(tDiffuse, vUv).rgb;\n\t\t\t\tcolor = changeSaturation(color, uSaturation);\n\t\t\t\tcolor = Desaturate(color, uDesaturate);\n\n\t\t\t\tcolor = (color - 0.5) * (uContrast + 1.0) + 0.5;\n\t\t\t\tcolor = color + uBrightness;\n\n\t\t\t\tcolor = toHue(color, uHue);\n\n\t\t\t\tgl_FragColor = vec4(color, 1.);\n\n\t\t\t}",
            vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = vec2(uv.x, uv.y);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}"
        },
    'chroma' : {
        uniforms: THREE.UniformsUtils.merge( [

            THREE.UniformsLib[ "fog" ],
            THREE.UniformsLib[ "lights" ],
            THREE.UniformsLib[ "shadowmap" ],

            {

            "enableChroma"   : { type: "i", value: 0 },
            "enableDisplacement"   : { type: "i", value: 0 },
            "enableReflection": { type: "i", value: 0 },
            "enableRipples": { type: "i", value: 0 },
            "enableColor": { type: "i", value: 0 },

            "tOne"     : { type: "t", value: null },
            "tTwo"     : { type: "t", value: null },
            "tDisplacement"     : { type: "t", value: null },

            "uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

            "uDisplacementBias": { type: "f", value: 0.0 },
            "uDisplacementScale": { type: "f", value: 1.0 },

            "uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
            "uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
            "uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },
            "uShininess": { type: "f", value: 30 },
            "uOpacity": { type: "f", value: 1 },

            //color
            "uSaturation": { type: "f", value: 1 },
            "uContrast": { type: "f", value: 0 },
            "uDesaturate": { type: "f", value: 0 },
            "uBrightness": { type: "f", value: 0 },
            "uHue": { type: "f", value: 0 },

            "uTime": { type: "f", value: 1 },
            "uWidth": { type: "f", value: 1 },
            "uHeight": { type: "f", value: 1 },
            "uRes": { type: "f", value: 1 },

            "useRefract": { type: "i", value: 0 },
            "uRefractionRatio": { type: "f", value: 0.98 },
            "uReflectivity": { type: "f", value: 0.5 },

            "uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
            "uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

            "wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

            }

            ] ),
            
            fragmentShader:"#define GLSLIFY 1\n            vec3 toHue(vec3 rgb, float adjustment) {\n                const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\n                    0.595716, -0.274453, -0.321263,\n                    0.211456, -0.522591, 0.311135);\n                const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\n                    1.0, -0.2721, -0.6474,\n                    1.0, -1.107, 1.7046);\n\n                vec3 yiq = toYIQ * rgb;\n                float hue = atan(yiq.z, yiq.y) + adjustment;\n                float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n\n                vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n                return toRGB * color;\n            }\n\n            vec3 RGBToHSL(vec3 color) {\n                vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n                float fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n                float fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n                float delta = fmax - fmin; //Delta RGB value\n\n                hsl.z = (fmax + fmin) / 2.0; // Luminance\n\n                if (delta == 0.0) //This is a gray, no chroma...\n                {\n                    hsl.x = 0.0; // Hue\n                    hsl.y = 0.0; // Saturation\n                } else //Chromatic data...\n                {\n                    if (hsl.z < 0.5)\n                        hsl.y = delta / (fmax + fmin); // Saturation\n                    else\n                        hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n                    float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n                    float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n                    float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n                    if (color.r == fmax)\n                        hsl.x = deltaB - deltaG; // Hue\n                    else if (color.g == fmax)\n                        hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n                    else if (color.b == fmax)\n                        hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n                    if (hsl.x < 0.0)\n                        hsl.x += 1.0; // Hue\n                    else if (hsl.x > 1.0)\n                        hsl.x -= 1.0; // Hue\n                }\n\n                return hsl;\n            }\n\n            vec3 rgb2hsv(vec3 rgb) {\n                float Cmax = max(rgb.r, max(rgb.g, rgb.b));\n                float Cmin = min(rgb.r, min(rgb.g, rgb.b));\n                float delta = Cmax - Cmin;\n\n                vec3 hsv = vec3(0., 0., Cmax);\n\n                if (Cmax > Cmin) {\n                    hsv.y = delta / Cmax;\n\n                    if (rgb.r == Cmax)\n                        hsv.x = (rgb.g - rgb.b) / delta;\n                    else {\n                        if (rgb.g == Cmax)\n                            hsv.x = 2. + (rgb.b - rgb.r) / delta;\n                        else\n                            hsv.x = 4. + (rgb.r - rgb.g) / delta;\n                    }\n                    hsv.x = fract(hsv.x / 6.);\n                }\n                return hsv;\n            }\n\n            float chromaVal(vec3 color, vec3 keyColor, float tolerance, float slope) {\n                float d = abs(length(abs(keyColor - color)));\n                float edge0 = tolerance * (1.0 - slope);\n                float alpha = smoothstep(edge0, tolerance, d);\n                return 1. - alpha;\n            }\n\n            float average(vec4 col) {\n                return (col.r + col.g + col.b) / 3.0;\n            }\n\n\n\n            vec3 changeSaturation(vec3 color, float saturation) {\n                float luma = dot(vec3(0.2125, 0.7154, 0.0721) * color, vec3(1.));\n                return mix(vec3(luma), color, saturation);\n            }\n\n            vec3 Desaturate(vec3 color, float Desaturation) {\n                vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n                vec3 gray = vec3(dot(grayXfer, color));\n                return vec3(mix(color, gray, Desaturation));\n            }\n\n            uniform vec3 uAmbientColor;\n            uniform vec3 uDiffuseColor;\n            uniform vec3 uSpecularColor;\n            uniform float uShininess;\n            uniform float uOpacity;\n\n            uniform bool enableChroma;\n            uniform bool enableReflection;\n            uniform bool enableDisplacement;\n            uniform bool enableColor;\n            uniform bool enableRipples;\n\n            uniform sampler2D tOne;\n            uniform sampler2D tTwo;\n            uniform sampler2D tDiffuse;\n            uniform sampler2D tNormal;\n            uniform sampler2D tSpecular;\n            uniform sampler2D tAO;\n\n            uniform samplerCube tCube;\n\n            uniform vec2 uNormalScale;\n\n            uniform bool useRefract;\n            uniform float uRefractionRatio;\n            uniform float uReflectivity;\n\n            uniform float uTime;\n            uniform float uWidth;\n            uniform float uHeight;\n            uniform float uRes;\n\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n             //color\n            uniform float uSaturation;\n            uniform float uContrast;\n            uniform float uDesaturate;\n            uniform float uBrightness;\n            uniform float uHue;\n\n            uniform vec3 ambientLightColor;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n\n            void main() {\n\n                gl_FragColor = vec4(vec3(1.0), uOpacity);\n\n                vec2 uv2 = vUv;\n\n                if (enableRipples) {\n                    vec2 center = vec2(0.5, 0.5);\n                    float x = (center.x - uv2.x);\n                    float y = (center.y - uv2.y);\n                    float r = -(x * x + y * y);\n                    float z = 1.0 + 0.01 * sin((r + uTime * 0.02) / 0.13);\n                    uv2.x *= z;\n                    uv2.y *= z;\n                }\n\n                vec4 texelColor = texture2D(tOne, uv2);\n                vec4 bgColor = texture2D(tTwo, uv2);\n                texelColor.xyz *= texelColor.xyz;\n\n                if (enableReflection) {\n                    uv2.x += step(uv2.x, 0.5) * (0.5 - uv2.x) * 2.0;\n                    uv2.y += step(0.5, uv2.y) * (0.5 - uv2.y) * 2.0;\n                    //uv2.x -= step(0.5, uv2.x) * (uv2.x-0.5) * 2.0;\n                    //uv2.y -= step(0.5, uv2.y) * (uv2.y-0.5) * 2.0;\n                    texelColor = texture2D(tOne, uv2);\n                    bgColor = texture2D(tTwo, uv2);\n                    //gl_FragColor = vec4(mix(texelColor.rgb, bgColor.rgb, average(bgColor)), 1.0);\n                }\n\n                gl_FragColor = gl_FragColor * texelColor;\n\n                vec3 color = gl_FragColor.rgb;\n\n                if (enableColor) {\n                    color = changeSaturation(color, uSaturation);\n                    color = Desaturate(color, uDesaturate);\n\n                    color = (color - 0.5) * (uContrast + 1.0) + 0.5;\n                    color = color + uBrightness;\n\n                    color = toHue(color, uHue);\n\n                    gl_FragColor = vec4(color, 1.);\n                }\n\n                if (enableChroma) {\n                    float ff = chromaVal(color, vec3(1.0, 0.0, 0.0), 0.8, 0.2);\n                    color = mix(color, bgColor.rgb, ff);\n                    gl_FragColor = vec4(color, 1.);\n                }\n\n\n            }",
            vertexShader:"#define GLSLIFY 1\n            attribute vec4 tangent;\n\n            uniform vec2 uOffset;\n            uniform vec2 uRepeat;\n\n            uniform bool enableDisplacement;\n\n            #ifdef VERTEX_TEXTURES\n\n                uniform sampler2D tDisplacement;\n                uniform float uDisplacementScale;\n                uniform float uDisplacementBias;\n\n            #endif\n\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n            #ifdef USE_SKINNING\n\n                #ifdef BONE_TEXTURE\n\n                    uniform sampler2D boneTexture;\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        float j = i * 4.0;\n                        float x = mod( j, N_BONE_PIXEL_X );\n                        float y = floor( j / N_BONE_PIXEL_X );\n\n                        const float dx = 1.0 / N_BONE_PIXEL_X;\n                        const float dy = 1.0 / N_BONE_PIXEL_Y;\n\n                        y = dy * ( y + 0.5 );\n\n                        vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n                        vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n                        vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n                        vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n                        mat4 bone = mat4( v1, v2, v3, v4 );\n\n                        return bone;\n\n                    }\n\n                #else\n\n                    uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        mat4 bone = boneGlobalMatrices[ int(i) ];\n                        return bone;\n\n                    }\n\n                #endif\n\n            #endif\n            \n            #ifdef USE_SHADOWMAP\n\n                varying vec4 vShadowCoord[ MAX_SHADOWS ];\n                uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n            #endif\n\n            void main() {\n\n\n                vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n                vUv = uv * uRepeat + uOffset;\n\n                // displacement mapping\n\n                vec3 displacedPosition;\n\n                #ifdef VERTEX_TEXTURES\n\n                    if ( enableDisplacement ) {\n\n                        vec3 dv = texture2D( tDisplacement, uv ).xyz;\n                        float df = uDisplacementScale * dv.x + uDisplacementBias;\n                        displacedPosition = position + normalize( normal ) * df;\n\n                    } else {\n\n                        #ifdef USE_SKINNING\n\n                            vec4 skinVertex = vec4( position, 1.0 );\n\n                            vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                            skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                            displacedPosition  = skinned.xyz;\n\n                        #else\n\n                            displacedPosition = position;\n\n                        #endif\n\n                    }\n\n                #else\n\n                    #ifdef USE_SKINNING\n\n                        vec4 skinVertex = vec4( position, 1.0 );\n\n                        vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                        skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                        displacedPosition  = skinned.xyz;\n\n                    #else\n\n                        displacedPosition = position;\n\n                    #endif\n\n                #endif\n\n                //\n\n                vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n                vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\n                gl_Position = projectionMatrix * mvPosition;\n\n                //\n\n                vWorldPosition = worldPosition.xyz;\n                vViewPosition = -mvPosition.xyz;\n\n                // shadows\n\n                #ifdef USE_SHADOWMAP\n\n                    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n                        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n                    }\n\n                #endif\n\n            }"
        },
        'fractal1' : {
            uniforms: THREE.UniformsUtils.merge( [
                 THREE.UniformsLib[ "fog" ],
                    THREE.UniformsLib[ "lights" ],
                    THREE.UniformsLib[ "shadowmap" ],

                {
                "tOne"     : { type: "t", value: null },
                "tTwo"     : { type: "t", value: null },
                "tDisplacement"     : { type: "t", value: null },

                "uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
                "uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
                "uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },

                "uTime": { type: "f", value: 1 },
                "uWidth": { type: "f", value: 1 },
                "uHeight": { type: "f", value: 1 },
                "uRes": { type: "f", value: 1 },
                "uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
                "uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

                }

                ] ),
                
                fragmentShader:"#define GLSLIFY 1\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n            uniform vec3 uAmbientColor;\n            uniform vec3 uDiffuseColor;\n            uniform vec3 uSpecularColor;\n\n            uniform float uTime;\n            uniform float uWidth;\n            uniform float uHeight;\n            uniform float uRes;\n\n            uniform sampler2D tOne;\n            uniform sampler2D tTwo;\n            uniform sampler2D tDisplacement;\n\n             //Basic fractal by @paulofalcao\n\n            const int maxIterations = 4; //a nice value for fullscreen is 8\n\n            float circleSize = 1.0 / (0.4 * pow(2.0, float(maxIterations)));\n\n             //generic rotation formula\n            vec2 rot(vec2 uv, float a) {\n                return vec2(uv.x * cos(a) - uv.y * sin(a), uv.y * cos(a) + uv.x * sin(a));\n            }\n\n            void main() {\n                vec2 iResolution = vec2(uWidth, uHeight);\n                //normalize stuff\n                vec2 uv = iResolution.xy;\n                uv.x = uv.x / uWidth;\n                uv.y = uv.y / uHeight;\n                uv = -.5 * (uv - 2.0 * vUv.xy) / uv.x;\n                //global rotation and zoom\n                uv = rot(uv, uTime);\n                uv *= sin(uTime) * 0.05 + 4.;\n\n                //mirror, rotate and scale 6 times...\n                float s = 1.;\n                for (int i = 0; i < maxIterations; i++) {\n                    uv = abs(uv) - s;\n                    uv = rot(uv, uTime);\n                    s = s / 2.1;\n                }\n\n                //draw a circle\n                //float c = length(uv) > circleSize ? 0.0 : 1.0;*/\n\n                vec4 texelColor = texture2D(tOne,  uv );\n                gl_FragColor = vec4(texelColor.rgb, 1.0);\n                //gl_FragColor = vec4(c,c,c, 1.0);\n            }",
                vertexShader:"#define GLSLIFY 1\n            attribute vec4 tangent;\n\n            uniform vec2 uOffset;\n            uniform vec2 uRepeat;\n\n            uniform bool enableDisplacement;\n\n            #ifdef VERTEX_TEXTURES\n\n                uniform sampler2D tDisplacement;\n                uniform float uDisplacementScale;\n                uniform float uDisplacementBias;\n\n            #endif\n\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n            #ifdef USE_SKINNING\n\n                #ifdef BONE_TEXTURE\n\n                    uniform sampler2D boneTexture;\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        float j = i * 4.0;\n                        float x = mod( j, N_BONE_PIXEL_X );\n                        float y = floor( j / N_BONE_PIXEL_X );\n\n                        const float dx = 1.0 / N_BONE_PIXEL_X;\n                        const float dy = 1.0 / N_BONE_PIXEL_Y;\n\n                        y = dy * ( y + 0.5 );\n\n                        vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n                        vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n                        vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n                        vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n                        mat4 bone = mat4( v1, v2, v3, v4 );\n\n                        return bone;\n\n                    }\n\n                #else\n\n                    uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        mat4 bone = boneGlobalMatrices[ int(i) ];\n                        return bone;\n\n                    }\n\n                #endif\n\n            #endif\n            \n            #ifdef USE_SHADOWMAP\n\n                varying vec4 vShadowCoord[ MAX_SHADOWS ];\n                uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n            #endif\n\n            void main() {\n\n\n                vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n                vUv = uv * uRepeat + uOffset;\n\n                // displacement mapping\n\n                vec3 displacedPosition;\n\n                #ifdef VERTEX_TEXTURES\n\n                    if ( enableDisplacement ) {\n\n                        vec3 dv = texture2D( tDisplacement, uv ).xyz;\n                        float df = uDisplacementScale * dv.x + uDisplacementBias;\n                        displacedPosition = position + normalize( normal ) * df;\n\n                    } else {\n\n                        #ifdef USE_SKINNING\n\n                            vec4 skinVertex = vec4( position, 1.0 );\n\n                            vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                            skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                            displacedPosition  = skinned.xyz;\n\n                        #else\n\n                            displacedPosition = position;\n\n                        #endif\n\n                    }\n\n                #else\n\n                    #ifdef USE_SKINNING\n\n                        vec4 skinVertex = vec4( position, 1.0 );\n\n                        vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                        skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                        displacedPosition  = skinned.xyz;\n\n                    #else\n\n                        displacedPosition = position;\n\n                    #endif\n\n                #endif\n\n                //\n\n                vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n                vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\n                gl_Position = projectionMatrix * mvPosition;\n\n                //\n\n                vWorldPosition = worldPosition.xyz;\n                vViewPosition = -mvPosition.xyz;\n\n                // shadows\n\n                #ifdef USE_SHADOWMAP\n\n                    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n                        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n                    }\n\n                #endif\n\n            }"
            },
            'cave' : {
                uniforms: THREE.UniformsUtils.merge( [
                     THREE.UniformsLib[ "fog" ],
                        THREE.UniformsLib[ "lights" ],
                        THREE.UniformsLib[ "shadowmap" ],

                    {
                    "tOne"     : { type: "t", value: null },
                    "tTwo"     : { type: "t", value: null },
                    "tDisplacement"     : { type: "t", value: null },

                    "uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
                    "uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
                    "uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },

                    "uTime": { type: "f", value: 1 },
                    "uWidth": { type: "f", value: 1 },
                    "uHeight": { type: "f", value: 1 },
                    "uRes": { type: "f", value: 1 },
                    "uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
                    "uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

                    }

                    ] ),
                    
                    fragmentShader:"#define GLSLIFY 1\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n            uniform vec3 uAmbientColor;\n            uniform vec3 uDiffuseColor;\n            uniform vec3 uSpecularColor;\n\n            uniform float uTime;\n            uniform float uWidth;\n            uniform float uHeight;\n            uniform float uRes;\n\n            uniform sampler2D tOne;\n            uniform sampler2D tTwo;\n            uniform sampler2D tDisplacement;\n\n\n            void main() {\n                vec3 iResolution = vec3(1., 1.,1. );\n                //normalize stuff\n               /* vec2 uv = iResolution.xy;\n                uv.x = uv.x / uWidth;\n                uv.y = uv.y / uHeight;\n*/\n\n                vec4 p = vec4(vUv, 1, 1) / iResolution.xyzz - .5, d = p * .1, t;\n                p.w += uTime * 1.;\n                d.y += sin(p.w) * .001;\n                d.y = -abs(d.y);\n\n                for (float i = 10.; i > 0.; i -= .005) {\n                    p += d;\n                    t = texture2D(tOne, .2 + p.xw / 2e2, -99.);\n                    t *= texture2D(tTwo, .2 + p.xw / 3e2, -99.);\n                    gl_FragColor = t * i;\n\n                    if (t.y * 13. > p.y + 6.) break;\n                }\n                //gl_FragColor = vec4(texelColor.rgb, 1.0);\n                //gl_FragColor = vec4(c,c,c, 1.0);\n            }\n",
                    vertexShader:"#define GLSLIFY 1\n            attribute vec4 tangent;\n\n            uniform vec2 uOffset;\n            uniform vec2 uRepeat;\n\n            uniform bool enableDisplacement;\n\n            #ifdef VERTEX_TEXTURES\n\n                uniform sampler2D tDisplacement;\n                uniform float uDisplacementScale;\n                uniform float uDisplacementBias;\n\n            #endif\n\n            varying vec3 vTangent;\n            varying vec3 vBinormal;\n            varying vec3 vNormal;\n            varying vec2 vUv;\n\n            varying vec3 vWorldPosition;\n            varying vec3 vViewPosition;\n\n            #ifdef USE_SKINNING\n\n                #ifdef BONE_TEXTURE\n\n                    uniform sampler2D boneTexture;\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        float j = i * 4.0;\n                        float x = mod( j, N_BONE_PIXEL_X );\n                        float y = floor( j / N_BONE_PIXEL_X );\n\n                        const float dx = 1.0 / N_BONE_PIXEL_X;\n                        const float dy = 1.0 / N_BONE_PIXEL_Y;\n\n                        y = dy * ( y + 0.5 );\n\n                        vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n                        vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n                        vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n                        vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n                        mat4 bone = mat4( v1, v2, v3, v4 );\n\n                        return bone;\n\n                    }\n\n                #else\n\n                    uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n                    mat4 getBoneMatrix( const in float i ) {\n\n                        mat4 bone = boneGlobalMatrices[ int(i) ];\n                        return bone;\n\n                    }\n\n                #endif\n\n            #endif\n            \n            #ifdef USE_SHADOWMAP\n\n                varying vec4 vShadowCoord[ MAX_SHADOWS ];\n                uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n            #endif\n\n            void main() {\n\n\n                vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n                vUv = uv * uRepeat + uOffset;\n\n                // displacement mapping\n\n                vec3 displacedPosition;\n\n                #ifdef VERTEX_TEXTURES\n\n                    if ( enableDisplacement ) {\n\n                        vec3 dv = texture2D( tDisplacement, uv ).xyz;\n                        float df = uDisplacementScale * dv.x + uDisplacementBias;\n                        displacedPosition = position + normalize( normal ) * df;\n\n                    } else {\n\n                        #ifdef USE_SKINNING\n\n                            vec4 skinVertex = vec4( position, 1.0 );\n\n                            vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                            skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                            displacedPosition  = skinned.xyz;\n\n                        #else\n\n                            displacedPosition = position;\n\n                        #endif\n\n                    }\n\n                #else\n\n                    #ifdef USE_SKINNING\n\n                        vec4 skinVertex = vec4( position, 1.0 );\n\n                        vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n                        skinned      += boneMatY * skinVertex * skinWeight.y;\n\n                        displacedPosition  = skinned.xyz;\n\n                    #else\n\n                        displacedPosition = position;\n\n                    #endif\n\n                #endif\n\n                //\n\n                vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n                vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\n                gl_Position = projectionMatrix * mvPosition;\n\n                //\n\n                vWorldPosition = worldPosition.xyz;\n                vViewPosition = -mvPosition.xyz;\n\n                // shadows\n\n                #ifdef USE_SHADOWMAP\n\n                    for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n                        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n                    }\n\n                #endif\n\n            }"
                },
                'twist' : {
                uniforms: THREE.UniformsUtils.merge( [

                        {
                        "tDiffuse": { type: "t", value: null },
                        "radius":    { type: "f", value: Math.PI },
                        "angle":    { type: "f", value: 1.0 }
                        }

                    ] ),
                    
                    fragmentShader:"#define GLSLIFY 1\nuniform sampler2D tDiffuse;\nuniform float radius;\nuniform float angle;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec2 coord = vUv - 0.5;\n  float dist = length(coord);\n\n       float ratio = (radius - dist) / radius;\n       float angleMod = ratio * ratio * angle;\n       float s = sin(angleMod);\n       float c = cos(angleMod);\n       coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n\n  gl_FragColor = texture2D(tDiffuse, coord+0.5);\n}",
                    vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = vec2(uv.x, uv.y);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}"
                },
                 'rgbShift' : {
                uniforms: THREE.UniformsUtils.merge( [

                        {
                        "tDiffuse": { type: "t", value: null },
                        "tSize"    : { type: "v2", value: new THREE.Vector2( 128, 128 ) },
                        "uRed":    { type: "i", value: 1 },
                        "uGreen":    { type: "i", value: 1 },
                        "uBlue":    { type: "i", value: 1 }
                        }

                    ] ),
                    
                    fragmentShader:"#define GLSLIFY 1\nvarying vec2 vTextureCoord;\n\nuniform sampler2D tDiffuse;\nuniform vec2 tSize;\nuniform int uRed;\nuniform int uGreen;\nuniform int uBlue;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n\tgl_FragColor.r = texture2D(tDiffuse, vUv + vec2(uRed, uRed) / tSize.xy).r;\n\tgl_FragColor.g = texture2D(tDiffuse, vUv + vec2(uGreen, uGreen) / tSize.xy).g;\n\tgl_FragColor.b = texture2D(tDiffuse, vUv + vec2(uBlue, uBlue) / tSize.xy).b;\n\tgl_FragColor.a = 1.0;\n}",
                    vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = vec2(uv.x, uv.y);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}"
                },
                bleach:require('./shaders/BleachBypassShader'),
                bit:require('./shaders/BitShader'),
                pixelate:require('./shaders/PixelateShader'),
                blend:require('./shaders/BlendShader'),
                brightness:require('./shaders/BrightnessContrastShader'),
                colorify:require('./shaders/ColorifyShader'),
                hue:require('./shaders/HueSaturationShader'),
                displacement:require('./shaders/NormalDisplacementShader'),
                technicolor:require('./shaders/TechnicolorShader'),
                tone:require('./shaders/ToneMapShader'),
                bokah:require('./shaders/BokehShader2'), //bad
                convolution:require('./shaders/ConvolutionShader'),
                edge:require('./shaders/EdgeShader2'),
                film:require('./shaders/FilmShader'),
                focus:require('./shaders/FocusShader'),
                fxxa:require('./shaders/FXAAShader'),
                hBlur:require('./shaders/HorizontalBlurShader'),
                vBlur:require('./shaders/VerticalBlurShader'),
                kaleido:require('./shaders/KaleidoShader'),
                mirror:require('./shaders/MirrorShader'),
                rgb:require('./shaders/RGBShiftShader'),
                sepia:require('./shaders/SepiaShader'),
                glitch:require('./shaders/DigitalGlitch'),
                dot:require('./shaders/DotScreenShader'),
                copy:THREE.CopyShader
    };
},{"./post/EffectComposer":18,"./post/MaskPass":19,"./post/RenderPass":20,"./post/ShaderPass":21,"./shaders/BitShader":27,"./shaders/BleachBypassShader":28,"./shaders/BlendShader":29,"./shaders/BokehShader2":30,"./shaders/BrightnessContrastShader":31,"./shaders/ColorifyShader":32,"./shaders/ConvolutionShader":33,"./shaders/CopyShader":34,"./shaders/DigitalGlitch":35,"./shaders/DotScreenShader":36,"./shaders/EdgeShader2":37,"./shaders/FXAAShader":38,"./shaders/FilmShader":39,"./shaders/FocusShader":40,"./shaders/HorizontalBlurShader":41,"./shaders/HueSaturationShader":42,"./shaders/KaleidoShader":43,"./shaders/MirrorShader":44,"./shaders/NormalDisplacementShader":45,"./shaders/PixelateShader":46,"./shaders/RGBShiftShader":47,"./shaders/SepiaShader":48,"./shaders/TechnicolorShader":49,"./shaders/ToneMapShader":50,"./shaders/VerticalBlurShader":51}],27:[function(require,module,exports){
module.exports = {

    uniforms: {

        "tDiffuse": {type: "t", value: null},
        "bitSize": {type: "f", value: 4.0}

    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

        "vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform float bitSize;",

        "uniform sampler2D tDiffuse;",

        "varying vec2 vUv;",

        "void main() {",

        "vec4 texel = texture2D( tDiffuse, vUv );",
        "float n = pow(bitSize,2.0);",
        "float newR = floor(texel.r*n)/n;",
        "float newG = floor(texel.g*n)/n;",
        "float newB = floor(texel.b*n)/n;",

        "gl_FragColor = vec4( vec3(newR,newG,newB), 1.0);",

        "}"

    ].join("\n")

};
},{}],28:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]
 * - based on Nvidia example
 * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 base = texture2D( tDiffuse, vUv );",

			"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
			"float lum = dot( lumCoeff, base.rgb );",
			"vec3 blend = vec3( lum );",

			"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",

			"vec3 result1 = 2.0 * base.rgb * blend;",
			"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",

			"vec3 newColor = mix( result1, result2, L );",

			"float A2 = opacity * base.a;",
			"vec3 mixRGB = A2 * newColor.rgb;",
			"mixRGB += ( ( 1.0 - A2 ) * base.rgb );",

			"gl_FragColor = vec4( mixRGB, base.a );",

		"}"

	].join("\n")

};

},{}],29:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Blend two textures
 */

module.exports = {

	uniforms: {

		"tDiffuse1": { type: "t", value: null },
		"tDiffuse2": { type: "t", value: null },
		"mixRatio":  { type: "f", value: 0.5 },
		"opacity":   { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",
		"uniform float mixRatio;",

		"uniform sampler2D tDiffuse1;",
		"uniform sampler2D tDiffuse2;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel1 = texture2D( tDiffuse1, vUv );",
			"vec4 texel2 = texture2D( tDiffuse2, vUv );",
			"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );",

		"}"

	].join("\n")

};

},{}],30:[function(require,module,exports){
/**
 * @author zz85 / https://github.com/zz85 | twitter.com/blurspline
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 *
 * Requires #define RINGS and SAMPLES integers
 */



module.exports = {

	uniforms: {

		"textureWidth":  { type: "f", value: 1.0 },
		"textureHeight":  { type: "f", value: 1.0 },

		"focalDepth":   { type: "f", value: 1.0 },
		"focalLength":   { type: "f", value: 24.0 },
		"fstop": { type: "f", value: 0.9 },

		"tColor":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },

		"maxblur":  { type: "f", value: 1.0 },

		"showFocus":   { type: "i", value: 0 },
		"manualdof":   { type: "i", value: 0 },
		"vignetting":   { type: "i", value: 0 },
		"depthblur":   { type: "i", value: 0 },

		"threshold":  { type: "f", value: 0.5 },
		"gain":  { type: "f", value: 2.0 },
		"bias":  { type: "f", value: 0.5 },
		"fringe":  { type: "f", value: 0.7 },

		"znear":  { type: "f", value: 0.1 },
		"zfar":  { type: "f", value: 100 },

		"noise":  { type: "i", value: 1 },
		"dithering":  { type: "f", value: 0.0001 },
		"pentagon": { type: "i", value: 0 },

		"shaderFocus":  { type: "i", value: 1 },
		"focusCoords":  { type: "v2", value: new THREE.Vector2() },


	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"varying vec2 vUv;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",
		"uniform float textureWidth;",
		"uniform float textureHeight;",

		"const float PI = 3.14159265;",

		"float width = textureWidth; //texture width",
		"float height = textureHeight; //texture height",

		"vec2 texel = vec2(1.0/width,1.0/height);",

		"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below",
		"uniform float focalLength; //focal length in mm",
		"uniform float fstop; //f-stop value",
		"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)",

		"/*",
		"make sure that these two values are the same for your camera, otherwise distances will be wrong.",
		"*/",

		"uniform float znear; // camera clipping start",
		"uniform float zfar; // camera clipping end",

		"//------------------------------------------",
		"//user variables",

		"const int samples = SAMPLES; //samples on the first ring",
		"const int rings = RINGS; //ring count",

		"const int maxringsamples = rings * samples;",

		"uniform bool manualdof; // manual dof calculation",
		"float ndofstart = 1.0; // near dof blur start",
		"float ndofdist = 2.0; // near dof blur falloff distance",
		"float fdofstart = 1.0; // far dof blur start",
		"float fdofdist = 3.0; // far dof blur falloff distance",

		"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)",

		"uniform bool vignetting; // use optical lens vignetting",

		"float vignout = 1.3; // vignetting outer border",
		"float vignin = 0.0; // vignetting inner border",
		"float vignfade = 22.0; // f-stops till vignete fades",

		"uniform bool shaderFocus;",

		"bool autofocus = shaderFocus;",
		"//use autofocus in shader - use with focusCoords",
		"// disable if you use external focalDepth value",

		"uniform vec2 focusCoords;",
		"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)",
		"// if center of screen use vec2(0.5, 0.5);",

		"uniform float maxblur;",
		"//clamp value of max blur (0.0 = no blur, 1.0 default)",

		"uniform float threshold; // highlight threshold;",
		"uniform float gain; // highlight gain;",

		"uniform float bias; // bokeh edge bias",
		"uniform float fringe; // bokeh chromatic aberration / fringing",

		"uniform bool noise; //use noise instead of pattern for sample dithering",

		"uniform float dithering;",
		"float namount = dithering; //dither amount",

		"uniform bool depthblur; // blur the depth buffer",
		"float dbsize = 1.25; // depth blur size",

		"/*",
		"next part is experimental",
		"not looking good with small sample and ring count",
		"looks okay starting from samples = 4, rings = 4",
		"*/",

		"uniform bool pentagon; //use pentagon as bokeh shape?",
		"float feather = 0.4; //pentagon shape feather",

		"//------------------------------------------",

		"float penta(vec2 coords) {",
			"//pentagonal shape",
			"float scale = float(rings) - 1.3;",
			"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);",
			"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);",
			"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);",
			"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);",
			"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);",
			"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);",

			"vec4  one = vec4( 1.0 );",

			"vec4 P = vec4((coords),vec2(scale, scale));",

			"vec4 dist = vec4(0.0);",
			"float inorout = -4.0;",

			"dist.x = dot( P, HS0 );",
			"dist.y = dot( P, HS1 );",
			"dist.z = dot( P, HS2 );",
			"dist.w = dot( P, HS3 );",

			"dist = smoothstep( -feather, feather, dist );",

			"inorout += dot( dist, one );",

			"dist.x = dot( P, HS4 );",
			"dist.y = HS5.w - abs( P.z );",

			"dist = smoothstep( -feather, feather, dist );",
			"inorout += dist.x;",

			"return clamp( inorout, 0.0, 1.0 );",
		"}",

		"float bdepth(vec2 coords) {",
			"// Depth buffer blur",
			"float d = 0.0;",
			"float kernel[9];",
			"vec2 offset[9];",

			"vec2 wh = vec2(texel.x, texel.y) * dbsize;",

			"offset[0] = vec2(-wh.x,-wh.y);",
			"offset[1] = vec2( 0.0, -wh.y);",
			"offset[2] = vec2( wh.x -wh.y);",

			"offset[3] = vec2(-wh.x,  0.0);",
			"offset[4] = vec2( 0.0,   0.0);",
			"offset[5] = vec2( wh.x,  0.0);",

			"offset[6] = vec2(-wh.x, wh.y);",
			"offset[7] = vec2( 0.0,  wh.y);",
			"offset[8] = vec2( wh.x, wh.y);",

			"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;",
			"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;",
			"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;",


			"for( int i=0; i<9; i++ ) {",
				"float tmp = texture2D(tDepth, coords + offset[i]).r;",
				"d += tmp * kernel[i];",
			"}",

			"return d;",
		"}",


		"vec3 color(vec2 coords,float blur) {",
			"//processing the sample",

			"vec3 col = vec3(0.0);",

			"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;",
			"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;",
			"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;",

			"vec3 lumcoeff = vec3(0.299,0.587,0.114);",
			"float lum = dot(col.rgb, lumcoeff);",
			"float thresh = max((lum-threshold)*gain, 0.0);",
			"return col+mix(vec3(0.0),col,thresh*blur);",
		"}",

		"vec2 rand(vec2 coord) {",
			"// generating noise / pattern texture for dithering",

			"float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;",
			"float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;",

			"if (noise) {",
				"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;",
				"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;",
			"}",

			"return vec2(noiseX,noiseY);",
		"}",

		"vec3 debugFocus(vec3 col, float blur, float depth) {",
			"float edge = 0.002*depth; //distance based edge smoothing",
			"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);",
			"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);",

			"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);",
			"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);",

			"return col;",
		"}",

		"float linearize(float depth) {",
			"return -zfar * znear / (depth * (zfar - znear) - zfar);",
		"}",


		"float vignette() {",
			"float dist = distance(vUv.xy, vec2(0.5,0.5));",
			"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);",
			"return clamp(dist,0.0,1.0);",
		"}",

		"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {",
			"float rings2 = float(rings);",
			"float step = PI*2.0 / float(ringsamples);",
			"float pw = cos(j*step)*i;",
			"float ph = sin(j*step)*i;",
			"float p = 1.0;",
			"if (pentagon) {",
				"p = penta(vec2(pw,ph));",
			"}",
			"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;",
			"return 1.0 * mix(1.0, i /rings2, bias) * p;",
		"}",

		"void main() {",
			"//scene depth calculation",

			"float depth = linearize(texture2D(tDepth,vUv.xy).x);",

			"// Blur depth?",
			"if (depthblur) {",
				"depth = linearize(bdepth(vUv.xy));",
			"}",

			"//focal plane calculation",

			"float fDepth = focalDepth;",

			"if (autofocus) {",

				"fDepth = linearize(texture2D(tDepth,focusCoords).x);",

			"}",

			"// dof blur factor calculation",

			"float blur = 0.0;",

			"if (manualdof) {",
				"float a = depth-fDepth; // Focal plane",
				"float b = (a-fdofstart)/fdofdist; // Far DoF",
				"float c = (-a-ndofstart)/ndofdist; // Near Dof",
				"blur = (a>0.0) ? b : c;",
			"} else {",
				"float f = focalLength; // focal length in mm",
				"float d = fDepth*1000.0; // focal plane in mm",
				"float o = depth*1000.0; // depth in mm",

				"float a = (o*f)/(o-f);",
				"float b = (d*f)/(d-f);",
				"float c = (d-f)/(d*fstop*CoC);",

				"blur = abs(a-b)*c;",
			"}",

			"blur = clamp(blur,0.0,1.0);",

			"// calculation of pattern for dithering",

			"vec2 noise = rand(vUv.xy)*namount*blur;",

			"// getting blur x and y step factor",

			"float w = (1.0/width)*blur*maxblur+noise.x;",
			"float h = (1.0/height)*blur*maxblur+noise.y;",

			"// calculation of final color",

			"vec3 col = vec3(0.0);",

			"if(blur < 0.05) {",
				"//some optimization thingy",
				"col = texture2D(tColor, vUv.xy).rgb;",
			"} else {",
				"col = texture2D(tColor, vUv.xy).rgb;",
				"float s = 1.0;",
				"int ringsamples;",

				"for (int i = 1; i <= rings; i++) {",
					"/*unboxstart*/",
					"ringsamples = i * samples;",

					"for (int j = 0 ; j < maxringsamples ; j++) {",
						"if (j >= ringsamples) break;",
						"s += gather(float(i), float(j), ringsamples, col, w, h, blur);",
					"}",
					"/*unboxend*/",
				"}",

				"col /= s; //divide by sample count",
			"}",

			"if (showFocus) {",
				"col = debugFocus(col, blur, depth);",
			"}",

			"if (vignetting) {",
				"col *= vignette();",
			"}",

			"gl_FragColor.rgb = col;",
			"gl_FragColor.a = 1.0;",
		"} "

	].join("\n")

};

},{}],31:[function(require,module,exports){
/**
 * @author tapio / http://tapio.github.com/
 *
 * Brightness and contrast adjustment
 * https://github.com/evanw/glfx.js
 * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"brightness": { type: "f", value: 0 },
		"contrast":   { type: "f", value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float brightness;",
		"uniform float contrast;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			"gl_FragColor.rgb += brightness;",

			"if (contrast > 0.0) {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
			"} else {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
			"}",

		"}"

	].join("\n")

};

},{}],32:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Colorify shader
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"color":    { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec3 color;",
		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",
			"float v = dot( texel.xyz, luma );",

			"gl_FragColor = vec4( v * color, texel.w );",

		"}"

	].join("\n")

};

},{}],33:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */

module.exports = {

	defines: {

		"KERNEL_SIZE_FLOAT": "25.0",
		"KERNEL_SIZE_INT": "25",

	},

	uniforms: {

		"tDiffuse":        { type: "t", value: null },
		"uImageIncrement": { type: "v2", value: new THREE.Vector2( 0.001953125, 0.0 ) },
		"cKernel":         { type: "fv1", value: new THREE.Vector2( 0.001953125, 0.0 ) }

	},

	vertexShader: [

		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float cKernel[ KERNEL_SIZE_INT ];",

		"uniform sampler2D tDiffuse;",
		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 imageCoord = vUv;",
			"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",

			"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",

				"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
				"imageCoord += uImageIncrement;",

			"}",

			"gl_FragColor = sum;",

		"}"


	].join("\n"),

	buildKernel: function ( sigma ) {

		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

		function gauss( x, sigma ) {

			return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );

		}

		var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;

		if ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;
		halfWidth = ( kernelSize - 1 ) * 0.5;

		values = new Array( kernelSize );
		sum = 0.0;
		for ( i = 0; i < kernelSize; ++ i ) {

			values[ i ] = gauss( i - halfWidth, sigma );
			sum += values[ i ];

		}

		// normalize the kernel

		for ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;

		return values;

	}

};

},{}],34:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};

},{}],35:[function(require,module,exports){
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

module.exports = {

	uniforms: {

		"tDiffuse":		{ type: "t", value: null },//diffuse texture
		"tDisp":		{ type: "t", value: null },//displacement texture for digital glitch squares
		"byp":			{ type: "i", value: 1 },//apply the glitch ?
		"amount":		{ type: "f", value: 0.08 },
		"angle":		{ type: "f", value: 0.02 },
		"seed":			{ type: "f", value: 0.02 },
		"seed_x":		{ type: "f", value: 0.02 },//-1,1
		"seed_y":		{ type: "f", value: 0.02 },//-1,1
		"distortion_x":	{ type: "f", value: 0.5 },
		"distortion_y":	{ type: "f", value: 0.6 },
		"col_s":		{ type: "f", value: 0.05 }
	},

	vertexShader: [

		"varying vec2 vUv;",
		"void main() {",
			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
		"}"
	].join("\n"),

	fragmentShader: [
		"uniform int byp;",//should we apply the glitch ?
		
		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDisp;",
		
		"uniform float amount;",
		"uniform float angle;",
		"uniform float seed;",
		"uniform float seed_x;",
		"uniform float seed_y;",
		"uniform float distortion_x;",
		"uniform float distortion_y;",
		"uniform float col_s;",
			
		"varying vec2 vUv;",
		
		
		"float rand(vec2 co){",
			"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
		"}",
				
		"void main() {",
			"if(byp<1) {",
				"vec2 p = vUv;",
				"float xs = floor(gl_FragCoord.x / 0.5);",
				"float ys = floor(gl_FragCoord.y / 0.5);",
				//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
				"vec4 normal = texture2D (tDisp, p*seed*seed);",
				"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
					"if(seed_x>0.){",
						"p.y = 1. - (p.y + distortion_y);",
					"}",
					"else {",
						"p.y = distortion_y;",
					"}",
				"}",
				"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
					"if(seed_y>0.){",
						"p.x=distortion_x;",
					"}",
					"else {",
						"p.x = 1. - (p.x + distortion_x);",
					"}",
				"}",
				"p.x+=normal.x*seed_x*(seed/5.);",
				"p.y+=normal.y*seed_y*(seed/5.);",
				//base from RGB shift shader
				"vec2 offset = amount * vec2( cos(angle), sin(angle));",
				"vec4 cr = texture2D(tDiffuse, p + offset);",
				"vec4 cga = texture2D(tDiffuse, p);",
				"vec4 cb = texture2D(tDiffuse, p - offset);",
				"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
				//add noise
				"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
				"gl_FragColor = gl_FragColor+ snow;",
			"}",
			"else {",
				"gl_FragColor=texture2D (tDiffuse, vUv);",
			"}",
		"}"

	].join("\n")

};

},{}],36:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

module.exports= {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"tSize":    { type: "v2", value: new THREE.Vector2( 256, 256 ) },
		"center":   { type: "v2", value: new THREE.Vector2( 0.5, 0.5 ) },
		"angle":    { type: "f", value: 1.57 },
		"scale":    { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec2 center;",
		"uniform float angle;",
		"uniform float scale;",
		"uniform vec2 tSize;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"float pattern() {",

			"float s = sin( angle ), c = cos( angle );",

			"vec2 tex = vUv * tSize - center;",
			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

		"}",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",

			"float average = ( color.r + color.g + color.b ) / 3.0;",

			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

		"}"

	].join("\n")

};

},{}],37:[function(require,module,exports){
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Sobel filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"aspect":    { type: "v2", value: new THREE.Vector2( 512, 512 ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform vec2 aspect;",


		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",

		"mat3 G[2];",

		"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );",
		"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );",


		"void main(void)",
		"{",
			"mat3 I;",
			"float cnv[2];",
			"vec3 sample;",

			"G[0] = g0;",
			"G[1] = g1;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++)",
			"for (float j=0.0; j<3.0; j++) {",
				"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
				"I[int(i)][int(j)] = length(sample);",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<2; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3; ",
			"}",

			"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));",
		"} ",

	].join("\n")

};

},{}],38:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: [

		"void main() {",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",
			"vec4 rgbA = (1.0/2.0) * (",
        	"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
    		"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
      		"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
    		"float lumaB = dot(rgbB, vec4(luma, 0.0));",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = rgbA;",

			"} else {",
				"gl_FragColor = rgbB;",

			"}",

		"}"

	].join("\n")

};

},{}],39:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */

module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"time":       { type: "f", value: 0.0 },
		"nIntensity": { type: "f", value: 0.5 },
		"sIntensity": { type: "f", value: 0.05 },
		"sCount":     { type: "f", value: 4096 },
		"grayscale":  { type: "i", value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		// control parameter
		"uniform float time;",

		"uniform bool grayscale;",

		// noise effect intensity value (0 = no effect, 1 = full effect)
		"uniform float nIntensity;",

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		"uniform float sIntensity;",

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		"uniform float sCount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// sample the source
			"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

			// make some noise
			"float x = vUv.x * vUv.y * time *  1000.0;",
			"x = mod( x, 13.0 ) * mod( x, 123.0 );",
			"float dx = mod( x, 0.01 );",

			// add noise
			"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );",

			// get us a sine and cosine
			"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

			// add scanlines
			"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

			// interpolate between source and result by intensity
			"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

			// convert to grayscale if desired
			"if( grayscale ) {",

				"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",

			"}",

			"gl_FragColor =  vec4( cResult, cTextureScreen.a );",

		"}"

	].join("\n")

};

},{}],40:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Focus shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

module.exports = {

	uniforms : {

		"tDiffuse":       { type: "t", value: null },
		"screenWidth":    { type: "f", value: 1024 },
		"screenHeight":   { type: "f", value: 1024 },
		"sampleDistance": { type: "f", value: 0.94 },
		"waveFactor":     { type: "f", value: 0.00125 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float screenWidth;",
		"uniform float screenHeight;",
		"uniform float sampleDistance;",
		"uniform float waveFactor;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color, org, tmp, add;",
			"float sample_dist, f;",
			"vec2 vin;",
			"vec2 uv = vUv;",

			"add = color = org = texture2D( tDiffuse, uv );",

			"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
			"sample_dist = dot( vin, vin ) * 2.0;",

			"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",

			"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
			"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",

			"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",

		"}"


	].join("\n")
};

},{}],41:[function(require,module,exports){
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"h":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

},{}],42:[function(require,module,exports){
/**
 * @author tapio / http://tapio.github.com/
 *
 * Hue and saturation adjustment
 * https://github.com/evanw/glfx.js
 * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
 * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"hue":        { type: "f", value: 0 },
		"saturation": { type: "f", value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float hue;",
		"uniform float saturation;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			// hue
			"float angle = hue * 3.14159265;",
			"float s = sin(angle), c = cos(angle);",
			"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
			"float len = length(gl_FragColor.rgb);",
			"gl_FragColor.rgb = vec3(",
				"dot(gl_FragColor.rgb, weights.xyz),",
				"dot(gl_FragColor.rgb, weights.zxy),",
				"dot(gl_FragColor.rgb, weights.yzx)",
			");",

			// saturation
			"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
			"if (saturation > 0.0) {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
			"} else {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
			"}",

		"}"

	].join("\n")

};

},{}],43:[function(require,module,exports){
/**
 * @author felixturner / http://airtight.cc/
 *
 * Kaleidoscope Shader
 * Radial reflection around center point
 * Ported from: http://pixelshaders.com/editor/
 * by Toby Schachman / http://tobyschachman.com/
 *
 * sides: number of reflections
 * angle: initial angle in radians
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"sides":    { type: "f", value: 6.0 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float sides;",
		"uniform float angle;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv - 0.5;",
			"float r = length(p);",
			"float a = atan(p.y, p.x) + angle;",
			"float tau = 2. * 3.1416 ;",
			"a = mod(a, tau/sides);",
			"a = abs(a - tau/sides/2.) ;",
			"p = r * vec2(cos(a), sin(a));",
			"vec4 color = texture2D(tDiffuse, p + 0.5);",
			"gl_FragColor = color;",

		"}"

	].join("\n")

};

},{}],44:[function(require,module,exports){
/**
 * @author felixturner / http://airtight.cc/
 *
 * Mirror Shader
 * Copies half the input to the other half
 *
 * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"side":     { type: "i", value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform int side;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv;",
			"if (side == 0){",
				"if (p.x > 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 1){",
				"if (p.x < 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 2){",
				"if (p.y < 0.5) p.y = 1.0 - p.y;",
			"}else if (side == 3){",
				"if (p.y > 0.5) p.y = 1.0 - p.y;",
			"} ",
			"vec4 color = texture2D(tDiffuse, p);",
			"gl_FragColor = color;",

		"}"

	].join("\n")

};

},{}],45:[function(require,module,exports){
/*
 * @author alteredq / http://alteredqualia.com/
 *
 * Normal map shader
 *  - Blinn-Phong
 *  - normal + diffuse + specular + AO + displacement + reflection + shadow maps
 *  - point and directional lights (use with "lights: true" material option)
 */

module.exports = {

	uniforms: THREE.UniformsUtils.merge( [

		THREE.UniformsLib[ "fog" ],
		THREE.UniformsLib[ "lights" ],
		THREE.UniformsLib[ "shadowmap" ],

		{

		"enableAO"          : { type: "i", value: 0 },
		"enableDiffuse"     : { type: "i", value: 0 },
		"enableSpecular"    : { type: "i", value: 0 },
		"enableReflection"  : { type: "i", value: 0 },
		"enableDisplacement": { type: "i", value: 0 },

		"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
		"tDiffuse"     : { type: "t", value: null },
		"tCube"        : { type: "t", value: null },
		"tNormal"      : { type: "t", value: null },
		"tSpecular"    : { type: "t", value: null },
		"tAO"          : { type: "t", value: null },

		"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

		"uDisplacementBias": { type: "f", value: 0.0 },
		"uDisplacementScale": { type: "f", value: 1.0 },

		"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
		"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
		"shininess": { type: "f", value: 30 },
		"opacity": { type: "f", value: 1 },

		"refractionRatio": { type: "f", value: 0.98 },
		"reflectivity": { type: "f", value: 0.5 },

		"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
		"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

		"wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

		}

	] ),

	fragmentShader: [

		"uniform vec3 diffuse;",
		"uniform vec3 specular;",
		"uniform float shininess;",
		"uniform float opacity;",

		"uniform bool enableDiffuse;",
		"uniform bool enableSpecular;",
		"uniform bool enableAO;",
		"uniform bool enableReflection;",

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tNormal;",
		"uniform sampler2D tSpecular;",
		"uniform sampler2D tAO;",

		"uniform samplerCube tCube;",

		"uniform vec2 uNormalScale;",

		"uniform float refractionRatio;",
		"uniform float reflectivity;",

		"varying vec3 vTangent;",
		"varying vec3 vBinormal;",
		"varying vec3 vNormal;",
		"varying vec2 vUv;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

		"	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
		"	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

		"	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
		"	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
		"	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

		"	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
		"	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
		"	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

		"	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
		"	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
		"	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
		"	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
		"	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
		"	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

		"	uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vWorldPosition;",
		"varying vec3 vViewPosition;",

		THREE.ShaderChunk[ "common" ],
		THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
		THREE.ShaderChunk[ "fog_pars_fragment" ],
		THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

		"void main() {",
			THREE.ShaderChunk[ "logdepthbuf_fragment" ],

		"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
		"	vec4 diffuseColor = vec4( diffuse, opacity );",

		"	vec3 specularTex = vec3( 1.0 );",

		"	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
		"	normalTex.xy *= uNormalScale;",
		"	normalTex = normalize( normalTex );",

		"	if( enableDiffuse ) {",

		"		#ifdef GAMMA_INPUT",

		"			vec4 texelColor = texture2D( tDiffuse, vUv );",
		"			texelColor.xyz *= texelColor.xyz;",

		"			diffuseColor *= texelColor;",

		"		#else",

		"			diffuseColor *= texture2D( tDiffuse, vUv );",

		"		#endif",

		"	}",

		"	if( enableAO ) {",

		"		#ifdef GAMMA_INPUT",

		"			vec4 aoColor = texture2D( tAO, vUv );",
		"			aoColor.xyz *= aoColor.xyz;",

		"			diffuseColor.rgb *= aoColor.xyz;",

		"		#else",

		"			diffuseColor.rgb *= texture2D( tAO, vUv ).xyz;",

		"		#endif",

		"	}",

		THREE.ShaderChunk[ "alphatest_fragment" ],

		"	if( enableSpecular )",
		"		specularTex = texture2D( tSpecular, vUv ).xyz;",

		"	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
		"	vec3 finalNormal = tsb * normalTex;",

		"	#ifdef FLIP_SIDED",

		"		finalNormal = -finalNormal;",

		"	#endif",

		"	vec3 normal = normalize( finalNormal );",
		"	vec3 viewPosition = normalize( vViewPosition );",

		"	vec3 totalDiffuseLight = vec3( 0.0 );",
		"	vec3 totalSpecularLight = vec3( 0.0 );",

			// point lights

		"	#if MAX_POINT_LIGHTS > 0",

		"		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

		"			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
		"			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

		"			float pointDistance = 1.0;",
		"			if ( pointLightDistance[ i ] > 0.0 )",
		"				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

		"			pointVector = normalize( pointVector );",

					// diffuse

		"			#ifdef WRAP_AROUND",

		"				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
		"				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

		"				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

		"			#else",

		"				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

		"			#endif",

		"			totalDiffuseLight += pointDistance * pointLightColor[ i ] * pointDiffuseWeight;",

					// specular

		"			vec3 pointHalfVector = normalize( pointVector + viewPosition );",
		"			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
		"			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

		"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

		"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
		"			totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

		"		}",

		"	#endif",

			// spot lights

		"	#if MAX_SPOT_LIGHTS > 0",

		"		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

		"			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
		"			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

		"			float spotDistance = 1.0;",
		"			if ( spotLightDistance[ i ] > 0.0 )",
		"				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

		"			spotVector = normalize( spotVector );",

		"			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

		"			if ( spotEffect > spotLightAngleCos[ i ] ) {",

		"				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

						// diffuse

		"				#ifdef WRAP_AROUND",

		"					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
		"					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

		"					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

		"				#else",

		"					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

		"				#endif",

		"				totalDiffuseLight += spotDistance * spotLightColor[ i ] * spotDiffuseWeight * spotEffect;",

						// specular

		"				vec3 spotHalfVector = normalize( spotVector + viewPosition );",
		"				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
		"				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

		"				float specularNormalization = ( shininess + 2.0 ) / 8.0;",

		"				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
		"				totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

		"			}",

		"		}",

		"	#endif",

			// directional lights

		"	#if MAX_DIR_LIGHTS > 0",

		"		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

		"			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
		"			vec3 dirVector = normalize( lDirection.xyz );",

					// diffuse

		"			#ifdef WRAP_AROUND",

		"				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
		"				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

		"				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

		"			#else",

		"				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

		"			#endif",

		"			totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;",

					// specular

		"			vec3 dirHalfVector = normalize( dirVector + viewPosition );",
		"			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
		"			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

		"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

		"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
		"			totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

		"		}",

		"	#endif",

			// hemisphere lights

		"	#if MAX_HEMI_LIGHTS > 0",

		"		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

		"			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
		"			vec3 lVector = normalize( lDirection.xyz );",

					// diffuse

		"			float dotProduct = dot( normal, lVector );",
		"			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

		"			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

		"			totalDiffuseLight += hemiColor;",

					// specular (sky light)


		"			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
		"			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
		"			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

					// specular (ground light)

		"			vec3 lVectorGround = -lVector;",

		"			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
		"			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
		"			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

		"			float dotProductGround = dot( normal, lVectorGround );",

		"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

		"			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
		"			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
		"			totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

		"		}",

		"	#endif",

		"	#ifdef METAL",

		"		outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );",

		"	#else",

		"		outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight;",

		"	#endif",

		"	if ( enableReflection ) {",

		"		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

		"		#ifdef ENVMAP_MODE_REFLECTION",

		"			vec3 vReflect = reflect( cameraToVertex, normal );",

		"		#else",

		"			vec3 vReflect = refract( cameraToVertex, normal, refractionRatio );",

		"		#endif",

		"		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

		"		#ifdef GAMMA_INPUT",

		"			cubeColor.xyz *= cubeColor.xyz;",

		"		#endif",

		"		outgoingLight = mix( outgoingLight, cubeColor.xyz, specularTex.r * reflectivity );",

		"	}",

			THREE.ShaderChunk[ "shadowmap_fragment" ],
			THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
			THREE.ShaderChunk[ "fog_fragment" ],

		"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

		"}"

	].join("\n"),

	vertexShader: [

		"attribute vec4 tangent;",

		"uniform vec2 uOffset;",
		"uniform vec2 uRepeat;",

		"uniform bool enableDisplacement;",

		"#ifdef VERTEX_TEXTURES",

		"	uniform sampler2D tDisplacement;",
		"	uniform float uDisplacementScale;",
		"	uniform float uDisplacementBias;",

		"#endif",

		"varying vec3 vTangent;",
		"varying vec3 vBinormal;",
		"varying vec3 vNormal;",
		"varying vec2 vUv;",

		"varying vec3 vWorldPosition;",
		"varying vec3 vViewPosition;",

		THREE.ShaderChunk[ "skinning_pars_vertex" ],
		THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
		THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

		"void main() {",

			THREE.ShaderChunk[ "skinbase_vertex" ],
			THREE.ShaderChunk[ "skinnormal_vertex" ],

			// normal, tangent and binormal vectors

		"	#ifdef USE_SKINNING",

		"		vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

		"		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
		"		vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

		"	#else",

		"		vNormal = normalize( normalMatrix * normal );",
		"		vTangent = normalize( normalMatrix * tangent.xyz );",

		"	#endif",

		"	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

		"	vUv = uv * uRepeat + uOffset;",

			// displacement mapping

		"	vec3 displacedPosition;",

		"	#ifdef VERTEX_TEXTURES",

		"		if ( enableDisplacement ) {",

		"			vec3 dv = texture2D( tDisplacement, uv ).xyz;",
		"			float df = uDisplacementScale * dv.x + uDisplacementBias;",
		"			displacedPosition = position + normalize( normal ) * df;",

		"		} else {",

		"			#ifdef USE_SKINNING",

		"				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

		"				vec4 skinned = vec4( 0.0 );",
		"				skinned += boneMatX * skinVertex * skinWeight.x;",
		"				skinned += boneMatY * skinVertex * skinWeight.y;",
		"				skinned += boneMatZ * skinVertex * skinWeight.z;",
		"				skinned += boneMatW * skinVertex * skinWeight.w;",
		"				skinned  = bindMatrixInverse * skinned;",

		"				displacedPosition = skinned.xyz;",

		"			#else",

		"				displacedPosition = position;",

		"			#endif",

		"		}",

		"	#else",

		"		#ifdef USE_SKINNING",

		"			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

		"			vec4 skinned = vec4( 0.0 );",
		"			skinned += boneMatX * skinVertex * skinWeight.x;",
		"			skinned += boneMatY * skinVertex * skinWeight.y;",
		"			skinned += boneMatZ * skinVertex * skinWeight.z;",
		"			skinned += boneMatW * skinVertex * skinWeight.w;",
		"			skinned  = bindMatrixInverse * skinned;",

		"			displacedPosition = skinned.xyz;",

		"		#else",

		"			displacedPosition = position;",

		"		#endif",

		"	#endif",

			//

		"	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
		"	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

		"	gl_Position = projectionMatrix * mvPosition;",

			THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			//

		"	vWorldPosition = worldPosition.xyz;",
		"	vViewPosition = -mvPosition.xyz;",

			// shadows

		"	#ifdef USE_SHADOWMAP",

		"		for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

		"			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

		"		}",

		"	#endif",

		"}"

	].join("\n")

};

},{}],46:[function(require,module,exports){
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Sobel filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

module.exports = {

	uniforms: {

		"tDiffuse": {
			type: "t",
			value: null
		},
		"xAmount": {
			type: "f",
			value: 0.01
		},
		"yAmount": {
			type: "f",
			value: 0.01
		},
		"tSize":    { type: "v2", value: new THREE.Vector2( 64, 64 ) }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

		"vUv = uv;",
		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform float xAmount;",
		"uniform float yAmount;",
		"uniform vec2 tSize;",


		"void main(void)",
		"{",
			"vec2 s = vec2(xAmount,yAmount);",
			"vec2 size = tSize / s;",
			 "vec2 color = floor( ( vUv * size ) ) / size + s/tSize * 0.5;",
			"gl_FragColor = texture2D(tDiffuse, color);",
		"} ",

	].join("\n")

};
},{}],47:[function(require,module,exports){
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 0.005 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float amount;",
		"uniform float angle;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
			"vec4 cga = texture2D(tDiffuse, vUv);",
			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

		"}"

	].join("\n")

};

},{}],48:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Sepia tone shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float amount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",
			"vec3 c = color.rgb;",

			"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );",
			"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );",
			"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );",

			"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );",

		"}"

	].join("\n")

};

},{}],49:[function(require,module,exports){
/**
 * @author flimshaw / http://charliehoey.com
 *
 * Technicolor Shader
 * Simulates the look of the two-strip technicolor process popular in early 20th century films.
 * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm
 * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",

		"void main() {",

			"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
			"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);",

			"gl_FragColor = newTex;",

		"}"

	].join("\n")

};

},{}],50:[function(require,module,exports){
/**
 * @author miibond
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"averageLuminance":  { type: "f", value: 1.0 },
		"luminanceMap":  { type: "t", value: null },
		"maxLuminance":  { type: "f", value: 16.0 },
		"middleGrey":  { type: "f", value: 0.6 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"uniform float middleGrey;",
		"uniform float maxLuminance;",
		"#ifdef ADAPTED_LUMINANCE",
			"uniform sampler2D luminanceMap;",
		"#else",
			"uniform float averageLuminance;",
		"#endif",
		
		"const vec3 LUM_CONVERT = vec3(0.299, 0.587, 0.114);",

		"vec3 ToneMap( vec3 vColor ) {",
			"#ifdef ADAPTED_LUMINANCE",
				// Get the calculated average luminance 
				"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
			"#else",
				"float fLumAvg = averageLuminance;",
			"#endif",
			
			// Calculate the luminance of the current pixel
			"float fLumPixel = dot(vColor, LUM_CONVERT);",

			// Apply the modified operator (Eq. 4)
			"float fLumScaled = (fLumPixel * middleGrey) / fLumAvg;",

			"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
			"return fLumCompressed * vColor;",
		"}",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			
			"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
			//Gamma 2.0
			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"}"

	].join("\n")

};

},{}],51:[function(require,module,exports){
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"v":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

},{}],52:[function(require,module,exports){
var P_WIDTH = 256;
var P_HEIGHT = 256;
var P_DEPTH = 256;
var TIME_BIAS = -1000;
var TWEEN = require('tweenjs');

'use strict';

var Three = function() {
	'use strict';

	var _container, _animateCallback;

	var _camera, _scene, _renderer, _lightGroup, _ambientLight, _controls;

	var windowHalfX, windowHalfY;

	function init(container, animateCallback) {

		_container = container;
		_animateCallback = animateCallback;

		_camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
		_camera.position.set(0, 0, 1400);

		_scene = new THREE.Scene();

		_renderer = new THREE.WebGLRenderer();
		_renderer.setSize(window.innerWidth, window.innerHeight);
		_container.appendChild(_renderer.domElement);

		// LIGHTS
		_lightGroup = new THREE.Object3D();
		_scene.add(_lightGroup);
		_lightGroup.position.z = 4000;

		var gLight = new THREE.AmbientLight(0xefefef);
		_scene.add(gLight);

		_ambientLight = new THREE.SpotLight(0xffffff);

		var light = new THREE.SphereGeometry(40, 4, 4);
		var lMesh = new THREE.Mesh(light, new THREE.MeshBasicMaterial({
			wireframe: true
		}));

		//_lightGroup.add(lMesh);
		_lightGroup.add(_ambientLight);

		_controls = new THREE.TrackballControls(_camera, _renderer.domElement);
		_controls.minDistance = 400;
		_controls.maxDistance = 1000;
		_renderer.gammaInput = true;
		_renderer.gammaOutput = true;

		animate();

		window.addEventListener('resize', onWindowResize, false);

		return _scene;
	}

	///------------------
	//API
	///------------------

	///--------------------------
	//PRIVATED
	///--------------------------


	//resize
	function onWindowResize() {
		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;
		_camera.updateProjectionMatrix();
		_renderer.setSize(window.innerWidth, window.innerHeight);
	}
	//render
	function animate() {
		TWEEN.update();
		window.requestAnimationFrame(animate);
		threeRender();
	}

	function threeRender() {
		_controls.update();
		_animateCallback();
		_lightGroup.position.copy(_camera.position);
		_lightGroup.rotation.copy(_camera.rotation);
		_renderer.render(_scene, _camera);
	}

	return {
		init:init
	}
};

module.exports = Three;
},{"tweenjs":8}],53:[function(require,module,exports){
var Q = require('q');
var Perlin = require('./noise');
var _ = require('lodash');
//seconds
var INTERVAL = 0.5;
var SEQUENCIAL_REFS = false;
var CHAPTER_DURATION = 45; //mins

var flattendData = [];

/*
 
 
 */

var Timeline = function() {
    'use strict';
    var ALL;

    function start(clipsManifest) {
        ALL = [];
        _.each(clipsManifest, function(chapter, i) {
            var o = Object.create(null);
            ALL.push(o);
            o['routes'] = [];
            _buildRoutes(o['routes'], chapter, i);

        });
        return _replaceRoute(clipsManifest, ALL);
    }

    function _buildRoutes(routes, chapter, chapterIndex) {
        var totalDuration = 0;

        function __createRoute() {
            if (totalDuration > (CHAPTER_DURATION * 60)) {
                return;
            }
            var route = [];
            var seed = Math.floor(Math.random() * chapter[0]['videos'].length);
            route.push([0, seed]);
            for (var i = 1; i < chapter.length; i++) {
                var total = chapter[i]['videos'].length;
                var factor = Perlin.getVal(i);
                var min = Math.max(seed - 1, 0);
                var max = Math.min(seed + 1, total - 1);
                var choices = [min, seed, max];
                var choice;
                var norm = i / chapter.length;
                //fast to slow at end
                if (chapterIndex === 3) {
                    norm = 1 - norm;
                }
                var choiceFactor;
                switch (chapterIndex) {
                    case 0:
                    case 3:
                        choiceFactor = (factor + Math.asin(norm)) / 2;
                        choice = choices[Math.floor(_clamp(choices.length * choiceFactor, 0,total))];
                        break;
                    case 1:
                    case 2:
                        choice = choices[Math.floor(_clamp(choices.length * factor, 0,total))];
                        break;
                }
                if (choice !== undefined) {
                    totalDuration += chapter[i]['videos'][choice]['duration'];
                    route.push([i, choice]);
                    seed = choice;
                }
            }
            routes.push(route);
            __createRoute();
        }

        __createRoute();
    }

    function _replaceRoute(manifest, routes){
        var replacedManifest = [];
        _.each(routes,function(routeObj, chapterIndex){
            var videos = manifest[chapterIndex];
            var ch = [];
            _.each(routeObj['routes'],function(route){
                _.each(route,function(data, i){
                    var o = Object.create(null);
                    var item = videos[data[0]];
                    o['chapter'] = chapterIndex;
                    o['index'] = i;
                    o['dir'] = item['dir'];
                    o['clip'] = item['dashed'][data[1]];
                    ch.push(o);
                });
            });
            replacedManifest.push(ch);
        });
        return replacedManifest;
    }

    function _clamp(number, min, max) {
        return Math.max(min, Math.min(number, max));
    }
    //function _createRoute()

    return {
        start: start
    }
}

module.exports = Timeline;
},{"./noise":16,"lodash":4,"q":6}],54:[function(require,module,exports){
var AP = 0.5625;
var W = 1280;
var H = 720;
'use strict';

var UTILS = (function() {
	var obj = Object.create(null);

	function onAspectResize(w, h, callback) {
		return _doOp(w, h);
	}

	function _doOp(w, h) {
		w = w || window.innerWidth;
		h = h || window.innerHeight;
		var containerRatio = w / h;
		var elRatio = W / H;
		var scale = 1,
			x, y;

		// define scale
		if (containerRatio > elRatio) {
			if (w > W) {
				scale = w / W;
			} else {
				scale = W / w;
			}
			scale = w / W;
		} else {
			if (h > H) {
				scale = h / H;
			} else {
				scale = H / h;
			}
			scale = h / H;
		}
		// define position
		if (containerRatio === elRatio) {
			x = y = 0;
		} else {
			x = (w - W * scale) * 0.5 / scale;
			y = (h - H * scale) * 0.5 / scale;
		}
		scale = Math.max(scale, 1);
		// fixed
		//x = Number(x.toFixed(1));
		//y = Number(y.toFixed(1));
		obj['w'] = W * scale;
		obj['h'] = H * scale;
		obj['scale'] = scale;
		obj['x'] = x;
		obj['y'] = y;

		return obj;
	}

	return {
		onAspectResize: onAspectResize
	}
})();

module.exports = UTILS;
},{}],55:[function(require,module,exports){
'use strict';

function Webcam(videoEl) {
	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

	if (navigator.getUserMedia) {
		navigator.getUserMedia({
			video: true
		}, handleVideo, videoError);
	}

	function handleVideo(stream) {
		// if found attach feed to video element
		videoEl.src = window.URL.createObjectURL(stream);
	}

	function videoError(e) {
		// no webcam found - do something
	}
}

module.exports = Webcam;
},{}],56:[function(require,module,exports){
// app dependencies
var App = require('../app');

// define module
App.module('AppController', function(AppController, App, Backbone, Marionette, $, _) {
	// controller class
	AppController.Controller = Marionette.Controller.extend({

		initialize: function() {
			// listen to events
			this.createViews();
		},

		createViews: function() {
			this.appView = new App.Views.App();
			App.Regions.show('nav', this.appView);
		}
	});

	// instance
	AppController.instance = new AppController.Controller();
});

// export
module.exports = App.AppController;
},{"../app":13}],57:[function(require,module,exports){
// app dependencies
var App = require('../app');
var Q = require('q');
// define module
App.module('Entities', function(Entities, App, Backbone, Marionette, $, _) {

    function _getManifest() {
        var defer = Q.defer();
        Q($.ajax({
            type: 'GET',
            url: 'assets/json/videos_manifest.json'
        })).then(function(data) {
            defer.resolve(data);
        });
        return defer.promise;
    }

    function _getEffects() {
        var defer = Q.defer();
        Q($.ajax({
            type: 'GET',
            url: 'assets/json/effect_durations.json'
        })).then(function(data) {
            defer.resolve(data);
        });
        return defer.promise;
    }

    App.reqres.setHandler('reqres:effects', _getEffects);
    App.reqres.setHandler('reqres:manifest', _getManifest);

});

// export
module.exports = App.Entities;
},{"../app":13,"q":6}],58:[function(require,module,exports){
// app dependencies
var App = require('../app');

// define module
App.module('Regions', function(Regions, App, Backbone, Marionette, $, _) {

	// region manager class
	Regions.RegionManager = Marionette.RegionManager.extend({

		initialize: function() {
			// define regions
			var data = {};
			data['nav'] = '#nav-region';
			data['content'] = '#content-region';
			this.addRegions(data);
		}
	});
	
	Regions.get = function(regionId) {
		return Regions.instance.get(regionId);
	};

	// helpers
	Regions.show = function(regionId, view) {
		if (!view) return;
		var region = Regions.instance.get(regionId);
		if (region) {
			region.show(view);
		}
	};

	Regions.add = function(constant, selector) {
		if (!Regions.instance) return;
		var r = {};
		r[constant] = selector;
		Regions.instance.addRegions(r);
	};

	// instance
	Regions.instance = new Regions.RegionManager();

});

// export
module.exports = App.Regions;
},{"../app":13}],59:[function(require,module,exports){
// app dependencies
var App = require('../app');
// define module
App.module('Views', function(Views, App, Backbone, Marionette, $, _) {
    Views.App = Marionette.LayoutView.extend({
        template: JST['app'],
        regions:{
            contentz:'#content'
        },
        events: {
            'click .js-shader': 'onShader',
            'click .js-composer': 'onComposer',
            'click .js-fx': 'onFx'
        },
        initialize: function(options) {
        },
        onRender: function() {},
        onShow: function() {
        },
        onShader: function() {
            this.shaderView = new App.Views.ShaderView();
            App.Regions.show('content', this.shaderView);
            //this.contentz.show(this.shaderView);
        },
        onComposer: function() {
            this.composerView = new App.Views.Composer();
            App.Regions.show('content', this.composerView);
            //this.contentz.show(this.shaderView);
        },
        onFx: function() {
            this.fxView = new App.Views.FX();
            App.Regions.show('content', this.fxView);
            //this.contentz.show(this.shaderView);
        }
    });
});

// export
module.exports = App.Views;
},{"../app":13}],60:[function(require,module,exports){
var App = require('../app');
var dat = require('dat-gui');
var Stats = require('stats');
var TIMELINE = require('../common/timeline');
var SHADERS_LIB = require('../common/shader_lib');
var THREE_SCENE = require('../common/three_scene');
var SCENE = require('../common/scene');
var UTILS = require('../common/utils');
var AUDIO = require('../common/audio_analyser');
var PLAYER = require('../common/player_controller');
// app dependencies
var NUM_COLUMNS = 2;
var VIDEO_WIDTH = 480;
var VIDEO_HEIGHT = 360;
var MAX_ASPECT = 2.31;

var statsEnabled = true;

var container, stats, loader;
var camera, scene, renderer;

var geometry;
var planes;
var videoPlane, videoMaterial, textMaterial, textMaterialSide, textMaterialFront, textMaterialArray, textColor = new THREE.Color(0xFF000);
var texture1, texture2, texture3, video, sceneA, sceneB;
var planesGroup;

//Normal map shader
var ambient = 0xffffff,
	diffuse = 0xffffff / 5,
	specular = 0xffffff,
	scale = 143;

var textMesh, textGeo;

var spotLight, pointLight, ambientLight;
var isRender = true;

var mouseX = 0;
var mouseY = 0;

var controls;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

// define module
App.module('Views', function(Views, App, Backbone, Marionette, $, _) {

	'use strict';

	Views.Composer = Marionette.ItemView.extend({
		template: JST['composer_view'],
		events: {
			'click .js-go': 'startProcess'
		},
		initialize: function(options) {
			this.timeline = new TIMELINE();
			App.reqres.request('reqres:manifest').then(function(manifest) {
				console.log(manifest);
				/*var finalManifest = [];
				var newManifest = [];
				_.each(manifest,function(clip){
					newManifest = newManifest.concat(clip['videos']);
				});
				for (var i = 0; i < 4; i++) {
					var ch = [];
					for (var j = 0; j < 20; j++) {
						var clip = Object.create(null);
						clip['videos'] = [];
						for (var k = 0; k < 3; k++) {
							if(newManifest.length){
								var item = newManifest.shift();
								var sidx = item['sidx'];
								var duration = 0;
								_.each(sidx['references'],function(o){
									duration += o['durationSec'];
								});
								item['duration'] = duration;
								clip['videos'].push(item);
							}
						}
						ch.push(clip)
					}
					finalManifest.push(ch);
				}
				console.log(finalManifest);
				*/
				this.manifest =  this.timeline.start(manifest);
				this.setupPlayer();
			}.bind(this)).done();
		},
		onRender: function() {
			//gui
			this.updateCounter = 0;
			this.guiOptions = Object.create(null);
			this.guiOptions['uMixRatio'] = 0.01;
			this.guiOptions['uThreshold'] = 0.01;
			this.guiOptions['uSaturation'] = 0.01;
		},
		onShow: function() {
			var self = this;
			var gui = new dat.GUI();
			gui.add(this.guiOptions, 'uMixRatio', 0, 1).onChange(function(val) {
				videoMaterial.uniforms["uMixRatio"].value = this.guiOptions['uMixRatio'];
			}.bind(this));

			gui.add(this.guiOptions, 'uThreshold', 0, .5).onChange(function() {
				videoMaterial.uniforms["uThreshold"].value = this.guiOptions['uThreshold'];
			}.bind(this));

			gui.add(this.guiOptions, 'uSaturation', 0, 2.).onChange(function() {
				videoMaterial.uniforms["uSaturation"].value = this.guiOptions['uSaturation'];
			}.bind(this));

			gui.width = 300;
			this.aa = new AUDIO();
			this.aa.addTrack('assets/audio/girl.mp3');

			/*
			this.videoElement = document.getElementById('myVideo');
			this.videoElement.volume = 0;
			this.videoElement.width = VIDEO_WIDTH;
			this.videoElement.height = VIDEO_HEIGHT;

			this.videoElement2 = document.getElementById('myVideo2');
			this.videoElement2.volume = 0;
			this.videoElement2.width = VIDEO_WIDTH;
			this.videoElement2.height = VIDEO_HEIGHT;

			this.videoElement3 = document.getElementById('mixer');
			this.videoElement3.volume = 0;
			this.videoElement3.width = VIDEO_WIDTH;
			this.videoElement3.height = VIDEO_HEIGHT;*/

			this.gui = gui;
			//this.setup3D();
		},
		setupPlayer:function(){
			this.videoElement = document.getElementById('myVideo');
			this.playerController = new PLAYER();
			this.playerController.init(this.videoElement);
			console.log(this.manifest);
			this.playerController.setEntireManifest(this.manifest);
		},
		////------------------------
		//3D
		////------------------------

		setup3D: function() {
			var Z_DIS = 400;
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('three').appendChild(renderer.domElement);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			this.el.appendChild(stats.domElement);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 0, Z_DIS);

			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.minDistance = Z_DIS;
			controls.maxDistance = 1000;

			texture1 = new THREE.Texture(this.videoElement);
			texture1.minFilter = THREE.LinearFilter;
			texture1.magFilter = THREE.LinearFilter;

			texture2 = new THREE.Texture(this.videoElement2);
			texture2.minFilter = THREE.LinearFilter;
			texture2.magFilter = THREE.LinearFilter;

			texture3 = new THREE.Texture(this.videoElement3);
			texture3.minFilter = THREE.LinearFilter;
			texture3.magFilter = THREE.LinearFilter;

			//texture3 = new THREE.ImageUtils.loadTexture('../img1.jpg');
			var scaleObj = UTILS.onAspectResize();

			sceneA = new SCENE(renderer, 0xffffff, Z_DIS);
			sceneA.createPlane(scaleObj.w, scaleObj.h, new THREE.MeshBasicMaterial({
				map: texture1
			}));

			sceneB = new SCENE(renderer, 0x000000, Z_DIS);
			sceneB.createPlane(scaleObj.w, scaleObj.h, new THREE.MeshBasicMaterial({
				map: texture2
			}));

			var d = SHADERS_LIB['mix']();
			console.log(d);
			var shader = d['shader'];
			var uniforms = d['uniforms'];
			uniforms["tOne"].value = sceneA.fbo;
			uniforms["tTwo"].value = sceneB.fbo;
			uniforms["tMix"].value = texture3;
			uniforms["uMixRatio"].value = this.guiOptions['uMixRatio'];
			uniforms["uThreshold"].value = this.guiOptions['uThreshold'];

			var parameters = {
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: uniforms
			};
			var quadgeometry = new THREE.PlaneGeometry(scaleObj.w, scaleObj.h, 4, 4);
			//THREE.GeometryUtils.center(quadgeometry);

			videoMaterial = new THREE.ShaderMaterial(parameters);

			scene = new THREE.Scene();

			this.quad = new THREE.Mesh(quadgeometry, videoMaterial);
			scene.add(this.quad);

			scene.add(this.quad);

			this.boundAnimate = this.animate.bind(this);
			this.boundAnimate();

			window.addEventListener('resize', this.onWindowResize.bind(this), false);

			this.onWindowResize();
		},
		onWindowResize: function() {
			var w = window.innerWidth;
			var h = window.innerHeight;
			camera.aspect = w / h;
			console.log(camera.aspect);
			var scale = 0;
			if (w / h > MAX_ASPECT) {
				scale = 1 + w / h / MAX_ASPECT;
			} else {
				scale = 1
			}
			this.quad.scale.x = this.quad.scale.y = scale;
			renderer.setSize(w, h)
			sceneA.resize(w, h, scale);
			sceneB.resize(w, h, scale);
		},
		handleResize: function(w, h) {
			console.log(w, h);
		},
		animate: function() {
			window.requestAnimationFrame(this.boundAnimate);
			this.threeRender();
			stats.update();
		},

		threeRender: function() {
			controls.update();
			texture1.needsUpdate = true;
			texture2.needsUpdate = true;
			texture3.needsUpdate = true;
			videoMaterial.uniforms.uMixRatio.value = this.guiOptions['uMixRatio'];
			videoMaterial.uniforms.uThreshold.value = this.guiOptions['uThreshold'];
			if (this.guiOptions['uMixRatio'] == 0) {
				sceneB.render(false);
			} else if (this.guiOptions['uMixRatio'] == 1) {
				sceneA.render(false);
			} else {
				sceneA.render(true);
				sceneB.render(true);
				renderer.render(scene, camera, null, true);
			}
		}

	});
});

// export
module.exports = App.Composer;
},{"../app":13,"../common/audio_analyser":14,"../common/player_controller":17,"../common/scene":22,"../common/shader_lib":23,"../common/three_scene":52,"../common/timeline":53,"../common/utils":54,"dat-gui":10,"stats":7}],61:[function(require,module,exports){
var App = require('../app');
var dat = require('dat-gui');
var Stats = require('stats');
var SHADERS_LIB = require('../common/shader_lib');
var THREE_SCENE = require('../common/three_scene');
var SCENE = require('../common/scene');
var UTILS = require('../common/utils');
var FX_OPTIONS = require('../common/shader_options');
var TIMELINE = require('../common/timeline');
var WEBCAM = require('../common/webcam');
var PLAYER = require('../common/player_controller');
// app dependencies
var NUM_COLUMNS = 2;
var VIDEO_WIDTH = 1280;
var VIDEO_HEIGHT = 853;
var MAX_ASPECT = 2.31;

var statsEnabled = true;

var container, stats, loader;
var camera, scene, renderer;

var geometry;
var planes;
var videoPlane, videoMaterial, textMaterial, textMaterialSide, textMaterialFront, textMaterialArray, textColor = new THREE.Color(0xFF000);
var texture1, texture2, texture3, video, sceneA, sceneB, mixer;
var planesGroup;

//Normal map shader
var ambient = 0xffffff,
	diffuse = 0xffffff / 5,
	specular = 0xffffff,
	scale = 143;

var textMesh, textGeo;

var spotLight, pointLight, ambientLight;
var isRender = true;

var mouseX = 0;
var mouseY = 0;

var controls;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

// define module
App.module('Views', function(Views, App, Backbone, Marionette, $, _) {

	'use strict';

	Views.FX = Marionette.ItemView.extend({
		template: JST['effect_view'],
		events: {
			'click .js-go': 'startProcess'
		},
		initialize: function(options) {
			this.timeline = new TIMELINE();
			App.reqres.request('reqres:manifest').then(function(manifest) {
				this.manifest = this.timeline.start(manifest);
				this.setupPlayer();
			}.bind(this)).done();
		},
		setupPlayer: function() {
			this.videoElement = document.getElementById('myVideo');
			this.playerController = new PLAYER();
			this.playerController.init(this.videoElement);
			this.playerController.setEntireManifest(this.manifest);
		},
		onRender: function() {
			this.updateCounter = 0;
			this.guiOptions = Object.create(null);
			this.guiOptions['uMixRatio'] = 0.01;
			this.guiOptions['uThreshold'] = 0.01;
			this.guiOptions['uSaturation'] = 0.01;
			//gui
		},
		onShow: function() {

			var self = this;
			var gui = new dat.GUI();
			var main = gui.addFolder('main');
			main.add(this.guiOptions, 'uMixRatio', 0, 1).onChange(function(val) {
				videoMaterial.uniforms["uMixRatio"].value = this.guiOptions['uMixRatio'];
			}.bind(this));

			main.add(this.guiOptions, 'uThreshold', 0, .5).onChange(function() {
				videoMaterial.uniforms["uThreshold"].value = this.guiOptions['uThreshold'];
			}.bind(this));

			main.add(this.guiOptions, 'uSaturation', 0, 10.).onChange(function() {
				videoMaterial.uniforms["uSaturation"].value = this.guiOptions['uSaturation'];
			}.bind(this));

			var optionsA = gui.addFolder('sceneA');
			var optnsFolder = [];
			var options = _.cloneDeep(FX_OPTIONS);
			_.forIn(options, function(obj, key) {
				var f = optionsA.addFolder('sceneA-'+key);
				optnsFolder.push(f);
				_.forIn(obj, function(v, k) {
					var b = Object.create(null);
					b['uniforms'] = obj;
					b['shader'] = key;
					if (_.isObject(v)) {
						console.log(v);
						_.forIn(v, function(vv, kk) {
							if (kk === k) {
								f.add(v, k, v['min'], v['max']).onChange(function(val) {
									sceneA.updateUniforms(this);
								}.bind(b));
							}
						});
					} else if(typeof v === 'boolean'){
						f.add(obj, k).onChange(function(val) {
							sceneA.updateUniforms(this);
						}.bind(b));
					}
				});
			});

			var optionsB = gui.addFolder('sceneB');
			var optnsFolder = [];
			var options = _.cloneDeep(FX_OPTIONS);
			_.forIn(options, function(obj, key) {
				var f = optionsB.addFolder('sceneB-'+key);
				optnsFolder.push(f);
				_.forIn(obj, function(v, k) {
					var b = Object.create(null);
					b['uniforms'] = obj;
					b['shader'] = key;
					if (_.isObject(v)) {
						_.forIn(v, function(vv, kk) {
							if (kk === k) {
								f.add(v, k, v['min'], v['max']).onChange(function(val) {
									sceneB.updateUniforms(this);
								}.bind(b));
							}
						});
					} else {
						f.add(obj, k).onChange(function(val) {
							sceneB.updateUniforms(this);
						}.bind(b));
					}
				});
			});
			/*
			var optnsFolder2 = [];
			var optionsB = gui.addFolder('sceneB');
			var options = _.cloneDeep(FX_OPTIONS);
			_.forIn(options, function(obj, key) {
				var f = optionsB.addFolder(key);
				optnsFolder2.push(f);
				_.forIn(obj, function(v, k) {
					var b = Object.create(null);
					b['uniforms'] = obj;
					b['shader'] = key;
					f.add(obj, k, 0.01, 10.0).onChange(function(val) {
						console.log(val);
						sceneB.updateUniforms(this);
					}.bind(b));
				});
			});*/
			//optionsA.

			gui.width = 300;

			this.videoElement = document.getElementById('myVideo');
			this.videoElement.volume = 0;
			this.videoElement.width = VIDEO_WIDTH;
			this.videoElement.height = VIDEO_HEIGHT;

			this.videoElement2 = document.getElementById('myVideo2');
			this.videoElement2.volume = 0;
			this.videoElement2.width = VIDEO_WIDTH;
			this.videoElement2.height = VIDEO_HEIGHT;

			this.videoElement3 = document.getElementById('mixer');
			this.webcam = new WEBCAM(this.videoElement3);
			this.videoElement3.volume = 0;
			this.videoElement3.width = VIDEO_WIDTH;
			this.videoElement3.height = VIDEO_HEIGHT;

			this.gui = gui;
			this.setup3D();
		},

		////------------------------
		//3D
		////------------------------

		setup3D: function() {
			var Z_DIS = 400;
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('three').appendChild(renderer.domElement);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			this.el.appendChild(stats.domElement);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 0, Z_DIS);

			texture1 = new THREE.Texture(this.videoElement);
			texture1.minFilter = THREE.LinearFilter;
			texture1.magFilter = THREE.LinearFilter;

			texture2 = new THREE.Texture(this.videoElement2);
			texture2.minFilter = THREE.LinearFilter;
			texture2.magFilter = THREE.LinearFilter;

			texture3 = new THREE.Texture(this.videoElement3);
			texture3.minFilter = THREE.LinearFilter;
			texture3.magFilter = THREE.LinearFilter;

			var scaleObj = UTILS.onAspectResize();

			sceneA = new SCENE(renderer, 0xffffff, Z_DIS);
			sceneA.createPlane(scaleObj.w, scaleObj.h, new THREE.MeshBasicMaterial({
				map: texture1
			}));

			sceneB = new SCENE(renderer, 0x000000, Z_DIS);
			sceneB.createPlane(scaleObj.w, scaleObj.h, new THREE.MeshBasicMaterial({
				map: texture2
			}));

			sceneA.fx.setOtherFbo(sceneB.fbo);
			sceneB.fx.setOtherFbo(sceneA.fbo);

			var d = SHADERS_LIB['mix']();
			var shader = d['shader'];
			var uniforms = d['uniforms'];
			uniforms["tOne"].value = sceneA.fbo;
			uniforms["tTwo"].value = sceneB.fbo;
			uniforms["tMix"].value = texture3;
			uniforms["uMixRatio"].value = this.guiOptions['uMixRatio'];
			uniforms["uThreshold"].value = this.guiOptions['uThreshold'];

			var parameters = {
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: uniforms
			};
			var quadgeometry = new THREE.PlaneGeometry(scaleObj.w, scaleObj.h, 4, 4);
			//THREE.GeometryUtils.center(quadgeometry);

			videoMaterial = new THREE.ShaderMaterial(parameters);

			scene = new THREE.Scene();

			this.quad = new THREE.Mesh(quadgeometry, videoMaterial);
			scene.add(this.quad);

			scene.add(this.quad);

			this.boundAnimate = this.animate.bind(this);
			this.boundAnimate();

			window.addEventListener('resize', this.onWindowResize.bind(this), false);

			this.onWindowResize();
		},
		onWindowResize: function() {
			var w = window.innerWidth;
			var h = window.innerHeight;
			camera.aspect = w / h;
			console.log(UTILS.onAspectResize(w, h));
			var scale = 1;
			scale = UTILS.onAspectResize(w, h).scale
			/*if (w / h > MAX_ASPECT) {
				scale = 1 + w / h / MAX_ASPECT;
			} else {
				scale = 1
			}*/
			scale = 1;
			this.quad.scale.x = this.quad.scale.y = scale;
			renderer.setSize(w, h)
			sceneA.resize(w, h, scale);
			sceneB.resize(w, h, scale);
		},
		handleResize: function(w, h) {
			console.log(w, h);
		},
		animate: function() {
			window.requestAnimationFrame(this.boundAnimate);
			this.threeRender();
			stats.update();
		},

		threeRender: function() {
			texture1.needsUpdate = true;
			texture2.needsUpdate = true;
			texture3.needsUpdate = true;
			videoMaterial.uniforms.uMixRatio.value = this.guiOptions['uMixRatio'];
			videoMaterial.uniforms.uThreshold.value = this.guiOptions['uThreshold'];
			if (this.guiOptions['uMixRatio'] == 0) {
				sceneB.render();
			} else if (this.guiOptions['uMixRatio'] == 1) {
				sceneA.render();
			} else {
				sceneA.render();
				sceneB.render();
			}
			renderer.render(scene, camera, null, true);
		}

	});
});

// export
module.exports = App.FX;
},{"../app":13,"../common/player_controller":17,"../common/scene":22,"../common/shader_lib":23,"../common/shader_options":24,"../common/three_scene":52,"../common/timeline":53,"../common/utils":54,"../common/webcam":55,"dat-gui":10,"stats":7}],62:[function(require,module,exports){
var App = require('../app');
var dat = require('dat-gui');
var Stats = require('stats');
var SHADERS_LIB = require('../common/shader_lib');
var THREE_SCENE = require('../common/three_scene');
// app dependencies
var NUM_COLUMNS = 2;
var VIDEO_WIDTH = 1280;
var VIDEO_HEIGHT = 720;

var statsEnabled = true;

var container, stats, loader;
var camera, scene, renderer;

var geometry;
var planes;
var videoPlane, videoMaterial, textMaterial, textMaterialSide, textMaterialFront, textMaterialArray, textColor = new THREE.Color(0xFF000);
var texture, texture2, video;
var planesGroup;

//Normal map shader
var ambient = 0xffffff,
	diffuse = 0xffffff / 5,
	specular = 0xffffff,
	scale = 143;

var textMesh, textGeo;

var spotLight, pointLight, ambientLight;
var isRender = true;

var mouseX = 0;
var mouseY = 0;

var controls;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

// define module
App.module('Views', function(Views, App, Backbone, Marionette, $, _) {

	'use strict';

	Views.ShaderView = Marionette.ItemView.extend({
		template: JST['youtube_three'],
		events: {
			'click .js-go': 'startProcess'
		},
		initialize: function(options) {
			this.updateCounter = 0;
			this.guiOptions = Object.create(null);
			this.guiOptions['numPlanes'] = 1;
			this.guiOptions['setShader'] = 'fractal1';
		},
		onRender: function() {
			//gui
			var gui = new dat.GUI();
			gui.add(this.guiOptions, 'numPlanes', 1, 4).step(1).onChange(function(val) {
				this.createPlanes(val);
			}.bind(this));
			gui.add(this.guiOptions, 'setShader', ['fractal1', 'chroma', 'cave']).onChange(_.debounce(function(val) {
				this.setShader(val);
			},100).bind(this));

			gui.width = 300;
			this.gui = gui;
		},
		onShow: function() {
			var self = this;
			this.$textEl = this.$el.find('.ThreeFonts');

			this.videoElement = document.getElementById('myVideo');
			this.videoElement.volume = 0;
			this.videoElement.width = VIDEO_WIDTH;
			this.videoElement.height = VIDEO_HEIGHT;

			this.videoElement2 = document.getElementById('myVideo2');
			this.videoElement2.volume = 0;
			this.videoElement2.width = VIDEO_WIDTH;
			this.videoElement2.height = VIDEO_HEIGHT;

			this.setup3D();
		},

		////------------------------
		//3D
		////------------------------

		setup3D: function() {
			planes = [];

			geometry = new THREE.PlaneGeometry(VIDEO_WIDTH, VIDEO_HEIGHT, 480, 270);
			geometry.computeTangents();

			texture = new THREE.Texture(this.videoElement);
			texture.minFilter = THREE.LinearFilter;
			texture.magFilter = THREE.LinearFilter;

			texture2 = new THREE.Texture(this.videoElement2);
			texture2.minFilter = THREE.LinearFilter;
			texture2.magFilter = THREE.LinearFilter;

			var _s = new THREE_SCENE();
			scene = _s.init(document.getElementById('three'), this.threeRender.bind(this));

			this.setShader('cave');
		},

		setShader: function(name) {
			var d = SHADERS_LIB[name]();
			var shader = d['shader'];
			var uniforms = d['uniforms'];
			uniforms["tOne"].value = texture2;
			uniforms["tTwo"].value = texture;
			uniforms["tDisplacement"].value = texture;
			uniforms["uAmbientColor"].value.setHex(ambient);
			uniforms["uDiffuseColor"].value.setHex(diffuse);

			uniforms["uWidth"].value = VIDEO_WIDTH;
			uniforms["uHeight"].value = VIDEO_HEIGHT;
			uniforms["uRes"].value = VIDEO_HEIGHT / VIDEO_WIDTH;

			console.log(shader);
			console.log(uniforms);

			var parameters = {
				fragmentShader: shader.fragmentShader,
				shading: THREE.SmoothShading,
				vertexShader: shader.vertexShader,
				uniforms: uniforms,
				lights: true,
				fog: false,
				map: texture,
				side: THREE.DoubleSide
			};
			videoMaterial = new THREE.ShaderMaterial(parameters);
			this.createPlanes();
		},

		createPlanes: function() {
			if (planes.length > 0) {
				for (var i = 0; i < planes.length; i++) {
					planesGroup.remove(planes[i]);
				}
				scene.remove(planesGroup);
				planes.length = 0;
				planesGroup = null;
			}
			var columns = 2;
			var rows = 0;
			var numPlanes = this.guiOptions['numPlanes'];
			planesGroup = new THREE.Object3D();
			//planesGroup.position.set(0, -VIDEO_HEIGHT / (numPlanes / 2), 0);
			for (var i = 0; i < numPlanes; i++) {
				var mesh = new THREE.Mesh(geometry, videoMaterial);

				var offsetX = numPlanes > 1 ? 2 * VIDEO_WIDTH / 4 : 0;
				var offsetY = VIDEO_HEIGHT - 2;
				if (i % columns !== 0) {
					mesh.position.set(-offsetX, offsetY * rows, 0);
				} else {
					planesGroup.position.y = -(offsetY * .5) * rows - offsetY;
					rows++;
					mesh.position.set(offsetX, offsetY * rows, 0);
				}
				planes.push(mesh);
				planesGroup.add(mesh);
			}
			scene.add(planesGroup);
		},

		threeRender: function() {
			texture2.needsUpdate = true;
			texture.needsUpdate = true;
			if(videoMaterial){
				videoMaterial.uniforms['uTime'].value = this.updateCounter / 60;
			}
			this.updateCounter++;
		}

	});
});

// export
module.exports = App.ShaderView;
},{"../app":13,"../common/shader_lib":23,"../common/three_scene":52,"dat-gui":10,"stats":7}],63:[function(require,module,exports){
// app dependencies
var App = require('./app/app');

// kick off
App.start();
},{"./app/app":13}]},{},[63])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9hc3NldHMvdmVuZG9yL2JhY2tib25lL2JhY2tib25lLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvYXNzZXRzL3ZlbmRvci9mYXN0Y2xpY2svbGliL2Zhc3RjbGljay5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L2Fzc2V0cy92ZW5kb3IvanF1ZXJ5L2pxdWVyeS5taW4uanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9hc3NldHMvdmVuZG9yL2xvZGFzaC9sb2Rhc2gubWluLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvYXNzZXRzL3ZlbmRvci9tYXJpb25ldHRlL2xpYi9iYWNrYm9uZS5tYXJpb25ldHRlLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvYXNzZXRzL3ZlbmRvci9xL3EuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9hc3NldHMvdmVuZG9yL3N0YXRzLmpzL2J1aWxkL3N0YXRzLm1pbi5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L2Fzc2V0cy92ZW5kb3IvdHdlZW5qcy9idWlsZC90d2Vlbi5taW4uanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvbm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9ub2RlX21vZHVsZXMvZGF0LWd1aS92ZW5kb3IvZGF0LmNvbG9yLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2FwcC5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL2F1ZGlvX2FuYWx5c2VyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vZWZmZWN0c19zY2VuZS5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL25vaXNlLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vcGxheWVyX2NvbnRyb2xsZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9wb3N0L0VmZmVjdENvbXBvc2VyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vcG9zdC9NYXNrUGFzcy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3Bvc3QvUmVuZGVyUGFzcy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3Bvc3QvU2hhZGVyUGFzcy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NjZW5lLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVyX2xpYi5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcl9vcHRpb25zLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVyX3NldHRpbmdzLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvQml0U2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9CbGVhY2hCeXBhc3NTaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0JsZW5kU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9Cb2tlaFNoYWRlcjIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0JyaWdodG5lc3NDb250cmFzdFNoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvQ29sb3JpZnlTaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0NvbnZvbHV0aW9uU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9Db3B5U2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9EaWdpdGFsR2xpdGNoLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9Eb3RTY3JlZW5TaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0VkZ2VTaGFkZXIyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9GWEFBU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9GaWxtU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9Gb2N1c1NoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0h1ZVNhdHVyYXRpb25TaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL0thbGVpZG9TaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL01pcnJvclNoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvTm9ybWFsRGlzcGxhY2VtZW50U2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9QaXhlbGF0ZVNoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvUkdCU2hpZnRTaGFkZXIuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi9zaGFkZXJzL1NlcGlhU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vc2hhZGVycy9UZWNobmljb2xvclNoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvVG9uZU1hcFNoYWRlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3NoYWRlcnMvVmVydGljYWxCbHVyU2hhZGVyLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vdGhyZWVfc2NlbmUuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL2NvbW1vbi90aW1lbGluZS5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvY29tbW9uL3V0aWxzLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb21tb24vd2ViY2FtLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9jb250cm9sbGVycy9hcHBfY29udHJvbGxlci5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvZW50aXRpZXMvbWFuaWZlc3RfZW50aXR5LmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC9yZWdpb25zL2FwcF9yZWdpb25zLmpzIiwiL1VzZXJzL3NhbWVsaWUvRG9jdW1lbnRzL3JhZC9nYWxsZXJ5LXZpei9jbGllbnQvc3JjL2pzL2FwcC92aWV3cy9hcHBfdmlldy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvdmlld3MvY29tcG9zZXJfdmlldy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9hcHAvdmlld3MvZWZmZWN0X3ZpZXcuanMiLCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9zcmMvanMvYXBwL3ZpZXdzL3NoYWRlcnNfdmlldy5qcyIsIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L3NyYy9qcy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2tIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG47IHJlcXVpcmUoXCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9hc3NldHMvdmVuZG9yL2xvZGFzaC9sb2Rhc2gubWluLmpzXCIpO1xucmVxdWlyZShcIi9Vc2Vycy9zYW1lbGllL0RvY3VtZW50cy9yYWQvZ2FsbGVyeS12aXovY2xpZW50L2Fzc2V0cy92ZW5kb3IvanF1ZXJ5L2pxdWVyeS5taW4uanNcIik7XG47IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vLyAgICAgQmFja2JvbmUuanMgMS4xLjJcblxuLy8gICAgIChjKSAyMDEwLTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBCYWNrYm9uZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XG4vLyAgICAgaHR0cDovL2JhY2tib25lanMub3JnXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgLy8gU2V0IHVwIEJhY2tib25lIGFwcHJvcHJpYXRlbHkgZm9yIHRoZSBlbnZpcm9ubWVudC4gU3RhcnQgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWyd1bmRlcnNjb3JlJywgJ2pxdWVyeScsICdleHBvcnRzJ10sIGZ1bmN0aW9uKF8sICQsIGV4cG9ydHMpIHtcbiAgICAgIC8vIEV4cG9ydCBnbG9iYWwgZXZlbiBpbiBBTUQgY2FzZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCB3aXRoXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxuICAgICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwgZXhwb3J0cywgXywgJCk7XG4gICAgfSk7XG5cbiAgLy8gTmV4dCBmb3IgTm9kZS5qcyBvciBDb21tb25KUy4galF1ZXJ5IG1heSBub3QgYmUgbmVlZGVkIGFzIGEgbW9kdWxlLlxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfID0gX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fKCd1bmRlcnNjb3JlJyk7XG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfKTtcblxuICAvLyBGaW5hbGx5LCBhcyBhIGJyb3dzZXIgZ2xvYmFsLlxuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIHt9LCByb290Ll8sIChyb290LmpRdWVyeSB8fCByb290LlplcHRvIHx8IHJvb3QuZW5kZXIgfHwgcm9vdC4kKSk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXywgJCkge1xuXG4gIC8vIEluaXRpYWwgU2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyByZXN0b3JlZCBsYXRlciBvbiwgaWYgYG5vQ29uZmxpY3RgIGlzIHVzZWQuXG4gIHZhciBwcmV2aW91c0JhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcblxuICAvLyBDcmVhdGUgbG9jYWwgcmVmZXJlbmNlcyB0byBhcnJheSBtZXRob2RzIHdlJ2xsIHdhbnQgdG8gdXNlIGxhdGVyLlxuICB2YXIgYXJyYXkgPSBbXTtcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xuICB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiAgdmFyIHNwbGljZSA9IGFycmF5LnNwbGljZTtcblxuICAvLyBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuIEtlZXAgaW4gc3luYyB3aXRoIGBwYWNrYWdlLmpzb25gLlxuICBCYWNrYm9uZS5WRVJTSU9OID0gJzEuMS4yJztcblxuICAvLyBGb3IgQmFja2JvbmUncyBwdXJwb3NlcywgalF1ZXJ5LCBaZXB0bywgRW5kZXIsIG9yIE15IExpYnJhcnkgKGtpZGRpbmcpIG93bnNcbiAgLy8gdGhlIGAkYCB2YXJpYWJsZS5cbiAgQmFja2JvbmUuJCA9ICQ7XG5cbiAgLy8gUnVucyBCYWNrYm9uZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cbiAgQmFja2JvbmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuQmFja2JvbmUgPSBwcmV2aW91c0JhY2tib25lO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cbiAgLy8gd2lsbCBmYWtlIGBcIlBBVENIXCJgLCBgXCJQVVRcImAgYW5kIGBcIkRFTEVURVwiYCByZXF1ZXN0cyB2aWEgdGhlIGBfbWV0aG9kYCBwYXJhbWV0ZXIgYW5kXG4gIC8vIHNldCBhIGBYLUh0dHAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUpTT05gIHRvIHN1cHBvcnQgbGVnYWN5IHNlcnZlcnMgdGhhdCBjYW4ndCBkZWFsIHdpdGggZGlyZWN0XG4gIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcbiAgLy8gYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAgaW5zdGVhZCBhbmQgd2lsbCBzZW5kIHRoZSBtb2RlbCBpbiBhXG4gIC8vIGZvcm0gcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcblxuICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbiAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pIHx8ICFjYWxsYmFjaykgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIGV2ZW50cy5wdXNoKHtjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCB0aGlzfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gICAgb25jZTogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBvbmNlID0gXy5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgb25lIG9yIG1hbnkgY2FsbGJhY2tzLiBJZiBgY29udGV4dGAgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuICAgIC8vIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgICBvZmY6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICFldmVudHNBcGkodGhpcywgJ29mZicsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHJlbW92ZSA9ICFuYW1lICYmICFjYWxsYmFjaztcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBpZiAob2JqKSAobGlzdGVuaW5nVG8gPSB7fSlbb2JqLl9saXN0ZW5JZF0gPSBvYmo7XG4gICAgICBmb3IgKHZhciBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XG4gICAgICAgIG9iai5vZmYobmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgICBpZiAocmVtb3ZlIHx8IF8uaXNFbXB0eShvYmouX2V2ZW50cykpIGRlbGV0ZSB0aGlzLl9saXN0ZW5pbmdUb1tpZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxuICAvLyBuYW1lcyBgXCJjaGFuZ2UgYmx1clwiYCBhbmQgalF1ZXJ5LXN0eWxlIGV2ZW50IG1hcHMgYHtjaGFuZ2U6IGFjdGlvbn1gXG4gIC8vIGluIHRlcm1zIG9mIHRoZSBleGlzdGluZyBBUEkuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtrZXksIG5hbWVba2V5XV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBBIGRpZmZpY3VsdC10by1iZWxpZXZlLCBidXQgb3B0aW1pemVkIGludGVybmFsIGRpc3BhdGNoIGZ1bmN0aW9uIGZvclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4gIC8vIEJhY2tib25lIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgY2FzZSAyOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKTsgcmV0dXJuO1xuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nVG9baWRdID0gb2JqO1xuICAgICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIGNhbGxiYWNrID0gdGhpcztcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG4gIEV2ZW50cy51bmJpbmQgPSBFdmVudHMub2ZmO1xuXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cbiAgLy8gd2FudCBnbG9iYWwgXCJwdWJzdWJcIiBpbiBhIGNvbnZlbmllbnQgcGxhY2UuXG4gIF8uZXh0ZW5kKEJhY2tib25lLCBFdmVudHMpO1xuXG4gIC8vIEJhY2tib25lLk1vZGVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbiAgLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXG4gIC8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuICAvLyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBhbmQgYXNzaWduZWQgZm9yIHlvdS5cbiAgdmFyIE1vZGVsID0gQmFja2JvbmUuTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgnYycpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgbW9kZWwncyBgYXR0cmlidXRlc2Agb2JqZWN0LlxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQgLS0gYnV0IG92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWRcbiAgICAvLyBjdXN0b20gc3luY2luZyBzZW1hbnRpY3MgZm9yICp0aGlzKiBwYXJ0aWN1bGFyIG1vZGVsLlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgZXNjYXBlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICByZXR1cm4gXy5lc2NhcGUodGhpcy5nZXQoYXR0cikpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdW5zZXQgICAgICAgICAgID0gb3B0aW9ucy51bnNldDtcbiAgICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgY2hhbmdlcyAgICAgICAgID0gW107XG4gICAgICBjaGFuZ2luZyAgICAgICAgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XG5cbiAgICAgIGlmICghY2hhbmdpbmcpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XG5cbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIGBpZGAuXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xuXG4gICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gWW91IG1pZ2h0IGJlIHdvbmRlcmluZyB3aHkgdGhlcmUncyBhIGB3aGlsZWAgbG9vcCBoZXJlLiBDaGFuZ2VzIGNhblxuICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCB2b2lkIDAsIF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB7dW5zZXQ6IHRydWV9KSk7XG4gICAgfSxcblxuICAgIC8vIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGBcImNoYW5nZVwiYCBldmVudC5cbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhXy5pc0VtcHR5KHRoaXMuY2hhbmdlZCk7XG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAvLyBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAvLyBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgIC8vIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gXy5jbG9uZSh0aGlzLmNoYW5nZWQpIDogZmFsc2U7XG4gICAgICB2YXIgdmFsLCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sICh2YWwgPSBkaWZmW2F0dHJdKSkpIGNvbnRpbnVlO1xuICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgIC8vIG1vZGVsIGRpZmZlcnMgZnJvbSBpdHMgY3VycmVudCBhdHRyaWJ1dGVzLCB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbixcbiAgICAvLyB0cmlnZ2VyaW5nIGEgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzLCBhbmQgc3luYyB0aGUgbW9kZWwgdG8gdGhlIHNlcnZlci5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcbiAgICAvLyBzdGF0ZSB3aWxsIGJlIGBzZXRgIGFnYWluLlxuICAgIHNhdmU6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7dmFsaWRhdGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xuICAgICAgLy8gYHNldChhdHRyKS5zYXZlKG51bGwsIG9wdHMpYCB3aXRoIHZhbGlkYXRpb24uIE90aGVyd2lzZSwgY2hlY2sgaWZcbiAgICAgIC8vIHRoZSBtb2RlbCB3aWxsIGJlIHZhbGlkIHdoZW4gdGhlIGF0dHJpYnV0ZXMsIGlmIGFueSwgYXJlIHNldC5cbiAgICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGlmICghdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXG4gICAgICBpZiAoYXR0cnMgJiYgb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoYXR0cnMgfHwge30sIHNlcnZlckF0dHJzKTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIG1ldGhvZCA9IHRoaXMuaXNOZXcoKSA/ICdjcmVhdGUnIDogKG9wdGlvbnMucGF0Y2ggPyAncGF0Y2gnIDogJ3VwZGF0ZScpO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xuICAgICAgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG5cbiAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQgfHwgbW9kZWwuaXNOZXcoKSkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMud2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC8oW15cXC9dKSQvLCAnJDEvJykgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pZCk7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gdGhlIGhhc2ggb2YgYXR0cmlidXRlcyB0byBiZSBgc2V0YCBvblxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBBIG1vZGVsIGlzIG5ldyBpZiBpdCBoYXMgbmV2ZXIgYmVlbiBzYXZlZCB0byB0aGUgc2VydmVyLCBhbmQgbGFja3MgYW4gaWQuXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgXy5leHRlbmQob3B0aW9ucyB8fCB7fSwgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnZhbGlkYXRlIHx8ICF0aGlzLnZhbGlkYXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xuICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cbiAgdmFyIG1vZGVsTWV0aG9kcyA9IFsna2V5cycsICd2YWx1ZXMnLCAncGFpcnMnLCAnaW52ZXJ0JywgJ3BpY2snLCAnb21pdCddO1xuXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxuICBfLmVhY2gobW9kZWxNZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBNb2RlbC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsYWdvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUHJveHkgYEJhY2tib25lLnN5bmNgIGJ5IGRlZmF1bHQuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgXy5leHRlbmQoe21lcmdlOiBmYWxzZX0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogXy5jbG9uZShtb2RlbHMpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHZhciBpLCBsLCBpbmRleCwgbW9kZWw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFttb2RlbC5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIGEgY29sbGVjdGlvbiBieSBgc2V0YC1pbmcgYSBuZXcgbGlzdCBvZiBtb2RlbHMsIGFkZGluZyBuZXcgb25lcyxcbiAgICAvLyByZW1vdmluZyBtb2RlbHMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQsIGFuZCBtZXJnaW5nIG1vZGVscyB0aGF0XG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXG4gICAgLy8gdGhlIGNvcmUgb3BlcmF0aW9uIGZvciB1cGRhdGluZyB0aGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IF8uY2xvbmUobW9kZWxzKTtcbiAgICAgIHZhciBpLCBsLCBpZCwgbW9kZWwsIGF0dHJzLCBleGlzdGluZywgc29ydDtcbiAgICAgIHZhciBhdCA9IG9wdGlvbnMuYXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIHNvcnRhYmxlID0gdGhpcy5jb21wYXJhdG9yICYmIChhdCA9PSBudWxsKSAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgdmFyIHNvcnRBdHRyID0gXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcbiAgICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xuICAgICAgdmFyIGFkZCA9IG9wdGlvbnMuYWRkLCBtZXJnZSA9IG9wdGlvbnMubWVyZ2UsIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgICAgdmFyIG9yZGVyID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmUgPyBbXSA6IGZhbHNlO1xuXG4gICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAvLyBmcm9tIGJlaW5nIGFkZGVkLlxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXR0cnMgPSBtb2RlbHNbaV0gfHwge307XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gYXR0cnNbdGFyZ2V0TW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cbiAgICAgICAgaWYgKGV4aXN0aW5nID0gdGhpcy5nZXQoaWQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92ZSkgbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSA9IHRydWU7XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzID09PSBtb2RlbCA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBhdHRycztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcnNlKSBhdHRycyA9IGV4aXN0aW5nLnBhcnNlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQgJiYgZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cikpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3LCB2YWxpZCBtb2RlbCwgcHVzaCBpdCB0byB0aGUgYHRvQWRkYCBsaXN0LlxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICB0aGlzLl9hZGRSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IGFkZCBtdWx0aXBsZSBtb2RlbHMgd2l0aCB0aGUgc2FtZSBgaWRgLlxuICAgICAgICBtb2RlbCA9IGV4aXN0aW5nIHx8IG1vZGVsO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpIG9yZGVyLnB1c2gobW9kZWwpO1xuICAgICAgICBtb2RlbE1hcFttb2RlbC5pZF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgbm9uZXhpc3RlbnQgbW9kZWxzIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICBpZiAoIW1vZGVsTWFwWyhtb2RlbCA9IHRoaXMubW9kZWxzW2ldKS5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b0FkZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShhdCArIGksIDAsIHRvQWRkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9yZGVyKSB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBvcmRlcmVkTW9kZWxzID0gb3JkZXIgfHwgdG9BZGQ7XG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9yZGVyZWRNb2RlbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XG5cbiAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0IGV2ZW50cy5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRvQWRkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChtb2RlbCA9IHRvQWRkW2ldKS50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnQgfHwgKG9yZGVyICYmIG9yZGVyLmxlbmd0aCkpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIG1vZGVscyA9IHRoaXMuYWRkKG1vZGVscywgXy5leHRlbmQoe3NpbGVudDogdHJ1ZX0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiB0aGlzLmxlbmd0aH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogMH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KDApO1xuICAgICAgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHwgdGhpcy5fYnlJZFtvYmouaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIG1vZGVscyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzIG9mXG4gICAgLy8gYGZpbHRlcmAuXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xuICAgICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IHZvaWQgMCA6IFtdO1xuICAgICAgcmV0dXJuIHRoaXNbZmlyc3QgPyAnZmluZCcgOiAnZmlsdGVyJ10oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG1vZGVsLmdldChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3Igc2ltcGxlIGNhc2VzXG4gICAgLy8gb2YgYGZpbmRgLlxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGF0dHJzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSB0aGlzLnNvcnRCeSh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFBsdWNrIGFuIGF0dHJpYnV0ZSBmcm9tIGVhY2ggbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmludm9rZSh0aGlzLm1vZGVscywgJ2dldCcsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcbiAgICAvLyBjb2xsZWN0aW9uIHdoZW4gdGhleSBhcnJpdmUuIElmIGByZXNldDogdHJ1ZWAgaXMgcGFzc2VkLCB0aGUgcmVzcG9uc2VcbiAgICAvLyBkYXRhIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGByZXNldGAgbWV0aG9kIGluc3RlYWQgb2YgYHNldGAuXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XG4gICAgICAgIGNvbGxlY3Rpb25bbWV0aG9kXShyZXNwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MoY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gaW1tZWRpYXRlbHksIHVubGVzcyBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgLy8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBhZ3JlZS5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGlmICghKG1vZGVsID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndhaXQpIGNvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHJldHVybiBhdHRycztcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5fYnlJZFttb2RlbC5jaWRdID0gbW9kZWw7XG4gICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgIGlmICghbW9kZWwuY29sbGVjdGlvbikgbW9kZWwuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmIChldmVudCA9PT0gJ2Rlc3Ryb3knKSB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLnByZXZpb3VzKG1vZGVsLmlkQXR0cmlidXRlKV07XG4gICAgICAgIGlmIChtb2RlbC5pZCAhPSBudWxsKSB0aGlzLl9ieUlkW21vZGVsLmlkXSA9IG1vZGVsO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxuICAvLyA5MCUgb2YgdGhlIGNvcmUgdXNlZnVsbmVzcyBvZiBCYWNrYm9uZSBDb2xsZWN0aW9ucyBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZFxuICAvLyByaWdodCBoZXJlOlxuICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXG4gICAgJ2luamVjdCcsICdyZWR1Y2VSaWdodCcsICdmb2xkcicsICdmaW5kJywgJ2RldGVjdCcsICdmaWx0ZXInLCAnc2VsZWN0JyxcbiAgICAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsICdpbmNsdWRlJywgJ2NvbnRhaW5zJywgJ2ludm9rZScsXG4gICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICd0YWlsJywgJ2Ryb3AnLCAnbGFzdCcsICd3aXRob3V0JywgJ2RpZmZlcmVuY2UnLCAnaW5kZXhPZicsICdzaHVmZmxlJyxcbiAgICAnbGFzdEluZGV4T2YnLCAnaXNFbXB0eScsICdjaGFpbicsICdzYW1wbGUnXTtcblxuICAvLyBNaXggaW4gZWFjaCBVbmRlcnNjb3JlIG1ldGhvZCBhcyBhIHByb3h5IHRvIGBDb2xsZWN0aW9uI21vZGVsc2AuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm1vZGVscyk7XG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXMubW9kZWxzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gQmFja2JvbmUgVmlld3MgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXG4gIC8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuICAvLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XG4gIC8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuICAvLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuICAvLyBDcmVhdGluZyBhIEJhY2tib25lLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gXy51bmlxdWVJZCgndmlldycpO1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cbiAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cbiAgdmFyIHZpZXdPcHRpb25zID0gWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2lkJywgJ2F0dHJpYnV0ZXMnLCAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJ107XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChWaWV3LnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyAqKnJlbmRlcioqIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAvLyB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSksIGluY2x1ZGluZyBldmVudFxuICAgIC8vIHJlLWRlbGVnYXRpb24uXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLiRlbCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWxlbWVudCA6IEJhY2tib25lLiQoZWxlbWVudCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICBpZiAoZGVsZWdhdGUgIT09IGZhbHNlKSB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxuICAgIC8vIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV07XG4gICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZWwub24oZXZlbnROYW1lLCBzZWxlY3RvciwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgd2l0aCBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIEJhY2tib25lIHZpZXdzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSBfLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgdmFyICRlbCA9IEJhY2tib25lLiQoJzwnICsgXy5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKSArICc+JykuYXR0cihhdHRycyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgkZWwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChfLnJlc3VsdCh0aGlzLCAnZWwnKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5zeW5jXG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGNoYW5nZSB0aGUgbWFubmVyIGluIHdoaWNoIEJhY2tib25lIHBlcnNpc3RzXG4gIC8vIG1vZGVscyB0byB0aGUgc2VydmVyLiBZb3Ugd2lsbCBiZSBwYXNzZWQgdGhlIHR5cGUgb2YgcmVxdWVzdCwgYW5kIHRoZVxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxuICAvLyB0byB0aGUgbW9kZWwncyBgdXJsKClgLiBTb21lIHBvc3NpYmxlIGN1c3RvbWl6YXRpb25zIGNvdWxkIGJlOlxuICAvL1xuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cbiAgLy8gKiBTZW5kIHVwIHRoZSBtb2RlbHMgYXMgWE1MIGluc3RlYWQgb2YgSlNPTi5cbiAgLy8gKiBQZXJzaXN0IG1vZGVscyB2aWEgV2ViU29ja2V0cyBpbnN0ZWFkIG9mIEFqYXguXG4gIC8vXG4gIC8vIFR1cm4gb24gYEJhY2tib25lLmVtdWxhdGVIVFRQYCBpbiBvcmRlciB0byBzZW5kIGBQVVRgIGFuZCBgREVMRVRFYCByZXF1ZXN0c1xuICAvLyBhcyBgUE9TVGAsIHdpdGggYSBgX21ldGhvZGAgcGFyYW1ldGVyIGNvbnRhaW5pbmcgdGhlIHRydWUgSFRUUCBtZXRob2QsXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcbiAgLy8gaW5zdGVhZCBvZiBgYXBwbGljYXRpb24vanNvbmAgd2l0aCB0aGUgbW9kZWwgaW4gYSBwYXJhbSBuYW1lZCBgbW9kZWxgLlxuICAvLyBVc2VmdWwgd2hlbiBpbnRlcmZhY2luZyB3aXRoIHNlcnZlci1zaWRlIGxhbmd1YWdlcyBsaWtlICoqUEhQKiogdGhhdCBtYWtlXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxuICBCYWNrYm9uZS5zeW5jID0gZnVuY3Rpb24obWV0aG9kLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gbWV0aG9kTWFwW21ldGhvZF07XG5cbiAgICAvLyBEZWZhdWx0IG9wdGlvbnMsIHVubGVzcyBzcGVjaWZpZWQuXG4gICAgXy5kZWZhdWx0cyhvcHRpb25zIHx8IChvcHRpb25zID0ge30pLCB7XG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXG4gICAgICBlbXVsYXRlSlNPTjogQmFja2JvbmUuZW11bGF0ZUpTT05cbiAgICB9KTtcblxuICAgIC8vIERlZmF1bHQgSlNPTi1yZXF1ZXN0IG9wdGlvbnMuXG4gICAgdmFyIHBhcmFtcyA9IHt0eXBlOiB0eXBlLCBkYXRhVHlwZTogJ2pzb24nfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSBVUkwuXG4gICAgaWYgKCFvcHRpb25zLnVybCkge1xuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PSBudWxsICYmIG1vZGVsICYmIChtZXRob2QgPT09ICdjcmVhdGUnIHx8IG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHwgbWV0aG9kID09PSAncGF0Y2gnKSkge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLmNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcbiAgICB9XG5cbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcbiAgICAvLyBBbmQgYW4gYFgtSFRUUC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgICBpZiAob3B0aW9ucy5lbXVsYXRlSFRUUCAmJiAodHlwZSA9PT0gJ1BVVCcgfHwgdHlwZSA9PT0gJ0RFTEVURScgfHwgdHlwZSA9PT0gJ1BBVENIJykpIHtcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xuICAgICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHBhcmFtcy5kYXRhLl9tZXRob2QgPSB0eXBlO1xuICAgICAgdmFyIGJlZm9yZVNlbmQgPSBvcHRpb25zLmJlZm9yZVNlbmQ7XG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnLCB0eXBlKTtcbiAgICAgICAgaWYgKGJlZm9yZVNlbmQpIHJldHVybiBiZWZvcmVTZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdHRVQnICYmICFvcHRpb25zLmVtdWxhdGVKU09OKSB7XG4gICAgICBwYXJhbXMucHJvY2Vzc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBzZW5kaW5nIGEgYFBBVENIYCByZXF1ZXN0LCBhbmQgd2UncmUgaW4gYW4gb2xkIEludGVybmV0IEV4cGxvcmVyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxuICAgIC8vIGZvciBYSFIgaW5zdGVhZC4gUmVtb3ZlIHRoaXMgbGluZSB3aGVuIGpRdWVyeSBzdXBwb3J0cyBgUEFUQ0hgIG9uIElFOC5cbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdQQVRDSCcgJiYgbm9YaHJQYXRjaCkge1xuICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgYW55IEFqYXggb3B0aW9ucy5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xuICAgIG1vZGVsLnRyaWdnZXIoJ3JlcXVlc3QnLCBtb2RlbCwgeGhyLCBvcHRpb25zKTtcbiAgICByZXR1cm4geGhyO1xuICB9O1xuXG4gIHZhciBub1hoclBhdGNoID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXG4gICAgICAhKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiAobmV3IFhNTEh0dHBSZXF1ZXN0KS5kaXNwYXRjaEV2ZW50KTtcblxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG1ldGhvZE1hcCA9IHtcbiAgICAnY3JlYXRlJzogJ1BPU1QnLFxuICAgICd1cGRhdGUnOiAnUFVUJyxcbiAgICAncGF0Y2gnOiAgJ1BBVENIJyxcbiAgICAnZGVsZXRlJzogJ0RFTEVURScsXG4gICAgJ3JlYWQnOiAgICdHRVQnXG4gIH07XG5cbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBpZiB5b3UnZCBsaWtlIHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5LlxuICBCYWNrYm9uZS5hamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEJhY2tib25lLlJvdXRlclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxuICAvLyBtYXRjaGVkLiBDcmVhdGluZyBhIG5ldyBvbmUgc2V0cyBpdHMgYHJvdXRlc2AgaGFzaCwgaWYgbm90IHNldCBzdGF0aWNhbGx5LlxuICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgaWYgKG9wdGlvbnMucm91dGVzKSB0aGlzLnJvdXRlcyA9IG9wdGlvbnMucm91dGVzO1xuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2c7XG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFJvdXRlci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAgLy8gTWFudWFsbHkgYmluZCBhIHNpbmdsZSBuYW1lZCByb3V0ZSB0byBhIGNhbGxiYWNrLiBGb3IgZXhhbXBsZTpcbiAgICAvL1xuICAgIC8vICAgICB0aGlzLnJvdXRlKCdzZWFyY2gvOnF1ZXJ5L3A6bnVtJywgJ3NlYXJjaCcsIGZ1bmN0aW9uKHF1ZXJ5LCBudW0pIHtcbiAgICAvLyAgICAgICAuLi5cbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gdGhpc1tuYW1lXTtcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5yb3V0ZShyb3V0ZSwgZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCk7XG4gICAgICAgIHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzKTtcbiAgICAgICAgcm91dGVyLnRyaWdnZXIuYXBwbHkocm91dGVyLCBbJ3JvdXRlOicgKyBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeGVjdXRlIGEgcm91dGUgaGFuZGxlciB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLiAgVGhpcyBpcyBhblxuICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbGUgcHJveHkgdG8gYEJhY2tib25lLmhpc3RvcnlgIHRvIHNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgQmFja2JvbmUuaGlzdG9yeS5uYXZpZ2F0ZShmcmFnbWVudCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEJhY2tib25lLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xuICAgICAgdGhpcy5yb3V0ZXMgPSBfLnJlc3VsdCh0aGlzLCAncm91dGVzJyk7XG4gICAgICB2YXIgcm91dGUsIHJvdXRlcyA9IF8ua2V5cyh0aGlzLnJvdXRlcyk7XG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGUsIHRoaXMucm91dGVzW3JvdXRlXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5hbWVkUGFyYW0sIGZ1bmN0aW9uKG1hdGNoLCBvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gbWF0Y2ggOiAnKFteLz9dKyknO1xuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyhbXj9dKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICcoPzpcXFxcPyhbXFxcXHNcXFxcU10qKSk/JCcpO1xuICAgIH0sXG5cbiAgICAvLyBHaXZlbiBhIHJvdXRlLCBhbmQgYSBVUkwgZnJhZ21lbnQgdGhhdCBpdCBtYXRjaGVzLCByZXR1cm4gdGhlIGFycmF5IG9mXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgYG51bGxgIHRvIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyIGJlaGF2aW9yLlxuICAgIF9leHRyYWN0UGFyYW1ldGVyczogZnVuY3Rpb24ocm91dGUsIGZyYWdtZW50KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XG4gICAgICByZXR1cm4gXy5tYXAocGFyYW1zLCBmdW5jdGlvbihwYXJhbSwgaSkge1xuICAgICAgICAvLyBEb24ndCBkZWNvZGUgdGhlIHNlYXJjaCBwYXJhbXMuXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBwYXJhbSA/IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSkgOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIEJhY2tib25lLkhpc3RvcnlcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEhhbmRsZXMgY3Jvc3MtYnJvd3NlciBoaXN0b3J5IG1hbmFnZW1lbnQsIGJhc2VkIG9uIGVpdGhlclxuICAvLyBbcHVzaFN0YXRlXShodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2hpc3RvcnkuaHRtbCkgYW5kIHJlYWwgVVJMcywgb3JcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcbiAgLy8gYW5kIFVSTCBmcmFnbWVudHMuIElmIHRoZSBicm93c2VyIHN1cHBvcnRzIG5laXRoZXIgKG9sZCBJRSwgbmF0Y2gpLFxuICAvLyBmYWxscyBiYWNrIHRvIHBvbGxpbmcuXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfLmJpbmRBbGwodGhpcywgJ2NoZWNrVXJsJyk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBgSGlzdG9yeWAgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICB0aGlzLmhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgYSBsZWFkaW5nIGhhc2gvc2xhc2ggYW5kIHRyYWlsaW5nIHNwYWNlLlxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcy5cbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgZGV0ZWN0aW5nIE1TSUUuXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciByZW1vdmluZyBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9bXlxcL10kLywgJyQmLycpID09PSB0aGlzLnJvb3Q7XG4gICAgfSxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3cpIHtcbiAgICAgIHZhciBtYXRjaCA9ICh3aW5kb3cgfHwgdGhpcykubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8ICF0aGlzLl93YW50c0hhc2hDaGFuZ2UgfHwgZm9yY2VQdXNoU3RhdGUpIHtcbiAgICAgICAgICBmcmFnbWVudCA9IGRlY29kZVVSSSh0aGlzLmxvY2F0aW9uLnBhdGhuYW1lICsgdGhpcy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xuICAgICAgICAgIGlmICghZnJhZ21lbnQuaW5kZXhPZihyb290KSkgZnJhZ21lbnQgPSBmcmFnbWVudC5zbGljZShyb290Lmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFwiKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XG4gICAgICAvLyBJcyBwdXNoU3RhdGUgZGVzaXJlZCAuLi4gaXMgaXQgYXZhaWxhYmxlP1xuICAgICAgdGhpcy5vcHRpb25zICAgICAgICAgID0gXy5leHRlbmQoe3Jvb3Q6ICcvJ30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xuICAgICAgdmFyIGZyYWdtZW50ICAgICAgICAgID0gdGhpcy5nZXRGcmFnbWVudCgpO1xuICAgICAgdmFyIGRvY01vZGUgICAgICAgICAgID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgdmFyIG9sZElFICAgICAgICAgICAgID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICBpZiAob2xkSUUgJiYgdGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IEJhY2tib25lLiQoJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgdGFiaW5kZXg9XCItMVwiPicpO1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGZyYW1lLmhpZGUoKS5hcHBlbmRUbygnYm9keScpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZnJhZ21lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSdyZSB1c2luZyBwdXNoU3RhdGUgb3IgaGFzaGVzLCBhbmQgd2hldGhlclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcbiAgICAgIC8vIG9wZW5lZCBieSBhIG5vbi1wdXNoU3RhdGUgYnJvd3Nlci5cbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZSh0aGlzLnJvb3QgKyAnIycgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgYXMgYnJvd3NlciB3aWxsIGRvIHJlZGlyZWN0IHRvIG5ldyB1cmxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBPciBpZiB3ZSd2ZSBzdGFydGVkIG91dCB3aXRoIGEgaGFzaC1iYXNlZCByb3V0ZSwgYnV0IHdlJ3JlIGN1cnJlbnRseVxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSAmJiB0aGlzLmF0Um9vdCgpICYmIGxvYy5oYXNoKSB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNpbGVudCkgcmV0dXJuIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBEaXNhYmxlIEJhY2tib25lLmhpc3RvcnksIHBlcmhhcHMgdGVtcG9yYXJpbHkuIE5vdCB1c2VmdWwgaW4gYSByZWFsIGFwcCxcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLiQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCkub2ZmKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcbiAgICAgIHRoaXMubG9hZFVybCgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRlbXB0IHRvIGxvYWQgdGhlIGN1cnJlbnQgVVJMIGZyYWdtZW50LiBJZiBhIHJvdXRlIHN1Y2NlZWRzIHdpdGggYVxuICAgIC8vIG1hdGNoLCByZXR1cm5zIGB0cnVlYC4gSWYgbm8gZGVmaW5lZCByb3V0ZXMgbWF0Y2hlcyB0aGUgZnJhZ21lbnQsXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxuICAgIGxvYWRVcmw6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyLnJvdXRlLnRlc3QoZnJhZ21lbnQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsYmFjayhmcmFnbWVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBTYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGFzaCBoaXN0b3J5LCBvciByZXBsYWNlIHRoZSBVUkwgc3RhdGUgaWYgdGhlXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xuICAgIC8vIHRoZSBmcmFnbWVudCBpbiBhZHZhbmNlLlxuICAgIC8vXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxuICAgIC8vIHJvdXRlIGNhbGxiYWNrIGJlIGZpcmVkIChub3QgdXN1YWxseSBkZXNpcmFibGUpLCBvciBgcmVwbGFjZTogdHJ1ZWAsIGlmXG4gICAgLy8geW91IHdpc2ggdG8gbW9kaWZ5IHRoZSBjdXJyZW50IFVSTCB3aXRob3V0IGFkZGluZyBhbiBlbnRyeSB0byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghSGlzdG9yeS5zdGFydGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSkgb3B0aW9ucyA9IHt0cmlnZ2VyOiAhIW9wdGlvbnN9O1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5yb290ICsgKGZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCB8fCAnJykpO1xuXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJyk7XG5cbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudCkgcmV0dXJuO1xuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICBpZiAoZnJhZ21lbnQgPT09ICcnICYmIHVybCAhPT0gJy8nKSB1cmwgPSB1cmwuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxuICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmhpc3Rvcnlbb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oe30sIGRvY3VtZW50LnRpdGxlLCB1cmwpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUhhc2godGhpcy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIGlmICh0aGlzLmlmcmFtZSAmJiAoZnJhZ21lbnQgIT09IHRoaXMuZ2V0RnJhZ21lbnQodGhpcy5nZXRIYXNoKHRoaXMuaWZyYW1lKSkpKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYoIW9wdGlvbnMucmVwbGFjZSkgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH07XG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcblxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgIGlmIChwcm90b1Byb3BzKSBfLmV4dGVuZChjaGlsZC5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwsIGNvbGxlY3Rpb24sIHJvdXRlciwgdmlldyBhbmQgaGlzdG9yeS5cbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcblxuICAvLyBUaHJvdyBhbiBlcnJvciB3aGVuIGEgVVJMIGlzIG5lZWRlZCwgYW5kIG5vbmUgaXMgc3VwcGxpZWQuXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBcInVybFwiIHByb3BlcnR5IG9yIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gIH07XG5cbiAgLy8gV3JhcCBhbiBvcHRpb25hbCBlcnJvciBjYWxsYmFjayB3aXRoIGEgZmFsbGJhY2sgZXJyb3IgZXZlbnQuXG4gIHZhciB3cmFwRXJyb3IgPSBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XG4gICAgb3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmU7XG5cbn0pKTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgQmFja2JvbmUgIT0gXCJ1bmRlZmluZWRcIiA/IEJhY2tib25lIDogd2luZG93LkJhY2tib25lKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbjsgdmFyIF9fYnJvd3NlcmlmeV9zaGltX3JlcXVpcmVfXz1yZXF1aXJlOyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUsIGRlZmluZSwgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18pIHtcbjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXNlIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvdXIgb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gRmFzdENsaWNrO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBGYXN0Q2xpY2suYXR0YWNoO1xuXHRcdG1vZHVsZS5leHBvcnRzLkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xuXHR9XG59KCkpO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBGYXN0Q2xpY2sgIT0gXCJ1bmRlZmluZWRcIiA/IEZhc3RDbGljayA6IHdpbmRvdy5GYXN0Q2xpY2spO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLyohIGpRdWVyeSB2MS4xMC4yIHwgKGMpIDIwMDUsIDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gfCBqcXVlcnkub3JnL2xpY2Vuc2Vcbi8vQCBzb3VyY2VNYXBwaW5nVVJMPWpxdWVyeS5taW4ubWFwXG4qL1xuKGZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPXR5cGVvZiB0LG89ZS5sb2NhdGlvbixhPWUuZG9jdW1lbnQscz1hLmRvY3VtZW50RWxlbWVudCxsPWUualF1ZXJ5LHU9ZS4kLGM9e30scD1bXSxmPVwiMS4xMC4yXCIsZD1wLmNvbmNhdCxoPXAucHVzaCxnPXAuc2xpY2UsbT1wLmluZGV4T2YseT1jLnRvU3RyaW5nLHY9Yy5oYXNPd25Qcm9wZXJ0eSxiPWYudHJpbSx4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyB4LmZuLmluaXQoZSx0LHIpfSx3PS9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSxUPS9cXFMrL2csQz0vXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csTj0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxrPS9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxFPS9eW1xcXSw6e31cXHNdKiQvLFM9Lyg/Ol58OnwsKSg/OlxccypcXFspKy9nLEE9L1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZyxqPS9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGQrXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpL2csRD0vXi1tcy0vLEw9Ly0oW1xcZGEtel0pL2dpLEg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSxxPWZ1bmN0aW9uKGUpeyhhLmFkZEV2ZW50TGlzdGVuZXJ8fFwibG9hZFwiPT09ZS50eXBlfHxcImNvbXBsZXRlXCI9PT1hLnJlYWR5U3RhdGUpJiYoXygpLHgucmVhZHkoKSl9LF89ZnVuY3Rpb24oKXthLmFkZEV2ZW50TGlzdGVuZXI/KGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixxLCExKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIscSwhMSkpOihhLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIscSksZS5kZXRhY2hFdmVudChcIm9ubG9hZFwiLHEpKX07eC5mbj14LnByb3RvdHlwZT17anF1ZXJ5OmYsY29uc3RydWN0b3I6eCxpbml0OmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvO2lmKCFlKXJldHVybiB0aGlzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihpPVwiPFwiPT09ZS5jaGFyQXQoMCkmJlwiPlwiPT09ZS5jaGFyQXQoZS5sZW5ndGgtMSkmJmUubGVuZ3RoPj0zP1tudWxsLGUsbnVsbF06Ti5leGVjKGUpLCFpfHwhaVsxXSYmbilyZXR1cm4hbnx8bi5qcXVlcnk/KG58fHIpLmZpbmQoZSk6dGhpcy5jb25zdHJ1Y3RvcihuKS5maW5kKGUpO2lmKGlbMV0pe2lmKG49biBpbnN0YW5jZW9mIHg/blswXTpuLHgubWVyZ2UodGhpcyx4LnBhcnNlSFRNTChpWzFdLG4mJm4ubm9kZVR5cGU/bi5vd25lckRvY3VtZW50fHxuOmEsITApKSxrLnRlc3QoaVsxXSkmJnguaXNQbGFpbk9iamVjdChuKSlmb3IoaSBpbiBuKXguaXNGdW5jdGlvbih0aGlzW2ldKT90aGlzW2ldKG5baV0pOnRoaXMuYXR0cihpLG5baV0pO3JldHVybiB0aGlzfWlmKG89YS5nZXRFbGVtZW50QnlJZChpWzJdKSxvJiZvLnBhcmVudE5vZGUpe2lmKG8uaWQhPT1pWzJdKXJldHVybiByLmZpbmQoZSk7dGhpcy5sZW5ndGg9MSx0aGlzWzBdPW99cmV0dXJuIHRoaXMuY29udGV4dD1hLHRoaXMuc2VsZWN0b3I9ZSx0aGlzfXJldHVybiBlLm5vZGVUeXBlPyh0aGlzLmNvbnRleHQ9dGhpc1swXT1lLHRoaXMubGVuZ3RoPTEsdGhpcyk6eC5pc0Z1bmN0aW9uKGUpP3IucmVhZHkoZSk6KGUuc2VsZWN0b3IhPT10JiYodGhpcy5zZWxlY3Rvcj1lLnNlbGVjdG9yLHRoaXMuY29udGV4dD1lLmNvbnRleHQpLHgubWFrZUFycmF5KGUsdGhpcykpfSxzZWxlY3RvcjpcIlwiLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gZy5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/dGhpcy50b0FycmF5KCk6MD5lP3RoaXNbdGhpcy5sZW5ndGgrZV06dGhpc1tlXX0scHVzaFN0YWNrOmZ1bmN0aW9uKGUpe3ZhciB0PXgubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGUpO3JldHVybiB0LnByZXZPYmplY3Q9dGhpcyx0LmNvbnRleHQ9dGhpcy5jb250ZXh0LHR9LGVhY2g6ZnVuY3Rpb24oZSx0KXtyZXR1cm4geC5lYWNoKHRoaXMsZSx0KX0scmVhZHk6ZnVuY3Rpb24oZSl7cmV0dXJuIHgucmVhZHkucHJvbWlzZSgpLmRvbmUoZSksdGhpc30sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZy5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmxlbmd0aCxuPStlKygwPmU/dDowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobj49MCYmdD5uP1t0aGlzW25dXTpbXSl9LG1hcDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soeC5tYXAodGhpcyxmdW5jdGlvbih0LG4pe3JldHVybiBlLmNhbGwodCxuLHQpfSkpfSxlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmV2T2JqZWN0fHx0aGlzLmNvbnN0cnVjdG9yKG51bGwpfSxwdXNoOmgsc29ydDpbXS5zb3J0LHNwbGljZTpbXS5zcGxpY2V9LHguZm4uaW5pdC5wcm90b3R5cGU9eC5mbix4LmV4dGVuZD14LmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBlLG4scixpLG8sYSxzPWFyZ3VtZW50c1swXXx8e30sbD0xLHU9YXJndW1lbnRzLmxlbmd0aCxjPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIHMmJihjPXMscz1hcmd1bWVudHNbMV18fHt9LGw9MiksXCJvYmplY3RcIj09dHlwZW9mIHN8fHguaXNGdW5jdGlvbihzKXx8KHM9e30pLHU9PT1sJiYocz10aGlzLC0tbCk7dT5sO2wrKylpZihudWxsIT0obz1hcmd1bWVudHNbbF0pKWZvcihpIGluIG8pZT1zW2ldLHI9b1tpXSxzIT09ciYmKGMmJnImJih4LmlzUGxhaW5PYmplY3Qocil8fChuPXguaXNBcnJheShyKSkpPyhuPyhuPSExLGE9ZSYmeC5pc0FycmF5KGUpP2U6W10pOmE9ZSYmeC5pc1BsYWluT2JqZWN0KGUpP2U6e30sc1tpXT14LmV4dGVuZChjLGEscikpOnIhPT10JiYoc1tpXT1yKSk7cmV0dXJuIHN9LHguZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKGYrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksbm9Db25mbGljdDpmdW5jdGlvbih0KXtyZXR1cm4gZS4kPT09eCYmKGUuJD11KSx0JiZlLmpRdWVyeT09PXgmJihlLmpRdWVyeT1sKSx4fSxpc1JlYWR5OiExLHJlYWR5V2FpdDoxLGhvbGRSZWFkeTpmdW5jdGlvbihlKXtlP3gucmVhZHlXYWl0Kys6eC5yZWFkeSghMCl9LHJlYWR5OmZ1bmN0aW9uKGUpe2lmKGU9PT0hMD8hLS14LnJlYWR5V2FpdDoheC5pc1JlYWR5KXtpZighYS5ib2R5KXJldHVybiBzZXRUaW1lb3V0KHgucmVhZHkpO3guaXNSZWFkeT0hMCxlIT09ITAmJi0teC5yZWFkeVdhaXQ+MHx8KG4ucmVzb2x2ZVdpdGgoYSxbeF0pLHguZm4udHJpZ2dlciYmeChhKS50cmlnZ2VyKFwicmVhZHlcIikub2ZmKFwicmVhZHlcIikpfX0saXNGdW5jdGlvbjpmdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT14LnR5cGUoZSl9LGlzQXJyYXk6QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJhcnJheVwiPT09eC50eXBlKGUpfSxpc1dpbmRvdzpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmZT09ZS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihlKXtyZXR1cm4haXNOYU4ocGFyc2VGbG9hdChlKSkmJmlzRmluaXRlKGUpfSx0eXBlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP2UrXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZT9jW3kuY2FsbChlKV18fFwib2JqZWN0XCI6dHlwZW9mIGV9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIG47aWYoIWV8fFwib2JqZWN0XCIhPT14LnR5cGUoZSl8fGUubm9kZVR5cGV8fHguaXNXaW5kb3coZSkpcmV0dXJuITE7dHJ5e2lmKGUuY29uc3RydWN0b3ImJiF2LmNhbGwoZSxcImNvbnN0cnVjdG9yXCIpJiYhdi5jYWxsKGUuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKSlyZXR1cm4hMX1jYXRjaChyKXtyZXR1cm4hMX1pZih4LnN1cHBvcnQub3duTGFzdClmb3IobiBpbiBlKXJldHVybiB2LmNhbGwoZSxuKTtmb3IobiBpbiBlKTtyZXR1cm4gbj09PXR8fHYuY2FsbChlLG4pfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0O2Zvcih0IGluIGUpcmV0dXJuITE7cmV0dXJuITB9LGVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKGUpfSxwYXJzZUhUTUw6ZnVuY3Rpb24oZSx0LG4pe2lmKCFlfHxcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gbnVsbDtcImJvb2xlYW5cIj09dHlwZW9mIHQmJihuPXQsdD0hMSksdD10fHxhO3ZhciByPWsuZXhlYyhlKSxpPSFuJiZbXTtyZXR1cm4gcj9bdC5jcmVhdGVFbGVtZW50KHJbMV0pXToocj14LmJ1aWxkRnJhZ21lbnQoW2VdLHQsaSksaSYmeChpKS5yZW1vdmUoKSx4Lm1lcmdlKFtdLHIuY2hpbGROb2RlcykpfSxwYXJzZUpTT046ZnVuY3Rpb24obil7cmV0dXJuIGUuSlNPTiYmZS5KU09OLnBhcnNlP2UuSlNPTi5wYXJzZShuKTpudWxsPT09bj9uOlwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj14LnRyaW0obiksbiYmRS50ZXN0KG4ucmVwbGFjZShBLFwiQFwiKS5yZXBsYWNlKGosXCJdXCIpLnJlcGxhY2UoUyxcIlwiKSkpP0Z1bmN0aW9uKFwicmV0dXJuIFwiK24pKCk6KHguZXJyb3IoXCJJbnZhbGlkIEpTT046IFwiK24pLHQpfSxwYXJzZVhNTDpmdW5jdGlvbihuKXt2YXIgcixpO2lmKCFufHxcInN0cmluZ1wiIT10eXBlb2YgbilyZXR1cm4gbnVsbDt0cnl7ZS5ET01QYXJzZXI/KGk9bmV3IERPTVBhcnNlcixyPWkucGFyc2VGcm9tU3RyaW5nKG4sXCJ0ZXh0L3htbFwiKSk6KHI9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpLHIuYXN5bmM9XCJmYWxzZVwiLHIubG9hZFhNTChuKSl9Y2F0Y2gobyl7cj10fXJldHVybiByJiZyLmRvY3VtZW50RWxlbWVudCYmIXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGh8fHguZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrbikscn0sbm9vcDpmdW5jdGlvbigpe30sZ2xvYmFsRXZhbDpmdW5jdGlvbih0KXt0JiZ4LnRyaW0odCkmJihlLmV4ZWNTY3JpcHR8fGZ1bmN0aW9uKHQpe2UuZXZhbC5jYWxsKGUsdCl9KSh0KX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoRCxcIm1zLVwiKS5yZXBsYWNlKEwsSCl9LG5vZGVOYW1lOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXQudG9Mb3dlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT0wLG89ZS5sZW5ndGgsYT1NKGUpO2lmKG4pe2lmKGEpe2Zvcig7bz5pO2krKylpZihyPXQuYXBwbHkoZVtpXSxuKSxyPT09ITEpYnJlYWt9ZWxzZSBmb3IoaSBpbiBlKWlmKHI9dC5hcHBseShlW2ldLG4pLHI9PT0hMSlicmVha31lbHNlIGlmKGEpe2Zvcig7bz5pO2krKylpZihyPXQuY2FsbChlW2ldLGksZVtpXSkscj09PSExKWJyZWFrfWVsc2UgZm9yKGkgaW4gZSlpZihyPXQuY2FsbChlW2ldLGksZVtpXSkscj09PSExKWJyZWFrO3JldHVybiBlfSx0cmltOmImJiFiLmNhbGwoXCJcXHVmZWZmXFx1MDBhMFwiKT9mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmIuY2FsbChlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjooZStcIlwiKS5yZXBsYWNlKEMsXCJcIil9LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuPXR8fFtdO3JldHVybiBudWxsIT1lJiYoTShPYmplY3QoZSkpP3gubWVyZ2UobixcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06ZSk6aC5jYWxsKG4sZSkpLG59LGluQXJyYXk6ZnVuY3Rpb24oZSx0LG4pe3ZhciByO2lmKHQpe2lmKG0pcmV0dXJuIG0uY2FsbCh0LGUsbik7Zm9yKHI9dC5sZW5ndGgsbj1uPzA+bj9NYXRoLm1heCgwLHIrbik6bjowO3I+bjtuKyspaWYobiBpbiB0JiZ0W25dPT09ZSlyZXR1cm4gbn1yZXR1cm4tMX0sbWVyZ2U6ZnVuY3Rpb24oZSxuKXt2YXIgcj1uLmxlbmd0aCxpPWUubGVuZ3RoLG89MDtpZihcIm51bWJlclwiPT10eXBlb2Ygcilmb3IoO3I+bztvKyspZVtpKytdPW5bb107ZWxzZSB3aGlsZShuW29dIT09dCllW2krK109bltvKytdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9W10sbz0wLGE9ZS5sZW5ndGg7Zm9yKG49ISFuO2E+bztvKyspcj0hIXQoZVtvXSxvKSxuIT09ciYmaS5wdXNoKGVbb10pO3JldHVybiBpfSxtYXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9MCxvPWUubGVuZ3RoLGE9TShlKSxzPVtdO2lmKGEpZm9yKDtvPmk7aSsrKXI9dChlW2ldLGksbiksbnVsbCE9ciYmKHNbcy5sZW5ndGhdPXIpO2Vsc2UgZm9yKGkgaW4gZSlyPXQoZVtpXSxpLG4pLG51bGwhPXImJihzW3MubGVuZ3RoXT1yKTtyZXR1cm4gZC5hcHBseShbXSxzKX0sZ3VpZDoxLHByb3h5OmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxvO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBuJiYobz1lW25dLG49ZSxlPW8pLHguaXNGdW5jdGlvbihlKT8ocj1nLmNhbGwoYXJndW1lbnRzLDIpLGk9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseShufHx0aGlzLHIuY29uY2F0KGcuY2FsbChhcmd1bWVudHMpKSl9LGkuZ3VpZD1lLmd1aWQ9ZS5ndWlkfHx4Lmd1aWQrKyxpKTp0fSxhY2Nlc3M6ZnVuY3Rpb24oZSxuLHIsaSxvLGEscyl7dmFyIGw9MCx1PWUubGVuZ3RoLGM9bnVsbD09cjtpZihcIm9iamVjdFwiPT09eC50eXBlKHIpKXtvPSEwO2ZvcihsIGluIHIpeC5hY2Nlc3MoZSxuLGwscltsXSwhMCxhLHMpfWVsc2UgaWYoaSE9PXQmJihvPSEwLHguaXNGdW5jdGlvbihpKXx8KHM9ITApLGMmJihzPyhuLmNhbGwoZSxpKSxuPW51bGwpOihjPW4sbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGMuY2FsbCh4KGUpLG4pfSkpLG4pKWZvcig7dT5sO2wrKyluKGVbbF0scixzP2k6aS5jYWxsKGVbbF0sbCxuKGVbbF0scikpKTtyZXR1cm4gbz9lOmM/bi5jYWxsKGUpOnU/bihlWzBdLHIpOmF9LG5vdzpmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfSxzd2FwOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYT17fTtmb3IobyBpbiB0KWFbb109ZS5zdHlsZVtvXSxlLnN0eWxlW29dPXRbb107aT1uLmFwcGx5KGUscnx8W10pO2ZvcihvIGluIHQpZS5zdHlsZVtvXT1hW29dO3JldHVybiBpfX0pLHgucmVhZHkucHJvbWlzZT1mdW5jdGlvbih0KXtpZighbilpZihuPXguRGVmZXJyZWQoKSxcImNvbXBsZXRlXCI9PT1hLnJlYWR5U3RhdGUpc2V0VGltZW91dCh4LnJlYWR5KTtlbHNlIGlmKGEuYWRkRXZlbnRMaXN0ZW5lcilhLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIscSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHEsITEpO2Vsc2V7YS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLHEpLGUuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixxKTt2YXIgcj0hMTt0cnl7cj1udWxsPT1lLmZyYW1lRWxlbWVudCYmYS5kb2N1bWVudEVsZW1lbnR9Y2F0Y2goaSl7fXImJnIuZG9TY3JvbGwmJmZ1bmN0aW9uIG8oKXtpZigheC5pc1JlYWR5KXt0cnl7ci5kb1Njcm9sbChcImxlZnRcIil9Y2F0Y2goZSl7cmV0dXJuIHNldFRpbWVvdXQobyw1MCl9XygpLHgucmVhZHkoKX19KCl9cmV0dXJuIG4ucHJvbWlzZSh0KX0seC5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe2NbXCJbb2JqZWN0IFwiK3QrXCJdXCJdPXQudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIE0oZSl7dmFyIHQ9ZS5sZW5ndGgsbj14LnR5cGUoZSk7cmV0dXJuIHguaXNXaW5kb3coZSk/ITE6MT09PWUubm9kZVR5cGUmJnQ/ITA6XCJhcnJheVwiPT09bnx8XCJmdW5jdGlvblwiIT09biYmKDA9PT10fHxcIm51bWJlclwiPT10eXBlb2YgdCYmdD4wJiZ0LTEgaW4gZSl9cj14KGEpLGZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLG8sYSxzLGwsdSxjLHAsZixkLGgsZyxtLHksdixiPVwic2l6emxlXCIrLW5ldyBEYXRlLHc9ZS5kb2N1bWVudCxUPTAsQz0wLE49c3QoKSxrPXN0KCksRT1zdCgpLFM9ITEsQT1mdW5jdGlvbihlLHQpe3JldHVybiBlPT09dD8oUz0hMCwwKTowfSxqPXR5cGVvZiB0LEQ9MTw8MzEsTD17fS5oYXNPd25Qcm9wZXJ0eSxIPVtdLHE9SC5wb3AsXz1ILnB1c2gsTT1ILnB1c2gsTz1ILnNsaWNlLEY9SC5pbmRleE9mfHxmdW5jdGlvbihlKXt2YXIgdD0wLG49dGhpcy5sZW5ndGg7Zm9yKDtuPnQ7dCsrKWlmKHRoaXNbdF09PT1lKXJldHVybiB0O3JldHVybi0xfSxCPVwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixQPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixSPVwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsVz1SLnJlcGxhY2UoXCJ3XCIsXCJ3I1wiKSwkPVwiXFxcXFtcIitQK1wiKihcIitSK1wiKVwiK1ArXCIqKD86KFsqXiR8IX5dPz0pXCIrUCtcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIitXK1wiKXwpfClcIitQK1wiKlxcXFxdXCIsST1cIjooXCIrUitcIikoPzpcXFxcKCgoWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiskLnJlcGxhY2UoMyw4KStcIikqKXwuKilcXFxcKXwpXCIsej1SZWdFeHAoXCJeXCIrUCtcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrUCtcIiskXCIsXCJnXCIpLFg9UmVnRXhwKFwiXlwiK1ArXCIqLFwiK1ArXCIqXCIpLFU9UmVnRXhwKFwiXlwiK1ArXCIqKFs+K35dfFwiK1ArXCIpXCIrUCtcIipcIiksVj1SZWdFeHAoUCtcIipbK35dXCIpLFk9UmVnRXhwKFwiPVwiK1ArXCIqKFteXFxcXF0nXFxcIl0qKVwiK1ArXCIqXFxcXF1cIixcImdcIiksSj1SZWdFeHAoSSksRz1SZWdFeHAoXCJeXCIrVytcIiRcIiksUT17SUQ6UmVnRXhwKFwiXiMoXCIrUitcIilcIiksQ0xBU1M6UmVnRXhwKFwiXlxcXFwuKFwiK1IrXCIpXCIpLFRBRzpSZWdFeHAoXCJeKFwiK1IucmVwbGFjZShcIndcIixcIncqXCIpK1wiKVwiKSxBVFRSOlJlZ0V4cChcIl5cIiskKSxQU0VVRE86UmVnRXhwKFwiXlwiK0kpLENISUxEOlJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrUCtcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK1ArXCIqKD86KFsrLV18KVwiK1ArXCIqKFxcXFxkKyl8KSlcIitQK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpSZWdFeHAoXCJeKD86XCIrQitcIikkXCIsXCJpXCIpLG5lZWRzQ29udGV4dDpSZWdFeHAoXCJeXCIrUCtcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIrUCtcIiooKD86LVxcXFxkKT9cXFxcZCopXCIrUCtcIipcXFxcKXwpKD89W14tXXwkKVwiLFwiaVwiKX0sSz0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFo9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sZXQ9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSx0dD0vXmhcXGQkL2ksbnQ9Lyd8XFxcXC9nLHJ0PVJlZ0V4cChcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiK1ArXCI/fChcIitQK1wiKXwuKVwiLFwiaWdcIiksaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVwiMHhcIit0LTY1NTM2O3JldHVybiByIT09cnx8bj90OjA+cj9TdHJpbmcuZnJvbUNoYXJDb2RlKHIrNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8cj4+MTAsNTYzMjB8MTAyMyZyKX07dHJ5e00uYXBwbHkoSD1PLmNhbGwody5jaGlsZE5vZGVzKSx3LmNoaWxkTm9kZXMpLEhbdy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2gob3Qpe009e2FwcGx5OkgubGVuZ3RoP2Z1bmN0aW9uKGUsdCl7Xy5hcHBseShlLE8uY2FsbCh0KSl9OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5sZW5ndGgscj0wO3doaWxlKGVbbisrXT10W3IrK10pO2UubGVuZ3RoPW4tMX19fWZ1bmN0aW9uIGF0KGUsdCxuLGkpe3ZhciBvLGEscyxsLHUsYyxkLG0seSx4O2lmKCh0P3Qub3duZXJEb2N1bWVudHx8dDp3KSE9PWYmJnAodCksdD10fHxmLG49bnx8W10sIWV8fFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiBuO2lmKDEhPT0obD10Lm5vZGVUeXBlKSYmOSE9PWwpcmV0dXJuW107aWYoaCYmIWkpe2lmKG89Wi5leGVjKGUpKWlmKHM9b1sxXSl7aWYoOT09PWwpe2lmKGE9dC5nZXRFbGVtZW50QnlJZChzKSwhYXx8IWEucGFyZW50Tm9kZSlyZXR1cm4gbjtpZihhLmlkPT09cylyZXR1cm4gbi5wdXNoKGEpLG59ZWxzZSBpZih0Lm93bmVyRG9jdW1lbnQmJihhPXQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChzKSkmJnYodCxhKSYmYS5pZD09PXMpcmV0dXJuIG4ucHVzaChhKSxufWVsc2V7aWYob1syXSlyZXR1cm4gTS5hcHBseShuLHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkpLG47aWYoKHM9b1szXSkmJnIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBNLmFwcGx5KG4sdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHMpKSxufWlmKHIucXNhJiYoIWd8fCFnLnRlc3QoZSkpKXtpZihtPWQ9Yix5PXQseD05PT09bCYmZSwxPT09bCYmXCJvYmplY3RcIiE9PXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7Yz1tdChlKSwoZD10LmdldEF0dHJpYnV0ZShcImlkXCIpKT9tPWQucmVwbGFjZShudCxcIlxcXFwkJlwiKTp0LnNldEF0dHJpYnV0ZShcImlkXCIsbSksbT1cIltpZD0nXCIrbStcIiddIFwiLHU9Yy5sZW5ndGg7d2hpbGUodS0tKWNbdV09bSt5dChjW3VdKTt5PVYudGVzdChlKSYmdC5wYXJlbnROb2RlfHx0LHg9Yy5qb2luKFwiLFwiKX1pZih4KXRyeXtyZXR1cm4gTS5hcHBseShuLHkucXVlcnlTZWxlY3RvckFsbCh4KSksbn1jYXRjaChUKXt9ZmluYWxseXtkfHx0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIGt0KGUucmVwbGFjZSh6LFwiJDFcIiksdCxuLGkpfWZ1bmN0aW9uIHN0KCl7dmFyIGU9W107ZnVuY3Rpb24gdChuLHIpe3JldHVybiBlLnB1c2gobis9XCIgXCIpPm8uY2FjaGVMZW5ndGgmJmRlbGV0ZSB0W2Uuc2hpZnQoKV0sdFtuXT1yfXJldHVybiB0fWZ1bmN0aW9uIGx0KGUpe3JldHVybiBlW2JdPSEwLGV9ZnVuY3Rpb24gdXQoZSl7dmFyIHQ9Zi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXtyZXR1cm4hIWUodCl9Y2F0Y2gobil7cmV0dXJuITF9ZmluYWxseXt0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSx0PW51bGx9fWZ1bmN0aW9uIGN0KGUsdCl7dmFyIG49ZS5zcGxpdChcInxcIikscj1lLmxlbmd0aDt3aGlsZShyLS0pby5hdHRySGFuZGxlW25bcl1dPXR9ZnVuY3Rpb24gcHQoZSx0KXt2YXIgbj10JiZlLHI9biYmMT09PWUubm9kZVR5cGUmJjE9PT10Lm5vZGVUeXBlJiYofnQuc291cmNlSW5kZXh8fEQpLSh+ZS5zb3VyY2VJbmRleHx8RCk7aWYocilyZXR1cm4gcjtpZihuKXdoaWxlKG49bi5uZXh0U2libGluZylpZihuPT09dClyZXR1cm4tMTtyZXR1cm4gZT8xOi0xfWZ1bmN0aW9uIGZ0KGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09biYmdC50eXBlPT09ZX19ZnVuY3Rpb24gZHQoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oXCJpbnB1dFwiPT09bnx8XCJidXR0b25cIj09PW4pJiZ0LnR5cGU9PT1lfX1mdW5jdGlvbiBodChlKXtyZXR1cm4gbHQoZnVuY3Rpb24odCl7cmV0dXJuIHQ9K3QsbHQoZnVuY3Rpb24obixyKXt2YXIgaSxvPWUoW10sbi5sZW5ndGgsdCksYT1vLmxlbmd0aDt3aGlsZShhLS0pbltpPW9bYV1dJiYobltpXT0hKHJbaV09bltpXSkpfSl9KX1zPWF0LmlzWE1MPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJihlLm93bmVyRG9jdW1lbnR8fGUpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gdD9cIkhUTUxcIiE9PXQubm9kZU5hbWU6ITF9LHI9YXQuc3VwcG9ydD17fSxwPWF0LnNldERvY3VtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPWU/ZS5vd25lckRvY3VtZW50fHxlOncsaT1uLmRlZmF1bHRWaWV3O3JldHVybiBuIT09ZiYmOT09PW4ubm9kZVR5cGUmJm4uZG9jdW1lbnRFbGVtZW50PyhmPW4sZD1uLmRvY3VtZW50RWxlbWVudCxoPSFzKG4pLGkmJmkuYXR0YWNoRXZlbnQmJmkhPT1pLnRvcCYmaS5hdHRhY2hFdmVudChcIm9uYmVmb3JldW5sb2FkXCIsZnVuY3Rpb24oKXtwKCl9KSxyLmF0dHJpYnV0ZXM9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NOYW1lPVwiaVwiLCFlLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKX0pLHIuZ2V0RWxlbWVudHNCeVRhZ05hbWU9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwZW5kQ2hpbGQobi5jcmVhdGVDb21tZW50KFwiXCIpKSwhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPXV0KGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCIsZS5maXJzdENoaWxkLmNsYXNzTmFtZT1cImlcIiwyPT09ZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGh9KSxyLmdldEJ5SWQ9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGQuYXBwZW5kQ2hpbGQoZSkuaWQ9Yiwhbi5nZXRFbGVtZW50c0J5TmFtZXx8IW4uZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RofSksci5nZXRCeUlkPyhvLmZpbmQuSUQ9ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCE9PWomJmgpe3ZhciBuPXQuZ2V0RWxlbWVudEJ5SWQoZSk7cmV0dXJuIG4mJm4ucGFyZW50Tm9kZT9bbl06W119fSxvLmZpbHRlci5JRD1mdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UocnQsaXQpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKT09PXR9fSk6KGRlbGV0ZSBvLmZpbmQuSUQsby5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKHJ0LGl0KTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSE9PWomJmUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO3JldHVybiBuJiZuLnZhbHVlPT09dH19KSxvLmZpbmQuVEFHPXIuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdHlwZW9mIG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUhPT1qP24uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk6dH06ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9MCxvPXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7aWYoXCIqXCI9PT1lKXt3aGlsZShuPW9baSsrXSkxPT09bi5ub2RlVHlwZSYmci5wdXNoKG4pO3JldHVybiByfXJldHVybiBvfSxvLmZpbmQuQ0xBU1M9ci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihlLG4pe3JldHVybiB0eXBlb2Ygbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIT09aiYmaD9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSk6dH0sbT1bXSxnPVtdLChyLnFzYT1LLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkmJih1dChmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxzZWxlY3Q+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aHx8Zy5wdXNoKFwiXFxcXFtcIitQK1wiKig/OnZhbHVlfFwiK0IrXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8Zy5wdXNoKFwiOmNoZWNrZWRcIil9KSx1dChmdW5jdGlvbihlKXt2YXIgdD1uLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0LnNldEF0dHJpYnV0ZShcInR5cGVcIixcImhpZGRlblwiKSxlLmFwcGVuZENoaWxkKHQpLnNldEF0dHJpYnV0ZShcInRcIixcIlwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdF49JyddXCIpLmxlbmd0aCYmZy5wdXNoKFwiWypeJF09XCIrUCtcIiooPzonJ3xcXFwiXFxcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RofHxnLnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIiksZy5wdXNoKFwiLC4qOlwiKX0pKSwoci5tYXRjaGVzU2VsZWN0b3I9Sy50ZXN0KHk9ZC53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fGQubW96TWF0Y2hlc1NlbGVjdG9yfHxkLm9NYXRjaGVzU2VsZWN0b3J8fGQubXNNYXRjaGVzU2VsZWN0b3IpKSYmdXQoZnVuY3Rpb24oZSl7ci5kaXNjb25uZWN0ZWRNYXRjaD15LmNhbGwoZSxcImRpdlwiKSx5LmNhbGwoZSxcIltzIT0nJ106eFwiKSxtLnB1c2goXCIhPVwiLEkpfSksZz1nLmxlbmd0aCYmUmVnRXhwKGcuam9pbihcInxcIikpLG09bS5sZW5ndGgmJlJlZ0V4cChtLmpvaW4oXCJ8XCIpKSx2PUsudGVzdChkLmNvbnRhaW5zKXx8ZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe3ZhciBuPTk9PT1lLm5vZGVUeXBlP2UuZG9jdW1lbnRFbGVtZW50OmUscj10JiZ0LnBhcmVudE5vZGU7cmV0dXJuIGU9PT1yfHwhKCFyfHwxIT09ci5ub2RlVHlwZXx8IShuLmNvbnRhaW5zP24uY29udGFpbnMocik6ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmMTYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyKSkpfTpmdW5jdGlvbihlLHQpe2lmKHQpd2hpbGUodD10LnBhcmVudE5vZGUpaWYodD09PWUpcmV0dXJuITA7cmV0dXJuITF9LEE9ZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe2lmKGU9PT10KXJldHVybiBTPSEwLDA7dmFyIGk9dC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KTtyZXR1cm4gaT8xJml8fCFyLnNvcnREZXRhY2hlZCYmdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKT09PWk/ZT09PW58fHYodyxlKT8tMTp0PT09bnx8dih3LHQpPzE6Yz9GLmNhbGwoYyxlKS1GLmNhbGwoYyx0KTowOjQmaT8tMToxOmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24/LTE6MX06ZnVuY3Rpb24oZSx0KXt2YXIgcixpPTAsbz1lLnBhcmVudE5vZGUsYT10LnBhcmVudE5vZGUscz1bZV0sbD1bdF07aWYoZT09PXQpcmV0dXJuIFM9ITAsMDtpZighb3x8IWEpcmV0dXJuIGU9PT1uPy0xOnQ9PT1uPzE6bz8tMTphPzE6Yz9GLmNhbGwoYyxlKS1GLmNhbGwoYyx0KTowO2lmKG89PT1hKXJldHVybiBwdChlLHQpO3I9ZTt3aGlsZShyPXIucGFyZW50Tm9kZSlzLnVuc2hpZnQocik7cj10O3doaWxlKHI9ci5wYXJlbnROb2RlKWwudW5zaGlmdChyKTt3aGlsZShzW2ldPT09bFtpXSlpKys7cmV0dXJuIGk/cHQoc1tpXSxsW2ldKTpzW2ldPT09dz8tMTpsW2ldPT09dz8xOjB9LG4pOmZ9LGF0Lm1hdGNoZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXQoZSxudWxsLG51bGwsdCl9LGF0Lm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihlLHQpe2lmKChlLm93bmVyRG9jdW1lbnR8fGUpIT09ZiYmcChlKSx0PXQucmVwbGFjZShZLFwiPSckMSddXCIpLCEoIXIubWF0Y2hlc1NlbGVjdG9yfHwhaHx8bSYmbS50ZXN0KHQpfHxnJiZnLnRlc3QodCkpKXRyeXt2YXIgbj15LmNhbGwoZSx0KTtpZihufHxyLmRpc2Nvbm5lY3RlZE1hdGNofHxlLmRvY3VtZW50JiYxMSE9PWUuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIG59Y2F0Y2goaSl7fXJldHVybiBhdCh0LGYsbnVsbCxbZV0pLmxlbmd0aD4wfSxhdC5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybihlLm93bmVyRG9jdW1lbnR8fGUpIT09ZiYmcChlKSx2KGUsdCl9LGF0LmF0dHI9ZnVuY3Rpb24oZSxuKXsoZS5vd25lckRvY3VtZW50fHxlKSE9PWYmJnAoZSk7dmFyIGk9by5hdHRySGFuZGxlW24udG9Mb3dlckNhc2UoKV0sYT1pJiZMLmNhbGwoby5hdHRySGFuZGxlLG4udG9Mb3dlckNhc2UoKSk/aShlLG4sIWgpOnQ7cmV0dXJuIGE9PT10P3IuYXR0cmlidXRlc3x8IWg/ZS5nZXRBdHRyaWJ1dGUobik6KGE9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSYmYS5zcGVjaWZpZWQ/YS52YWx1ZTpudWxsOmF9LGF0LmVycm9yPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIrZSl9LGF0LnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1bXSxpPTAsbz0wO2lmKFM9IXIuZGV0ZWN0RHVwbGljYXRlcyxjPSFyLnNvcnRTdGFibGUmJmUuc2xpY2UoMCksZS5zb3J0KEEpLFMpe3doaWxlKHQ9ZVtvKytdKXQ9PT1lW29dJiYoaT1uLnB1c2gobykpO3doaWxlKGktLSllLnNwbGljZShuW2ldLDEpfXJldHVybiBlfSxhPWF0LmdldFRleHQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIlwiLHI9MCxpPWUubm9kZVR5cGU7aWYoaSl7aWYoMT09PWl8fDk9PT1pfHwxMT09PWkpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlLnRleHRDb250ZW50KXJldHVybiBlLnRleHRDb250ZW50O2ZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZyluKz1hKGUpfWVsc2UgaWYoMz09PWl8fDQ9PT1pKXJldHVybiBlLm5vZGVWYWx1ZX1lbHNlIGZvcig7dD1lW3JdO3IrKyluKz1hKHQpO3JldHVybiBufSxvPWF0LnNlbGVjdG9ycz17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOmx0LG1hdGNoOlEsYXR0ckhhbmRsZTp7fSxmaW5kOnt9LHJlbGF0aXZlOntcIj5cIjp7ZGlyOlwicGFyZW50Tm9kZVwiLGZpcnN0OiEwfSxcIiBcIjp7ZGlyOlwicGFyZW50Tm9kZVwifSxcIitcIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCIsZmlyc3Q6ITB9LFwiflwiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihlKXtyZXR1cm4gZVsxXT1lWzFdLnJlcGxhY2UocnQsaXQpLGVbM109KGVbNF18fGVbNV18fFwiXCIpLnJlcGxhY2UocnQsaXQpLFwifj1cIj09PWVbMl0mJihlWzNdPVwiIFwiK2VbM10rXCIgXCIpLGUuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS50b0xvd2VyQ2FzZSgpLFwibnRoXCI9PT1lWzFdLnNsaWNlKDAsMyk/KGVbM118fGF0LmVycm9yKGVbMF0pLGVbNF09KyhlWzRdP2VbNV0rKGVbNl18fDEpOjIqKFwiZXZlblwiPT09ZVszXXx8XCJvZGRcIj09PWVbM10pKSxlWzVdPSsoZVs3XStlWzhdfHxcIm9kZFwiPT09ZVszXSkpOmVbM10mJmF0LmVycm9yKGVbMF0pLGV9LFBTRVVETzpmdW5jdGlvbihlKXt2YXIgbixyPSFlWzVdJiZlWzJdO3JldHVybiBRLkNISUxELnRlc3QoZVswXSk/bnVsbDooZVszXSYmZVs0XSE9PXQ/ZVsyXT1lWzRdOnImJkoudGVzdChyKSYmKG49bXQociwhMCkpJiYobj1yLmluZGV4T2YoXCIpXCIsci5sZW5ndGgtbiktci5sZW5ndGgpJiYoZVswXT1lWzBdLnNsaWNlKDAsbiksZVsyXT1yLnNsaWNlKDAsbikpLGUuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UocnQsaXQpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1lP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT10fX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9TltlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9UmVnRXhwKFwiKF58XCIrUCtcIilcIitlK1wiKFwiK1ArXCJ8JClcIikpJiZOKGUsZnVuY3Rpb24oZSl7cmV0dXJuIHQudGVzdChcInN0cmluZ1wiPT10eXBlb2YgZS5jbGFzc05hbWUmJmUuY2xhc3NOYW1lfHx0eXBlb2YgZS5nZXRBdHRyaWJ1dGUhPT1qJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGk9YXQuYXR0cihyLGUpO3JldHVybiBudWxsPT1pP1wiIT1cIj09PXQ6dD8oaSs9XCJcIixcIj1cIj09PXQ/aT09PW46XCIhPVwiPT09dD9pIT09bjpcIl49XCI9PT10P24mJjA9PT1pLmluZGV4T2Yobik6XCIqPVwiPT09dD9uJiZpLmluZGV4T2Yobik+LTE6XCIkPVwiPT09dD9uJiZpLnNsaWNlKC1uLmxlbmd0aCk9PT1uOlwifj1cIj09PXQ/KFwiIFwiK2krXCIgXCIpLmluZGV4T2Yobik+LTE6XCJ8PVwiPT09dD9pPT09bnx8aS5zbGljZSgwLG4ubGVuZ3RoKzEpPT09bitcIi1cIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvPVwibnRoXCIhPT1lLnNsaWNlKDAsMyksYT1cImxhc3RcIiE9PWUuc2xpY2UoLTQpLHM9XCJvZi10eXBlXCI9PT10O3JldHVybiAxPT09ciYmMD09PWk/ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnBhcmVudE5vZGV9OmZ1bmN0aW9uKHQsbixsKXt2YXIgdSxjLHAsZixkLGgsZz1vIT09YT9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixtPXQucGFyZW50Tm9kZSx5PXMmJnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSx2PSFsJiYhcztpZihtKXtpZihvKXt3aGlsZShnKXtwPXQ7d2hpbGUocD1wW2ddKWlmKHM/cC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09eToxPT09cC5ub2RlVHlwZSlyZXR1cm4hMTtoPWc9XCJvbmx5XCI9PT1lJiYhaCYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKGg9W2E/bS5maXJzdENoaWxkOm0ubGFzdENoaWxkXSxhJiZ2KXtjPW1bYl18fChtW2JdPXt9KSx1PWNbZV18fFtdLGQ9dVswXT09PVQmJnVbMV0sZj11WzBdPT09VCYmdVsyXSxwPWQmJm0uY2hpbGROb2Rlc1tkXTt3aGlsZShwPSsrZCYmcCYmcFtnXXx8KGY9ZD0wKXx8aC5wb3AoKSlpZigxPT09cC5ub2RlVHlwZSYmKytmJiZwPT09dCl7Y1tlXT1bVCxkLGZdO2JyZWFrfX1lbHNlIGlmKHYmJih1PSh0W2JdfHwodFtiXT17fSkpW2VdKSYmdVswXT09PVQpZj11WzFdO2Vsc2Ugd2hpbGUocD0rK2QmJnAmJnBbZ118fChmPWQ9MCl8fGgucG9wKCkpaWYoKHM/cC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09eToxPT09cC5ub2RlVHlwZSkmJisrZiYmKHYmJigocFtiXXx8KHBbYl09e30pKVtlXT1bVCxmXSkscD09PXQpKWJyZWFrO3JldHVybiBmLT1pLGY9PT1yfHwwPT09ZiVyJiZmL3I+PTB9fX0sUFNFVURPOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1vLnBzZXVkb3NbZV18fG8uc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldfHxhdC5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrZSk7cmV0dXJuIHJbYl0/cih0KTpyLmxlbmd0aD4xPyhuPVtlLGUsXCJcIix0XSxvLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoZS50b0xvd2VyQ2FzZSgpKT9sdChmdW5jdGlvbihlLG4pe3ZhciBpLG89cihlLHQpLGE9by5sZW5ndGg7d2hpbGUoYS0tKWk9Ri5jYWxsKGUsb1thXSksZVtpXT0hKG5baV09b1thXSl9KTpmdW5jdGlvbihlKXtyZXR1cm4gcihlLDAsbil9KTpyfX0scHNldWRvczp7bm90Omx0KGZ1bmN0aW9uKGUpe3ZhciB0PVtdLG49W10scj1sKGUucmVwbGFjZSh6LFwiJDFcIikpO3JldHVybiByW2JdP2x0KGZ1bmN0aW9uKGUsdCxuLGkpe3ZhciBvLGE9cihlLG51bGwsaSxbXSkscz1lLmxlbmd0aDt3aGlsZShzLS0pKG89YVtzXSkmJihlW3NdPSEodFtzXT1vKSl9KTpmdW5jdGlvbihlLGksbyl7cmV0dXJuIHRbMF09ZSxyKHQsbnVsbCxvLG4pLCFuLnBvcCgpfX0pLGhhczpsdChmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGF0KGUsdCkubGVuZ3RoPjB9fSksY29udGFpbnM6bHQoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybih0LnRleHRDb250ZW50fHx0LmlubmVyVGV4dHx8YSh0KSkuaW5kZXhPZihlKT4tMX19KSxsYW5nOmx0KGZ1bmN0aW9uKGUpe3JldHVybiBHLnRlc3QoZXx8XCJcIil8fGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIrZSksZT1lLnJlcGxhY2UocnQsaXQpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24odCl7dmFyIG47ZG8gaWYobj1oP3QubGFuZzp0LmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHx0LmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuIG49bi50b0xvd2VyQ2FzZSgpLG49PT1lfHwwPT09bi5pbmRleE9mKGUrXCItXCIpO3doaWxlKCh0PXQucGFyZW50Tm9kZSkmJjE9PT10Lm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24odCl7dmFyIG49ZS5sb2NhdGlvbiYmZS5sb2NhdGlvbi5oYXNoO3JldHVybiBuJiZuLnNsaWNlKDEpPT09dC5pZH0scm9vdDpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWR9LGZvY3VzOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09Zi5hY3RpdmVFbGVtZW50JiYoIWYuaGFzRm9jdXN8fGYuaGFzRm9jdXMoKSkmJiEhKGUudHlwZXx8ZS5ocmVmfHx+ZS50YWJJbmRleCl9LGVuYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMX0sZGlzYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMH0sY2hlY2tlZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmISFlLmNoZWNrZWR8fFwib3B0aW9uXCI9PT10JiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LGUuc2VsZWN0ZWQ9PT0hMH0sZW1wdHk6ZnVuY3Rpb24oZSl7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKWlmKGUubm9kZU5hbWU+XCJAXCJ8fDM9PT1lLm5vZGVUeXBlfHw0PT09ZS5ub2RlVHlwZSlyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFvLnBzZXVkb3MuZW1wdHkoZSl9LGhlYWRlcjpmdW5jdGlvbihlKXtyZXR1cm4gdHQudGVzdChlLm5vZGVOYW1lKX0saW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGV0LnRlc3QoZS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmXCJidXR0b25cIj09PWUudHlwZXx8XCJidXR0b25cIj09PXR9LHRleHQ6ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuXCJpbnB1dFwiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZcInRleHRcIj09PWUudHlwZSYmKG51bGw9PSh0PWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fHQudG9Mb3dlckNhc2UoKT09PWUudHlwZSl9LGZpcnN0Omh0KGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDpodChmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6aHQoZnVuY3Rpb24oZSx0LG4pe3JldHVyblswPm4/bit0Om5dfSksZXZlbjpodChmdW5jdGlvbihlLHQpe3ZhciBuPTA7Zm9yKDt0Pm47bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxvZGQ6aHQoZnVuY3Rpb24oZSx0KXt2YXIgbj0xO2Zvcig7dD5uO24rPTIpZS5wdXNoKG4pO3JldHVybiBlfSksbHQ6aHQoZnVuY3Rpb24oZSx0LG4pe3ZhciByPTA+bj9uK3Q6bjtmb3IoOy0tcj49MDspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6aHQoZnVuY3Rpb24oZSx0LG4pe3ZhciByPTA+bj9uK3Q6bjtmb3IoO3Q+KytyOyllLnB1c2gocik7cmV0dXJuIGV9KX19LG8ucHNldWRvcy5udGg9by5wc2V1ZG9zLmVxO2ZvcihuIGlue3JhZGlvOiEwLGNoZWNrYm94OiEwLGZpbGU6ITAscGFzc3dvcmQ6ITAsaW1hZ2U6ITB9KW8ucHNldWRvc1tuXT1mdChuKTtmb3IobiBpbntzdWJtaXQ6ITAscmVzZXQ6ITB9KW8ucHNldWRvc1tuXT1kdChuKTtmdW5jdGlvbiBndCgpe31ndC5wcm90b3R5cGU9by5maWx0ZXJzPW8ucHNldWRvcyxvLnNldEZpbHRlcnM9bmV3IGd0O2Z1bmN0aW9uIG10KGUsdCl7dmFyIG4scixpLGEscyxsLHUsYz1rW2UrXCIgXCJdO2lmKGMpcmV0dXJuIHQ/MDpjLnNsaWNlKDApO3M9ZSxsPVtdLHU9by5wcmVGaWx0ZXI7d2hpbGUocyl7KCFufHwocj1YLmV4ZWMocykpKSYmKHImJihzPXMuc2xpY2UoclswXS5sZW5ndGgpfHxzKSxsLnB1c2goaT1bXSkpLG49ITEsKHI9VS5leGVjKHMpKSYmKG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOnJbMF0ucmVwbGFjZSh6LFwiIFwiKX0pLHM9cy5zbGljZShuLmxlbmd0aCkpO2ZvcihhIGluIG8uZmlsdGVyKSEocj1RW2FdLmV4ZWMocykpfHx1W2FdJiYhKHI9dVthXShyKSl8fChuPXIuc2hpZnQoKSxpLnB1c2goe3ZhbHVlOm4sdHlwZTphLG1hdGNoZXM6cn0pLHM9cy5zbGljZShuLmxlbmd0aCkpO2lmKCFuKWJyZWFrfXJldHVybiB0P3MubGVuZ3RoOnM/YXQuZXJyb3IoZSk6ayhlLGwpLnNsaWNlKDApfWZ1bmN0aW9uIHl0KGUpe3ZhciB0PTAsbj1lLmxlbmd0aCxyPVwiXCI7Zm9yKDtuPnQ7dCsrKXIrPWVbdF0udmFsdWU7cmV0dXJuIHJ9ZnVuY3Rpb24gdnQoZSx0LG4pe3ZhciByPXQuZGlyLG89biYmXCJwYXJlbnROb2RlXCI9PT1yLGE9QysrO3JldHVybiB0LmZpcnN0P2Z1bmN0aW9uKHQsbixpKXt3aGlsZSh0PXRbcl0paWYoMT09PXQubm9kZVR5cGV8fG8pcmV0dXJuIGUodCxuLGkpfTpmdW5jdGlvbih0LG4scyl7dmFyIGwsdSxjLHA9VCtcIiBcIithO2lmKHMpe3doaWxlKHQ9dFtyXSlpZigoMT09PXQubm9kZVR5cGV8fG8pJiZlKHQsbixzKSlyZXR1cm4hMH1lbHNlIHdoaWxlKHQ9dFtyXSlpZigxPT09dC5ub2RlVHlwZXx8bylpZihjPXRbYl18fCh0W2JdPXt9KSwodT1jW3JdKSYmdVswXT09PXApe2lmKChsPXVbMV0pPT09ITB8fGw9PT1pKXJldHVybiBsPT09ITB9ZWxzZSBpZih1PWNbcl09W3BdLHVbMV09ZSh0LG4scyl8fGksdVsxXT09PSEwKXJldHVybiEwfX1mdW5jdGlvbiBidChlKXtyZXR1cm4gZS5sZW5ndGg+MT9mdW5jdGlvbih0LG4scil7dmFyIGk9ZS5sZW5ndGg7d2hpbGUoaS0tKWlmKCFlW2ldKHQsbixyKSlyZXR1cm4hMTtyZXR1cm4hMH06ZVswXX1mdW5jdGlvbiB4dChlLHQsbixyLGkpe3ZhciBvLGE9W10scz0wLGw9ZS5sZW5ndGgsdT1udWxsIT10O2Zvcig7bD5zO3MrKykobz1lW3NdKSYmKCFufHxuKG8scixpKSkmJihhLnB1c2gobyksdSYmdC5wdXNoKHMpKTtyZXR1cm4gYX1mdW5jdGlvbiB3dChlLHQsbixyLGksbyl7cmV0dXJuIHImJiFyW2JdJiYocj13dChyKSksaSYmIWlbYl0mJihpPXd0KGksbykpLGx0KGZ1bmN0aW9uKG8sYSxzLGwpe3ZhciB1LGMscCxmPVtdLGQ9W10saD1hLmxlbmd0aCxnPW98fE50KHR8fFwiKlwiLHMubm9kZVR5cGU/W3NdOnMsW10pLG09IWV8fCFvJiZ0P2c6eHQoZyxmLGUscyxsKSx5PW4/aXx8KG8/ZTpofHxyKT9bXTphOm07aWYobiYmbihtLHkscyxsKSxyKXt1PXh0KHksZCkscih1LFtdLHMsbCksYz11Lmxlbmd0aDt3aGlsZShjLS0pKHA9dVtjXSkmJih5W2RbY11dPSEobVtkW2NdXT1wKSl9aWYobyl7aWYoaXx8ZSl7aWYoaSl7dT1bXSxjPXkubGVuZ3RoO3doaWxlKGMtLSkocD15W2NdKSYmdS5wdXNoKG1bY109cCk7aShudWxsLHk9W10sdSxsKX1jPXkubGVuZ3RoO3doaWxlKGMtLSkocD15W2NdKSYmKHU9aT9GLmNhbGwobyxwKTpmW2NdKT4tMSYmKG9bdV09IShhW3VdPXApKX19ZWxzZSB5PXh0KHk9PT1hP3kuc3BsaWNlKGgseS5sZW5ndGgpOnkpLGk/aShudWxsLGEseSxsKTpNLmFwcGx5KGEseSl9KX1mdW5jdGlvbiBUdChlKXt2YXIgdCxuLHIsaT1lLmxlbmd0aCxhPW8ucmVsYXRpdmVbZVswXS50eXBlXSxzPWF8fG8ucmVsYXRpdmVbXCIgXCJdLGw9YT8xOjAsYz12dChmdW5jdGlvbihlKXtyZXR1cm4gZT09PXR9LHMsITApLHA9dnQoZnVuY3Rpb24oZSl7cmV0dXJuIEYuY2FsbCh0LGUpPi0xfSxzLCEwKSxmPVtmdW5jdGlvbihlLG4scil7cmV0dXJuIWEmJihyfHxuIT09dSl8fCgodD1uKS5ub2RlVHlwZT9jKGUsbixyKTpwKGUsbixyKSl9XTtmb3IoO2k+bDtsKyspaWYobj1vLnJlbGF0aXZlW2VbbF0udHlwZV0pZj1bdnQoYnQoZiksbildO2Vsc2V7aWYobj1vLmZpbHRlcltlW2xdLnR5cGVdLmFwcGx5KG51bGwsZVtsXS5tYXRjaGVzKSxuW2JdKXtmb3Iocj0rK2w7aT5yO3IrKylpZihvLnJlbGF0aXZlW2Vbcl0udHlwZV0pYnJlYWs7cmV0dXJuIHd0KGw+MSYmYnQoZiksbD4xJiZ5dChlLnNsaWNlKDAsbC0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09ZVtsLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKHosXCIkMVwiKSxuLHI+bCYmVHQoZS5zbGljZShsLHIpKSxpPnImJlR0KGU9ZS5zbGljZShyKSksaT5yJiZ5dChlKSl9Zi5wdXNoKG4pfXJldHVybiBidChmKX1mdW5jdGlvbiBDdChlLHQpe3ZhciBuPTAscj10Lmxlbmd0aD4wLGE9ZS5sZW5ndGg+MCxzPWZ1bmN0aW9uKHMsbCxjLHAsZCl7dmFyIGgsZyxtLHk9W10sdj0wLGI9XCIwXCIseD1zJiZbXSx3PW51bGwhPWQsQz11LE49c3x8YSYmby5maW5kLlRBRyhcIipcIixkJiZsLnBhcmVudE5vZGV8fGwpLGs9VCs9bnVsbD09Qz8xOk1hdGgucmFuZG9tKCl8fC4xO2Zvcih3JiYodT1sIT09ZiYmbCxpPW4pO251bGwhPShoPU5bYl0pO2IrKyl7aWYoYSYmaCl7Zz0wO3doaWxlKG09ZVtnKytdKWlmKG0oaCxsLGMpKXtwLnB1c2goaCk7YnJlYWt9dyYmKFQ9ayxpPSsrbil9ciYmKChoPSFtJiZoKSYmdi0tLHMmJngucHVzaChoKSl9aWYodis9YixyJiZiIT09dil7Zz0wO3doaWxlKG09dFtnKytdKW0oeCx5LGwsYyk7aWYocyl7aWYodj4wKXdoaWxlKGItLSl4W2JdfHx5W2JdfHwoeVtiXT1xLmNhbGwocCkpO3k9eHQoeSl9TS5hcHBseShwLHkpLHcmJiFzJiZ5Lmxlbmd0aD4wJiZ2K3QubGVuZ3RoPjEmJmF0LnVuaXF1ZVNvcnQocCl9cmV0dXJuIHcmJihUPWssdT1DKSx4fTtyZXR1cm4gcj9sdChzKTpzfWw9YXQuY29tcGlsZT1mdW5jdGlvbihlLHQpe3ZhciBuLHI9W10saT1bXSxvPUVbZStcIiBcIl07aWYoIW8pe3R8fCh0PW10KGUpKSxuPXQubGVuZ3RoO3doaWxlKG4tLSlvPVR0KHRbbl0pLG9bYl0/ci5wdXNoKG8pOmkucHVzaChvKTtvPUUoZSxDdChpLHIpKX1yZXR1cm4gb307ZnVuY3Rpb24gTnQoZSx0LG4pe3ZhciByPTAsaT10Lmxlbmd0aDtmb3IoO2k+cjtyKyspYXQoZSx0W3JdLG4pO3JldHVybiBufWZ1bmN0aW9uIGt0KGUsdCxuLGkpe3ZhciBhLHMsdSxjLHAsZj1tdChlKTtpZighaSYmMT09PWYubGVuZ3RoKXtpZihzPWZbMF09ZlswXS5zbGljZSgwKSxzLmxlbmd0aD4yJiZcIklEXCI9PT0odT1zWzBdKS50eXBlJiZyLmdldEJ5SWQmJjk9PT10Lm5vZGVUeXBlJiZoJiZvLnJlbGF0aXZlW3NbMV0udHlwZV0pe2lmKHQ9KG8uZmluZC5JRCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCxpdCksdCl8fFtdKVswXSwhdClyZXR1cm4gbjtlPWUuc2xpY2Uocy5zaGlmdCgpLnZhbHVlLmxlbmd0aCl9YT1RLm5lZWRzQ29udGV4dC50ZXN0KGUpPzA6cy5sZW5ndGg7d2hpbGUoYS0tKXtpZih1PXNbYV0sby5yZWxhdGl2ZVtjPXUudHlwZV0pYnJlYWs7aWYoKHA9by5maW5kW2NdKSYmKGk9cCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCxpdCksVi50ZXN0KHNbMF0udHlwZSkmJnQucGFyZW50Tm9kZXx8dCkpKXtpZihzLnNwbGljZShhLDEpLGU9aS5sZW5ndGgmJnl0KHMpLCFlKXJldHVybiBNLmFwcGx5KG4saSksbjticmVha319fXJldHVybiBsKGUsZikoaSx0LCFoLG4sVi50ZXN0KGUpKSxufXIuc29ydFN0YWJsZT1iLnNwbGl0KFwiXCIpLnNvcnQoQSkuam9pbihcIlwiKT09PWIsci5kZXRlY3REdXBsaWNhdGVzPVMscCgpLHIuc29ydERldGFjaGVkPXV0KGZ1bmN0aW9uKGUpe3JldHVybiAxJmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKX0pLHV0KGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxhIGhyZWY9JyMnPjwvYT5cIixcIiNcIj09PWUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfSl8fGN0KFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gcj90OmUuZ2V0QXR0cmlidXRlKG4sXCJ0eXBlXCI9PT1uLnRvTG93ZXJDYXNlKCk/MToyKX0pLHIuYXR0cmlidXRlcyYmdXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5uZXJIVE1MPVwiPGlucHV0Lz5cIixlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiKSxcIlwiPT09ZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpfSl8fGN0KFwidmFsdWVcIixmdW5jdGlvbihlLG4scil7cmV0dXJuIHJ8fFwiaW5wdXRcIiE9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT90OmUuZGVmYXVsdFZhbHVlfSksdXQoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8Y3QoQixmdW5jdGlvbihlLG4scil7dmFyIGk7cmV0dXJuIHI/dDooaT1lLmdldEF0dHJpYnV0ZU5vZGUobikpJiZpLnNwZWNpZmllZD9pLnZhbHVlOmVbbl09PT0hMD9uLnRvTG93ZXJDYXNlKCk6bnVsbH0pLHguZmluZD1hdCx4LmV4cHI9YXQuc2VsZWN0b3JzLHguZXhwcltcIjpcIl09eC5leHByLnBzZXVkb3MseC51bmlxdWU9YXQudW5pcXVlU29ydCx4LnRleHQ9YXQuZ2V0VGV4dCx4LmlzWE1MRG9jPWF0LmlzWE1MLHguY29udGFpbnM9YXQuY29udGFpbnN9KGUpO3ZhciBPPXt9O2Z1bmN0aW9uIEYoZSl7dmFyIHQ9T1tlXT17fTtyZXR1cm4geC5lYWNoKGUubWF0Y2goVCl8fFtdLGZ1bmN0aW9uKGUsbil7dFtuXT0hMH0pLHR9eC5DYWxsYmFja3M9ZnVuY3Rpb24oZSl7ZT1cInN0cmluZ1wiPT10eXBlb2YgZT9PW2VdfHxGKGUpOnguZXh0ZW5kKHt9LGUpO3ZhciBuLHIsaSxvLGEscyxsPVtdLHU9IWUub25jZSYmW10sYz1mdW5jdGlvbih0KXtmb3Iocj1lLm1lbW9yeSYmdCxpPSEwLGE9c3x8MCxzPTAsbz1sLmxlbmd0aCxuPSEwO2wmJm8+YTthKyspaWYobFthXS5hcHBseSh0WzBdLHRbMV0pPT09ITEmJmUuc3RvcE9uRmFsc2Upe3I9ITE7YnJlYWt9bj0hMSxsJiYodT91Lmxlbmd0aCYmYyh1LnNoaWZ0KCkpOnI/bD1bXTpwLmRpc2FibGUoKSl9LHA9e2FkZDpmdW5jdGlvbigpe2lmKGwpe3ZhciB0PWwubGVuZ3RoOyhmdW5jdGlvbiBpKHQpe3guZWFjaCh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9eC50eXBlKG4pO1wiZnVuY3Rpb25cIj09PXI/ZS51bmlxdWUmJnAuaGFzKG4pfHxsLnB1c2gobik6biYmbi5sZW5ndGgmJlwic3RyaW5nXCIhPT1yJiZpKG4pfSl9KShhcmd1bWVudHMpLG4/bz1sLmxlbmd0aDpyJiYocz10LGMocikpfXJldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbCYmeC5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihlLHQpe3ZhciByO3doaWxlKChyPXguaW5BcnJheSh0LGwscikpPi0xKWwuc3BsaWNlKHIsMSksbiYmKG8+PXImJm8tLSxhPj1yJiZhLS0pfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlP3guaW5BcnJheShlLGwpPi0xOiEoIWx8fCFsLmxlbmd0aCl9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIGw9W10sbz0wLHRoaXN9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gbD11PXI9dCx0aGlzfSxkaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiFsfSxsb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIHU9dCxyfHxwLmRpc2FibGUoKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hdX0sZmlyZVdpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4hbHx8aSYmIXV8fCh0PXR8fFtdLHQ9W2UsdC5zbGljZT90LnNsaWNlKCk6dF0sbj91LnB1c2godCk6Yyh0KSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBwLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhaX19O3JldHVybiBwfSx4LmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9W1tcInJlc29sdmVcIixcImRvbmVcIix4LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIseC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIix4LkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLG49XCJwZW5kaW5nXCIscj17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzO3JldHVybiB4LkRlZmVycmVkKGZ1bmN0aW9uKG4pe3guZWFjaCh0LGZ1bmN0aW9uKHQsbyl7dmFyIGE9b1swXSxzPXguaXNGdW5jdGlvbihlW3RdKSYmZVt0XTtpW29bMV1dKGZ1bmN0aW9uKCl7dmFyIGU9cyYmcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmeC5pc0Z1bmN0aW9uKGUucHJvbWlzZSk/ZS5wcm9taXNlKCkuZG9uZShuLnJlc29sdmUpLmZhaWwobi5yZWplY3QpLnByb2dyZXNzKG4ubm90aWZ5KTpuW2ErXCJXaXRoXCJdKHRoaXM9PT1yP24ucHJvbWlzZSgpOnRoaXMscz9bZV06YXJndW1lbnRzKX0pfSksZT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP3guZXh0ZW5kKGUscik6cn19LGk9e307cmV0dXJuIHIucGlwZT1yLnRoZW4seC5lYWNoKHQsZnVuY3Rpb24oZSxvKXt2YXIgYT1vWzJdLHM9b1szXTtyW29bMV1dPWEuYWRkLHMmJmEuYWRkKGZ1bmN0aW9uKCl7bj1zfSx0WzFeZV1bMl0uZGlzYWJsZSx0WzJdWzJdLmxvY2spLGlbb1swXV09ZnVuY3Rpb24oKXtyZXR1cm4gaVtvWzBdK1wiV2l0aFwiXSh0aGlzPT09aT9yOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxpW29bMF0rXCJXaXRoXCJdPWEuZmlyZVdpdGh9KSxyLnByb21pc2UoaSksZSYmZS5jYWxsKGksaSksaX0sd2hlbjpmdW5jdGlvbihlKXt2YXIgdD0wLG49Zy5jYWxsKGFyZ3VtZW50cykscj1uLmxlbmd0aCxpPTEhPT1yfHxlJiZ4LmlzRnVuY3Rpb24oZS5wcm9taXNlKT9yOjAsbz0xPT09aT9lOnguRGVmZXJyZWQoKSxhPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7dFtlXT10aGlzLG5bZV09YXJndW1lbnRzLmxlbmd0aD4xP2cuY2FsbChhcmd1bWVudHMpOnIsbj09PXM/by5ub3RpZnlXaXRoKHQsbik6LS1pfHxvLnJlc29sdmVXaXRoKHQsbil9fSxzLGwsdTtpZihyPjEpZm9yKHM9QXJyYXkociksbD1BcnJheShyKSx1PUFycmF5KHIpO3I+dDt0Kyspblt0XSYmeC5pc0Z1bmN0aW9uKG5bdF0ucHJvbWlzZSk/blt0XS5wcm9taXNlKCkuZG9uZShhKHQsdSxuKSkuZmFpbChvLnJlamVjdCkucHJvZ3Jlc3MoYSh0LGwscykpOi0taTtyZXR1cm4gaXx8by5yZXNvbHZlV2l0aCh1LG4pLG8ucHJvbWlzZSgpfX0pLHguc3VwcG9ydD1mdW5jdGlvbih0KXt2YXIgbixyLG8scyxsLHUsYyxwLGYsZD1hLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYoZC5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIixcInRcIiksZC5pbm5lckhUTUw9XCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIixuPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpfHxbXSxyPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWzBdLCFyfHwhci5zdHlsZXx8IW4ubGVuZ3RoKXJldHVybiB0O3M9YS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLHU9cy5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLG89ZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLHIuc3R5bGUuY3NzVGV4dD1cInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCIsdC5nZXRTZXRBdHRyaWJ1dGU9XCJ0XCIhPT1kLmNsYXNzTmFtZSx0LmxlYWRpbmdXaGl0ZXNwYWNlPTM9PT1kLmZpcnN0Q2hpbGQubm9kZVR5cGUsdC50Ym9keT0hZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCx0Lmh0bWxTZXJpYWxpemU9ISFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKS5sZW5ndGgsdC5zdHlsZT0vdG9wLy50ZXN0KHIuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpLHQuaHJlZk5vcm1hbGl6ZWQ9XCIvYVwiPT09ci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHQub3BhY2l0eT0vXjAuNS8udGVzdChyLnN0eWxlLm9wYWNpdHkpLHQuY3NzRmxvYXQ9ISFyLnN0eWxlLmNzc0Zsb2F0LHQuY2hlY2tPbj0hIW8udmFsdWUsdC5vcHRTZWxlY3RlZD11LnNlbGVjdGVkLHQuZW5jdHlwZT0hIWEuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSx0Lmh0bWw1Q2xvbmU9XCI8Om5hdj48LzpuYXY+XCIhPT1hLmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCEwKS5vdXRlckhUTUwsdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0PSExLHQuc2hyaW5rV3JhcEJsb2Nrcz0hMSx0LnBpeGVsUG9zaXRpb249ITEsdC5kZWxldGVFeHBhbmRvPSEwLHQubm9DbG9uZUV2ZW50PSEwLHQucmVsaWFibGVNYXJnaW5SaWdodD0hMCx0LmJveFNpemluZ1JlbGlhYmxlPSEwLG8uY2hlY2tlZD0hMCx0Lm5vQ2xvbmVDaGVja2VkPW8uY2xvbmVOb2RlKCEwKS5jaGVja2VkLHMuZGlzYWJsZWQ9ITAsdC5vcHREaXNhYmxlZD0hdS5kaXNhYmxlZDt0cnl7ZGVsZXRlIGQudGVzdH1jYXRjaChoKXt0LmRlbGV0ZUV4cGFuZG89ITF9bz1hLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxvLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksdC5pbnB1dD1cIlwiPT09by5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSxvLnZhbHVlPVwidFwiLG8uc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksdC5yYWRpb1ZhbHVlPVwidFwiPT09by52YWx1ZSxvLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcInRcIiksby5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJ0XCIpLGw9YS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksbC5hcHBlbmRDaGlsZChvKSx0LmFwcGVuZENoZWNrZWQ9by5jaGVja2VkLHQuY2hlY2tDbG9uZT1sLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxkLmF0dGFjaEV2ZW50JiYoZC5hdHRhY2hFdmVudChcIm9uY2xpY2tcIixmdW5jdGlvbigpe3Qubm9DbG9uZUV2ZW50PSExfSksZC5jbG9uZU5vZGUoITApLmNsaWNrKCkpO2ZvcihmIGlue3N1Ym1pdDohMCxjaGFuZ2U6ITAsZm9jdXNpbjohMH0pZC5zZXRBdHRyaWJ1dGUoYz1cIm9uXCIrZixcInRcIiksdFtmK1wiQnViYmxlc1wiXT1jIGluIGV8fGQuYXR0cmlidXRlc1tjXS5leHBhbmRvPT09ITE7ZC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cImNvbnRlbnQtYm94XCIsZC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiXCIsdC5jbGVhckNsb25lU3R5bGU9XCJjb250ZW50LWJveFwiPT09ZC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcDtmb3IoZiBpbiB4KHQpKWJyZWFrO3JldHVybiB0Lm93bkxhc3Q9XCIwXCIhPT1mLHgoZnVuY3Rpb24oKXt2YXIgbixyLG8scz1cInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtcIixsPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO2wmJihuPWEuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuLnN0eWxlLmNzc1RleHQ9XCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweFwiLGwuYXBwZW5kQ2hpbGQobikuYXBwZW5kQ2hpbGQoZCksZC5pbm5lckhUTUw9XCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCIsbz1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIiksb1swXS5zdHlsZS5jc3NUZXh0PVwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZVwiLHA9MD09PW9bMF0ub2Zmc2V0SGVpZ2h0LG9bMF0uc3R5bGUuZGlzcGxheT1cIlwiLG9bMV0uc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cz1wJiYwPT09b1swXS5vZmZzZXRIZWlnaHQsZC5pbm5lckhUTUw9XCJcIixkLnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoxcHg7Ym9yZGVyOjFweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjRweDttYXJnaW4tdG9wOjElO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxJTtcIix4LnN3YXAobCxudWxsIT1sLnN0eWxlLnpvb20/e3pvb206MX06e30sZnVuY3Rpb24oKXt0LmJveFNpemluZz00PT09ZC5vZmZzZXRXaWR0aH0pLGUuZ2V0Q29tcHV0ZWRTdHlsZSYmKHQucGl4ZWxQb3NpdGlvbj1cIjElXCIhPT0oZS5nZXRDb21wdXRlZFN0eWxlKGQsbnVsbCl8fHt9KS50b3AsdC5ib3hTaXppbmdSZWxpYWJsZT1cIjRweFwiPT09KGUuZ2V0Q29tcHV0ZWRTdHlsZShkLG51bGwpfHx7d2lkdGg6XCI0cHhcIn0pLndpZHRoLHI9ZC5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLHIuc3R5bGUuY3NzVGV4dD1kLnN0eWxlLmNzc1RleHQ9cyxyLnN0eWxlLm1hcmdpblJpZ2h0PXIuc3R5bGUud2lkdGg9XCIwXCIsZC5zdHlsZS53aWR0aD1cIjFweFwiLHQucmVsaWFibGVNYXJnaW5SaWdodD0hcGFyc2VGbG9hdCgoZS5nZXRDb21wdXRlZFN0eWxlKHIsbnVsbCl8fHt9KS5tYXJnaW5SaWdodCkpLHR5cGVvZiBkLnN0eWxlLnpvb20hPT1pJiYoZC5pbm5lckhUTUw9XCJcIixkLnN0eWxlLmNzc1RleHQ9cytcIndpZHRoOjFweDtwYWRkaW5nOjFweDtkaXNwbGF5OmlubGluZTt6b29tOjFcIix0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQ9Mz09PWQub2Zmc2V0V2lkdGgsZC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLmlubmVySFRNTD1cIjxkaXY+PC9kaXY+XCIsZC5maXJzdENoaWxkLnN0eWxlLndpZHRoPVwiNXB4XCIsdC5zaHJpbmtXcmFwQmxvY2tzPTMhPT1kLm9mZnNldFdpZHRoLHQuaW5saW5lQmxvY2tOZWVkc0xheW91dCYmKGwuc3R5bGUuem9vbT0xKSksbC5yZW1vdmVDaGlsZChuKSxuPWQ9bz1yPW51bGwpfSksbj1zPWw9dT1yPW89bnVsbCx0XG59KHt9KTt2YXIgQj0vKD86XFx7W1xcc1xcU10qXFx9fFxcW1tcXHNcXFNdKlxcXSkkLyxQPS8oW0EtWl0pL2c7ZnVuY3Rpb24gUihlLG4scixpKXtpZih4LmFjY2VwdERhdGEoZSkpe3ZhciBvLGEscz14LmV4cGFuZG8sbD1lLm5vZGVUeXBlLHU9bD94LmNhY2hlOmUsYz1sP2Vbc106ZVtzXSYmcztpZihjJiZ1W2NdJiYoaXx8dVtjXS5kYXRhKXx8ciE9PXR8fFwic3RyaW5nXCIhPXR5cGVvZiBuKXJldHVybiBjfHwoYz1sP2Vbc109cC5wb3AoKXx8eC5ndWlkKys6cyksdVtjXXx8KHVbY109bD97fTp7dG9KU09OOngubm9vcH0pLChcIm9iamVjdFwiPT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiPT10eXBlb2YgbikmJihpP3VbY109eC5leHRlbmQodVtjXSxuKTp1W2NdLmRhdGE9eC5leHRlbmQodVtjXS5kYXRhLG4pKSxhPXVbY10saXx8KGEuZGF0YXx8KGEuZGF0YT17fSksYT1hLmRhdGEpLHIhPT10JiYoYVt4LmNhbWVsQ2FzZShuKV09ciksXCJzdHJpbmdcIj09dHlwZW9mIG4/KG89YVtuXSxudWxsPT1vJiYobz1hW3guY2FtZWxDYXNlKG4pXSkpOm89YSxvfX1mdW5jdGlvbiBXKGUsdCxuKXtpZih4LmFjY2VwdERhdGEoZSkpe3ZhciByLGksbz1lLm5vZGVUeXBlLGE9bz94LmNhY2hlOmUscz1vP2VbeC5leHBhbmRvXTp4LmV4cGFuZG87aWYoYVtzXSl7aWYodCYmKHI9bj9hW3NdOmFbc10uZGF0YSkpe3guaXNBcnJheSh0KT90PXQuY29uY2F0KHgubWFwKHQseC5jYW1lbENhc2UpKTp0IGluIHI/dD1bdF06KHQ9eC5jYW1lbENhc2UodCksdD10IGluIHI/W3RdOnQuc3BsaXQoXCIgXCIpKSxpPXQubGVuZ3RoO3doaWxlKGktLSlkZWxldGUgclt0W2ldXTtpZihuPyFJKHIpOiF4LmlzRW1wdHlPYmplY3QocikpcmV0dXJufShufHwoZGVsZXRlIGFbc10uZGF0YSxJKGFbc10pKSkmJihvP3guY2xlYW5EYXRhKFtlXSwhMCk6eC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG98fGEhPWEud2luZG93P2RlbGV0ZSBhW3NdOmFbc109bnVsbCl9fX14LmV4dGVuZCh7Y2FjaGU6e30sbm9EYXRhOnthcHBsZXQ6ITAsZW1iZWQ6ITAsb2JqZWN0OlwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJ9LGhhc0RhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZS5ub2RlVHlwZT94LmNhY2hlW2VbeC5leHBhbmRvXV06ZVt4LmV4cGFuZG9dLCEhZSYmIUkoZSl9LGRhdGE6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKGUsdCxuKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe3JldHVybiBXKGUsdCl9LF9kYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUihlLHQsbiwhMCl9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFcoZSx0LCEwKX0sYWNjZXB0RGF0YTpmdW5jdGlvbihlKXtpZihlLm5vZGVUeXBlJiYxIT09ZS5ub2RlVHlwZSYmOSE9PWUubm9kZVR5cGUpcmV0dXJuITE7dmFyIHQ9ZS5ub2RlTmFtZSYmeC5ub0RhdGFbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4hdHx8dCE9PSEwJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIik9PT10fX0pLHguZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxvPW51bGwsYT0wLHM9dGhpc1swXTtpZihlPT09dCl7aWYodGhpcy5sZW5ndGgmJihvPXguZGF0YShzKSwxPT09cy5ub2RlVHlwZSYmIXguX2RhdGEocyxcInBhcnNlZEF0dHJzXCIpKSl7Zm9yKHI9cy5hdHRyaWJ1dGVzO3IubGVuZ3RoPmE7YSsrKWk9clthXS5uYW1lLDA9PT1pLmluZGV4T2YoXCJkYXRhLVwiKSYmKGk9eC5jYW1lbENhc2UoaS5zbGljZSg1KSksJChzLGksb1tpXSkpO3guX2RhdGEocyxcInBhcnNlZEF0dHJzXCIsITApfXJldHVybiBvfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP3RoaXMuZWFjaChmdW5jdGlvbigpe3guZGF0YSh0aGlzLGUpfSk6YXJndW1lbnRzLmxlbmd0aD4xP3RoaXMuZWFjaChmdW5jdGlvbigpe3guZGF0YSh0aGlzLGUsbil9KTpzPyQocyxlLHguZGF0YShzLGUpKTpudWxsfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt4LnJlbW92ZURhdGEodGhpcyxlKX0pfX0pO2Z1bmN0aW9uICQoZSxuLHIpe2lmKHI9PT10JiYxPT09ZS5ub2RlVHlwZSl7dmFyIGk9XCJkYXRhLVwiK24ucmVwbGFjZShQLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7aWYocj1lLmdldEF0dHJpYnV0ZShpKSxcInN0cmluZ1wiPT10eXBlb2Ygcil7dHJ5e3I9XCJ0cnVlXCI9PT1yPyEwOlwiZmFsc2VcIj09PXI/ITE6XCJudWxsXCI9PT1yP251bGw6K3IrXCJcIj09PXI/K3I6Qi50ZXN0KHIpP3gucGFyc2VKU09OKHIpOnJ9Y2F0Y2gobyl7fXguZGF0YShlLG4scil9ZWxzZSByPXR9cmV0dXJuIHJ9ZnVuY3Rpb24gSShlKXt2YXIgdDtmb3IodCBpbiBlKWlmKChcImRhdGFcIiE9PXR8fCF4LmlzRW1wdHlPYmplY3QoZVt0XSkpJiZcInRvSlNPTlwiIT09dClyZXR1cm4hMTtyZXR1cm4hMH14LmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpO3JldHVybiBlPyhuPShufHxcImZ4XCIpK1wicXVldWVcIixpPXguX2RhdGEoZSxuKSxyJiYoIWl8fHguaXNBcnJheShyKT9pPXguX2RhdGEoZSxuLHgubWFrZUFycmF5KHIpKTppLnB1c2gocikpLGl8fFtdKTp0fSxkZXF1ZXVlOmZ1bmN0aW9uKGUsdCl7dD10fHxcImZ4XCI7dmFyIG49eC5xdWV1ZShlLHQpLHI9bi5sZW5ndGgsaT1uLnNoaWZ0KCksbz14Ll9xdWV1ZUhvb2tzKGUsdCksYT1mdW5jdGlvbigpe3guZGVxdWV1ZShlLHQpfTtcImlucHJvZ3Jlc3NcIj09PWkmJihpPW4uc2hpZnQoKSxyLS0pLGkmJihcImZ4XCI9PT10JiZuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLGRlbGV0ZSBvLnN0b3AsaS5jYWxsKGUsYSxvKSksIXImJm8mJm8uZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIHguX2RhdGEoZSxuKXx8eC5fZGF0YShlLG4se2VtcHR5OnguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7eC5fcmVtb3ZlRGF0YShlLHQrXCJxdWV1ZVwiKSx4Ll9yZW1vdmVEYXRhKGUsbil9KX0pfX0pLHguZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLG4pe3ZhciByPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGUmJihuPWUsZT1cImZ4XCIsci0tKSxyPmFyZ3VtZW50cy5sZW5ndGg/eC5xdWV1ZSh0aGlzWzBdLGUpOm49PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9eC5xdWV1ZSh0aGlzLGUsbik7eC5fcXVldWVIb29rcyh0aGlzLGUpLFwiZnhcIj09PWUmJlwiaW5wcm9ncmVzc1wiIT09dFswXSYmeC5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVxdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7eC5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVsYXk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT14LmZ4P3guZnguc3BlZWRzW2VdfHxlOmUsdD10fHxcImZ4XCIsdGhpcy5xdWV1ZSh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9c2V0VGltZW91dCh0LGUpO24uc3RvcD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChyKX19KX0sY2xlYXJRdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5xdWV1ZShlfHxcImZ4XCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGUsbil7dmFyIHIsaT0xLG89eC5EZWZlcnJlZCgpLGE9dGhpcyxzPXRoaXMubGVuZ3RoLGw9ZnVuY3Rpb24oKXstLWl8fG8ucmVzb2x2ZVdpdGgoYSxbYV0pfTtcInN0cmluZ1wiIT10eXBlb2YgZSYmKG49ZSxlPXQpLGU9ZXx8XCJmeFwiO3doaWxlKHMtLSlyPXguX2RhdGEoYVtzXSxlK1wicXVldWVIb29rc1wiKSxyJiZyLmVtcHR5JiYoaSsrLHIuZW1wdHkuYWRkKGwpKTtyZXR1cm4gbCgpLG8ucHJvbWlzZShuKX19KTt2YXIgeixYLFU9L1tcXHRcXHJcXG5cXGZdL2csVj0vXFxyL2csWT0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSxKPS9eKD86YXxhcmVhKSQvaSxHPS9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksUT14LnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLEs9eC5zdXBwb3J0LmlucHV0O3guZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHguYWNjZXNzKHRoaXMseC5hdHRyLGUsdCxhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt4LnJlbW92ZUF0dHIodGhpcyxlKX0pfSxwcm9wOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHguYWNjZXNzKHRoaXMseC5wcm9wLGUsdCxhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGUpe3JldHVybiBlPXgucHJvcEZpeFtlXXx8ZSx0aGlzLmVhY2goZnVuY3Rpb24oKXt0cnl7dGhpc1tlXT10LGRlbGV0ZSB0aGlzW2VdfWNhdGNoKG4pe319KX0sYWRkQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGksbyxhPTAscz10aGlzLmxlbmd0aCxsPVwic3RyaW5nXCI9PXR5cGVvZiBlJiZlO2lmKHguaXNGdW5jdGlvbihlKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3godGhpcykuYWRkQ2xhc3MoZS5jYWxsKHRoaXMsdCx0aGlzLmNsYXNzTmFtZSkpfSk7aWYobClmb3IodD0oZXx8XCJcIikubWF0Y2goVCl8fFtdO3M+YTthKyspaWYobj10aGlzW2FdLHI9MT09PW4ubm9kZVR5cGUmJihuLmNsYXNzTmFtZT8oXCIgXCIrbi5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UoVSxcIiBcIik6XCIgXCIpKXtvPTA7d2hpbGUoaT10W28rK10pMD5yLmluZGV4T2YoXCIgXCIraStcIiBcIikmJihyKz1pK1wiIFwiKTtuLmNsYXNzTmFtZT14LnRyaW0ocil9cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLG8sYT0wLHM9dGhpcy5sZW5ndGgsbD0wPT09YXJndW1lbnRzLmxlbmd0aHx8XCJzdHJpbmdcIj09dHlwZW9mIGUmJmU7aWYoeC5pc0Z1bmN0aW9uKGUpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7eCh0aGlzKS5yZW1vdmVDbGFzcyhlLmNhbGwodGhpcyx0LHRoaXMuY2xhc3NOYW1lKSl9KTtpZihsKWZvcih0PShlfHxcIlwiKS5tYXRjaChUKXx8W107cz5hO2ErKylpZihuPXRoaXNbYV0scj0xPT09bi5ub2RlVHlwZSYmKG4uY2xhc3NOYW1lPyhcIiBcIituLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShVLFwiIFwiKTpcIlwiKSl7bz0wO3doaWxlKGk9dFtvKytdKXdoaWxlKHIuaW5kZXhPZihcIiBcIitpK1wiIFwiKT49MClyPXIucmVwbGFjZShcIiBcIitpK1wiIFwiLFwiIFwiKTtuLmNsYXNzTmFtZT1lP3gudHJpbShyKTpcIlwifXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihlLHQpe3ZhciBuPXR5cGVvZiBlO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdCYmXCJzdHJpbmdcIj09PW4/dD90aGlzLmFkZENsYXNzKGUpOnRoaXMucmVtb3ZlQ2xhc3MoZSk6eC5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbihuKXt4KHRoaXMpLnRvZ2dsZUNsYXNzKGUuY2FsbCh0aGlzLG4sdGhpcy5jbGFzc05hbWUsdCksdCl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT09bil7dmFyIHQscj0wLG89eCh0aGlzKSxhPWUubWF0Y2goVCl8fFtdO3doaWxlKHQ9YVtyKytdKW8uaGFzQ2xhc3ModCk/by5yZW1vdmVDbGFzcyh0KTpvLmFkZENsYXNzKHQpfWVsc2Uobj09PWl8fFwiYm9vbGVhblwiPT09bikmJih0aGlzLmNsYXNzTmFtZSYmeC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiLHRoaXMuY2xhc3NOYW1lKSx0aGlzLmNsYXNzTmFtZT10aGlzLmNsYXNzTmFtZXx8ZT09PSExP1wiXCI6eC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIil9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9XCIgXCIrZStcIiBcIixuPTAscj10aGlzLmxlbmd0aDtmb3IoO3I+bjtuKyspaWYoMT09PXRoaXNbbl0ubm9kZVR5cGUmJihcIiBcIit0aGlzW25dLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShVLFwiIFwiKS5pbmRleE9mKHQpPj0wKXJldHVybiEwO3JldHVybiExfSx2YWw6ZnVuY3Rpb24oZSl7dmFyIG4scixpLG89dGhpc1swXTt7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaT14LmlzRnVuY3Rpb24oZSksdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3ZhciBvOzE9PT10aGlzLm5vZGVUeXBlJiYobz1pP2UuY2FsbCh0aGlzLG4seCh0aGlzKS52YWwoKSk6ZSxudWxsPT1vP289XCJcIjpcIm51bWJlclwiPT10eXBlb2Ygbz9vKz1cIlwiOnguaXNBcnJheShvKSYmKG89eC5tYXAobyxmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmUrXCJcIn0pKSxyPXgudmFsSG9va3NbdGhpcy50eXBlXXx8eC52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLHImJlwic2V0XCJpbiByJiZyLnNldCh0aGlzLG8sXCJ2YWx1ZVwiKSE9PXR8fCh0aGlzLnZhbHVlPW8pKX0pO2lmKG8pcmV0dXJuIHI9eC52YWxIb29rc1tvLnR5cGVdfHx4LnZhbEhvb2tzW28ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sciYmXCJnZXRcImluIHImJihuPXIuZ2V0KG8sXCJ2YWx1ZVwiKSkhPT10P246KG49by52YWx1ZSxcInN0cmluZ1wiPT10eXBlb2Ygbj9uLnJlcGxhY2UoVixcIlwiKTpudWxsPT1uP1wiXCI6bil9fX0pLHguZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9eC5maW5kLmF0dHIoZSxcInZhbHVlXCIpO3JldHVybiBudWxsIT10P3Q6ZS50ZXh0fX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPWUub3B0aW9ucyxpPWUuc2VsZWN0ZWRJbmRleCxvPVwic2VsZWN0LW9uZVwiPT09ZS50eXBlfHwwPmksYT1vP251bGw6W10scz1vP2krMTpyLmxlbmd0aCxsPTA+aT9zOm8/aTowO2Zvcig7cz5sO2wrKylpZihuPXJbbF0sISghbi5zZWxlY3RlZCYmbCE9PWl8fCh4LnN1cHBvcnQub3B0RGlzYWJsZWQ/bi5kaXNhYmxlZDpudWxsIT09bi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSl8fG4ucGFyZW50Tm9kZS5kaXNhYmxlZCYmeC5ub2RlTmFtZShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKHQ9eChuKS52YWwoKSxvKXJldHVybiB0O2EucHVzaCh0KX1yZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPWUub3B0aW9ucyxvPXgubWFrZUFycmF5KHQpLGE9aS5sZW5ndGg7d2hpbGUoYS0tKXI9aVthXSwoci5zZWxlY3RlZD14LmluQXJyYXkoeChyKS52YWwoKSxvKT49MCkmJihuPSEwKTtyZXR1cm4gbnx8KGUuc2VsZWN0ZWRJbmRleD0tMSksb319fSxhdHRyOmZ1bmN0aW9uKGUsbixyKXt2YXIgbyxhLHM9ZS5ub2RlVHlwZTtpZihlJiYzIT09cyYmOCE9PXMmJjIhPT1zKXJldHVybiB0eXBlb2YgZS5nZXRBdHRyaWJ1dGU9PT1pP3gucHJvcChlLG4scik6KDE9PT1zJiZ4LmlzWE1MRG9jKGUpfHwobj1uLnRvTG93ZXJDYXNlKCksbz14LmF0dHJIb29rc1tuXXx8KHguZXhwci5tYXRjaC5ib29sLnRlc3Qobik/WDp6KSkscj09PXQ/byYmXCJnZXRcImluIG8mJm51bGwhPT0oYT1vLmdldChlLG4pKT9hOihhPXguZmluZC5hdHRyKGUsbiksbnVsbD09YT90OmEpOm51bGwhPT1yP28mJlwic2V0XCJpbiBvJiYoYT1vLnNldChlLHIsbikpIT09dD9hOihlLnNldEF0dHJpYnV0ZShuLHIrXCJcIikscik6KHgucmVtb3ZlQXR0cihlLG4pLHQpKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaT0wLG89dCYmdC5tYXRjaChUKTtpZihvJiYxPT09ZS5ub2RlVHlwZSl3aGlsZShuPW9baSsrXSlyPXgucHJvcEZpeFtuXXx8bix4LmV4cHIubWF0Y2guYm9vbC50ZXN0KG4pP0smJlF8fCFHLnRlc3Qobik/ZVtyXT0hMTplW3guY2FtZWxDYXNlKFwiZGVmYXVsdC1cIituKV09ZVtyXT0hMTp4LmF0dHIoZSxuLFwiXCIpLGUucmVtb3ZlQXR0cmlidXRlKFE/bjpyKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oZSx0KXtpZigheC5zdXBwb3J0LnJhZGlvVmFsdWUmJlwicmFkaW9cIj09PXQmJngubm9kZU5hbWUoZSxcImlucHV0XCIpKXt2YXIgbj1lLnZhbHVlO3JldHVybiBlLnNldEF0dHJpYnV0ZShcInR5cGVcIix0KSxuJiYoZS52YWx1ZT1uKSx0fX19fSxwcm9wRml4OntcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwifSxwcm9wOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1lLm5vZGVUeXBlO2lmKGUmJjMhPT1zJiY4IT09cyYmMiE9PXMpcmV0dXJuIGE9MSE9PXN8fCF4LmlzWE1MRG9jKGUpLGEmJihuPXgucHJvcEZpeFtuXXx8bixvPXgucHJvcEhvb2tzW25dKSxyIT09dD9vJiZcInNldFwiaW4gbyYmKGk9by5zZXQoZSxyLG4pKSE9PXQ/aTplW25dPXI6byYmXCJnZXRcImluIG8mJm51bGwhPT0oaT1vLmdldChlLG4pKT9pOmVbbl19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihlKXt2YXIgdD14LmZpbmQuYXR0cihlLFwidGFiaW5kZXhcIik7cmV0dXJuIHQ/cGFyc2VJbnQodCwxMCk6WS50ZXN0KGUubm9kZU5hbWUpfHxKLnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOi0xfX19fSksWD17c2V0OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdD09PSExP3gucmVtb3ZlQXR0cihlLG4pOksmJlF8fCFHLnRlc3Qobik/ZS5zZXRBdHRyaWJ1dGUoIVEmJngucHJvcEZpeFtuXXx8bixuKTplW3guY2FtZWxDYXNlKFwiZGVmYXVsdC1cIituKV09ZVtuXT0hMCxufX0seC5lYWNoKHguZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSxmdW5jdGlvbihlLG4pe3ZhciByPXguZXhwci5hdHRySGFuZGxlW25dfHx4LmZpbmQuYXR0cjt4LmV4cHIuYXR0ckhhbmRsZVtuXT1LJiZRfHwhRy50ZXN0KG4pP2Z1bmN0aW9uKGUsbixpKXt2YXIgbz14LmV4cHIuYXR0ckhhbmRsZVtuXSxhPWk/dDooeC5leHByLmF0dHJIYW5kbGVbbl09dCkhPXIoZSxuLGkpP24udG9Mb3dlckNhc2UoKTpudWxsO3JldHVybiB4LmV4cHIuYXR0ckhhbmRsZVtuXT1vLGF9OmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gcj90OmVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiK24pXT9uLnRvTG93ZXJDYXNlKCk6bnVsbH19KSxLJiZRfHwoeC5hdHRySG9va3MudmFsdWU9e3NldDpmdW5jdGlvbihlLG4scil7cmV0dXJuIHgubm9kZU5hbWUoZSxcImlucHV0XCIpPyhlLmRlZmF1bHRWYWx1ZT1uLHQpOnomJnouc2V0KGUsbixyKX19KSxRfHwoej17c2V0OmZ1bmN0aW9uKGUsbixyKXt2YXIgaT1lLmdldEF0dHJpYnV0ZU5vZGUocik7cmV0dXJuIGl8fGUuc2V0QXR0cmlidXRlTm9kZShpPWUub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUocikpLGkudmFsdWU9bis9XCJcIixcInZhbHVlXCI9PT1yfHxuPT09ZS5nZXRBdHRyaWJ1dGUocik/bjp0fX0seC5leHByLmF0dHJIYW5kbGUuaWQ9eC5leHByLmF0dHJIYW5kbGUubmFtZT14LmV4cHIuYXR0ckhhbmRsZS5jb29yZHM9ZnVuY3Rpb24oZSxuLHIpe3ZhciBpO3JldHVybiByP3Q6KGk9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSYmXCJcIiE9PWkudmFsdWU/aS52YWx1ZTpudWxsfSx4LnZhbEhvb2tzLmJ1dHRvbj17Z2V0OmZ1bmN0aW9uKGUsbil7dmFyIHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pO3JldHVybiByJiZyLnNwZWNpZmllZD9yLnZhbHVlOnR9LHNldDp6LnNldH0seC5hdHRySG9va3MuY29udGVudGVkaXRhYmxlPXtzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ouc2V0KGUsXCJcIj09PXQ/ITE6dCxuKX19LHguZWFjaChbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLGZ1bmN0aW9uKGUsbil7eC5hdHRySG9va3Nbbl09e3NldDpmdW5jdGlvbihlLHIpe3JldHVyblwiXCI9PT1yPyhlLnNldEF0dHJpYnV0ZShuLFwiYXV0b1wiKSxyKTp0fX19KSkseC5zdXBwb3J0LmhyZWZOb3JtYWxpemVkfHx4LmVhY2goW1wiaHJlZlwiLFwic3JjXCJdLGZ1bmN0aW9uKGUsdCl7eC5wcm9wSG9va3NbdF09e2dldDpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUodCw0KX19fSkseC5zdXBwb3J0LnN0eWxlfHwoeC5hdHRySG9va3Muc3R5bGU9e2dldDpmdW5jdGlvbihlKXtyZXR1cm4gZS5zdHlsZS5jc3NUZXh0fHx0fSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zdHlsZS5jc3NUZXh0PXQrXCJcIn19KSx4LnN1cHBvcnQub3B0U2VsZWN0ZWR8fCh4LnByb3BIb29rcy5zZWxlY3RlZD17Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTtyZXR1cm4gdCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KSxudWxsfX0pLHguZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXt4LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSkseC5zdXBwb3J0LmVuY3R5cGV8fCh4LnByb3BGaXguZW5jdHlwZT1cImVuY29kaW5nXCIpLHguZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXt4LnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5pc0FycmF5KG4pP2UuY2hlY2tlZD14LmluQXJyYXkoeChlKS52YWwoKSxuKT49MDp0fX0seC5zdXBwb3J0LmNoZWNrT258fCh4LnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09PWUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmUudmFsdWV9KX0pO3ZhciBaPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaSxldD0vXmtleS8sdHQ9L14oPzptb3VzZXxjb250ZXh0bWVudSl8Y2xpY2svLG50PS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxydD0vXihbXi5dKikoPzpcXC4oLispfCkkLztmdW5jdGlvbiBpdCgpe3JldHVybiEwfWZ1bmN0aW9uIG90KCl7cmV0dXJuITF9ZnVuY3Rpb24gYXQoKXt0cnl7cmV0dXJuIGEuYWN0aXZlRWxlbWVudH1jYXRjaChlKXt9fXguZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24oZSxuLHIsbyxhKXt2YXIgcyxsLHUsYyxwLGYsZCxoLGcsbSx5LHY9eC5fZGF0YShlKTtpZih2KXtyLmhhbmRsZXImJihjPXIscj1jLmhhbmRsZXIsYT1jLnNlbGVjdG9yKSxyLmd1aWR8fChyLmd1aWQ9eC5ndWlkKyspLChsPXYuZXZlbnRzKXx8KGw9di5ldmVudHM9e30pLChmPXYuaGFuZGxlKXx8KGY9di5oYW5kbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiB4PT09aXx8ZSYmeC5ldmVudC50cmlnZ2VyZWQ9PT1lLnR5cGU/dDp4LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGYuZWxlbSxhcmd1bWVudHMpfSxmLmVsZW09ZSksbj0obnx8XCJcIikubWF0Y2goVCl8fFtcIlwiXSx1PW4ubGVuZ3RoO3doaWxlKHUtLSlzPXJ0LmV4ZWMoblt1XSl8fFtdLGc9eT1zWzFdLG09KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZyYmKHA9eC5ldmVudC5zcGVjaWFsW2ddfHx7fSxnPShhP3AuZGVsZWdhdGVUeXBlOnAuYmluZFR5cGUpfHxnLHA9eC5ldmVudC5zcGVjaWFsW2ddfHx7fSxkPXguZXh0ZW5kKHt0eXBlOmcsb3JpZ1R5cGU6eSxkYXRhOm8saGFuZGxlcjpyLGd1aWQ6ci5ndWlkLHNlbGVjdG9yOmEsbmVlZHNDb250ZXh0OmEmJnguZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChhKSxuYW1lc3BhY2U6bS5qb2luKFwiLlwiKX0sYyksKGg9bFtnXSl8fChoPWxbZ109W10saC5kZWxlZ2F0ZUNvdW50PTAscC5zZXR1cCYmcC5zZXR1cC5jYWxsKGUsbyxtLGYpIT09ITF8fChlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKGcsZiwhMSk6ZS5hdHRhY2hFdmVudCYmZS5hdHRhY2hFdmVudChcIm9uXCIrZyxmKSkpLHAuYWRkJiYocC5hZGQuY2FsbChlLGQpLGQuaGFuZGxlci5ndWlkfHwoZC5oYW5kbGVyLmd1aWQ9ci5ndWlkKSksYT9oLnNwbGljZShoLmRlbGVnYXRlQ291bnQrKywwLGQpOmgucHVzaChkKSx4LmV2ZW50Lmdsb2JhbFtnXT0hMCk7ZT1udWxsfX0scmVtb3ZlOmZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG8sYSxzLGwsdSxjLHAsZixkLGgsZyxtPXguaGFzRGF0YShlKSYmeC5fZGF0YShlKTtpZihtJiYoYz1tLmV2ZW50cykpe3Q9KHR8fFwiXCIpLm1hdGNoKFQpfHxbXCJcIl0sdT10Lmxlbmd0aDt3aGlsZSh1LS0paWYocz1ydC5leGVjKHRbdV0pfHxbXSxkPWc9c1sxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQpe3A9eC5ldmVudC5zcGVjaWFsW2RdfHx7fSxkPShyP3AuZGVsZWdhdGVUeXBlOnAuYmluZFR5cGUpfHxkLGY9Y1tkXXx8W10scz1zWzJdJiZSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKSxsPW89Zi5sZW5ndGg7d2hpbGUoby0tKWE9ZltvXSwhaSYmZyE9PWEub3JpZ1R5cGV8fG4mJm4uZ3VpZCE9PWEuZ3VpZHx8cyYmIXMudGVzdChhLm5hbWVzcGFjZSl8fHImJnIhPT1hLnNlbGVjdG9yJiYoXCIqKlwiIT09cnx8IWEuc2VsZWN0b3IpfHwoZi5zcGxpY2UobywxKSxhLnNlbGVjdG9yJiZmLmRlbGVnYXRlQ291bnQtLSxwLnJlbW92ZSYmcC5yZW1vdmUuY2FsbChlLGEpKTtsJiYhZi5sZW5ndGgmJihwLnRlYXJkb3duJiZwLnRlYXJkb3duLmNhbGwoZSxoLG0uaGFuZGxlKSE9PSExfHx4LnJlbW92ZUV2ZW50KGUsZCxtLmhhbmRsZSksZGVsZXRlIGNbZF0pfWVsc2UgZm9yKGQgaW4gYyl4LmV2ZW50LnJlbW92ZShlLGQrdFt1XSxuLHIsITApO3guaXNFbXB0eU9iamVjdChjKSYmKGRlbGV0ZSBtLmhhbmRsZSx4Ll9yZW1vdmVEYXRhKGUsXCJldmVudHNcIikpfX0sdHJpZ2dlcjpmdW5jdGlvbihuLHIsaSxvKXt2YXIgcyxsLHUsYyxwLGYsZCxoPVtpfHxhXSxnPXYuY2FsbChuLFwidHlwZVwiKT9uLnR5cGU6bixtPXYuY2FsbChuLFwibmFtZXNwYWNlXCIpP24ubmFtZXNwYWNlLnNwbGl0KFwiLlwiKTpbXTtpZih1PWY9aT1pfHxhLDMhPT1pLm5vZGVUeXBlJiY4IT09aS5ub2RlVHlwZSYmIW50LnRlc3QoZyt4LmV2ZW50LnRyaWdnZXJlZCkmJihnLmluZGV4T2YoXCIuXCIpPj0wJiYobT1nLnNwbGl0KFwiLlwiKSxnPW0uc2hpZnQoKSxtLnNvcnQoKSksbD0wPmcuaW5kZXhPZihcIjpcIikmJlwib25cIitnLG49blt4LmV4cGFuZG9dP246bmV3IHguRXZlbnQoZyxcIm9iamVjdFwiPT10eXBlb2YgbiYmbiksbi5pc1RyaWdnZXI9bz8yOjMsbi5uYW1lc3BhY2U9bS5qb2luKFwiLlwiKSxuLm5hbWVzcGFjZV9yZT1uLm5hbWVzcGFjZT9SZWdFeHAoXCIoXnxcXFxcLilcIittLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLG4ucmVzdWx0PXQsbi50YXJnZXR8fChuLnRhcmdldD1pKSxyPW51bGw9PXI/W25dOngubWFrZUFycmF5KHIsW25dKSxwPXguZXZlbnQuc3BlY2lhbFtnXXx8e30sb3x8IXAudHJpZ2dlcnx8cC50cmlnZ2VyLmFwcGx5KGkscikhPT0hMSkpe2lmKCFvJiYhcC5ub0J1YmJsZSYmIXguaXNXaW5kb3coaSkpe2ZvcihjPXAuZGVsZWdhdGVUeXBlfHxnLG50LnRlc3QoYytnKXx8KHU9dS5wYXJlbnROb2RlKTt1O3U9dS5wYXJlbnROb2RlKWgucHVzaCh1KSxmPXU7Zj09PShpLm93bmVyRG9jdW1lbnR8fGEpJiZoLnB1c2goZi5kZWZhdWx0Vmlld3x8Zi5wYXJlbnRXaW5kb3d8fGUpfWQ9MDt3aGlsZSgodT1oW2QrK10pJiYhbi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKW4udHlwZT1kPjE/YzpwLmJpbmRUeXBlfHxnLHM9KHguX2RhdGEodSxcImV2ZW50c1wiKXx8e30pW24udHlwZV0mJnguX2RhdGEodSxcImhhbmRsZVwiKSxzJiZzLmFwcGx5KHUscikscz1sJiZ1W2xdLHMmJnguYWNjZXB0RGF0YSh1KSYmcy5hcHBseSYmcy5hcHBseSh1LHIpPT09ITEmJm4ucHJldmVudERlZmF1bHQoKTtpZihuLnR5cGU9ZywhbyYmIW4uaXNEZWZhdWx0UHJldmVudGVkKCkmJighcC5fZGVmYXVsdHx8cC5fZGVmYXVsdC5hcHBseShoLnBvcCgpLHIpPT09ITEpJiZ4LmFjY2VwdERhdGEoaSkmJmwmJmlbZ10mJiF4LmlzV2luZG93KGkpKXtmPWlbbF0sZiYmKGlbbF09bnVsbCkseC5ldmVudC50cmlnZ2VyZWQ9Zzt0cnl7aVtnXSgpfWNhdGNoKHkpe314LmV2ZW50LnRyaWdnZXJlZD10LGYmJihpW2xdPWYpfXJldHVybiBuLnJlc3VsdH19LGRpc3BhdGNoOmZ1bmN0aW9uKGUpe2U9eC5ldmVudC5maXgoZSk7dmFyIG4scixpLG8sYSxzPVtdLGw9Zy5jYWxsKGFyZ3VtZW50cyksdT0oeC5fZGF0YSh0aGlzLFwiZXZlbnRzXCIpfHx7fSlbZS50eXBlXXx8W10sYz14LmV2ZW50LnNwZWNpYWxbZS50eXBlXXx8e307aWYobFswXT1lLGUuZGVsZWdhdGVUYXJnZXQ9dGhpcywhYy5wcmVEaXNwYXRjaHx8Yy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsZSkhPT0hMSl7cz14LmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyxlLHUpLG49MDt3aGlsZSgobz1zW24rK10pJiYhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtlLmN1cnJlbnRUYXJnZXQ9by5lbGVtLGE9MDt3aGlsZSgoaT1vLmhhbmRsZXJzW2ErK10pJiYhZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSghZS5uYW1lc3BhY2VfcmV8fGUubmFtZXNwYWNlX3JlLnRlc3QoaS5uYW1lc3BhY2UpKSYmKGUuaGFuZGxlT2JqPWksZS5kYXRhPWkuZGF0YSxyPSgoeC5ldmVudC5zcGVjaWFsW2kub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxpLmhhbmRsZXIpLmFwcGx5KG8uZWxlbSxsKSxyIT09dCYmKGUucmVzdWx0PXIpPT09ITEmJihlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSkpfXJldHVybiBjLnBvc3REaXNwYXRjaCYmYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLGUpLGUucmVzdWx0fX0saGFuZGxlcnM6ZnVuY3Rpb24oZSxuKXt2YXIgcixpLG8sYSxzPVtdLGw9bi5kZWxlZ2F0ZUNvdW50LHU9ZS50YXJnZXQ7aWYobCYmdS5ub2RlVHlwZSYmKCFlLmJ1dHRvbnx8XCJjbGlja1wiIT09ZS50eXBlKSlmb3IoO3UhPXRoaXM7dT11LnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PXUubm9kZVR5cGUmJih1LmRpc2FibGVkIT09ITB8fFwiY2xpY2tcIiE9PWUudHlwZSkpe2ZvcihvPVtdLGE9MDtsPmE7YSsrKWk9blthXSxyPWkuc2VsZWN0b3IrXCIgXCIsb1tyXT09PXQmJihvW3JdPWkubmVlZHNDb250ZXh0P3gocix0aGlzKS5pbmRleCh1KT49MDp4LmZpbmQocix0aGlzLG51bGwsW3VdKS5sZW5ndGgpLG9bcl0mJm8ucHVzaChpKTtvLmxlbmd0aCYmcy5wdXNoKHtlbGVtOnUsaGFuZGxlcnM6b30pfXJldHVybiBuLmxlbmd0aD5sJiZzLnB1c2goe2VsZW06dGhpcyxoYW5kbGVyczpuLnNsaWNlKGwpfSksc30sZml4OmZ1bmN0aW9uKGUpe2lmKGVbeC5leHBhbmRvXSlyZXR1cm4gZTt2YXIgdCxuLHIsaT1lLnR5cGUsbz1lLHM9dGhpcy5maXhIb29rc1tpXTtzfHwodGhpcy5maXhIb29rc1tpXT1zPXR0LnRlc3QoaSk/dGhpcy5tb3VzZUhvb2tzOmV0LnRlc3QoaSk/dGhpcy5rZXlIb29rczp7fSkscj1zLnByb3BzP3RoaXMucHJvcHMuY29uY2F0KHMucHJvcHMpOnRoaXMucHJvcHMsZT1uZXcgeC5FdmVudChvKSx0PXIubGVuZ3RoO3doaWxlKHQtLSluPXJbdF0sZVtuXT1vW25dO3JldHVybiBlLnRhcmdldHx8KGUudGFyZ2V0PW8uc3JjRWxlbWVudHx8YSksMz09PWUudGFyZ2V0Lm5vZGVUeXBlJiYoZS50YXJnZXQ9ZS50YXJnZXQucGFyZW50Tm9kZSksZS5tZXRhS2V5PSEhZS5tZXRhS2V5LHMuZmlsdGVyP3MuZmlsdGVyKGUsbyk6ZX0scHJvcHM6XCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09ZS53aGljaCYmKGUud2hpY2g9bnVsbCE9dC5jaGFyQ29kZT90LmNoYXJDb2RlOnQua2V5Q29kZSksZX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihlLG4pe3ZhciByLGksbyxzPW4uYnV0dG9uLGw9bi5mcm9tRWxlbWVudDtyZXR1cm4gbnVsbD09ZS5wYWdlWCYmbnVsbCE9bi5jbGllbnRYJiYoaT1lLnRhcmdldC5vd25lckRvY3VtZW50fHxhLG89aS5kb2N1bWVudEVsZW1lbnQscj1pLmJvZHksZS5wYWdlWD1uLmNsaWVudFgrKG8mJm8uc2Nyb2xsTGVmdHx8ciYmci5zY3JvbGxMZWZ0fHwwKS0obyYmby5jbGllbnRMZWZ0fHxyJiZyLmNsaWVudExlZnR8fDApLGUucGFnZVk9bi5jbGllbnRZKyhvJiZvLnNjcm9sbFRvcHx8ciYmci5zY3JvbGxUb3B8fDApLShvJiZvLmNsaWVudFRvcHx8ciYmci5jbGllbnRUb3B8fDApKSwhZS5yZWxhdGVkVGFyZ2V0JiZsJiYoZS5yZWxhdGVkVGFyZ2V0PWw9PT1lLnRhcmdldD9uLnRvRWxlbWVudDpsKSxlLndoaWNofHxzPT09dHx8KGUud2hpY2g9MSZzPzE6MiZzPzM6NCZzPzI6MCksZX19LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxmb2N1czp7dHJpZ2dlcjpmdW5jdGlvbigpe2lmKHRoaXMhPT1hdCgpJiZ0aGlzLmZvY3VzKXRyeXtyZXR1cm4gdGhpcy5mb2N1cygpLCExfWNhdGNoKGUpe319LGRlbGVnYXRlVHlwZTpcImZvY3VzaW5cIn0sYmx1cjp7dHJpZ2dlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzPT09YXQoKSYmdGhpcy5ibHVyPyh0aGlzLmJsdXIoKSwhMSk6dH0sZGVsZWdhdGVUeXBlOlwiZm9jdXNvdXRcIn0sY2xpY2s6e3RyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm4geC5ub2RlTmFtZSh0aGlzLFwiaW5wdXRcIikmJlwiY2hlY2tib3hcIj09PXRoaXMudHlwZSYmdGhpcy5jbGljaz8odGhpcy5jbGljaygpLCExKTp0fSxfZGVmYXVsdDpmdW5jdGlvbihlKXtyZXR1cm4geC5ub2RlTmFtZShlLnRhcmdldCxcImFcIil9fSxiZWZvcmV1bmxvYWQ6e3Bvc3REaXNwYXRjaDpmdW5jdGlvbihlKXtlLnJlc3VsdCE9PXQmJihlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9ZS5yZXN1bHQpfX19LHNpbXVsYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXguZXh0ZW5kKG5ldyB4LkV2ZW50LG4se3R5cGU6ZSxpc1NpbXVsYXRlZDohMCxvcmlnaW5hbEV2ZW50Ont9fSk7cj94LmV2ZW50LnRyaWdnZXIoaSxudWxsLHQpOnguZXZlbnQuZGlzcGF0Y2guY2FsbCh0LGkpLGkuaXNEZWZhdWx0UHJldmVudGVkKCkmJm4ucHJldmVudERlZmF1bHQoKX19LHgucmVtb3ZlRXZlbnQ9YS5yZW1vdmVFdmVudExpc3RlbmVyP2Z1bmN0aW9uKGUsdCxuKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4sITEpfTpmdW5jdGlvbihlLHQsbil7dmFyIHI9XCJvblwiK3Q7ZS5kZXRhY2hFdmVudCYmKHR5cGVvZiBlW3JdPT09aSYmKGVbcl09bnVsbCksZS5kZXRhY2hFdmVudChyLG4pKX0seC5FdmVudD1mdW5jdGlvbihlLG4pe3JldHVybiB0aGlzIGluc3RhbmNlb2YgeC5FdmVudD8oZSYmZS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0aGlzLnR5cGU9ZS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWUuZGVmYXVsdFByZXZlbnRlZHx8ZS5yZXR1cm5WYWx1ZT09PSExfHxlLmdldFByZXZlbnREZWZhdWx0JiZlLmdldFByZXZlbnREZWZhdWx0KCk/aXQ6b3QpOnRoaXMudHlwZT1lLG4mJnguZXh0ZW5kKHRoaXMsbiksdGhpcy50aW1lU3RhbXA9ZSYmZS50aW1lU3RhbXB8fHgubm93KCksdGhpc1t4LmV4cGFuZG9dPSEwLHQpOm5ldyB4LkV2ZW50KGUsbil9LHguRXZlbnQucHJvdG90eXBlPXtpc0RlZmF1bHRQcmV2ZW50ZWQ6b3QsaXNQcm9wYWdhdGlvblN0b3BwZWQ6b3QsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6b3QscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9aXQsZSYmKGUucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITEpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1pdCxlJiYoZS5zdG9wUHJvcGFnYXRpb24mJmUuc3RvcFByb3BhZ2F0aW9uKCksZS5jYW5jZWxCdWJibGU9ITApfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPWl0LHRoaXMuc3RvcFByb3BhZ2F0aW9uKCl9fSx4LmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIn0sZnVuY3Rpb24oZSx0KXt4LmV2ZW50LnNwZWNpYWxbZV09e2RlbGVnYXRlVHlwZTp0LGJpbmRUeXBlOnQsaGFuZGxlOmZ1bmN0aW9uKGUpe3ZhciBuLHI9dGhpcyxpPWUucmVsYXRlZFRhcmdldCxvPWUuaGFuZGxlT2JqO3JldHVybighaXx8aSE9PXImJiF4LmNvbnRhaW5zKHIsaSkpJiYoZS50eXBlPW8ub3JpZ1R5cGUsbj1vLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGUudHlwZT10KSxufX19KSx4LnN1cHBvcnQuc3VibWl0QnViYmxlc3x8KHguZXZlbnQuc3BlY2lhbC5zdWJtaXQ9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHgubm9kZU5hbWUodGhpcyxcImZvcm1cIik/ITE6KHguZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fc3VibWl0IGtleXByZXNzLl9zdWJtaXRcIixmdW5jdGlvbihlKXt2YXIgbj1lLnRhcmdldCxyPXgubm9kZU5hbWUobixcImlucHV0XCIpfHx4Lm5vZGVOYW1lKG4sXCJidXR0b25cIik/bi5mb3JtOnQ7ciYmIXguX2RhdGEocixcInN1Ym1pdEJ1YmJsZXNcIikmJih4LmV2ZW50LmFkZChyLFwic3VibWl0Ll9zdWJtaXRcIixmdW5jdGlvbihlKXtlLl9zdWJtaXRfYnViYmxlPSEwfSkseC5fZGF0YShyLFwic3VibWl0QnViYmxlc1wiLCEwKSl9KSx0KX0scG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe2UuX3N1Ym1pdF9idWJibGUmJihkZWxldGUgZS5fc3VibWl0X2J1YmJsZSx0aGlzLnBhcmVudE5vZGUmJiFlLmlzVHJpZ2dlciYmeC5ldmVudC5zaW11bGF0ZShcInN1Ym1pdFwiLHRoaXMucGFyZW50Tm9kZSxlLCEwKSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7cmV0dXJuIHgubm9kZU5hbWUodGhpcyxcImZvcm1cIik/ITE6KHguZXZlbnQucmVtb3ZlKHRoaXMsXCIuX3N1Ym1pdFwiKSx0KX19KSx4LnN1cHBvcnQuY2hhbmdlQnViYmxlc3x8KHguZXZlbnQuc3BlY2lhbC5jaGFuZ2U9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIFoudGVzdCh0aGlzLm5vZGVOYW1lKT8oKFwiY2hlY2tib3hcIj09PXRoaXMudHlwZXx8XCJyYWRpb1wiPT09dGhpcy50eXBlKSYmKHguZXZlbnQuYWRkKHRoaXMsXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7XCJjaGVja2VkXCI9PT1lLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lJiYodGhpcy5fanVzdF9jaGFuZ2VkPSEwKX0pLHguZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7dGhpcy5fanVzdF9jaGFuZ2VkJiYhZS5pc1RyaWdnZXImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITEpLHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLGUsITApfSkpLCExKTooeC5ldmVudC5hZGQodGhpcyxcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIixmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDtaLnRlc3QodC5ub2RlTmFtZSkmJiF4Ll9kYXRhKHQsXCJjaGFuZ2VCdWJibGVzXCIpJiYoeC5ldmVudC5hZGQodCxcImNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7IXRoaXMucGFyZW50Tm9kZXx8ZS5pc1NpbXVsYXRlZHx8ZS5pc1RyaWdnZXJ8fHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLnBhcmVudE5vZGUsZSwhMCl9KSx4Ll9kYXRhKHQsXCJjaGFuZ2VCdWJibGVzXCIsITApKX0pLHQpfSxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQ7cmV0dXJuIHRoaXMhPT1ufHxlLmlzU2ltdWxhdGVkfHxlLmlzVHJpZ2dlcnx8XCJyYWRpb1wiIT09bi50eXBlJiZcImNoZWNrYm94XCIhPT1uLnR5cGU/ZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dH0sdGVhcmRvd246ZnVuY3Rpb24oKXtyZXR1cm4geC5ldmVudC5yZW1vdmUodGhpcyxcIi5fY2hhbmdlXCIpLCFaLnRlc3QodGhpcy5ub2RlTmFtZSl9fSkseC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzfHx4LmVhY2goe2ZvY3VzOlwiZm9jdXNpblwiLGJsdXI6XCJmb2N1c291dFwifSxmdW5jdGlvbihlLHQpe3ZhciBuPTAscj1mdW5jdGlvbihlKXt4LmV2ZW50LnNpbXVsYXRlKHQsZS50YXJnZXQseC5ldmVudC5maXgoZSksITApfTt4LmV2ZW50LnNwZWNpYWxbdF09e3NldHVwOmZ1bmN0aW9uKCl7MD09PW4rKyYmYS5hZGRFdmVudExpc3RlbmVyKGUsciwhMCl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7MD09PS0tbiYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGUsciwhMCl9fX0pLHguZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihlLG4scixpLG8pe3ZhciBhLHM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe1wic3RyaW5nXCIhPXR5cGVvZiBuJiYocj1yfHxuLG49dCk7Zm9yKGEgaW4gZSl0aGlzLm9uKGEsbixyLGVbYV0sbyk7cmV0dXJuIHRoaXN9aWYobnVsbD09ciYmbnVsbD09aT8oaT1uLHI9bj10KTpudWxsPT1pJiYoXCJzdHJpbmdcIj09dHlwZW9mIG4/KGk9cixyPXQpOihpPXIscj1uLG49dCkpLGk9PT0hMSlpPW90O2Vsc2UgaWYoIWkpcmV0dXJuIHRoaXM7cmV0dXJuIDE9PT1vJiYocz1pLGk9ZnVuY3Rpb24oZSl7cmV0dXJuIHgoKS5vZmYoZSkscy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGkuZ3VpZD1zLmd1aWR8fChzLmd1aWQ9eC5ndWlkKyspKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt4LmV2ZW50LmFkZCh0aGlzLGUsaSxyLG4pfSl9LG9uZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbihlLHQsbixyLDEpfSxvZmY6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpLG87aWYoZSYmZS5wcmV2ZW50RGVmYXVsdCYmZS5oYW5kbGVPYmopcmV0dXJuIGk9ZS5oYW5kbGVPYmoseChlLmRlbGVnYXRlVGFyZ2V0KS5vZmYoaS5uYW1lc3BhY2U/aS5vcmlnVHlwZStcIi5cIitpLm5hbWVzcGFjZTppLm9yaWdUeXBlLGkuc2VsZWN0b3IsaS5oYW5kbGVyKSx0aGlzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlKXtmb3IobyBpbiBlKXRoaXMub2ZmKG8sbixlW29dKTtyZXR1cm4gdGhpc31yZXR1cm4obj09PSExfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKSYmKHI9bixuPXQpLHI9PT0hMSYmKHI9b3QpLHRoaXMuZWFjaChmdW5jdGlvbigpe3guZXZlbnQucmVtb3ZlKHRoaXMsZSxyLG4pfSl9LHRyaWdnZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7eC5ldmVudC50cmlnZ2VyKGUsdCx0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihlLG4pe3ZhciByPXRoaXNbMF07cmV0dXJuIHI/eC5ldmVudC50cmlnZ2VyKGUsbixyLCEwKTp0fX0pO3ZhciBzdD0vXi5bXjojXFxbXFwuLF0qJC8sbHQ9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sdXQ9eC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxjdD17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTt4LmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihlKXt2YXIgdCxuPVtdLHI9dGhpcyxpPXIubGVuZ3RoO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLnB1c2hTdGFjayh4KGUpLmZpbHRlcihmdW5jdGlvbigpe2Zvcih0PTA7aT50O3QrKylpZih4LmNvbnRhaW5zKHJbdF0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKHQ9MDtpPnQ7dCsrKXguZmluZChlLHJbdF0sbik7cmV0dXJuIG49dGhpcy5wdXNoU3RhY2soaT4xP3gudW5pcXVlKG4pOm4pLG4uc2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj90aGlzLnNlbGVjdG9yK1wiIFwiK2U6ZSxufSxoYXM6ZnVuY3Rpb24oZSl7dmFyIHQsbj14KGUsdGhpcykscj1uLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodD0wO3I+dDt0KyspaWYoeC5jb250YWlucyh0aGlzLG5bdF0pKXJldHVybiEwfSl9LG5vdDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZnQodGhpcyxlfHxbXSwhMCkpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsZXx8W10sITEpKX0saXM6ZnVuY3Rpb24oZSl7cmV0dXJuISFmdCh0aGlzLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZ1dC50ZXN0KGUpP3goZSk6ZXx8W10sITEpLmxlbmd0aH0sY2xvc2VzdDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXRoaXMubGVuZ3RoLG89W10sYT11dC50ZXN0KGUpfHxcInN0cmluZ1wiIT10eXBlb2YgZT94KGUsdHx8dGhpcy5jb250ZXh0KTowO2Zvcig7aT5yO3IrKylmb3Iobj10aGlzW3JdO24mJm4hPT10O249bi5wYXJlbnROb2RlKWlmKDExPm4ubm9kZVR5cGUmJihhP2EuaW5kZXgobik+LTE6MT09PW4ubm9kZVR5cGUmJnguZmluZC5tYXRjaGVzU2VsZWN0b3IobixlKSkpe249by5wdXNoKG4pO2JyZWFrfXJldHVybiB0aGlzLnB1c2hTdGFjayhvLmxlbmd0aD4xP3gudW5pcXVlKG8pOm8pfSxpbmRleDpmdW5jdGlvbihlKXtyZXR1cm4gZT9cInN0cmluZ1wiPT10eXBlb2YgZT94LmluQXJyYXkodGhpc1swXSx4KGUpKTp4LmluQXJyYXkoZS5qcXVlcnk/ZVswXTplLHRoaXMpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGUsdCl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGU/eChlLHQpOngubWFrZUFycmF5KGUmJmUubm9kZVR5cGU/W2VdOmUpLHI9eC5tZXJnZSh0aGlzLmdldCgpLG4pO3JldHVybiB0aGlzLnB1c2hTdGFjayh4LnVuaXF1ZShyKSl9LGFkZEJhY2s6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWU/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpfX0pO2Z1bmN0aW9uIHB0KGUsdCl7ZG8gZT1lW3RdO3doaWxlKGUmJjEhPT1lLm5vZGVUeXBlKTtyZXR1cm4gZX14LmVhY2goe3BhcmVudDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJjExIT09dC5ub2RlVHlwZT90Om51bGx9LHBhcmVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZGlyKGUsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB4LmRpcihlLFwicGFyZW50Tm9kZVwiLG4pfSxuZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBwdChlLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oZSl7cmV0dXJuIHB0KGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZGlyKGUsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihlKXtyZXR1cm4geC5kaXIoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4geC5kaXIoZSxcIm5leHRTaWJsaW5nXCIsbil9LHByZXZVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHguZGlyKGUsXCJwcmV2aW91c1NpYmxpbmdcIixuKX0sc2libGluZ3M6ZnVuY3Rpb24oZSl7cmV0dXJuIHguc2libGluZygoZS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxlKX0sY2hpbGRyZW46ZnVuY3Rpb24oZSl7cmV0dXJuIHguc2libGluZyhlLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihlKXtyZXR1cm4geC5ub2RlTmFtZShlLFwiaWZyYW1lXCIpP2UuY29udGVudERvY3VtZW50fHxlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6eC5tZXJnZShbXSxlLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oZSx0KXt4LmZuW2VdPWZ1bmN0aW9uKG4scil7dmFyIGk9eC5tYXAodGhpcyx0LG4pO3JldHVyblwiVW50aWxcIiE9PWUuc2xpY2UoLTUpJiYocj1uKSxyJiZcInN0cmluZ1wiPT10eXBlb2YgciYmKGk9eC5maWx0ZXIocixpKSksdGhpcy5sZW5ndGg+MSYmKGN0W2VdfHwoaT14LnVuaXF1ZShpKSksbHQudGVzdChlKSYmKGk9aS5yZXZlcnNlKCkpKSx0aGlzLnB1c2hTdGFjayhpKX19KSx4LmV4dGVuZCh7ZmlsdGVyOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdO3JldHVybiBuJiYoZT1cIjpub3QoXCIrZStcIilcIiksMT09PXQubGVuZ3RoJiYxPT09ci5ub2RlVHlwZT94LmZpbmQubWF0Y2hlc1NlbGVjdG9yKHIsZSk/W3JdOltdOnguZmluZC5tYXRjaGVzKGUseC5ncmVwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfSkpfSxkaXI6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpPVtdLG89ZVtuXTt3aGlsZShvJiY5IT09by5ub2RlVHlwZSYmKHI9PT10fHwxIT09by5ub2RlVHlwZXx8IXgobykuaXMocikpKTE9PT1vLm5vZGVUeXBlJiZpLnB1c2gobyksbz1vW25dO3JldHVybiBpfSxzaWJsaW5nOmZ1bmN0aW9uKGUsdCl7dmFyIG49W107Zm9yKDtlO2U9ZS5uZXh0U2libGluZykxPT09ZS5ub2RlVHlwZSYmZSE9PXQmJm4ucHVzaChlKTtyZXR1cm4gbn19KTtmdW5jdGlvbiBmdChlLHQsbil7aWYoeC5pc0Z1bmN0aW9uKHQpKXJldHVybiB4LmdyZXAoZSxmdW5jdGlvbihlLHIpe3JldHVybiEhdC5jYWxsKGUscixlKSE9PW59KTtpZih0Lm5vZGVUeXBlKXJldHVybiB4LmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZT09PXQhPT1ufSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKHN0LnRlc3QodCkpcmV0dXJuIHguZmlsdGVyKHQsZSxuKTt0PXguZmlsdGVyKHQsZSl9cmV0dXJuIHguZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybiB4LmluQXJyYXkoZSx0KT49MCE9PW59KX1mdW5jdGlvbiBkdChlKXt2YXIgdD1odC5zcGxpdChcInxcIiksbj1lLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihuLmNyZWF0ZUVsZW1lbnQpd2hpbGUodC5sZW5ndGgpbi5jcmVhdGVFbGVtZW50KHQucG9wKCkpO3JldHVybiBufXZhciBodD1cImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixndD0vIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxtdD1SZWdFeHAoXCI8KD86XCIraHQrXCIpW1xcXFxzLz5dXCIsXCJpXCIpLHl0PS9eXFxzKy8sdnQ9LzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLGJ0PS88KFtcXHc6XSspLyx4dD0vPHRib2R5L2ksd3Q9Lzx8JiM/XFx3KzsvLFR0PS88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksQ3Q9L14oPzpjaGVja2JveHxyYWRpbykkL2ksTnQ9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxrdD0vXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLEV0PS9edHJ1ZVxcLyguKikvLFN0PS9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxBdD17b3B0aW9uOlsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLGxlZ2VuZDpbMSxcIjxmaWVsZHNldD5cIixcIjwvZmllbGRzZXQ+XCJdLGFyZWE6WzEsXCI8bWFwPlwiLFwiPC9tYXA+XCJdLHBhcmFtOlsxLFwiPG9iamVjdD5cIixcIjwvb2JqZWN0PlwiXSx0aGVhZDpbMSxcIjx0YWJsZT5cIixcIjwvdGFibGU+XCJdLHRyOlsyLFwiPHRhYmxlPjx0Ym9keT5cIixcIjwvdGJvZHk+PC90YWJsZT5cIl0sY29sOlsyLFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIixcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sdGQ6WzMsXCI8dGFibGU+PHRib2R5Pjx0cj5cIixcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxfZGVmYXVsdDp4LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZT9bMCxcIlwiLFwiXCJdOlsxLFwiWDxkaXY+XCIsXCI8L2Rpdj5cIl19LGp0PWR0KGEpLER0PWp0LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7QXQub3B0Z3JvdXA9QXQub3B0aW9uLEF0LnRib2R5PUF0LnRmb290PUF0LmNvbGdyb3VwPUF0LmNhcHRpb249QXQudGhlYWQsQXQudGg9QXQudGQseC5mbi5leHRlbmQoe3RleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHguYWNjZXNzKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT10P3gudGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuYXBwZW5kKCh0aGlzWzBdJiZ0aGlzWzBdLm93bmVyRG9jdW1lbnR8fGEpLmNyZWF0ZVRleHROb2RlKGUpKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oZSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciB0PUx0KHRoaXMsZSk7dC5hcHBlbmRDaGlsZChlKX19KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIHQ9THQodGhpcyxlKTt0Lmluc2VydEJlZm9yZShlLHQuZmlyc3RDaGlsZCl9fSl9LGJlZm9yZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzKX0pfSxhZnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzLm5leHRTaWJsaW5nKX0pfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWU/eC5maWx0ZXIoZSx0aGlzKTp0aGlzLGk9MDtmb3IoO251bGwhPShuPXJbaV0pO2krKyl0fHwxIT09bi5ub2RlVHlwZXx8eC5jbGVhbkRhdGEoRnQobikpLG4ucGFyZW50Tm9kZSYmKHQmJnguY29udGFpbnMobi5vd25lckRvY3VtZW50LG4pJiZfdChGdChuLFwic2NyaXB0XCIpKSxuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobikpO3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3ZhciBlLHQ9MDtmb3IoO251bGwhPShlPXRoaXNbdF0pO3QrKyl7MT09PWUubm9kZVR5cGUmJnguY2xlYW5EYXRhKEZ0KGUsITEpKTt3aGlsZShlLmZpcnN0Q2hpbGQpZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2Uub3B0aW9ucyYmeC5ub2RlTmFtZShlLFwic2VsZWN0XCIpJiYoZS5vcHRpb25zLmxlbmd0aD0wKX1yZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1udWxsPT1lPyExOmUsdD1udWxsPT10P2U6dCx0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiB4LmNsb25lKHRoaXMsZSx0KX0pfSxodG1sOmZ1bmN0aW9uKGUpe3JldHVybiB4LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXNbMF18fHt9LHI9MCxpPXRoaXMubGVuZ3RoO2lmKGU9PT10KXJldHVybiAxPT09bi5ub2RlVHlwZT9uLmlubmVySFRNTC5yZXBsYWNlKGd0LFwiXCIpOnQ7aWYoIShcInN0cmluZ1wiIT10eXBlb2YgZXx8VHQudGVzdChlKXx8IXguc3VwcG9ydC5odG1sU2VyaWFsaXplJiZtdC50ZXN0KGUpfHwheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlJiZ5dC50ZXN0KGUpfHxBdFsoYnQuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSl7ZT1lLnJlcGxhY2UodnQsXCI8JDE+PC8kMj5cIik7dHJ5e2Zvcig7aT5yO3IrKyluPXRoaXNbcl18fHt9LDE9PT1uLm5vZGVUeXBlJiYoeC5jbGVhbkRhdGEoRnQobiwhMSkpLG4uaW5uZXJIVE1MPWUpO249MH1jYXRjaChvKXt9fW4mJnRoaXMuZW1wdHkoKS5hcHBlbmQoZSl9LG51bGwsZSxhcmd1bWVudHMubGVuZ3RoKX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24oKXt2YXIgZT14Lm1hcCh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybltlLm5leHRTaWJsaW5nLGUucGFyZW50Tm9kZV19KSx0PTA7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKG4pe3ZhciByPWVbdCsrXSxpPWVbdCsrXTtpJiYociYmci5wYXJlbnROb2RlIT09aSYmKHI9dGhpcy5uZXh0U2libGluZykseCh0aGlzKS5yZW1vdmUoKSxpLmluc2VydEJlZm9yZShuLHIpKX0sITApLHQ/dGhpczp0aGlzLnJlbW92ZSgpfSxkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVtb3ZlKGUsITApfSxkb21NYW5pcDpmdW5jdGlvbihlLHQsbil7ZT1kLmFwcGx5KFtdLGUpO3ZhciByLGksbyxhLHMsbCx1PTAsYz10aGlzLmxlbmd0aCxwPXRoaXMsZj1jLTEsaD1lWzBdLGc9eC5pc0Z1bmN0aW9uKGgpO2lmKGd8fCEoMT49Y3x8XCJzdHJpbmdcIiE9dHlwZW9mIGh8fHguc3VwcG9ydC5jaGVja0Nsb25lKSYmTnQudGVzdChoKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHIpe3ZhciBpPXAuZXEocik7ZyYmKGVbMF09aC5jYWxsKHRoaXMscixpLmh0bWwoKSkpLGkuZG9tTWFuaXAoZSx0LG4pfSk7aWYoYyYmKGw9eC5idWlsZEZyYWdtZW50KGUsdGhpc1swXS5vd25lckRvY3VtZW50LCExLCFuJiZ0aGlzKSxyPWwuZmlyc3RDaGlsZCwxPT09bC5jaGlsZE5vZGVzLmxlbmd0aCYmKGw9cikscikpe2ZvcihhPXgubWFwKEZ0KGwsXCJzY3JpcHRcIiksSHQpLG89YS5sZW5ndGg7Yz51O3UrKylpPWwsdSE9PWYmJihpPXguY2xvbmUoaSwhMCwhMCksbyYmeC5tZXJnZShhLEZ0KGksXCJzY3JpcHRcIikpKSx0LmNhbGwodGhpc1t1XSxpLHUpO2lmKG8pZm9yKHM9YVthLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LHgubWFwKGEscXQpLHU9MDtvPnU7dSsrKWk9YVt1XSxrdC50ZXN0KGkudHlwZXx8XCJcIikmJiF4Ll9kYXRhKGksXCJnbG9iYWxFdmFsXCIpJiZ4LmNvbnRhaW5zKHMsaSkmJihpLnNyYz94Ll9ldmFsVXJsKGkuc3JjKTp4Lmdsb2JhbEV2YWwoKGkudGV4dHx8aS50ZXh0Q29udGVudHx8aS5pbm5lckhUTUx8fFwiXCIpLnJlcGxhY2UoU3QsXCJcIikpKTtsPXI9bnVsbH1yZXR1cm4gdGhpc319KTtmdW5jdGlvbiBMdChlLHQpe3JldHVybiB4Lm5vZGVOYW1lKGUsXCJ0YWJsZVwiKSYmeC5ub2RlTmFtZSgxPT09dC5ub2RlVHlwZT90OnQuZmlyc3RDaGlsZCxcInRyXCIpP2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXXx8ZS5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKTplfWZ1bmN0aW9uIEh0KGUpe3JldHVybiBlLnR5cGU9KG51bGwhPT14LmZpbmQuYXR0cihlLFwidHlwZVwiKSkrXCIvXCIrZS50eXBlLGV9ZnVuY3Rpb24gcXQoZSl7dmFyIHQ9RXQuZXhlYyhlLnR5cGUpO3JldHVybiB0P2UudHlwZT10WzFdOmUucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSxlfWZ1bmN0aW9uIF90KGUsdCl7dmFyIG4scj0wO2Zvcig7bnVsbCE9KG49ZVtyXSk7cisrKXguX2RhdGEobixcImdsb2JhbEV2YWxcIiwhdHx8eC5fZGF0YSh0W3JdLFwiZ2xvYmFsRXZhbFwiKSl9ZnVuY3Rpb24gTXQoZSx0KXtpZigxPT09dC5ub2RlVHlwZSYmeC5oYXNEYXRhKGUpKXt2YXIgbixyLGksbz14Ll9kYXRhKGUpLGE9eC5fZGF0YSh0LG8pLHM9by5ldmVudHM7aWYocyl7ZGVsZXRlIGEuaGFuZGxlLGEuZXZlbnRzPXt9O2ZvcihuIGluIHMpZm9yKHI9MCxpPXNbbl0ubGVuZ3RoO2k+cjtyKyspeC5ldmVudC5hZGQodCxuLHNbbl1bcl0pfWEuZGF0YSYmKGEuZGF0YT14LmV4dGVuZCh7fSxhLmRhdGEpKX19ZnVuY3Rpb24gT3QoZSx0KXt2YXIgbixyLGk7aWYoMT09PXQubm9kZVR5cGUpe2lmKG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCF4LnN1cHBvcnQubm9DbG9uZUV2ZW50JiZ0W3guZXhwYW5kb10pe2k9eC5fZGF0YSh0KTtmb3IociBpbiBpLmV2ZW50cyl4LnJlbW92ZUV2ZW50KHQscixpLmhhbmRsZSk7dC5yZW1vdmVBdHRyaWJ1dGUoeC5leHBhbmRvKX1cInNjcmlwdFwiPT09biYmdC50ZXh0IT09ZS50ZXh0PyhIdCh0KS50ZXh0PWUudGV4dCxxdCh0KSk6XCJvYmplY3RcIj09PW4/KHQucGFyZW50Tm9kZSYmKHQub3V0ZXJIVE1MPWUub3V0ZXJIVE1MKSx4LnN1cHBvcnQuaHRtbDVDbG9uZSYmZS5pbm5lckhUTUwmJiF4LnRyaW0odC5pbm5lckhUTUwpJiYodC5pbm5lckhUTUw9ZS5pbm5lckhUTUwpKTpcImlucHV0XCI9PT1uJiZDdC50ZXN0KGUudHlwZSk/KHQuZGVmYXVsdENoZWNrZWQ9dC5jaGVja2VkPWUuY2hlY2tlZCx0LnZhbHVlIT09ZS52YWx1ZSYmKHQudmFsdWU9ZS52YWx1ZSkpOlwib3B0aW9uXCI9PT1uP3QuZGVmYXVsdFNlbGVjdGVkPXQuc2VsZWN0ZWQ9ZS5kZWZhdWx0U2VsZWN0ZWQ6KFwiaW5wdXRcIj09PW58fFwidGV4dGFyZWFcIj09PW4pJiYodC5kZWZhdWx0VmFsdWU9ZS5kZWZhdWx0VmFsdWUpfX14LmVhY2goe2FwcGVuZFRvOlwiYXBwZW5kXCIscHJlcGVuZFRvOlwicHJlcGVuZFwiLGluc2VydEJlZm9yZTpcImJlZm9yZVwiLGluc2VydEFmdGVyOlwiYWZ0ZXJcIixyZXBsYWNlQWxsOlwicmVwbGFjZVdpdGhcIn0sZnVuY3Rpb24oZSx0KXt4LmZuW2VdPWZ1bmN0aW9uKGUpe3ZhciBuLHI9MCxpPVtdLG89eChlKSxhPW8ubGVuZ3RoLTE7Zm9yKDthPj1yO3IrKyluPXI9PT1hP3RoaXM6dGhpcy5jbG9uZSghMCkseChvW3JdKVt0XShuKSxoLmFwcGx5KGksbi5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGkpfX0pO2Z1bmN0aW9uIEZ0KGUsbil7dmFyIHIsbyxhPTAscz10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSE9PWk/ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShufHxcIipcIik6dHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbCE9PWk/ZS5xdWVyeVNlbGVjdG9yQWxsKG58fFwiKlwiKTp0O2lmKCFzKWZvcihzPVtdLHI9ZS5jaGlsZE5vZGVzfHxlO251bGwhPShvPXJbYV0pO2ErKykhbnx8eC5ub2RlTmFtZShvLG4pP3MucHVzaChvKTp4Lm1lcmdlKHMsRnQobyxuKSk7cmV0dXJuIG49PT10fHxuJiZ4Lm5vZGVOYW1lKGUsbik/eC5tZXJnZShbZV0scyk6c31mdW5jdGlvbiBCdChlKXtDdC50ZXN0KGUudHlwZSkmJihlLmRlZmF1bHRDaGVja2VkPWUuY2hlY2tlZCl9eC5leHRlbmQoe2Nsb25lOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLGw9eC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSk7aWYoeC5zdXBwb3J0Lmh0bWw1Q2xvbmV8fHguaXNYTUxEb2MoZSl8fCFtdC50ZXN0KFwiPFwiK2Uubm9kZU5hbWUrXCI+XCIpP289ZS5jbG9uZU5vZGUoITApOihEdC5pbm5lckhUTUw9ZS5vdXRlckhUTUwsRHQucmVtb3ZlQ2hpbGQobz1EdC5maXJzdENoaWxkKSksISh4LnN1cHBvcnQubm9DbG9uZUV2ZW50JiZ4LnN1cHBvcnQubm9DbG9uZUNoZWNrZWR8fDEhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGV8fHguaXNYTUxEb2MoZSkpKWZvcihyPUZ0KG8pLHM9RnQoZSksYT0wO251bGwhPShpPXNbYV0pOysrYSlyW2FdJiZPdChpLHJbYV0pO2lmKHQpaWYobilmb3Iocz1zfHxGdChlKSxyPXJ8fEZ0KG8pLGE9MDtudWxsIT0oaT1zW2FdKTthKyspTXQoaSxyW2FdKTtlbHNlIE10KGUsbyk7cmV0dXJuIHI9RnQobyxcInNjcmlwdFwiKSxyLmxlbmd0aD4wJiZfdChyLCFsJiZGdChlLFwic2NyaXB0XCIpKSxyPXM9aT1udWxsLG99LGJ1aWxkRnJhZ21lbnQ6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsbCx1LGMscD1lLmxlbmd0aCxmPWR0KHQpLGQ9W10saD0wO2Zvcig7cD5oO2grKylpZihvPWVbaF0sb3x8MD09PW8paWYoXCJvYmplY3RcIj09PXgudHlwZShvKSl4Lm1lcmdlKGQsby5ub2RlVHlwZT9bb106byk7ZWxzZSBpZih3dC50ZXN0KG8pKXtzPXN8fGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxsPShidC5leGVjKG8pfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSxjPUF0W2xdfHxBdC5fZGVmYXVsdCxzLmlubmVySFRNTD1jWzFdK28ucmVwbGFjZSh2dCxcIjwkMT48LyQyPlwiKStjWzJdLGk9Y1swXTt3aGlsZShpLS0pcz1zLmxhc3RDaGlsZDtpZigheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlJiZ5dC50ZXN0KG8pJiZkLnB1c2godC5jcmVhdGVUZXh0Tm9kZSh5dC5leGVjKG8pWzBdKSksIXguc3VwcG9ydC50Ym9keSl7bz1cInRhYmxlXCIhPT1sfHx4dC50ZXN0KG8pP1wiPHRhYmxlPlwiIT09Y1sxXXx8eHQudGVzdChvKT8wOnM6cy5maXJzdENoaWxkLGk9byYmby5jaGlsZE5vZGVzLmxlbmd0aDt3aGlsZShpLS0peC5ub2RlTmFtZSh1PW8uY2hpbGROb2Rlc1tpXSxcInRib2R5XCIpJiYhdS5jaGlsZE5vZGVzLmxlbmd0aCYmby5yZW1vdmVDaGlsZCh1KX14Lm1lcmdlKGQscy5jaGlsZE5vZGVzKSxzLnRleHRDb250ZW50PVwiXCI7d2hpbGUocy5maXJzdENoaWxkKXMucmVtb3ZlQ2hpbGQocy5maXJzdENoaWxkKTtzPWYubGFzdENoaWxkfWVsc2UgZC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO3MmJmYucmVtb3ZlQ2hpbGQocykseC5zdXBwb3J0LmFwcGVuZENoZWNrZWR8fHguZ3JlcChGdChkLFwiaW5wdXRcIiksQnQpLGg9MDt3aGlsZShvPWRbaCsrXSlpZigoIXJ8fC0xPT09eC5pbkFycmF5KG8scikpJiYoYT14LmNvbnRhaW5zKG8ub3duZXJEb2N1bWVudCxvKSxzPUZ0KGYuYXBwZW5kQ2hpbGQobyksXCJzY3JpcHRcIiksYSYmX3Qocyksbikpe2k9MDt3aGlsZShvPXNbaSsrXSlrdC50ZXN0KG8udHlwZXx8XCJcIikmJm4ucHVzaChvKX1yZXR1cm4gcz1udWxsLGZ9LGNsZWFuRGF0YTpmdW5jdGlvbihlLHQpe3ZhciBuLHIsbyxhLHM9MCxsPXguZXhwYW5kbyx1PXguY2FjaGUsYz14LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyxmPXguZXZlbnQuc3BlY2lhbDtmb3IoO251bGwhPShuPWVbc10pO3MrKylpZigodHx8eC5hY2NlcHREYXRhKG4pKSYmKG89bltsXSxhPW8mJnVbb10pKXtpZihhLmV2ZW50cylmb3IociBpbiBhLmV2ZW50cylmW3JdP3guZXZlbnQucmVtb3ZlKG4scik6eC5yZW1vdmVFdmVudChuLHIsYS5oYW5kbGUpO1xudVtvXSYmKGRlbGV0ZSB1W29dLGM/ZGVsZXRlIG5bbF06dHlwZW9mIG4ucmVtb3ZlQXR0cmlidXRlIT09aT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuW2xdPW51bGwscC5wdXNoKG8pKX19LF9ldmFsVXJsOmZ1bmN0aW9uKGUpe3JldHVybiB4LmFqYXgoe3VybDplLHR5cGU6XCJHRVRcIixkYXRhVHlwZTpcInNjcmlwdFwiLGFzeW5jOiExLGdsb2JhbDohMSxcInRocm93c1wiOiEwfSl9fSkseC5mbi5leHRlbmQoe3dyYXBBbGw6ZnVuY3Rpb24oZSl7aWYoeC5pc0Z1bmN0aW9uKGUpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7eCh0aGlzKS53cmFwQWxsKGUuY2FsbCh0aGlzLHQpKX0pO2lmKHRoaXNbMF0pe3ZhciB0PXgoZSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKTt0aGlzWzBdLnBhcmVudE5vZGUmJnQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLHQubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aGlsZShlLmZpcnN0Q2hpbGQmJjE9PT1lLmZpcnN0Q2hpbGQubm9kZVR5cGUpZT1lLmZpcnN0Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcyl9cmV0dXJuIHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihlKXtyZXR1cm4geC5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbih0KXt4KHRoaXMpLndyYXBJbm5lcihlLmNhbGwodGhpcyx0KSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD14KHRoaXMpLG49dC5jb250ZW50cygpO24ubGVuZ3RoP24ud3JhcEFsbChlKTp0LmFwcGVuZChlKX0pfSx3cmFwOmZ1bmN0aW9uKGUpe3ZhciB0PXguaXNGdW5jdGlvbihlKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3godGhpcykud3JhcEFsbCh0P2UuY2FsbCh0aGlzLG4pOmUpfSl9LHVud3JhcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXt4Lm5vZGVOYW1lKHRoaXMsXCJib2R5XCIpfHx4KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KS5lbmQoKX19KTt2YXIgUHQsUnQsV3QsJHQ9L2FscGhhXFwoW14pXSpcXCkvaSxJdD0vb3BhY2l0eVxccyo9XFxzKihbXildKikvLHp0PS9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLyxYdD0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sVXQ9L15tYXJnaW4vLFZ0PVJlZ0V4cChcIl4oXCIrdytcIikoLiopJFwiLFwiaVwiKSxZdD1SZWdFeHAoXCJeKFwiK3crXCIpKD8hcHgpW2EteiVdKyRcIixcImlcIiksSnQ9UmVnRXhwKFwiXihbKy1dKT0oXCIrdytcIilcIixcImlcIiksR3Q9e0JPRFk6XCJibG9ja1wifSxRdD17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sS3Q9e2xldHRlclNwYWNpbmc6MCxmb250V2VpZ2h0OjQwMH0sWnQ9W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLGVuPVtcIldlYmtpdFwiLFwiT1wiLFwiTW96XCIsXCJtc1wiXTtmdW5jdGlvbiB0bihlLHQpe2lmKHQgaW4gZSlyZXR1cm4gdDt2YXIgbj10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSkscj10LGk9ZW4ubGVuZ3RoO3doaWxlKGktLSlpZih0PWVuW2ldK24sdCBpbiBlKXJldHVybiB0O3JldHVybiByfWZ1bmN0aW9uIG5uKGUsdCl7cmV0dXJuIGU9dHx8ZSxcIm5vbmVcIj09PXguY3NzKGUsXCJkaXNwbGF5XCIpfHwheC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSl9ZnVuY3Rpb24gcm4oZSx0KXt2YXIgbixyLGksbz1bXSxhPTAscz1lLmxlbmd0aDtmb3IoO3M+YTthKyspcj1lW2FdLHIuc3R5bGUmJihvW2FdPXguX2RhdGEocixcIm9sZGRpc3BsYXlcIiksbj1yLnN0eWxlLmRpc3BsYXksdD8ob1thXXx8XCJub25lXCIhPT1ufHwoci5zdHlsZS5kaXNwbGF5PVwiXCIpLFwiXCI9PT1yLnN0eWxlLmRpc3BsYXkmJm5uKHIpJiYob1thXT14Ll9kYXRhKHIsXCJvbGRkaXNwbGF5XCIsbG4oci5ub2RlTmFtZSkpKSk6b1thXXx8KGk9bm4ociksKG4mJlwibm9uZVwiIT09bnx8IWkpJiZ4Ll9kYXRhKHIsXCJvbGRkaXNwbGF5XCIsaT9uOnguY3NzKHIsXCJkaXNwbGF5XCIpKSkpO2ZvcihhPTA7cz5hO2ErKylyPWVbYV0sci5zdHlsZSYmKHQmJlwibm9uZVwiIT09ci5zdHlsZS5kaXNwbGF5JiZcIlwiIT09ci5zdHlsZS5kaXNwbGF5fHwoci5zdHlsZS5kaXNwbGF5PXQ/b1thXXx8XCJcIjpcIm5vbmVcIikpO3JldHVybiBlfXguZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihlLG4scil7dmFyIGksbyxhPXt9LHM9MDtpZih4LmlzQXJyYXkobikpe2ZvcihvPVJ0KGUpLGk9bi5sZW5ndGg7aT5zO3MrKylhW25bc11dPXguY3NzKGUsbltzXSwhMSxvKTtyZXR1cm4gYX1yZXR1cm4gciE9PXQ/eC5zdHlsZShlLG4scik6eC5jc3MoZSxuKX0sZSxuLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHNob3c6ZnVuY3Rpb24oKXtyZXR1cm4gcm4odGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gcm4odGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihlKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGU/ZT90aGlzLnNob3coKTp0aGlzLmhpZGUoKTp0aGlzLmVhY2goZnVuY3Rpb24oKXtubih0aGlzKT94KHRoaXMpLnNob3coKTp4KHRoaXMpLmhpZGUoKX0pfX0pLHguZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGUsdCl7aWYodCl7dmFyIG49V3QoZSxcIm9wYWNpdHlcIik7cmV0dXJuXCJcIj09PW4/XCIxXCI6bn19fX0sY3NzTnVtYmVyOntjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmb250V2VpZ2h0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e1wiZmxvYXRcIjp4LnN1cHBvcnQuY3NzRmxvYXQ/XCJjc3NGbG9hdFwiOlwic3R5bGVGbG9hdFwifSxzdHlsZTpmdW5jdGlvbihlLG4scixpKXtpZihlJiYzIT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJmUuc3R5bGUpe3ZhciBvLGEscyxsPXguY2FtZWxDYXNlKG4pLHU9ZS5zdHlsZTtpZihuPXguY3NzUHJvcHNbbF18fCh4LmNzc1Byb3BzW2xdPXRuKHUsbCkpLHM9eC5jc3NIb29rc1tuXXx8eC5jc3NIb29rc1tsXSxyPT09dClyZXR1cm4gcyYmXCJnZXRcImluIHMmJihvPXMuZ2V0KGUsITEsaSkpIT09dD9vOnVbbl07aWYoYT10eXBlb2YgcixcInN0cmluZ1wiPT09YSYmKG89SnQuZXhlYyhyKSkmJihyPShvWzFdKzEpKm9bMl0rcGFyc2VGbG9hdCh4LmNzcyhlLG4pKSxhPVwibnVtYmVyXCIpLCEobnVsbD09cnx8XCJudW1iZXJcIj09PWEmJmlzTmFOKHIpfHwoXCJudW1iZXJcIiE9PWF8fHguY3NzTnVtYmVyW2xdfHwocis9XCJweFwiKSx4LnN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09cnx8MCE9PW4uaW5kZXhPZihcImJhY2tncm91bmRcIil8fCh1W25dPVwiaW5oZXJpdFwiKSxzJiZcInNldFwiaW4gcyYmKHI9cy5zZXQoZSxyLGkpKT09PXQpKSl0cnl7dVtuXT1yfWNhdGNoKGMpe319fSxjc3M6ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIG8sYSxzLGw9eC5jYW1lbENhc2Uobik7cmV0dXJuIG49eC5jc3NQcm9wc1tsXXx8KHguY3NzUHJvcHNbbF09dG4oZS5zdHlsZSxsKSkscz14LmNzc0hvb2tzW25dfHx4LmNzc0hvb2tzW2xdLHMmJlwiZ2V0XCJpbiBzJiYoYT1zLmdldChlLCEwLHIpKSxhPT09dCYmKGE9V3QoZSxuLGkpKSxcIm5vcm1hbFwiPT09YSYmbiBpbiBLdCYmKGE9S3Rbbl0pLFwiXCI9PT1yfHxyPyhvPXBhcnNlRmxvYXQoYSkscj09PSEwfHx4LmlzTnVtZXJpYyhvKT9vfHwwOmEpOmF9fSksZS5nZXRDb21wdXRlZFN0eWxlPyhSdD1mdW5jdGlvbih0KXtyZXR1cm4gZS5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCl9LFd0PWZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1yfHxSdChlKSxsPXM/cy5nZXRQcm9wZXJ0eVZhbHVlKG4pfHxzW25dOnQsdT1lLnN0eWxlO3JldHVybiBzJiYoXCJcIiE9PWx8fHguY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfHwobD14LnN0eWxlKGUsbikpLFl0LnRlc3QobCkmJlV0LnRlc3QobikmJihpPXUud2lkdGgsbz11Lm1pbldpZHRoLGE9dS5tYXhXaWR0aCx1Lm1pbldpZHRoPXUubWF4V2lkdGg9dS53aWR0aD1sLGw9cy53aWR0aCx1LndpZHRoPWksdS5taW5XaWR0aD1vLHUubWF4V2lkdGg9YSkpLGx9KTphLmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUmJihSdD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jdXJyZW50U3R5bGV9LFd0PWZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1yfHxSdChlKSxsPXM/c1tuXTp0LHU9ZS5zdHlsZTtyZXR1cm4gbnVsbD09bCYmdSYmdVtuXSYmKGw9dVtuXSksWXQudGVzdChsKSYmIXp0LnRlc3QobikmJihpPXUubGVmdCxvPWUucnVudGltZVN0eWxlLGE9byYmby5sZWZ0LGEmJihvLmxlZnQ9ZS5jdXJyZW50U3R5bGUubGVmdCksdS5sZWZ0PVwiZm9udFNpemVcIj09PW4/XCIxZW1cIjpsLGw9dS5waXhlbExlZnQrXCJweFwiLHUubGVmdD1pLGEmJihvLmxlZnQ9YSkpLFwiXCI9PT1sP1wiYXV0b1wiOmx9KTtmdW5jdGlvbiBvbihlLHQsbil7dmFyIHI9VnQuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMV0tKG58fDApKSsoclsyXXx8XCJweFwiKTp0fWZ1bmN0aW9uIGFuKGUsdCxuLHIsaSl7dmFyIG89bj09PShyP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpPzQ6XCJ3aWR0aFwiPT09dD8xOjAsYT0wO2Zvcig7ND5vO28rPTIpXCJtYXJnaW5cIj09PW4mJihhKz14LmNzcyhlLG4rWnRbb10sITAsaSkpLHI/KFwiY29udGVudFwiPT09biYmKGEtPXguY3NzKGUsXCJwYWRkaW5nXCIrWnRbb10sITAsaSkpLFwibWFyZ2luXCIhPT1uJiYoYS09eC5jc3MoZSxcImJvcmRlclwiK1p0W29dK1wiV2lkdGhcIiwhMCxpKSkpOihhKz14LmNzcyhlLFwicGFkZGluZ1wiK1p0W29dLCEwLGkpLFwicGFkZGluZ1wiIT09biYmKGErPXguY3NzKGUsXCJib3JkZXJcIitadFtvXStcIldpZHRoXCIsITAsaSkpKTtyZXR1cm4gYX1mdW5jdGlvbiBzbihlLHQsbil7dmFyIHI9ITAsaT1cIndpZHRoXCI9PT10P2Uub2Zmc2V0V2lkdGg6ZS5vZmZzZXRIZWlnaHQsbz1SdChlKSxhPXguc3VwcG9ydC5ib3hTaXppbmcmJlwiYm9yZGVyLWJveFwiPT09eC5jc3MoZSxcImJveFNpemluZ1wiLCExLG8pO2lmKDA+PWl8fG51bGw9PWkpe2lmKGk9V3QoZSx0LG8pLCgwPml8fG51bGw9PWkpJiYoaT1lLnN0eWxlW3RdKSxZdC50ZXN0KGkpKXJldHVybiBpO3I9YSYmKHguc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZXx8aT09PWUuc3R5bGVbdF0pLGk9cGFyc2VGbG9hdChpKXx8MH1yZXR1cm4gaSthbihlLHQsbnx8KGE/XCJib3JkZXJcIjpcImNvbnRlbnRcIikscixvKStcInB4XCJ9ZnVuY3Rpb24gbG4oZSl7dmFyIHQ9YSxuPUd0W2VdO3JldHVybiBufHwobj11bihlLHQpLFwibm9uZVwiIT09biYmbnx8KFB0PShQdHx8eChcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIikuY3NzKFwiY3NzVGV4dFwiLFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XCIpKS5hcHBlbmRUbyh0LmRvY3VtZW50RWxlbWVudCksdD0oUHRbMF0uY29udGVudFdpbmRvd3x8UHRbMF0uY29udGVudERvY3VtZW50KS5kb2N1bWVudCx0LndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpLHQuY2xvc2UoKSxuPXVuKGUsdCksUHQuZGV0YWNoKCkpLEd0W2VdPW4pLG59ZnVuY3Rpb24gdW4oZSx0KXt2YXIgbj14KHQuY3JlYXRlRWxlbWVudChlKSkuYXBwZW5kVG8odC5ib2R5KSxyPXguY3NzKG5bMF0sXCJkaXNwbGF5XCIpO3JldHVybiBuLnJlbW92ZSgpLHJ9eC5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oZSxuKXt4LmNzc0hvb2tzW25dPXtnZXQ6ZnVuY3Rpb24oZSxyLGkpe3JldHVybiByPzA9PT1lLm9mZnNldFdpZHRoJiZYdC50ZXN0KHguY3NzKGUsXCJkaXNwbGF5XCIpKT94LnN3YXAoZSxRdCxmdW5jdGlvbigpe3JldHVybiBzbihlLG4saSl9KTpzbihlLG4saSk6dH0sc2V0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1yJiZSdChlKTtyZXR1cm4gb24oZSx0LHI/YW4oZSxuLHIseC5zdXBwb3J0LmJveFNpemluZyYmXCJib3JkZXItYm94XCI9PT14LmNzcyhlLFwiYm94U2l6aW5nXCIsITEsaSksaSk6MCl9fX0pLHguc3VwcG9ydC5vcGFjaXR5fHwoeC5jc3NIb29rcy5vcGFjaXR5PXtnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXQudGVzdCgodCYmZS5jdXJyZW50U3R5bGU/ZS5jdXJyZW50U3R5bGUuZmlsdGVyOmUuc3R5bGUuZmlsdGVyKXx8XCJcIik/LjAxKnBhcnNlRmxvYXQoUmVnRXhwLiQxKStcIlwiOnQ/XCIxXCI6XCJcIn0sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5zdHlsZSxyPWUuY3VycmVudFN0eWxlLGk9eC5pc051bWVyaWModCk/XCJhbHBoYShvcGFjaXR5PVwiKzEwMCp0K1wiKVwiOlwiXCIsbz1yJiZyLmZpbHRlcnx8bi5maWx0ZXJ8fFwiXCI7bi56b29tPTEsKHQ+PTF8fFwiXCI9PT10KSYmXCJcIj09PXgudHJpbShvLnJlcGxhY2UoJHQsXCJcIikpJiZuLnJlbW92ZUF0dHJpYnV0ZSYmKG4ucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLFwiXCI9PT10fHxyJiYhci5maWx0ZXIpfHwobi5maWx0ZXI9JHQudGVzdChvKT9vLnJlcGxhY2UoJHQsaSk6bytcIiBcIitpKX19KSx4KGZ1bmN0aW9uKCl7eC5zdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHR8fCh4LmNzc0hvb2tzLm1hcmdpblJpZ2h0PXtnZXQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbj94LnN3YXAoZSx7ZGlzcGxheTpcImlubGluZS1ibG9ja1wifSxXdCxbZSxcIm1hcmdpblJpZ2h0XCJdKTp0fX0pLCF4LnN1cHBvcnQucGl4ZWxQb3NpdGlvbiYmeC5mbi5wb3NpdGlvbiYmeC5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihlLG4pe3guY3NzSG9va3Nbbl09e2dldDpmdW5jdGlvbihlLHIpe3JldHVybiByPyhyPVd0KGUsbiksWXQudGVzdChyKT94KGUpLnBvc2l0aW9uKClbbl0rXCJweFwiOnIpOnR9fX0pfSkseC5leHByJiZ4LmV4cHIuZmlsdGVycyYmKHguZXhwci5maWx0ZXJzLmhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4gMD49ZS5vZmZzZXRXaWR0aCYmMD49ZS5vZmZzZXRIZWlnaHR8fCF4LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzJiZcIm5vbmVcIj09PShlLnN0eWxlJiZlLnN0eWxlLmRpc3BsYXl8fHguY3NzKGUsXCJkaXNwbGF5XCIpKX0seC5leHByLmZpbHRlcnMudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4heC5leHByLmZpbHRlcnMuaGlkZGVuKGUpfSkseC5lYWNoKHttYXJnaW46XCJcIixwYWRkaW5nOlwiXCIsYm9yZGVyOlwiV2lkdGhcIn0sZnVuY3Rpb24oZSx0KXt4LmNzc0hvb2tzW2UrdF09e2V4cGFuZDpmdW5jdGlvbihuKXt2YXIgcj0wLGk9e30sbz1cInN0cmluZ1wiPT10eXBlb2Ygbj9uLnNwbGl0KFwiIFwiKTpbbl07Zm9yKDs0PnI7cisrKWlbZStadFtyXSt0XT1vW3JdfHxvW3ItMl18fG9bMF07cmV0dXJuIGl9fSxVdC50ZXN0KGUpfHwoeC5jc3NIb29rc1tlK3RdLnNldD1vbil9KTt2YXIgY249LyUyMC9nLHBuPS9cXFtcXF0kLyxmbj0vXFxyP1xcbi9nLGRuPS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxobj0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7eC5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiB4LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSl9LHNlcmlhbGl6ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGU9eC5wcm9wKHRoaXMsXCJlbGVtZW50c1wiKTtyZXR1cm4gZT94Lm1ha2VBcnJheShlKTp0aGlzfSkuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy50eXBlO3JldHVybiB0aGlzLm5hbWUmJiF4KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpJiZobi50ZXN0KHRoaXMubm9kZU5hbWUpJiYhZG4udGVzdChlKSYmKHRoaXMuY2hlY2tlZHx8IUN0LnRlc3QoZSkpfSkubWFwKGZ1bmN0aW9uKGUsdCl7dmFyIG49eCh0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09bj9udWxsOnguaXNBcnJheShuKT94Lm1hcChuLGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOnQubmFtZSx2YWx1ZTplLnJlcGxhY2UoZm4sXCJcXHJcXG5cIil9fSk6e25hbWU6dC5uYW1lLHZhbHVlOm4ucmVwbGFjZShmbixcIlxcclxcblwiKX19KS5nZXQoKX19KSx4LnBhcmFtPWZ1bmN0aW9uKGUsbil7dmFyIHIsaT1bXSxvPWZ1bmN0aW9uKGUsdCl7dD14LmlzRnVuY3Rpb24odCk/dCgpOm51bGw9PXQ/XCJcIjp0LGlbaS5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChlKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQodCl9O2lmKG49PT10JiYobj14LmFqYXhTZXR0aW5ncyYmeC5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwpLHguaXNBcnJheShlKXx8ZS5qcXVlcnkmJiF4LmlzUGxhaW5PYmplY3QoZSkpeC5lYWNoKGUsZnVuY3Rpb24oKXtvKHRoaXMubmFtZSx0aGlzLnZhbHVlKX0pO2Vsc2UgZm9yKHIgaW4gZSlnbihyLGVbcl0sbixvKTtyZXR1cm4gaS5qb2luKFwiJlwiKS5yZXBsYWNlKGNuLFwiK1wiKX07ZnVuY3Rpb24gZ24oZSx0LG4scil7dmFyIGk7aWYoeC5pc0FycmF5KHQpKXguZWFjaCh0LGZ1bmN0aW9uKHQsaSl7bnx8cG4udGVzdChlKT9yKGUsaSk6Z24oZStcIltcIisoXCJvYmplY3RcIj09dHlwZW9mIGk/dDpcIlwiKStcIl1cIixpLG4scil9KTtlbHNlIGlmKG58fFwib2JqZWN0XCIhPT14LnR5cGUodCkpcihlLHQpO2Vsc2UgZm9yKGkgaW4gdClnbihlK1wiW1wiK2krXCJdXCIsdFtpXSxuLHIpfXguZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXt4LmZuW3RdPWZ1bmN0aW9uKGUsbil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKHQsbnVsbCxlLG4pOnRoaXMudHJpZ2dlcih0KX19KSx4LmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGUpLm1vdXNlbGVhdmUodHx8ZSl9LGJpbmQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLm9uKGUsbnVsbCx0LG4pfSx1bmJpbmQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vZmYoZSxudWxsLHQpfSxkZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbih0LGUsbixyKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGUsXCIqKlwiKTp0aGlzLm9mZih0LGV8fFwiKipcIixuKX19KTt2YXIgbW4seW4sdm49eC5ub3coKSxibj0vXFw/Lyx4bj0vIy4qJC8sd249LyhbPyZdKV89W14mXSovLFRuPS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL2dtLENuPS9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLE5uPS9eKD86R0VUfEhFQUQpJC8sa249L15cXC9cXC8vLEVuPS9eKFtcXHcuKy1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFNuPXguZm4ubG9hZCxBbj17fSxqbj17fSxEbj1cIiovXCIuY29uY2F0KFwiKlwiKTt0cnl7eW49by5ocmVmfWNhdGNoKExuKXt5bj1hLmNyZWF0ZUVsZW1lbnQoXCJhXCIpLHluLmhyZWY9XCJcIix5bj15bi5ocmVmfW1uPUVuLmV4ZWMoeW4udG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIEhuKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe1wic3RyaW5nXCIhPXR5cGVvZiB0JiYobj10LHQ9XCIqXCIpO3ZhciByLGk9MCxvPXQudG9Mb3dlckNhc2UoKS5tYXRjaChUKXx8W107aWYoeC5pc0Z1bmN0aW9uKG4pKXdoaWxlKHI9b1tpKytdKVwiK1wiPT09clswXT8ocj1yLnNsaWNlKDEpfHxcIipcIiwoZVtyXT1lW3JdfHxbXSkudW5zaGlmdChuKSk6KGVbcl09ZVtyXXx8W10pLnB1c2gobil9fWZ1bmN0aW9uIHFuKGUsbixyLGkpe3ZhciBvPXt9LGE9ZT09PWpuO2Z1bmN0aW9uIHMobCl7dmFyIHU7cmV0dXJuIG9bbF09ITAseC5lYWNoKGVbbF18fFtdLGZ1bmN0aW9uKGUsbCl7dmFyIGM9bChuLHIsaSk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGN8fGF8fG9bY10/YT8hKHU9Yyk6dDoobi5kYXRhVHlwZXMudW5zaGlmdChjKSxzKGMpLCExKX0pLHV9cmV0dXJuIHMobi5kYXRhVHlwZXNbMF0pfHwhb1tcIipcIl0mJnMoXCIqXCIpfWZ1bmN0aW9uIF9uKGUsbil7dmFyIHIsaSxvPXguYWpheFNldHRpbmdzLmZsYXRPcHRpb25zfHx7fTtmb3IoaSBpbiBuKW5baV0hPT10JiYoKG9baV0/ZTpyfHwocj17fSkpW2ldPW5baV0pO3JldHVybiByJiZ4LmV4dGVuZCghMCxlLHIpLGV9eC5mbi5sb2FkPWZ1bmN0aW9uKGUsbixyKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmU24pcmV0dXJuIFNuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgaSxvLGEscz10aGlzLGw9ZS5pbmRleE9mKFwiIFwiKTtyZXR1cm4gbD49MCYmKGk9ZS5zbGljZShsLGUubGVuZ3RoKSxlPWUuc2xpY2UoMCxsKSkseC5pc0Z1bmN0aW9uKG4pPyhyPW4sbj10KTpuJiZcIm9iamVjdFwiPT10eXBlb2YgbiYmKGE9XCJQT1NUXCIpLHMubGVuZ3RoPjAmJnguYWpheCh7dXJsOmUsdHlwZTphLGRhdGFUeXBlOlwiaHRtbFwiLGRhdGE6bn0pLmRvbmUoZnVuY3Rpb24oZSl7bz1hcmd1bWVudHMscy5odG1sKGk/eChcIjxkaXY+XCIpLmFwcGVuZCh4LnBhcnNlSFRNTChlKSkuZmluZChpKTplKX0pLmNvbXBsZXRlKHImJmZ1bmN0aW9uKGUsdCl7cy5lYWNoKHIsb3x8W2UucmVzcG9uc2VUZXh0LHQsZV0pfSksdGhpc30seC5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oZSx0KXt4LmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSkseC5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOnluLHR5cGU6XCJHRVRcIixpc0xvY2FsOkNuLnRlc3QobW5bMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOkRuLHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjp4LnBhcnNlSlNPTixcInRleHQgeG1sXCI6eC5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/X24oX24oZSx4LmFqYXhTZXR0aW5ncyksdCk6X24oeC5hamF4U2V0dGluZ3MsZSl9LGFqYXhQcmVmaWx0ZXI6SG4oQW4pLGFqYXhUcmFuc3BvcnQ6SG4oam4pLGFqYXg6ZnVuY3Rpb24oZSxuKXtcIm9iamVjdFwiPT10eXBlb2YgZSYmKG49ZSxlPXQpLG49bnx8e307dmFyIHIsaSxvLGEscyxsLHUsYyxwPXguYWpheFNldHVwKHt9LG4pLGY9cC5jb250ZXh0fHxwLGQ9cC5jb250ZXh0JiYoZi5ub2RlVHlwZXx8Zi5qcXVlcnkpP3goZik6eC5ldmVudCxoPXguRGVmZXJyZWQoKSxnPXguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksbT1wLnN0YXR1c0NvZGV8fHt9LHk9e30sdj17fSxiPTAsdz1cImNhbmNlbGVkXCIsQz17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKDI9PT1iKXtpZighYyl7Yz17fTt3aGlsZSh0PVRuLmV4ZWMoYSkpY1t0WzFdLnRvTG93ZXJDYXNlKCldPXRbMl19dD1jW2UudG9Mb3dlckNhc2UoKV19cmV0dXJuIG51bGw9PXQ/bnVsbDp0fSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gMj09PWI/YTpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS50b0xvd2VyQ2FzZSgpO3JldHVybiBifHwoZT12W25dPXZbbl18fGUseVtlXT10KSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGUpe3JldHVybiBifHwocC5taW1lVHlwZT1lKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGUpaWYoMj5iKWZvcih0IGluIGUpbVt0XT1bbVt0XSxlW3RdXTtlbHNlIEMuYWx3YXlzKGVbQy5zdGF0dXNdKTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZXx8dztyZXR1cm4gdSYmdS5hYm9ydCh0KSxrKDAsdCksdGhpc319O2lmKGgucHJvbWlzZShDKS5jb21wbGV0ZT1nLmFkZCxDLnN1Y2Nlc3M9Qy5kb25lLEMuZXJyb3I9Qy5mYWlsLHAudXJsPSgoZXx8cC51cmx8fHluKStcIlwiKS5yZXBsYWNlKHhuLFwiXCIpLnJlcGxhY2Uoa24sbW5bMV0rXCIvL1wiKSxwLnR5cGU9bi5tZXRob2R8fG4udHlwZXx8cC5tZXRob2R8fHAudHlwZSxwLmRhdGFUeXBlcz14LnRyaW0ocC5kYXRhVHlwZXx8XCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goVCl8fFtcIlwiXSxudWxsPT1wLmNyb3NzRG9tYWluJiYocj1Fbi5leGVjKHAudXJsLnRvTG93ZXJDYXNlKCkpLHAuY3Jvc3NEb21haW49ISghcnx8clsxXT09PW1uWzFdJiZyWzJdPT09bW5bMl0mJihyWzNdfHwoXCJodHRwOlwiPT09clsxXT9cIjgwXCI6XCI0NDNcIikpPT09KG1uWzNdfHwoXCJodHRwOlwiPT09bW5bMV0/XCI4MFwiOlwiNDQzXCIpKSkpLHAuZGF0YSYmcC5wcm9jZXNzRGF0YSYmXCJzdHJpbmdcIiE9dHlwZW9mIHAuZGF0YSYmKHAuZGF0YT14LnBhcmFtKHAuZGF0YSxwLnRyYWRpdGlvbmFsKSkscW4oQW4scCxuLEMpLDI9PT1iKXJldHVybiBDO2w9cC5nbG9iYWwsbCYmMD09PXguYWN0aXZlKysmJnguZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSxwLnR5cGU9cC50eXBlLnRvVXBwZXJDYXNlKCkscC5oYXNDb250ZW50PSFObi50ZXN0KHAudHlwZSksbz1wLnVybCxwLmhhc0NvbnRlbnR8fChwLmRhdGEmJihvPXAudXJsKz0oYm4udGVzdChvKT9cIiZcIjpcIj9cIikrcC5kYXRhLGRlbGV0ZSBwLmRhdGEpLHAuY2FjaGU9PT0hMSYmKHAudXJsPXduLnRlc3Qobyk/by5yZXBsYWNlKHduLFwiJDFfPVwiK3ZuKyspOm8rKGJuLnRlc3Qobyk/XCImXCI6XCI/XCIpK1wiXz1cIit2bisrKSkscC5pZk1vZGlmaWVkJiYoeC5sYXN0TW9kaWZpZWRbb10mJkMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIseC5sYXN0TW9kaWZpZWRbb10pLHguZXRhZ1tvXSYmQy5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLHguZXRhZ1tvXSkpLChwLmRhdGEmJnAuaGFzQ29udGVudCYmcC5jb250ZW50VHlwZSE9PSExfHxuLmNvbnRlbnRUeXBlKSYmQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIscC5jb250ZW50VHlwZSksQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIscC5kYXRhVHlwZXNbMF0mJnAuYWNjZXB0c1twLmRhdGFUeXBlc1swXV0/cC5hY2NlcHRzW3AuZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT1wLmRhdGFUeXBlc1swXT9cIiwgXCIrRG4rXCI7IHE9MC4wMVwiOlwiXCIpOnAuYWNjZXB0c1tcIipcIl0pO2ZvcihpIGluIHAuaGVhZGVycylDLnNldFJlcXVlc3RIZWFkZXIoaSxwLmhlYWRlcnNbaV0pO2lmKHAuYmVmb3JlU2VuZCYmKHAuYmVmb3JlU2VuZC5jYWxsKGYsQyxwKT09PSExfHwyPT09YikpcmV0dXJuIEMuYWJvcnQoKTt3PVwiYWJvcnRcIjtmb3IoaSBpbntzdWNjZXNzOjEsZXJyb3I6MSxjb21wbGV0ZToxfSlDW2ldKHBbaV0pO2lmKHU9cW4oam4scCxuLEMpKXtDLnJlYWR5U3RhdGU9MSxsJiZkLnRyaWdnZXIoXCJhamF4U2VuZFwiLFtDLHBdKSxwLmFzeW5jJiZwLnRpbWVvdXQ+MCYmKHM9c2V0VGltZW91dChmdW5jdGlvbigpe0MuYWJvcnQoXCJ0aW1lb3V0XCIpfSxwLnRpbWVvdXQpKTt0cnl7Yj0xLHUuc2VuZCh5LGspfWNhdGNoKE4pe2lmKCEoMj5iKSl0aHJvdyBOO2soLTEsTil9fWVsc2UgaygtMSxcIk5vIFRyYW5zcG9ydFwiKTtmdW5jdGlvbiBrKGUsbixyLGkpe3ZhciBjLHksdix3LFQsTj1uOzIhPT1iJiYoYj0yLHMmJmNsZWFyVGltZW91dChzKSx1PXQsYT1pfHxcIlwiLEMucmVhZHlTdGF0ZT1lPjA/NDowLGM9ZT49MjAwJiYzMDA+ZXx8MzA0PT09ZSxyJiYodz1NbihwLEMscikpLHc9T24ocCx3LEMsYyksYz8ocC5pZk1vZGlmaWVkJiYoVD1DLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSxUJiYoeC5sYXN0TW9kaWZpZWRbb109VCksVD1DLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSxUJiYoeC5ldGFnW29dPVQpKSwyMDQ9PT1lfHxcIkhFQURcIj09PXAudHlwZT9OPVwibm9jb250ZW50XCI6MzA0PT09ZT9OPVwibm90bW9kaWZpZWRcIjooTj13LnN0YXRlLHk9dy5kYXRhLHY9dy5lcnJvcixjPSF2KSk6KHY9TiwoZXx8IU4pJiYoTj1cImVycm9yXCIsMD5lJiYoZT0wKSkpLEMuc3RhdHVzPWUsQy5zdGF0dXNUZXh0PShufHxOKStcIlwiLGM/aC5yZXNvbHZlV2l0aChmLFt5LE4sQ10pOmgucmVqZWN0V2l0aChmLFtDLE4sdl0pLEMuc3RhdHVzQ29kZShtKSxtPXQsbCYmZC50cmlnZ2VyKGM/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW0MscCxjP3k6dl0pLGcuZmlyZVdpdGgoZixbQyxOXSksbCYmKGQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFtDLHBdKSwtLXguYWN0aXZlfHx4LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiBDfSxnZXRKU09OOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4geC5nZXQoZSx0LG4sXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5nZXQoZSx0LG4sXCJzY3JpcHRcIil9fSkseC5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihlLG4pe3hbbl09ZnVuY3Rpb24oZSxyLGksbyl7cmV0dXJuIHguaXNGdW5jdGlvbihyKSYmKG89b3x8aSxpPXIscj10KSx4LmFqYXgoe3VybDplLHR5cGU6bixkYXRhVHlwZTpvLGRhdGE6cixzdWNjZXNzOml9KX19KTtmdW5jdGlvbiBNbihlLG4scil7dmFyIGksbyxhLHMsbD1lLmNvbnRlbnRzLHU9ZS5kYXRhVHlwZXM7d2hpbGUoXCIqXCI9PT11WzBdKXUuc2hpZnQoKSxvPT09dCYmKG89ZS5taW1lVHlwZXx8bi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7aWYobylmb3IocyBpbiBsKWlmKGxbc10mJmxbc10udGVzdChvKSl7dS51bnNoaWZ0KHMpO2JyZWFrfWlmKHVbMF1pbiByKWE9dVswXTtlbHNle2ZvcihzIGluIHIpe2lmKCF1WzBdfHxlLmNvbnZlcnRlcnNbcytcIiBcIit1WzBdXSl7YT1zO2JyZWFrfWl8fChpPXMpfWE9YXx8aX1yZXR1cm4gYT8oYSE9PXVbMF0mJnUudW5zaGlmdChhKSxyW2FdKTp0fWZ1bmN0aW9uIE9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLGwsdT17fSxjPWUuZGF0YVR5cGVzLnNsaWNlKCk7aWYoY1sxXSlmb3IoYSBpbiBlLmNvbnZlcnRlcnMpdVthLnRvTG93ZXJDYXNlKCldPWUuY29udmVydGVyc1thXTtvPWMuc2hpZnQoKTt3aGlsZShvKWlmKGUucmVzcG9uc2VGaWVsZHNbb10mJihuW2UucmVzcG9uc2VGaWVsZHNbb11dPXQpLCFsJiZyJiZlLmRhdGFGaWx0ZXImJih0PWUuZGF0YUZpbHRlcih0LGUuZGF0YVR5cGUpKSxsPW8sbz1jLnNoaWZ0KCkpaWYoXCIqXCI9PT1vKW89bDtlbHNlIGlmKFwiKlwiIT09bCYmbCE9PW8pe2lmKGE9dVtsK1wiIFwiK29dfHx1W1wiKiBcIitvXSwhYSlmb3IoaSBpbiB1KWlmKHM9aS5zcGxpdChcIiBcIiksc1sxXT09PW8mJihhPXVbbCtcIiBcIitzWzBdXXx8dVtcIiogXCIrc1swXV0pKXthPT09ITA/YT11W2ldOnVbaV0hPT0hMCYmKG89c1swXSxjLnVuc2hpZnQoc1sxXSkpO2JyZWFrfWlmKGEhPT0hMClpZihhJiZlW1widGhyb3dzXCJdKXQ9YSh0KTtlbHNlIHRyeXt0PWEodCl9Y2F0Y2gocCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjphP3A6XCJObyBjb252ZXJzaW9uIGZyb20gXCIrbCtcIiB0byBcIitvfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6dH19eC5hamF4U2V0dXAoe2FjY2VwdHM6e3NjcmlwdDpcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJ9LGNvbnRlbnRzOntzY3JpcHQ6Lyg/OmphdmF8ZWNtYSlzY3JpcHQvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZ2xvYmFsRXZhbChlKSxlfX19KSx4LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtlLmNhY2hlPT09dCYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIixlLmdsb2JhbD0hMSl9KSx4LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtpZihlLmNyb3NzRG9tYWluKXt2YXIgbixyPWEuaGVhZHx8eChcImhlYWRcIilbMF18fGEuZG9jdW1lbnRFbGVtZW50O3JldHVybntzZW5kOmZ1bmN0aW9uKHQsaSl7bj1hLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksbi5hc3luYz0hMCxlLnNjcmlwdENoYXJzZXQmJihuLmNoYXJzZXQ9ZS5zY3JpcHRDaGFyc2V0KSxuLnNyYz1lLnVybCxuLm9ubG9hZD1uLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbihlLHQpeyh0fHwhbi5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KG4ucmVhZHlTdGF0ZSkpJiYobi5vbmxvYWQ9bi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxuLnBhcmVudE5vZGUmJm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxuPW51bGwsdHx8aSgyMDAsXCJzdWNjZXNzXCIpKX0sci5pbnNlcnRCZWZvcmUobixyLmZpcnN0Q2hpbGQpfSxhYm9ydDpmdW5jdGlvbigpe24mJm4ub25sb2FkKHQsITApfX19fSk7dmFyIEZuPVtdLEJuPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87eC5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGU9Rm4ucG9wKCl8fHguZXhwYW5kbytcIl9cIit2bisrO3JldHVybiB0aGlzW2VdPSEwLGV9fSkseC5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKG4scixpKXt2YXIgbyxhLHMsbD1uLmpzb25wIT09ITEmJihCbi50ZXN0KG4udXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBuLmRhdGEmJiEobi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmQm4udGVzdChuLmRhdGEpJiZcImRhdGFcIik7cmV0dXJuIGx8fFwianNvbnBcIj09PW4uZGF0YVR5cGVzWzBdPyhvPW4uanNvbnBDYWxsYmFjaz14LmlzRnVuY3Rpb24obi5qc29ucENhbGxiYWNrKT9uLmpzb25wQ2FsbGJhY2soKTpuLmpzb25wQ2FsbGJhY2ssbD9uW2xdPW5bbF0ucmVwbGFjZShCbixcIiQxXCIrbyk6bi5qc29ucCE9PSExJiYobi51cmwrPShibi50ZXN0KG4udXJsKT9cIiZcIjpcIj9cIikrbi5qc29ucCtcIj1cIitvKSxuLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBzfHx4LmVycm9yKG8rXCIgd2FzIG5vdCBjYWxsZWRcIiksc1swXX0sbi5kYXRhVHlwZXNbMF09XCJqc29uXCIsYT1lW29dLGVbb109ZnVuY3Rpb24oKXtzPWFyZ3VtZW50c30saS5hbHdheXMoZnVuY3Rpb24oKXtlW29dPWEsbltvXSYmKG4uanNvbnBDYWxsYmFjaz1yLmpzb25wQ2FsbGJhY2ssRm4ucHVzaChvKSkscyYmeC5pc0Z1bmN0aW9uKGEpJiZhKHNbMF0pLHM9YT10fSksXCJzY3JpcHRcIik6dH0pO3ZhciBQbixSbixXbj0wLCRuPWUuQWN0aXZlWE9iamVjdCYmZnVuY3Rpb24oKXt2YXIgZTtmb3IoZSBpbiBQbilQbltlXSh0LCEwKX07ZnVuY3Rpb24gSW4oKXt0cnl7cmV0dXJuIG5ldyBlLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKHQpe319ZnVuY3Rpb24gem4oKXt0cnl7cmV0dXJuIG5ldyBlLkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaCh0KXt9fXguYWpheFNldHRpbmdzLnhocj1lLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0xvY2FsJiZJbigpfHx6bigpfTpJbixSbj14LmFqYXhTZXR0aW5ncy54aHIoKSx4LnN1cHBvcnQuY29ycz0hIVJuJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gUm4sUm49eC5zdXBwb3J0LmFqYXg9ISFSbixSbiYmeC5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKG4pe2lmKCFuLmNyb3NzRG9tYWlufHx4LnN1cHBvcnQuY29ycyl7dmFyIHI7cmV0dXJue3NlbmQ6ZnVuY3Rpb24oaSxvKXt2YXIgYSxzLGw9bi54aHIoKTtpZihuLnVzZXJuYW1lP2wub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyxuLnVzZXJuYW1lLG4ucGFzc3dvcmQpOmwub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyksbi54aHJGaWVsZHMpZm9yKHMgaW4gbi54aHJGaWVsZHMpbFtzXT1uLnhockZpZWxkc1tzXTtuLm1pbWVUeXBlJiZsLm92ZXJyaWRlTWltZVR5cGUmJmwub3ZlcnJpZGVNaW1lVHlwZShuLm1pbWVUeXBlKSxuLmNyb3NzRG9tYWlufHxpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXXx8KGlbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIik7dHJ5e2ZvcihzIGluIGkpbC5zZXRSZXF1ZXN0SGVhZGVyKHMsaVtzXSl9Y2F0Y2godSl7fWwuc2VuZChuLmhhc0NvbnRlbnQmJm4uZGF0YXx8bnVsbCkscj1mdW5jdGlvbihlLGkpe3ZhciBzLHUsYyxwO3RyeXtpZihyJiYoaXx8ND09PWwucmVhZHlTdGF0ZSkpaWYocj10LGEmJihsLm9ucmVhZHlzdGF0ZWNoYW5nZT14Lm5vb3AsJG4mJmRlbGV0ZSBQblthXSksaSk0IT09bC5yZWFkeVN0YXRlJiZsLmFib3J0KCk7ZWxzZXtwPXt9LHM9bC5zdGF0dXMsdT1sLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLFwic3RyaW5nXCI9PXR5cGVvZiBsLnJlc3BvbnNlVGV4dCYmKHAudGV4dD1sLnJlc3BvbnNlVGV4dCk7dHJ5e2M9bC5zdGF0dXNUZXh0fWNhdGNoKGYpe2M9XCJcIn1zfHwhbi5pc0xvY2FsfHxuLmNyb3NzRG9tYWluPzEyMjM9PT1zJiYocz0yMDQpOnM9cC50ZXh0PzIwMDo0MDR9fWNhdGNoKGQpe2l8fG8oLTEsZCl9cCYmbyhzLGMscCx1KX0sbi5hc3luYz80PT09bC5yZWFkeVN0YXRlP3NldFRpbWVvdXQocik6KGE9KytXbiwkbiYmKFBufHwoUG49e30seChlKS51bmxvYWQoJG4pKSxQblthXT1yKSxsLm9ucmVhZHlzdGF0ZWNoYW5nZT1yKTpyKCl9LGFib3J0OmZ1bmN0aW9uKCl7ciYmcih0LCEwKX19fX0pO3ZhciBYbixVbixWbj0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sWW49UmVnRXhwKFwiXig/OihbKy1dKT18KShcIit3K1wiKShbYS16JV0qKSRcIixcImlcIiksSm49L3F1ZXVlSG9va3MkLyxHbj1bbnJdLFFuPXtcIipcIjpbZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmNyZWF0ZVR3ZWVuKGUsdCkscj1uLmN1cigpLGk9WW4uZXhlYyh0KSxvPWkmJmlbM118fCh4LmNzc051bWJlcltlXT9cIlwiOlwicHhcIiksYT0oeC5jc3NOdW1iZXJbZV18fFwicHhcIiE9PW8mJityKSYmWW4uZXhlYyh4LmNzcyhuLmVsZW0sZSkpLHM9MSxsPTIwO2lmKGEmJmFbM10hPT1vKXtvPW98fGFbM10saT1pfHxbXSxhPStyfHwxO2RvIHM9c3x8XCIuNVwiLGEvPXMseC5zdHlsZShuLmVsZW0sZSxhK28pO3doaWxlKHMhPT0ocz1uLmN1cigpL3IpJiYxIT09cyYmLS1sKX1yZXR1cm4gaSYmKGE9bi5zdGFydD0rYXx8K3J8fDAsbi51bml0PW8sbi5lbmQ9aVsxXT9hKyhpWzFdKzEpKmlbMl06K2lbMl0pLG59XX07ZnVuY3Rpb24gS24oKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1huPXR9KSxYbj14Lm5vdygpfWZ1bmN0aW9uIFpuKGUsdCxuKXt2YXIgcixpPShRblt0XXx8W10pLmNvbmNhdChRbltcIipcIl0pLG89MCxhPWkubGVuZ3RoO2Zvcig7YT5vO28rKylpZihyPWlbb10uY2FsbChuLHQsZSkpcmV0dXJuIHJ9ZnVuY3Rpb24gZXIoZSx0LG4pe3ZhciByLGksbz0wLGE9R24ubGVuZ3RoLHM9eC5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBsLmVsZW19KSxsPWZ1bmN0aW9uKCl7aWYoaSlyZXR1cm4hMTt2YXIgdD1Ybnx8S24oKSxuPU1hdGgubWF4KDAsdS5zdGFydFRpbWUrdS5kdXJhdGlvbi10KSxyPW4vdS5kdXJhdGlvbnx8MCxvPTEtcixhPTAsbD11LnR3ZWVucy5sZW5ndGg7Zm9yKDtsPmE7YSsrKXUudHdlZW5zW2FdLnJ1bihvKTtyZXR1cm4gcy5ub3RpZnlXaXRoKGUsW3UsbyxuXSksMT5vJiZsP246KHMucmVzb2x2ZVdpdGgoZSxbdV0pLCExKX0sdT1zLnByb21pc2Uoe2VsZW06ZSxwcm9wczp4LmV4dGVuZCh7fSx0KSxvcHRzOnguZXh0ZW5kKCEwLHtzcGVjaWFsRWFzaW5nOnt9fSxuKSxvcmlnaW5hbFByb3BlcnRpZXM6dCxvcmlnaW5hbE9wdGlvbnM6bixzdGFydFRpbWU6WG58fEtuKCksZHVyYXRpb246bi5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24odCxuKXt2YXIgcj14LlR3ZWVuKGUsdS5vcHRzLHQsbix1Lm9wdHMuc3BlY2lhbEVhc2luZ1t0XXx8dS5vcHRzLmVhc2luZyk7cmV0dXJuIHUudHdlZW5zLnB1c2gocikscn0sc3RvcDpmdW5jdGlvbih0KXt2YXIgbj0wLHI9dD91LnR3ZWVucy5sZW5ndGg6MDtpZihpKXJldHVybiB0aGlzO2ZvcihpPSEwO3I+bjtuKyspdS50d2VlbnNbbl0ucnVuKDEpO3JldHVybiB0P3MucmVzb2x2ZVdpdGgoZSxbdSx0XSk6cy5yZWplY3RXaXRoKGUsW3UsdF0pLHRoaXN9fSksYz11LnByb3BzO2Zvcih0cihjLHUub3B0cy5zcGVjaWFsRWFzaW5nKTthPm87bysrKWlmKHI9R25bb10uY2FsbCh1LGUsYyx1Lm9wdHMpKXJldHVybiByO3JldHVybiB4Lm1hcChjLFpuLHUpLHguaXNGdW5jdGlvbih1Lm9wdHMuc3RhcnQpJiZ1Lm9wdHMuc3RhcnQuY2FsbChlLHUpLHguZngudGltZXIoeC5leHRlbmQobCx7ZWxlbTplLGFuaW06dSxxdWV1ZTp1Lm9wdHMucXVldWV9KSksdS5wcm9ncmVzcyh1Lm9wdHMucHJvZ3Jlc3MpLmRvbmUodS5vcHRzLmRvbmUsdS5vcHRzLmNvbXBsZXRlKS5mYWlsKHUub3B0cy5mYWlsKS5hbHdheXModS5vcHRzLmFsd2F5cyl9ZnVuY3Rpb24gdHIoZSx0KXt2YXIgbixyLGksbyxhO2ZvcihuIGluIGUpaWYocj14LmNhbWVsQ2FzZShuKSxpPXRbcl0sbz1lW25dLHguaXNBcnJheShvKSYmKGk9b1sxXSxvPWVbbl09b1swXSksbiE9PXImJihlW3JdPW8sZGVsZXRlIGVbbl0pLGE9eC5jc3NIb29rc1tyXSxhJiZcImV4cGFuZFwiaW4gYSl7bz1hLmV4cGFuZChvKSxkZWxldGUgZVtyXTtmb3IobiBpbiBvKW4gaW4gZXx8KGVbbl09b1tuXSx0W25dPWkpfWVsc2UgdFtyXT1pfXguQW5pbWF0aW9uPXguZXh0ZW5kKGVyLHt0d2VlbmVyOmZ1bmN0aW9uKGUsdCl7eC5pc0Z1bmN0aW9uKGUpPyh0PWUsZT1bXCIqXCJdKTplPWUuc3BsaXQoXCIgXCIpO3ZhciBuLHI9MCxpPWUubGVuZ3RoO2Zvcig7aT5yO3IrKyluPWVbcl0sUW5bbl09UW5bbl18fFtdLFFuW25dLnVuc2hpZnQodCl9LHByZWZpbHRlcjpmdW5jdGlvbihlLHQpe3Q/R24udW5zaGlmdChlKTpHbi5wdXNoKGUpfX0pO2Z1bmN0aW9uIG5yKGUsdCxuKXt2YXIgcixpLG8sYSxzLGwsdT10aGlzLGM9e30scD1lLnN0eWxlLGY9ZS5ub2RlVHlwZSYmbm4oZSksZD14Ll9kYXRhKGUsXCJmeHNob3dcIik7bi5xdWV1ZXx8KHM9eC5fcXVldWVIb29rcyhlLFwiZnhcIiksbnVsbD09cy51bnF1ZXVlZCYmKHMudW5xdWV1ZWQ9MCxsPXMuZW1wdHkuZmlyZSxzLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXtzLnVucXVldWVkfHxsKCl9KSxzLnVucXVldWVkKyssdS5hbHdheXMoZnVuY3Rpb24oKXt1LmFsd2F5cyhmdW5jdGlvbigpe3MudW5xdWV1ZWQtLSx4LnF1ZXVlKGUsXCJmeFwiKS5sZW5ndGh8fHMuZW1wdHkuZmlyZSgpfSl9KSksMT09PWUubm9kZVR5cGUmJihcImhlaWdodFwiaW4gdHx8XCJ3aWR0aFwiaW4gdCkmJihuLm92ZXJmbG93PVtwLm92ZXJmbG93LHAub3ZlcmZsb3dYLHAub3ZlcmZsb3dZXSxcImlubGluZVwiPT09eC5jc3MoZSxcImRpc3BsYXlcIikmJlwibm9uZVwiPT09eC5jc3MoZSxcImZsb2F0XCIpJiYoeC5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQmJlwiaW5saW5lXCIhPT1sbihlLm5vZGVOYW1lKT9wLnpvb209MTpwLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLG4ub3ZlcmZsb3cmJihwLm92ZXJmbG93PVwiaGlkZGVuXCIseC5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3N8fHUuYWx3YXlzKGZ1bmN0aW9uKCl7cC5vdmVyZmxvdz1uLm92ZXJmbG93WzBdLHAub3ZlcmZsb3dYPW4ub3ZlcmZsb3dbMV0scC5vdmVyZmxvd1k9bi5vdmVyZmxvd1syXX0pKTtmb3IociBpbiB0KWlmKGk9dFtyXSxWbi5leGVjKGkpKXtpZihkZWxldGUgdFtyXSxvPW98fFwidG9nZ2xlXCI9PT1pLGk9PT0oZj9cImhpZGVcIjpcInNob3dcIikpY29udGludWU7Y1tyXT1kJiZkW3JdfHx4LnN0eWxlKGUscil9aWYoIXguaXNFbXB0eU9iamVjdChjKSl7ZD9cImhpZGRlblwiaW4gZCYmKGY9ZC5oaWRkZW4pOmQ9eC5fZGF0YShlLFwiZnhzaG93XCIse30pLG8mJihkLmhpZGRlbj0hZiksZj94KGUpLnNob3coKTp1LmRvbmUoZnVuY3Rpb24oKXt4KGUpLmhpZGUoKX0pLHUuZG9uZShmdW5jdGlvbigpe3ZhciB0O3guX3JlbW92ZURhdGEoZSxcImZ4c2hvd1wiKTtmb3IodCBpbiBjKXguc3R5bGUoZSx0LGNbdF0pfSk7Zm9yKHIgaW4gYylhPVpuKGY/ZFtyXTowLHIsdSksciBpbiBkfHwoZFtyXT1hLnN0YXJ0LGYmJihhLmVuZD1hLnN0YXJ0LGEuc3RhcnQ9XCJ3aWR0aFwiPT09cnx8XCJoZWlnaHRcIj09PXI/MTowKSl9fWZ1bmN0aW9uIHJyKGUsdCxuLHIsaSl7cmV0dXJuIG5ldyByci5wcm90b3R5cGUuaW5pdChlLHQsbixyLGkpfXguVHdlZW49cnIscnIucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjpycixpbml0OmZ1bmN0aW9uKGUsdCxuLHIsaSxvKXt0aGlzLmVsZW09ZSx0aGlzLnByb3A9bix0aGlzLmVhc2luZz1pfHxcInN3aW5nXCIsdGhpcy5vcHRpb25zPXQsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPXIsdGhpcy51bml0PW98fCh4LmNzc051bWJlcltuXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBlPXJyLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBlJiZlLmdldD9lLmdldCh0aGlzKTpyci5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oZSl7dmFyIHQsbj1yci5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5wb3M9dD10aGlzLm9wdGlvbnMuZHVyYXRpb24/eC5lYXNpbmdbdGhpcy5lYXNpbmddKGUsdGhpcy5vcHRpb25zLmR1cmF0aW9uKmUsMCwxLHRoaXMub3B0aW9ucy5kdXJhdGlvbik6ZSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqdCt0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxuJiZuLnNldD9uLnNldCh0aGlzKTpyci5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSxyci5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9cnIucHJvdG90eXBlLHJyLnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gbnVsbD09ZS5lbGVtW2UucHJvcF18fGUuZWxlbS5zdHlsZSYmbnVsbCE9ZS5lbGVtLnN0eWxlW2UucHJvcF0/KHQ9eC5jc3MoZS5lbGVtLGUucHJvcCxcIlwiKSx0JiZcImF1dG9cIiE9PXQ/dDowKTplLmVsZW1bZS5wcm9wXX0sc2V0OmZ1bmN0aW9uKGUpe3guZnguc3RlcFtlLnByb3BdP3guZnguc3RlcFtlLnByb3BdKGUpOmUuZWxlbS5zdHlsZSYmKG51bGwhPWUuZWxlbS5zdHlsZVt4LmNzc1Byb3BzW2UucHJvcF1dfHx4LmNzc0hvb2tzW2UucHJvcF0pP3guc3R5bGUoZS5lbGVtLGUucHJvcCxlLm5vdytlLnVuaXQpOmUuZWxlbVtlLnByb3BdPWUubm93fX19LHJyLnByb3BIb29rcy5zY3JvbGxUb3A9cnIucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihlKXtlLmVsZW0ubm9kZVR5cGUmJmUuZWxlbS5wYXJlbnROb2RlJiYoZS5lbGVtW2UucHJvcF09ZS5ub3cpfX0seC5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHQpe3ZhciBuPXguZm5bdF07eC5mblt0XT1mdW5jdGlvbihlLHIsaSl7cmV0dXJuIG51bGw9PWV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoaXIodCwhMCksZSxyLGkpfX0pLHguZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMuZmlsdGVyKG5uKS5jc3MoXCJvcGFjaXR5XCIsMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe29wYWNpdHk6dH0sZSxuLHIpfSxhbmltYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXguaXNFbXB0eU9iamVjdChlKSxvPXguc3BlZWQodCxuLHIpLGE9ZnVuY3Rpb24oKXt2YXIgdD1lcih0aGlzLHguZXh0ZW5kKHt9LGUpLG8pOyhpfHx4Ll9kYXRhKHRoaXMsXCJmaW5pc2hcIikpJiZ0LnN0b3AoITApfTtyZXR1cm4gYS5maW5pc2g9YSxpfHxvLnF1ZXVlPT09ITE/dGhpcy5lYWNoKGEpOnRoaXMucXVldWUoby5xdWV1ZSxhKX0sc3RvcDpmdW5jdGlvbihlLG4scil7dmFyIGk9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdG9wO2RlbGV0ZSBlLnN0b3AsdChyKX07cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGUmJihyPW4sbj1lLGU9dCksbiYmZSE9PSExJiZ0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ITAsbj1udWxsIT1lJiZlK1wicXVldWVIb29rc1wiLG89eC50aW1lcnMsYT14Ll9kYXRhKHRoaXMpO2lmKG4pYVtuXSYmYVtuXS5zdG9wJiZpKGFbbl0pO2Vsc2UgZm9yKG4gaW4gYSlhW25dJiZhW25dLnN0b3AmJkpuLnRlc3QobikmJmkoYVtuXSk7Zm9yKG49by5sZW5ndGg7bi0tOylvW25dLmVsZW0hPT10aGlzfHxudWxsIT1lJiZvW25dLnF1ZXVlIT09ZXx8KG9bbl0uYW5pbS5zdG9wKHIpLHQ9ITEsby5zcGxpY2UobiwxKSk7KHR8fCFyKSYmeC5kZXF1ZXVlKHRoaXMsZSl9KX0sZmluaXNoOmZ1bmN0aW9uKGUpe3JldHVybiBlIT09ITEmJihlPWV8fFwiZnhcIiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQsbj14Ll9kYXRhKHRoaXMpLHI9bltlK1wicXVldWVcIl0saT1uW2UrXCJxdWV1ZUhvb2tzXCJdLG89eC50aW1lcnMsYT1yP3IubGVuZ3RoOjA7Zm9yKG4uZmluaXNoPSEwLHgucXVldWUodGhpcyxlLFtdKSxpJiZpLnN0b3AmJmkuc3RvcC5jYWxsKHRoaXMsITApLHQ9by5sZW5ndGg7dC0tOylvW3RdLmVsZW09PT10aGlzJiZvW3RdLnF1ZXVlPT09ZSYmKG9bdF0uYW5pbS5zdG9wKCEwKSxvLnNwbGljZSh0LDEpKTtmb3IodD0wO2E+dDt0Kyspclt0XSYmclt0XS5maW5pc2gmJnJbdF0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIG4uZmluaXNofSl9fSk7ZnVuY3Rpb24gaXIoZSx0KXt2YXIgbixyPXtoZWlnaHQ6ZX0saT0wO2Zvcih0PXQ/MTowOzQ+aTtpKz0yLXQpbj1adFtpXSxyW1wibWFyZ2luXCIrbl09cltcInBhZGRpbmdcIituXT1lO3JldHVybiB0JiYoci5vcGFjaXR5PXIud2lkdGg9ZSkscn14LmVhY2goe3NsaWRlRG93bjppcihcInNob3dcIiksc2xpZGVVcDppcihcImhpZGVcIiksc2xpZGVUb2dnbGU6aXIoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihlLHQpe3guZm5bZV09ZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0aGlzLmFuaW1hdGUodCxlLG4scil9fSkseC5zcGVlZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZSYmXCJvYmplY3RcIj09dHlwZW9mIGU/eC5leHRlbmQoe30sZSk6e2NvbXBsZXRlOm58fCFuJiZ0fHx4LmlzRnVuY3Rpb24oZSkmJmUsZHVyYXRpb246ZSxlYXNpbmc6biYmdHx8dCYmIXguaXNGdW5jdGlvbih0KSYmdH07cmV0dXJuIHIuZHVyYXRpb249eC5meC5vZmY/MDpcIm51bWJlclwiPT10eXBlb2Ygci5kdXJhdGlvbj9yLmR1cmF0aW9uOnIuZHVyYXRpb24gaW4geC5meC5zcGVlZHM/eC5meC5zcGVlZHNbci5kdXJhdGlvbl06eC5meC5zcGVlZHMuX2RlZmF1bHQsKG51bGw9PXIucXVldWV8fHIucXVldWU9PT0hMCkmJihyLnF1ZXVlPVwiZnhcIiksci5vbGQ9ci5jb21wbGV0ZSxyLmNvbXBsZXRlPWZ1bmN0aW9uKCl7eC5pc0Z1bmN0aW9uKHIub2xkKSYmci5vbGQuY2FsbCh0aGlzKSxyLnF1ZXVlJiZ4LmRlcXVldWUodGhpcyxyLnF1ZXVlKX0scn0seC5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sc3dpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuLjUtTWF0aC5jb3MoZSpNYXRoLlBJKS8yfX0seC50aW1lcnM9W10seC5meD1yci5wcm90b3R5cGUuaW5pdCx4LmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSxuPXgudGltZXJzLHI9MDtmb3IoWG49eC5ub3coKTtuLmxlbmd0aD5yO3IrKyllPW5bcl0sZSgpfHxuW3JdIT09ZXx8bi5zcGxpY2Uoci0tLDEpO24ubGVuZ3RofHx4LmZ4LnN0b3AoKSxYbj10fSx4LmZ4LnRpbWVyPWZ1bmN0aW9uKGUpe2UoKSYmeC50aW1lcnMucHVzaChlKSYmeC5meC5zdGFydCgpfSx4LmZ4LmludGVydmFsPTEzLHguZnguc3RhcnQ9ZnVuY3Rpb24oKXtVbnx8KFVuPXNldEludGVydmFsKHguZngudGljayx4LmZ4LmludGVydmFsKSl9LHguZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoVW4pLFVuPW51bGx9LHguZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LHguZnguc3RlcD17fSx4LmV4cHImJnguZXhwci5maWx0ZXJzJiYoeC5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHguZ3JlcCh4LnRpbWVycyxmdW5jdGlvbih0KXtyZXR1cm4gZT09PXQuZWxlbX0pLmxlbmd0aH0pLHguZm4ub2Zmc2V0PWZ1bmN0aW9uKGUpe2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGU9PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3gub2Zmc2V0LnNldE9mZnNldCh0aGlzLGUsdCl9KTt2YXIgbixyLG89e3RvcDowLGxlZnQ6MH0sYT10aGlzWzBdLHM9YSYmYS5vd25lckRvY3VtZW50O2lmKHMpcmV0dXJuIG49cy5kb2N1bWVudEVsZW1lbnQseC5jb250YWlucyhuLGEpPyh0eXBlb2YgYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QhPT1pJiYobz1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxyPW9yKHMpLHt0b3A6by50b3ArKHIucGFnZVlPZmZzZXR8fG4uc2Nyb2xsVG9wKS0obi5jbGllbnRUb3B8fDApLGxlZnQ6by5sZWZ0KyhyLnBhZ2VYT2Zmc2V0fHxuLnNjcm9sbExlZnQpLShuLmNsaWVudExlZnR8fDApfSk6b30seC5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9eC5jc3MoZSxcInBvc2l0aW9uXCIpO1wic3RhdGljXCI9PT1yJiYoZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpO3ZhciBpPXgoZSksbz1pLm9mZnNldCgpLGE9eC5jc3MoZSxcInRvcFwiKSxzPXguY3NzKGUsXCJsZWZ0XCIpLGw9KFwiYWJzb2x1dGVcIj09PXJ8fFwiZml4ZWRcIj09PXIpJiZ4LmluQXJyYXkoXCJhdXRvXCIsW2Esc10pPi0xLHU9e30sYz17fSxwLGY7bD8oYz1pLnBvc2l0aW9uKCkscD1jLnRvcCxmPWMubGVmdCk6KHA9cGFyc2VGbG9hdChhKXx8MCxmPXBhcnNlRmxvYXQocyl8fDApLHguaXNGdW5jdGlvbih0KSYmKHQ9dC5jYWxsKGUsbixvKSksbnVsbCE9dC50b3AmJih1LnRvcD10LnRvcC1vLnRvcCtwKSxudWxsIT10LmxlZnQmJih1LmxlZnQ9dC5sZWZ0LW8ubGVmdCtmKSxcInVzaW5nXCJpbiB0P3QudXNpbmcuY2FsbChlLHUpOmkuY3NzKHUpfX0seC5mbi5leHRlbmQoe3Bvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpc1swXSl7dmFyIGUsdCxuPXt0b3A6MCxsZWZ0OjB9LHI9dGhpc1swXTtyZXR1cm5cImZpeGVkXCI9PT14LmNzcyhyLFwicG9zaXRpb25cIik/dD1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOihlPXRoaXMub2Zmc2V0UGFyZW50KCksdD10aGlzLm9mZnNldCgpLHgubm9kZU5hbWUoZVswXSxcImh0bWxcIil8fChuPWUub2Zmc2V0KCkpLG4udG9wKz14LmNzcyhlWzBdLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksbi5sZWZ0Kz14LmNzcyhlWzBdLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKSx7dG9wOnQudG9wLW4udG9wLXguY3NzKHIsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDp0LmxlZnQtbi5sZWZ0LXguY3NzKHIsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXMub2Zmc2V0UGFyZW50fHxzO3doaWxlKGUmJiF4Lm5vZGVOYW1lKGUsXCJodG1sXCIpJiZcInN0YXRpY1wiPT09eC5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fHN9KX19KSx4LmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGUsbil7dmFyIHI9L1kvLnRlc3Qobik7eC5mbltlXT1mdW5jdGlvbihpKXtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihlLGksbyl7dmFyIGE9b3IoZSk7cmV0dXJuIG89PT10P2E/biBpbiBhP2Fbbl06YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbaV06ZVtpXTooYT9hLnNjcm9sbFRvKHI/eChhKS5zY3JvbGxMZWZ0KCk6byxyP286eChhKS5zY3JvbGxUb3AoKSk6ZVtpXT1vLHQpfSxlLGksYXJndW1lbnRzLmxlbmd0aCxudWxsKX19KTtmdW5jdGlvbiBvcihlKXtyZXR1cm4geC5pc1dpbmRvdyhlKT9lOjk9PT1lLm5vZGVUeXBlP2UuZGVmYXVsdFZpZXd8fGUucGFyZW50V2luZG93OiExfXguZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihlLG4pe3guZWFjaCh7cGFkZGluZzpcImlubmVyXCIrZSxjb250ZW50Om4sXCJcIjpcIm91dGVyXCIrZX0sZnVuY3Rpb24ocixpKXt4LmZuW2ldPWZ1bmN0aW9uKGksbyl7dmFyIGE9YXJndW1lbnRzLmxlbmd0aCYmKHJ8fFwiYm9vbGVhblwiIT10eXBlb2YgaSkscz1yfHwoaT09PSEwfHxvPT09ITA/XCJtYXJnaW5cIjpcImJvcmRlclwiKTtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihuLHIsaSl7dmFyIG87cmV0dXJuIHguaXNXaW5kb3cobik/bi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIitlXTo5PT09bi5ub2RlVHlwZT8obz1uLmRvY3VtZW50RWxlbWVudCxNYXRoLm1heChuLmJvZHlbXCJzY3JvbGxcIitlXSxvW1wic2Nyb2xsXCIrZV0sbi5ib2R5W1wib2Zmc2V0XCIrZV0sb1tcIm9mZnNldFwiK2VdLG9bXCJjbGllbnRcIitlXSkpOmk9PT10P3guY3NzKG4scixzKTp4LnN0eWxlKG4scixpLHMpfSxuLGE/aTp0LGEsbnVsbCl9fSl9KSx4LmZuLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9LHguZm4uYW5kU2VsZj14LmZuLmFkZEJhY2ssXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9eDooZS5qUXVlcnk9ZS4kPXgsXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiB4fSkpfSkod2luZG93KTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgJCAhPSBcInVuZGVmaW5lZFwiID8gJCA6IHdpbmRvdy4kKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbjsgdmFyIF9fYnJvd3NlcmlmeV9zaGltX3JlcXVpcmVfXz1yZXF1aXJlOyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUsIGRlZmluZSwgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18pIHtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIGxvZGFzaCAzLjEwLjAgKEN1c3RvbSBCdWlsZCkgbG9kYXNoLmNvbS9saWNlbnNlIHwgVW5kZXJzY29yZS5qcyAxLjguMyB1bmRlcnNjb3JlanMub3JnL0xJQ0VOU0VcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtbyAuL2xvZGFzaC5qc2BcbiAqL1xuOyhmdW5jdGlvbigpe2Z1bmN0aW9uIG4obix0KXtpZihuIT09dCl7dmFyIHI9bnVsbD09PW4sZT1uPT09dyx1PW49PT1uLG89bnVsbD09PXQsaT10PT09dyxmPXQ9PT10O2lmKG4+dCYmIW98fCF1fHxyJiYhaSYmZnx8ZSYmZilyZXR1cm4gMTtpZihuPHQmJiFyfHwhZnx8byYmIWUmJnV8fGkmJnUpcmV0dXJuLTF9cmV0dXJuIDB9ZnVuY3Rpb24gdChuLHQscil7Zm9yKHZhciBlPW4ubGVuZ3RoLHU9cj9lOi0xO3I/dS0tOisrdTxlOylpZih0KG5bdV0sdSxuKSlyZXR1cm4gdTtyZXR1cm4tMX1mdW5jdGlvbiByKG4sdCxyKXtpZih0IT09dClyZXR1cm4gcChuLHIpO3ItPTE7Zm9yKHZhciBlPW4ubGVuZ3RoOysrcjxlOylpZihuW3JdPT09dClyZXR1cm4gcjtyZXR1cm4tMX1mdW5jdGlvbiBlKG4pe3JldHVybiB0eXBlb2Ygbj09XCJmdW5jdGlvblwifHxmYWxzZX1mdW5jdGlvbiB1KG4pe3JldHVybiBudWxsPT1uP1wiXCI6bitcIlwifWZ1bmN0aW9uIG8obix0KXtmb3IodmFyIHI9LTEsZT1uLmxlbmd0aDsrK3I8ZSYmLTE8dC5pbmRleE9mKG4uY2hhckF0KHIpKTspO1xucmV0dXJuIHJ9ZnVuY3Rpb24gaShuLHQpe2Zvcih2YXIgcj1uLmxlbmd0aDtyLS0mJi0xPHQuaW5kZXhPZihuLmNoYXJBdChyKSk7KTtyZXR1cm4gcn1mdW5jdGlvbiBmKHQscil7cmV0dXJuIG4odC5hLHIuYSl8fHQuYi1yLmJ9ZnVuY3Rpb24gYShuKXtyZXR1cm4gTm5bbl19ZnVuY3Rpb24gYyhuKXtyZXR1cm4gVG5bbl19ZnVuY3Rpb24gbChuLHQscil7cmV0dXJuIHQ/bj1CbltuXTpyJiYobj1EbltuXSksXCJcXFxcXCIrbn1mdW5jdGlvbiBzKG4pe3JldHVyblwiXFxcXFwiK0RuW25dfWZ1bmN0aW9uIHAobix0LHIpe3ZhciBlPW4ubGVuZ3RoO2Zvcih0Kz1yPzA6LTE7cj90LS06Kyt0PGU7KXt2YXIgdT1uW3RdO2lmKHUhPT11KXJldHVybiB0fXJldHVybi0xfWZ1bmN0aW9uIGgobil7cmV0dXJuISFuJiZ0eXBlb2Ygbj09XCJvYmplY3RcIn1mdW5jdGlvbiBfKG4pe3JldHVybiAxNjA+PW4mJjk8PW4mJjEzPj1ufHwzMj09bnx8MTYwPT1ufHw1NzYwPT1ufHw2MTU4PT1ufHw4MTkyPD1uJiYoODIwMj49bnx8ODIzMj09bnx8ODIzMz09bnx8ODIzOT09bnx8ODI4Nz09bnx8MTIyODg9PW58fDY1Mjc5PT1uKTtcbn1mdW5jdGlvbiB2KG4sdCl7Zm9yKHZhciByPS0xLGU9bi5sZW5ndGgsdT0tMSxvPVtdOysrcjxlOyluW3JdPT09dCYmKG5bcl09eixvWysrdV09cik7cmV0dXJuIG99ZnVuY3Rpb24gZyhuKXtmb3IodmFyIHQ9LTEscj1uLmxlbmd0aDsrK3Q8ciYmXyhuLmNoYXJDb2RlQXQodCkpOyk7cmV0dXJuIHR9ZnVuY3Rpb24geShuKXtmb3IodmFyIHQ9bi5sZW5ndGg7dC0tJiZfKG4uY2hhckNvZGVBdCh0KSk7KTtyZXR1cm4gdH1mdW5jdGlvbiBkKG4pe3JldHVybiBMbltuXX1mdW5jdGlvbiBtKF8pe2Z1bmN0aW9uIE5uKG4pe2lmKGgobikmJiEoT28obil8fG4gaW5zdGFuY2VvZiB6bikpe2lmKG4gaW5zdGFuY2VvZiBMbilyZXR1cm4gbjtpZihudS5jYWxsKG4sXCJfX2NoYWluX19cIikmJm51LmNhbGwobixcIl9fd3JhcHBlZF9fXCIpKXJldHVybiBNcihuKX1yZXR1cm4gbmV3IExuKG4pfWZ1bmN0aW9uIFRuKCl7fWZ1bmN0aW9uIExuKG4sdCxyKXt0aGlzLl9fd3JhcHBlZF9fPW4sdGhpcy5fX2FjdGlvbnNfXz1yfHxbXSxcbnRoaXMuX19jaGFpbl9fPSEhdH1mdW5jdGlvbiB6bihuKXt0aGlzLl9fd3JhcHBlZF9fPW4sdGhpcy5fX2FjdGlvbnNfXz1bXSx0aGlzLl9fZGlyX189MSx0aGlzLl9fZmlsdGVyZWRfXz1mYWxzZSx0aGlzLl9faXRlcmF0ZWVzX189W10sdGhpcy5fX3Rha2VDb3VudF9fPVJ1LHRoaXMuX192aWV3c19fPVtdfWZ1bmN0aW9uIEJuKCl7dGhpcy5fX2RhdGFfXz17fX1mdW5jdGlvbiBEbihuKXt2YXIgdD1uP24ubGVuZ3RoOjA7Zm9yKHRoaXMuZGF0YT17aGFzaDpndShudWxsKSxzZXQ6bmV3IGx1fTt0LS07KXRoaXMucHVzaChuW3RdKX1mdW5jdGlvbiBNbihuLHQpe3ZhciByPW4uZGF0YTtyZXR1cm4odHlwZW9mIHQ9PVwic3RyaW5nXCJ8fGdlKHQpP3Iuc2V0Lmhhcyh0KTpyLmhhc2hbdF0pPzA6LTF9ZnVuY3Rpb24gcW4obix0KXt2YXIgcj0tMSxlPW4ubGVuZ3RoO2Zvcih0fHwodD1CZShlKSk7KytyPGU7KXRbcl09bltyXTtyZXR1cm4gdH1mdW5jdGlvbiBQbihuLHQpe2Zvcih2YXIgcj0tMSxlPW4ubGVuZ3RoOysrcjxlJiZmYWxzZSE9PXQobltyXSxyLG4pOyk7XG5yZXR1cm4gbn1mdW5jdGlvbiBLbihuLHQpe2Zvcih2YXIgcj0tMSxlPW4ubGVuZ3RoOysrcjxlOylpZighdChuW3JdLHIsbikpcmV0dXJuIGZhbHNlO3JldHVybiB0cnVlfWZ1bmN0aW9uIFZuKG4sdCl7Zm9yKHZhciByPS0xLGU9bi5sZW5ndGgsdT0tMSxvPVtdOysrcjxlOyl7dmFyIGk9bltyXTt0KGkscixuKSYmKG9bKyt1XT1pKX1yZXR1cm4gb31mdW5jdGlvbiBHbihuLHQpe2Zvcih2YXIgcj0tMSxlPW4ubGVuZ3RoLHU9QmUoZSk7KytyPGU7KXVbcl09dChuW3JdLHIsbik7cmV0dXJuIHV9ZnVuY3Rpb24gSm4obix0KXtmb3IodmFyIHI9LTEsZT10Lmxlbmd0aCx1PW4ubGVuZ3RoOysrcjxlOyluW3Urcl09dFtyXTtyZXR1cm4gbn1mdW5jdGlvbiBYbihuLHQscixlKXt2YXIgdT0tMSxvPW4ubGVuZ3RoO2ZvcihlJiZvJiYocj1uWysrdV0pOysrdTxvOylyPXQocixuW3VdLHUsbik7cmV0dXJuIHJ9ZnVuY3Rpb24gSG4obix0KXtmb3IodmFyIHI9LTEsZT1uLmxlbmd0aDsrK3I8ZTspaWYodChuW3JdLHIsbikpcmV0dXJuIHRydWU7XG5yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gUW4obix0LHIsZSl7cmV0dXJuIG4hPT13JiZudS5jYWxsKGUscik/bjp0fWZ1bmN0aW9uIG50KG4sdCxyKXtmb3IodmFyIGU9LTEsdT16byh0KSxvPXUubGVuZ3RoOysrZTxvOyl7dmFyIGk9dVtlXSxmPW5baV0sYT1yKGYsdFtpXSxpLG4sdCk7KGE9PT1hP2E9PT1mOmYhPT1mKSYmKGYhPT13fHxpIGluIG4pfHwobltpXT1hKX1yZXR1cm4gbn1mdW5jdGlvbiB0dChuLHQpe3JldHVybiBudWxsPT10P246ZXQodCx6byh0KSxuKX1mdW5jdGlvbiBydChuLHQpe2Zvcih2YXIgcj0tMSxlPW51bGw9PW4sdT0hZSYmRXIobiksbz11P24ubGVuZ3RoOjAsaT10Lmxlbmd0aCxmPUJlKGkpOysrcjxpOyl7dmFyIGE9dFtyXTtmW3JdPXU/Q3IoYSxvKT9uW2FdOnc6ZT93Om5bYV19cmV0dXJuIGZ9ZnVuY3Rpb24gZXQobix0LHIpe3J8fChyPXt9KTtmb3IodmFyIGU9LTEsdT10Lmxlbmd0aDsrK2U8dTspe3ZhciBvPXRbZV07cltvXT1uW29dfXJldHVybiByfWZ1bmN0aW9uIHV0KG4sdCxyKXtcbnZhciBlPXR5cGVvZiBuO3JldHVyblwiZnVuY3Rpb25cIj09ZT90PT09dz9uOkJ0KG4sdCxyKTpudWxsPT1uP0ZlOlwib2JqZWN0XCI9PWU/YnQobik6dD09PXc/emUobik6eHQobix0KX1mdW5jdGlvbiBvdChuLHQscixlLHUsbyxpKXt2YXIgZjtpZihyJiYoZj11P3IobixlLHUpOnIobikpLGYhPT13KXJldHVybiBmO2lmKCFnZShuKSlyZXR1cm4gbjtpZihlPU9vKG4pKXtpZihmPWtyKG4pLCF0KXJldHVybiBxbihuLGYpfWVsc2V7dmFyIGE9cnUuY2FsbChuKSxjPWE9PUs7aWYoYSE9WiYmYSE9QiYmKCFjfHx1KSlyZXR1cm4gRm5bYV0/UnIobixhLHQpOnU/bjp7fTtpZihmPUlyKGM/e306biksIXQpcmV0dXJuIHR0KGYsbil9Zm9yKG98fChvPVtdKSxpfHwoaT1bXSksdT1vLmxlbmd0aDt1LS07KWlmKG9bdV09PW4pcmV0dXJuIGlbdV07cmV0dXJuIG8ucHVzaChuKSxpLnB1c2goZiksKGU/UG46X3QpKG4sZnVuY3Rpb24oZSx1KXtmW3VdPW90KGUsdCxyLHUsbixvLGkpfSksZn1mdW5jdGlvbiBpdChuLHQscil7XG5pZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTtyZXR1cm4gc3UoZnVuY3Rpb24oKXtuLmFwcGx5KHcscil9LHQpfWZ1bmN0aW9uIGZ0KG4sdCl7dmFyIGU9bj9uLmxlbmd0aDowLHU9W107aWYoIWUpcmV0dXJuIHU7dmFyIG89LTEsaT14cigpLGY9aT09cixhPWYmJnQubGVuZ3RoPj1GJiZndSYmbHU/bmV3IERuKHQpOm51bGwsYz10Lmxlbmd0aDthJiYoaT1NbixmPWZhbHNlLHQ9YSk7bjpmb3IoOysrbzxlOylpZihhPW5bb10sZiYmYT09PWEpe2Zvcih2YXIgbD1jO2wtLTspaWYodFtsXT09PWEpY29udGludWUgbjt1LnB1c2goYSl9ZWxzZSAwPmkodCxhLDApJiZ1LnB1c2goYSk7cmV0dXJuIHV9ZnVuY3Rpb24gYXQobix0KXt2YXIgcj10cnVlO3JldHVybiBTdShuLGZ1bmN0aW9uKG4sZSx1KXtyZXR1cm4gcj0hIXQobixlLHUpfSkscn1mdW5jdGlvbiBjdChuLHQscixlKXt2YXIgdT1lLG89dTtyZXR1cm4gU3UobixmdW5jdGlvbihuLGksZil7aT0rdChuLGksZiksKHIoaSx1KXx8aT09PWUmJmk9PT1vKSYmKHU9aSxcbm89bil9KSxvfWZ1bmN0aW9uIGx0KG4sdCl7dmFyIHI9W107cmV0dXJuIFN1KG4sZnVuY3Rpb24obixlLHUpe3QobixlLHUpJiZyLnB1c2gobil9KSxyfWZ1bmN0aW9uIHN0KG4sdCxyLGUpe3ZhciB1O3JldHVybiByKG4sZnVuY3Rpb24obixyLG8pe3JldHVybiB0KG4scixvKT8odT1lP3I6bixmYWxzZSk6dm9pZCAwfSksdX1mdW5jdGlvbiBwdChuLHQscixlKXtlfHwoZT1bXSk7Zm9yKHZhciB1PS0xLG89bi5sZW5ndGg7Kyt1PG87KXt2YXIgaT1uW3VdO2goaSkmJkVyKGkpJiYocnx8T28oaSl8fHBlKGkpKT90P3B0KGksdCxyLGUpOkpuKGUsaSk6cnx8KGVbZS5sZW5ndGhdPWkpfXJldHVybiBlfWZ1bmN0aW9uIGh0KG4sdCl7TnUobix0LFJlKX1mdW5jdGlvbiBfdChuLHQpe3JldHVybiBOdShuLHQsem8pfWZ1bmN0aW9uIHZ0KG4sdCl7cmV0dXJuIFR1KG4sdCx6byl9ZnVuY3Rpb24gZ3Qobix0KXtmb3IodmFyIHI9LTEsZT10Lmxlbmd0aCx1PS0xLG89W107KytyPGU7KXt2YXIgaT10W3JdO1xudmUobltpXSkmJihvWysrdV09aSl9cmV0dXJuIG99ZnVuY3Rpb24geXQobix0LHIpe2lmKG51bGwhPW4pe3IhPT13JiZyIGluIEJyKG4pJiYodD1bcl0pLHI9MDtmb3IodmFyIGU9dC5sZW5ndGg7bnVsbCE9biYmcjxlOyluPW5bdFtyKytdXTtyZXR1cm4gciYmcj09ZT9uOnd9fWZ1bmN0aW9uIGR0KG4sdCxyLGUsdSxvKXtpZihuPT09dCluPXRydWU7ZWxzZSBpZihudWxsPT1ufHxudWxsPT10fHwhZ2UobikmJiFoKHQpKW49biE9PW4mJnQhPT10O2Vsc2Ugbjp7dmFyIGk9ZHQsZj1PbyhuKSxhPU9vKHQpLGM9RCxsPUQ7Znx8KGM9cnUuY2FsbChuKSxjPT1CP2M9WjpjIT1aJiYoZj14ZShuKSkpLGF8fChsPXJ1LmNhbGwodCksbD09Qj9sPVo6bCE9WiYmeGUodCkpO3ZhciBzPWM9PVosYT1sPT1aLGw9Yz09bDtpZighbHx8Znx8cyl7aWYoIWUmJihjPXMmJm51LmNhbGwobixcIl9fd3JhcHBlZF9fXCIpLGE9YSYmbnUuY2FsbCh0LFwiX193cmFwcGVkX19cIiksY3x8YSkpe249aShjP24udmFsdWUoKTpuLGE/dC52YWx1ZSgpOnQscixlLHUsbyk7XG5icmVhayBufWlmKGwpe2Zvcih1fHwodT1bXSksb3x8KG89W10pLGM9dS5sZW5ndGg7Yy0tOylpZih1W2NdPT1uKXtuPW9bY109PXQ7YnJlYWsgbn11LnB1c2gobiksby5wdXNoKHQpLG49KGY/eXI6bXIpKG4sdCxpLHIsZSx1LG8pLHUucG9wKCksby5wb3AoKX1lbHNlIG49ZmFsc2V9ZWxzZSBuPWRyKG4sdCxjKX1yZXR1cm4gbn1mdW5jdGlvbiBtdChuLHQscil7dmFyIGU9dC5sZW5ndGgsdT1lLG89IXI7aWYobnVsbD09bilyZXR1cm4hdTtmb3Iobj1CcihuKTtlLS07KXt2YXIgaT10W2VdO2lmKG8mJmlbMl0/aVsxXSE9PW5baVswXV06IShpWzBdaW4gbikpcmV0dXJuIGZhbHNlfWZvcig7KytlPHU7KXt2YXIgaT10W2VdLGY9aVswXSxhPW5bZl0sYz1pWzFdO2lmKG8mJmlbMl0pe2lmKGE9PT13JiYhKGYgaW4gbikpcmV0dXJuIGZhbHNlfWVsc2UgaWYoaT1yP3IoYSxjLGYpOncsaT09PXc/IWR0KGMsYSxyLHRydWUpOiFpKXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiB3dChuLHQpe3ZhciByPS0xLGU9RXIobik/QmUobi5sZW5ndGgpOltdO1xucmV0dXJuIFN1KG4sZnVuY3Rpb24obix1LG8pe2VbKytyXT10KG4sdSxvKX0pLGV9ZnVuY3Rpb24gYnQobil7dmFyIHQ9QXIobik7aWYoMT09dC5sZW5ndGgmJnRbMF1bMl0pe3ZhciByPXRbMF1bMF0sZT10WzBdWzFdO3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gbnVsbD09bj9mYWxzZTpuW3JdPT09ZSYmKGUhPT13fHxyIGluIEJyKG4pKX19cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBtdChuLHQpfX1mdW5jdGlvbiB4dChuLHQpe3ZhciByPU9vKG4pLGU9V3IobikmJnQ9PT10JiYhZ2UodCksdT1uK1wiXCI7cmV0dXJuIG49RHIobiksZnVuY3Rpb24obyl7aWYobnVsbD09bylyZXR1cm4gZmFsc2U7dmFyIGk9dTtpZihvPUJyKG8pLCEoIXImJmV8fGkgaW4gbykpe2lmKG89MT09bi5sZW5ndGg/bzp5dChvLEV0KG4sMCwtMSkpLG51bGw9PW8pcmV0dXJuIGZhbHNlO2k9WnIobiksbz1CcihvKX1yZXR1cm4gb1tpXT09PXQ/dCE9PXd8fGkgaW4gbzpkdCh0LG9baV0sdyx0cnVlKX19ZnVuY3Rpb24gQXQobix0LHIsZSx1KXtcbmlmKCFnZShuKSlyZXR1cm4gbjt2YXIgbz1Fcih0KSYmKE9vKHQpfHx4ZSh0KSksaT1vP3c6em8odCk7cmV0dXJuIFBuKGl8fHQsZnVuY3Rpb24oZixhKXtpZihpJiYoYT1mLGY9dFthXSksaChmKSl7ZXx8KGU9W10pLHV8fCh1PVtdKTtuOntmb3IodmFyIGM9YSxsPWUscz11LHA9bC5sZW5ndGgsXz10W2NdO3AtLTspaWYobFtwXT09Xyl7bltjXT1zW3BdO2JyZWFrIG59dmFyIHA9bltjXSx2PXI/cihwLF8sYyxuLHQpOncsZz12PT09dztnJiYodj1fLEVyKF8pJiYoT28oXyl8fHhlKF8pKT92PU9vKHApP3A6RXIocCk/cW4ocCk6W106bWUoXyl8fHBlKF8pP3Y9cGUocCk/a2UocCk6bWUocCk/cDp7fTpnPWZhbHNlKSxsLnB1c2goXykscy5wdXNoKHYpLGc/bltjXT1BdCh2LF8scixsLHMpOih2PT09dj92IT09cDpwPT09cCkmJihuW2NdPXYpfX1lbHNlIGM9blthXSxsPXI/cihjLGYsYSxuLHQpOncsKHM9bD09PXcpJiYobD1mKSxsPT09dyYmKCFvfHxhIGluIG4pfHwhcyYmKGw9PT1sP2w9PT1jOmMhPT1jKXx8KG5bYV09bCk7XG59KSxufWZ1bmN0aW9uIGp0KG4pe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dD93OnRbbl19fWZ1bmN0aW9uIGt0KG4pe3ZhciB0PW4rXCJcIjtyZXR1cm4gbj1EcihuKSxmdW5jdGlvbihyKXtyZXR1cm4geXQocixuLHQpfX1mdW5jdGlvbiBJdChuLHQpe2Zvcih2YXIgcj1uP3QubGVuZ3RoOjA7ci0tOyl7dmFyIGU9dFtyXTtpZihlIT11JiZDcihlKSl7dmFyIHU9ZTtwdS5jYWxsKG4sZSwxKX19fWZ1bmN0aW9uIFJ0KG4sdCl7cmV0dXJuIG4reXUoa3UoKSoodC1uKzEpKX1mdW5jdGlvbiBPdChuLHQscixlLHUpe3JldHVybiB1KG4sZnVuY3Rpb24obix1LG8pe3I9ZT8oZT1mYWxzZSxuKTp0KHIsbix1LG8pfSkscn1mdW5jdGlvbiBFdChuLHQscil7dmFyIGU9LTEsdT1uLmxlbmd0aDtmb3IodD1udWxsPT10PzA6K3R8fDAsMD50JiYodD0tdD51PzA6dSt0KSxyPXI9PT13fHxyPnU/dTorcnx8MCwwPnImJihyKz11KSx1PXQ+cj8wOnItdD4+PjAsdD4+Pj0wLHI9QmUodSk7KytlPHU7KXJbZV09bltlK3RdO1xucmV0dXJuIHJ9ZnVuY3Rpb24gQ3Qobix0KXt2YXIgcjtyZXR1cm4gU3UobixmdW5jdGlvbihuLGUsdSl7cmV0dXJuIHI9dChuLGUsdSksIXJ9KSwhIXJ9ZnVuY3Rpb24gVXQobix0KXt2YXIgcj1uLmxlbmd0aDtmb3Iobi5zb3J0KHQpO3ItLTspbltyXT1uW3JdLmM7cmV0dXJuIG59ZnVuY3Rpb24gV3QodCxyLGUpe3ZhciB1PXdyKCksbz0tMTtyZXR1cm4gcj1HbihyLGZ1bmN0aW9uKG4pe3JldHVybiB1KG4pfSksdD13dCh0LGZ1bmN0aW9uKG4pe3JldHVybnthOkduKHIsZnVuY3Rpb24odCl7cmV0dXJuIHQobil9KSxiOisrbyxjOm59fSksVXQodCxmdW5jdGlvbih0LHIpe3ZhciB1O246e2Zvcih2YXIgbz0tMSxpPXQuYSxmPXIuYSxhPWkubGVuZ3RoLGM9ZS5sZW5ndGg7KytvPGE7KWlmKHU9bihpW29dLGZbb10pKXtpZihvPj1jKWJyZWFrIG47bz1lW29dLHUqPVwiYXNjXCI9PT1vfHx0cnVlPT09bz8xOi0xO2JyZWFrIG59dT10LmItci5ifXJldHVybiB1fSl9ZnVuY3Rpb24gJHQobix0KXtcbnZhciByPTA7cmV0dXJuIFN1KG4sZnVuY3Rpb24obixlLHUpe3IrPSt0KG4sZSx1KXx8MH0pLHJ9ZnVuY3Rpb24gU3Qobix0KXt2YXIgZT0tMSx1PXhyKCksbz1uLmxlbmd0aCxpPXU9PXIsZj1pJiZvPj1GLGE9ZiYmZ3UmJmx1P25ldyBEbih2b2lkIDApOm51bGwsYz1bXTthPyh1PU1uLGk9ZmFsc2UpOihmPWZhbHNlLGE9dD9bXTpjKTtuOmZvcig7KytlPG87KXt2YXIgbD1uW2VdLHM9dD90KGwsZSxuKTpsO2lmKGkmJmw9PT1sKXtmb3IodmFyIHA9YS5sZW5ndGg7cC0tOylpZihhW3BdPT09cyljb250aW51ZSBuO3QmJmEucHVzaChzKSxjLnB1c2gobCl9ZWxzZSAwPnUoYSxzLDApJiYoKHR8fGYpJiZhLnB1c2gocyksYy5wdXNoKGwpKX1yZXR1cm4gY31mdW5jdGlvbiBGdChuLHQpe2Zvcih2YXIgcj0tMSxlPXQubGVuZ3RoLHU9QmUoZSk7KytyPGU7KXVbcl09blt0W3JdXTtyZXR1cm4gdX1mdW5jdGlvbiBOdChuLHQscixlKXtmb3IodmFyIHU9bi5sZW5ndGgsbz1lP3U6LTE7KGU/by0tOisrbzx1KSYmdChuW29dLG8sbik7KTtcbnJldHVybiByP0V0KG4sZT8wOm8sZT9vKzE6dSk6RXQobixlP28rMTowLGU/dTpvKX1mdW5jdGlvbiBUdChuLHQpe3ZhciByPW47ciBpbnN0YW5jZW9mIHpuJiYocj1yLnZhbHVlKCkpO2Zvcih2YXIgZT0tMSx1PXQubGVuZ3RoOysrZTx1Oyl2YXIgbz10W2VdLHI9by5mdW5jLmFwcGx5KG8udGhpc0FyZyxKbihbcl0sby5hcmdzKSk7cmV0dXJuIHJ9ZnVuY3Rpb24gTHQobix0LHIpe3ZhciBlPTAsdT1uP24ubGVuZ3RoOmU7aWYodHlwZW9mIHQ9PVwibnVtYmVyXCImJnQ9PT10JiZ1PD1FdSl7Zm9yKDtlPHU7KXt2YXIgbz1lK3U+Pj4xLGk9bltvXTsocj9pPD10Omk8dCkmJm51bGwhPT1pP2U9bysxOnU9b31yZXR1cm4gdX1yZXR1cm4genQobix0LEZlLHIpfWZ1bmN0aW9uIHp0KG4sdCxyLGUpe3Q9cih0KTtmb3IodmFyIHU9MCxvPW4/bi5sZW5ndGg6MCxpPXQhPT10LGY9bnVsbD09PXQsYT10PT09dzt1PG87KXt2YXIgYz15dSgodStvKS8yKSxsPXIobltjXSkscz1sIT09dyxwPWw9PT1sO1xuKGk/cHx8ZTpmP3AmJnMmJihlfHxudWxsIT1sKTphP3AmJihlfHxzKTpudWxsPT1sPzA6ZT9sPD10Omw8dCk/dT1jKzE6bz1jfXJldHVybiB4dShvLE91KX1mdW5jdGlvbiBCdChuLHQscil7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIilyZXR1cm4gRmU7aWYodD09PXcpcmV0dXJuIG47c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIG4uY2FsbCh0LHIpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHIsZSx1KXtyZXR1cm4gbi5jYWxsKHQscixlLHUpfTtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHIsZSx1LG8pe3JldHVybiBuLmNhbGwodCxyLGUsdSxvKX07Y2FzZSA1OnJldHVybiBmdW5jdGlvbihyLGUsdSxvLGkpe3JldHVybiBuLmNhbGwodCxyLGUsdSxvLGkpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbi5hcHBseSh0LGFyZ3VtZW50cyl9fWZ1bmN0aW9uIER0KG4pe3ZhciB0PW5ldyBvdShuLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgaHUodCkuc2V0KG5ldyBodShuKSksXG50fWZ1bmN0aW9uIE10KG4sdCxyKXtmb3IodmFyIGU9ci5sZW5ndGgsdT0tMSxvPWJ1KG4ubGVuZ3RoLWUsMCksaT0tMSxmPXQubGVuZ3RoLGE9QmUoZitvKTsrK2k8ZjspYVtpXT10W2ldO2Zvcig7Kyt1PGU7KWFbclt1XV09blt1XTtmb3IoO28tLTspYVtpKytdPW5bdSsrXTtyZXR1cm4gYX1mdW5jdGlvbiBxdChuLHQscil7Zm9yKHZhciBlPS0xLHU9ci5sZW5ndGgsbz0tMSxpPWJ1KG4ubGVuZ3RoLXUsMCksZj0tMSxhPXQubGVuZ3RoLGM9QmUoaSthKTsrK288aTspY1tvXT1uW29dO2ZvcihpPW87KytmPGE7KWNbaStmXT10W2ZdO2Zvcig7KytlPHU7KWNbaStyW2VdXT1uW28rK107cmV0dXJuIGN9ZnVuY3Rpb24gUHQobix0KXtyZXR1cm4gZnVuY3Rpb24ocixlLHUpe3ZhciBvPXQ/dCgpOnt9O2lmKGU9d3IoZSx1LDMpLE9vKHIpKXt1PS0xO2Zvcih2YXIgaT1yLmxlbmd0aDsrK3U8aTspe3ZhciBmPXJbdV07bihvLGYsZShmLHUscikscil9fWVsc2UgU3UocixmdW5jdGlvbih0LHIsdSl7XG5uKG8sdCxlKHQscix1KSx1KX0pO3JldHVybiBvfX1mdW5jdGlvbiBLdChuKXtyZXR1cm4gbGUoZnVuY3Rpb24odCxyKXt2YXIgZT0tMSx1PW51bGw9PXQ/MDpyLmxlbmd0aCxvPTI8dT9yW3UtMl06dyxpPTI8dT9yWzJdOncsZj0xPHU/clt1LTFdOnc7Zm9yKHR5cGVvZiBvPT1cImZ1bmN0aW9uXCI/KG89QnQobyxmLDUpLHUtPTIpOihvPXR5cGVvZiBmPT1cImZ1bmN0aW9uXCI/Zjp3LHUtPW8/MTowKSxpJiZVcihyWzBdLHJbMV0saSkmJihvPTM+dT93Om8sdT0xKTsrK2U8dTspKGk9cltlXSkmJm4odCxpLG8pO3JldHVybiB0fSl9ZnVuY3Rpb24gVnQobix0KXtyZXR1cm4gZnVuY3Rpb24ocixlKXt2YXIgdT1yP0J1KHIpOjA7aWYoIVNyKHUpKXJldHVybiBuKHIsZSk7Zm9yKHZhciBvPXQ/dTotMSxpPUJyKHIpOyh0P28tLTorK288dSkmJmZhbHNlIT09ZShpW29dLG8saSk7KTtyZXR1cm4gcn19ZnVuY3Rpb24gWnQobil7cmV0dXJuIGZ1bmN0aW9uKHQscixlKXt2YXIgdT1Ccih0KTtlPWUodCk7Zm9yKHZhciBvPWUubGVuZ3RoLGk9bj9vOi0xO24/aS0tOisraTxvOyl7XG52YXIgZj1lW2ldO2lmKGZhbHNlPT09cih1W2ZdLGYsdSkpYnJlYWt9cmV0dXJuIHR9fWZ1bmN0aW9uIFl0KG4sdCl7ZnVuY3Rpb24gcigpe3JldHVybih0aGlzJiZ0aGlzIT09Wm4mJnRoaXMgaW5zdGFuY2VvZiByP2U6bikuYXBwbHkodCxhcmd1bWVudHMpfXZhciBlPUp0KG4pO3JldHVybiByfWZ1bmN0aW9uIEd0KG4pe3JldHVybiBmdW5jdGlvbih0KXt2YXIgcj0tMTt0PSRlKENlKHQpKTtmb3IodmFyIGU9dC5sZW5ndGgsdT1cIlwiOysrcjxlOyl1PW4odSx0W3JdLHIpO3JldHVybiB1fX1mdW5jdGlvbiBKdChuKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHM7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyBuO2Nhc2UgMTpyZXR1cm4gbmV3IG4odFswXSk7Y2FzZSAyOnJldHVybiBuZXcgbih0WzBdLHRbMV0pO2Nhc2UgMzpyZXR1cm4gbmV3IG4odFswXSx0WzFdLHRbMl0pO2Nhc2UgNDpyZXR1cm4gbmV3IG4odFswXSx0WzFdLHRbMl0sdFszXSk7Y2FzZSA1OlxucmV0dXJuIG5ldyBuKHRbMF0sdFsxXSx0WzJdLHRbM10sdFs0XSk7Y2FzZSA2OnJldHVybiBuZXcgbih0WzBdLHRbMV0sdFsyXSx0WzNdLHRbNF0sdFs1XSk7Y2FzZSA3OnJldHVybiBuZXcgbih0WzBdLHRbMV0sdFsyXSx0WzNdLHRbNF0sdFs1XSx0WzZdKX12YXIgcj0kdShuLnByb3RvdHlwZSksdD1uLmFwcGx5KHIsdCk7cmV0dXJuIGdlKHQpP3Q6cn19ZnVuY3Rpb24gWHQobil7ZnVuY3Rpb24gdChyLGUsdSl7cmV0dXJuIHUmJlVyKHIsZSx1KSYmKGU9dykscj1ncihyLG4sdyx3LHcsdyx3LGUpLHIucGxhY2Vob2xkZXI9dC5wbGFjZWhvbGRlcixyfXJldHVybiB0fWZ1bmN0aW9uIEh0KG4sdCl7cmV0dXJuIGxlKGZ1bmN0aW9uKHIpe3ZhciBlPXJbMF07cmV0dXJuIG51bGw9PWU/ZTooci5wdXNoKHQpLG4uYXBwbHkodyxyKSl9KX1mdW5jdGlvbiBRdChuLHQpe3JldHVybiBmdW5jdGlvbihyLGUsdSl7aWYodSYmVXIocixlLHUpJiYoZT13KSxlPXdyKGUsdSwzKSwxPT1lLmxlbmd0aCl7XG51PXI9T28ocik/cjp6cihyKTtmb3IodmFyIG89ZSxpPS0xLGY9dS5sZW5ndGgsYT10LGM9YTsrK2k8Zjspe3ZhciBsPXVbaV0scz0rbyhsKTtuKHMsYSkmJihhPXMsYz1sKX1pZih1PWMsIXIubGVuZ3RofHx1IT09dClyZXR1cm4gdX1yZXR1cm4gY3QocixlLG4sdCl9fWZ1bmN0aW9uIG5yKG4scil7cmV0dXJuIGZ1bmN0aW9uKGUsdSxvKXtyZXR1cm4gdT13cih1LG8sMyksT28oZSk/KHU9dChlLHUsciksLTE8dT9lW3VdOncpOnN0KGUsdSxuKX19ZnVuY3Rpb24gdHIobil7cmV0dXJuIGZ1bmN0aW9uKHIsZSx1KXtyZXR1cm4gciYmci5sZW5ndGg/KGU9d3IoZSx1LDMpLHQocixlLG4pKTotMX19ZnVuY3Rpb24gcnIobil7cmV0dXJuIGZ1bmN0aW9uKHQscixlKXtyZXR1cm4gcj13cihyLGUsMyksc3QodCxyLG4sdHJ1ZSl9fWZ1bmN0aW9uIGVyKG4pe3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdCxyPWFyZ3VtZW50cy5sZW5ndGgsZT1uP3I6LTEsdT0wLG89QmUocik7bj9lLS06KytlPHI7KXtcbnZhciBpPW9bdSsrXT1hcmd1bWVudHNbZV07aWYodHlwZW9mIGkhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgR2UoTCk7IXQmJkxuLnByb3RvdHlwZS50aHJ1JiZcIndyYXBwZXJcIj09YnIoaSkmJih0PW5ldyBMbihbXSx0cnVlKSl9Zm9yKGU9dD8tMTpyOysrZTxyOyl7dmFyIGk9b1tlXSx1PWJyKGkpLGY9XCJ3cmFwcGVyXCI9PXU/enUoaSk6dzt0PWYmJiRyKGZbMF0pJiZmWzFdPT0oRXxrfFJ8QykmJiFmWzRdLmxlbmd0aCYmMT09Zls5XT90W2JyKGZbMF0pXS5hcHBseSh0LGZbM10pOjE9PWkubGVuZ3RoJiYkcihpKT90W3VdKCk6dC50aHJ1KGkpfXJldHVybiBmdW5jdGlvbigpe3ZhciBuPWFyZ3VtZW50cyxlPW5bMF07aWYodCYmMT09bi5sZW5ndGgmJk9vKGUpJiZlLmxlbmd0aD49RilyZXR1cm4gdC5wbGFudChlKS52YWx1ZSgpO2Zvcih2YXIgdT0wLG49cj9vW3VdLmFwcGx5KHRoaXMsbik6ZTsrK3U8cjspbj1vW3VdLmNhbGwodGhpcyxuKTtyZXR1cm4gbn19fWZ1bmN0aW9uIHVyKG4sdCl7XG5yZXR1cm4gZnVuY3Rpb24ocixlLHUpe3JldHVybiB0eXBlb2YgZT09XCJmdW5jdGlvblwiJiZ1PT09dyYmT28ocik/bihyLGUpOnQocixCdChlLHUsMykpfX1mdW5jdGlvbiBvcihuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUpe3JldHVybih0eXBlb2YgciE9XCJmdW5jdGlvblwifHxlIT09dykmJihyPUJ0KHIsZSwzKSksbih0LHIsUmUpfX1mdW5jdGlvbiBpcihuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUpe3JldHVybih0eXBlb2YgciE9XCJmdW5jdGlvblwifHxlIT09dykmJihyPUJ0KHIsZSwzKSksbih0LHIpfX1mdW5jdGlvbiBmcihuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUpe3ZhciB1PXt9O3JldHVybiByPXdyKHIsZSwzKSxfdCh0LGZ1bmN0aW9uKHQsZSxvKXtvPXIodCxlLG8pLGU9bj9vOmUsdD1uP3Q6byx1W2VdPXR9KSx1fX1mdW5jdGlvbiBhcihuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUpe3JldHVybiB0PXUodCksKG4/dDpcIlwiKStwcih0LHIsZSkrKG4/XCJcIjp0KX19ZnVuY3Rpb24gY3Iobil7XG52YXIgdD1sZShmdW5jdGlvbihyLGUpe3ZhciB1PXYoZSx0LnBsYWNlaG9sZGVyKTtyZXR1cm4gZ3IocixuLHcsZSx1KX0pO3JldHVybiB0fWZ1bmN0aW9uIGxyKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIsZSx1LG8pe3ZhciBpPTM+YXJndW1lbnRzLmxlbmd0aDtyZXR1cm4gdHlwZW9mIGU9PVwiZnVuY3Rpb25cIiYmbz09PXcmJk9vKHIpP24ocixlLHUsaSk6T3Qocix3cihlLG8sNCksdSxpLHQpfX1mdW5jdGlvbiBzcihuLHQscixlLHUsbyxpLGYsYSxjKXtmdW5jdGlvbiBsKCl7Zm9yKHZhciBtPWFyZ3VtZW50cy5sZW5ndGgsYj1tLGo9QmUobSk7Yi0tOylqW2JdPWFyZ3VtZW50c1tiXTtpZihlJiYoaj1NdChqLGUsdSkpLG8mJihqPXF0KGosbyxpKSksX3x8eSl7dmFyIGI9bC5wbGFjZWhvbGRlcixrPXYoaixiKSxtPW0tay5sZW5ndGg7aWYobTxjKXt2YXIgST1mP3FuKGYpOncsbT1idShjLW0sMCksRT1fP2s6dyxrPV8/dzprLEM9Xz9qOncsaj1fP3c6ajtyZXR1cm4gdHw9Xz9SOk8sdCY9fihfP086UiksXG5nfHwodCY9fih4fEEpKSxqPVtuLHQscixDLEUsaixrLEksYSxtXSxJPXNyLmFwcGx5KHcsaiksJHIobikmJkR1KEksaiksSS5wbGFjZWhvbGRlcj1iLEl9fWlmKGI9cD9yOnRoaXMsST1oP2Jbbl06bixmKWZvcihtPWoubGVuZ3RoLEU9eHUoZi5sZW5ndGgsbSksaz1xbihqKTtFLS07KUM9ZltFXSxqW0VdPUNyKEMsbSk/a1tDXTp3O3JldHVybiBzJiZhPGoubGVuZ3RoJiYoai5sZW5ndGg9YSksdGhpcyYmdGhpcyE9PVpuJiZ0aGlzIGluc3RhbmNlb2YgbCYmKEk9ZHx8SnQobikpLEkuYXBwbHkoYixqKX12YXIgcz10JkUscD10JngsaD10JkEsXz10JmssZz10JmoseT10JkksZD1oP3c6SnQobik7cmV0dXJuIGx9ZnVuY3Rpb24gcHIobix0LHIpe3JldHVybiBuPW4ubGVuZ3RoLHQ9K3Qsbjx0JiZtdSh0KT8odC09bixyPW51bGw9PXI/XCIgXCI6citcIlwiLFVlKHIsdnUodC9yLmxlbmd0aCkpLnNsaWNlKDAsdCkpOlwiXCJ9ZnVuY3Rpb24gaHIobix0LHIsZSl7ZnVuY3Rpb24gdSgpe2Zvcih2YXIgdD0tMSxmPWFyZ3VtZW50cy5sZW5ndGgsYT0tMSxjPWUubGVuZ3RoLGw9QmUoYytmKTsrK2E8YzspbFthXT1lW2FdO1xuZm9yKDtmLS07KWxbYSsrXT1hcmd1bWVudHNbKyt0XTtyZXR1cm4odGhpcyYmdGhpcyE9PVpuJiZ0aGlzIGluc3RhbmNlb2YgdT9pOm4pLmFwcGx5KG8/cjp0aGlzLGwpfXZhciBvPXQmeCxpPUp0KG4pO3JldHVybiB1fWZ1bmN0aW9uIF9yKG4pe3ZhciB0PVBlW25dO3JldHVybiBmdW5jdGlvbihuLHIpe3JldHVybihyPXI9PT13PzA6K3J8fDApPyhyPWF1KDEwLHIpLHQobipyKS9yKTp0KG4pfX1mdW5jdGlvbiB2cihuKXtyZXR1cm4gZnVuY3Rpb24odCxyLGUsdSl7dmFyIG89d3IoZSk7cmV0dXJuIG51bGw9PWUmJm89PT11dD9MdCh0LHIsbik6enQodCxyLG8oZSx1LDEpLG4pfX1mdW5jdGlvbiBncihuLHQscixlLHUsbyxpLGYpe3ZhciBhPXQmQTtpZighYSYmdHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgR2UoTCk7dmFyIGM9ZT9lLmxlbmd0aDowO2lmKGN8fCh0Jj1+KFJ8TyksZT11PXcpLGMtPXU/dS5sZW5ndGg6MCx0Jk8pe3ZhciBsPWUscz11O2U9dT13fXZhciBwPWE/dzp6dShuKTtcbnJldHVybiByPVtuLHQscixlLHUsbCxzLG8saSxmXSxwJiYoZT1yWzFdLHQ9cFsxXSxmPWV8dCx1PXQ9PUUmJmU9PWt8fHQ9PUUmJmU9PUMmJnJbN10ubGVuZ3RoPD1wWzhdfHx0PT0oRXxDKSYmZT09aywoZjxFfHx1KSYmKHQmeCYmKHJbMl09cFsyXSxmfD1lJng/MDpqKSwoZT1wWzNdKSYmKHU9clszXSxyWzNdPXU/TXQodSxlLHBbNF0pOnFuKGUpLHJbNF09dT92KHJbM10seik6cW4ocFs0XSkpLChlPXBbNV0pJiYodT1yWzVdLHJbNV09dT9xdCh1LGUscFs2XSk6cW4oZSkscls2XT11P3Yocls1XSx6KTpxbihwWzZdKSksKGU9cFs3XSkmJihyWzddPXFuKGUpKSx0JkUmJihyWzhdPW51bGw9PXJbOF0/cFs4XTp4dShyWzhdLHBbOF0pKSxudWxsPT1yWzldJiYocls5XT1wWzldKSxyWzBdPXBbMF0sclsxXT1mKSx0PXJbMV0sZj1yWzldKSxyWzldPW51bGw9PWY/YT8wOm4ubGVuZ3RoOmJ1KGYtYywwKXx8MCwocD9MdTpEdSkodD09eD9ZdChyWzBdLHJbMl0pOnQhPVImJnQhPSh4fFIpfHxyWzRdLmxlbmd0aD9zci5hcHBseSh3LHIpOmhyLmFwcGx5KHcscikscik7XG59ZnVuY3Rpb24geXIobix0LHIsZSx1LG8saSl7dmFyIGY9LTEsYT1uLmxlbmd0aCxjPXQubGVuZ3RoO2lmKGEhPWMmJighdXx8Yzw9YSkpcmV0dXJuIGZhbHNlO2Zvcig7KytmPGE7KXt2YXIgbD1uW2ZdLGM9dFtmXSxzPWU/ZSh1P2M6bCx1P2w6YyxmKTp3O2lmKHMhPT13KXtpZihzKWNvbnRpbnVlO3JldHVybiBmYWxzZX1pZih1KXtpZighSG4odCxmdW5jdGlvbihuKXtyZXR1cm4gbD09PW58fHIobCxuLGUsdSxvLGkpfSkpcmV0dXJuIGZhbHNlfWVsc2UgaWYobCE9PWMmJiFyKGwsYyxlLHUsbyxpKSlyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZnVuY3Rpb24gZHIobix0LHIpe3N3aXRjaChyKXtjYXNlIE06Y2FzZSBxOnJldHVybituPT0rdDtjYXNlIFA6cmV0dXJuIG4ubmFtZT09dC5uYW1lJiZuLm1lc3NhZ2U9PXQubWVzc2FnZTtjYXNlIFY6cmV0dXJuIG4hPStuP3QhPSt0Om49PSt0O2Nhc2UgWTpjYXNlIEc6cmV0dXJuIG49PXQrXCJcIn1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gbXIobix0LHIsZSx1LG8saSl7dmFyIGY9em8obiksYT1mLmxlbmd0aCxjPXpvKHQpLmxlbmd0aDtcbmlmKGEhPWMmJiF1KXJldHVybiBmYWxzZTtmb3IoYz1hO2MtLTspe3ZhciBsPWZbY107aWYoISh1P2wgaW4gdDpudS5jYWxsKHQsbCkpKXJldHVybiBmYWxzZX1mb3IodmFyIHM9dTsrK2M8YTspe3ZhciBsPWZbY10scD1uW2xdLGg9dFtsXSxfPWU/ZSh1P2g6cCx1P3A6aCxsKTp3O2lmKF89PT13PyFyKHAsaCxlLHUsbyxpKTohXylyZXR1cm4gZmFsc2U7c3x8KHM9XCJjb25zdHJ1Y3RvclwiPT1sKX1yZXR1cm4gc3x8KHI9bi5jb25zdHJ1Y3RvcixlPXQuY29uc3RydWN0b3IsIShyIT1lJiZcImNvbnN0cnVjdG9yXCJpbiBuJiZcImNvbnN0cnVjdG9yXCJpbiB0KXx8dHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmciBpbnN0YW5jZW9mIHImJnR5cGVvZiBlPT1cImZ1bmN0aW9uXCImJmUgaW5zdGFuY2VvZiBlKT90cnVlOmZhbHNlfWZ1bmN0aW9uIHdyKG4sdCxyKXt2YXIgZT1Obi5jYWxsYmFja3x8U2UsZT1lPT09U2U/dXQ6ZTtyZXR1cm4gcj9lKG4sdCxyKTplfWZ1bmN0aW9uIGJyKG4pe2Zvcih2YXIgdD1uLm5hbWUscj1XdVt0XSxlPXI/ci5sZW5ndGg6MDtlLS07KXtcbnZhciB1PXJbZV0sbz11LmZ1bmM7aWYobnVsbD09b3x8bz09bilyZXR1cm4gdS5uYW1lfXJldHVybiB0fWZ1bmN0aW9uIHhyKG4sdCxlKXt2YXIgdT1Obi5pbmRleE9mfHxWcix1PXU9PT1Wcj9yOnU7cmV0dXJuIG4/dShuLHQsZSk6dX1mdW5jdGlvbiBBcihuKXtuPU9lKG4pO2Zvcih2YXIgdD1uLmxlbmd0aDt0LS07KXt2YXIgcj1uW3RdWzFdO25bdF1bMl09cj09PXImJiFnZShyKX1yZXR1cm4gbn1mdW5jdGlvbiBqcihuLHQpe3ZhciByPW51bGw9PW4/dzpuW3RdO3JldHVybiB5ZShyKT9yOnd9ZnVuY3Rpb24ga3Iobil7dmFyIHQ9bi5sZW5ndGgscj1uZXcgbi5jb25zdHJ1Y3Rvcih0KTtyZXR1cm4gdCYmXCJzdHJpbmdcIj09dHlwZW9mIG5bMF0mJm51LmNhbGwobixcImluZGV4XCIpJiYoci5pbmRleD1uLmluZGV4LHIuaW5wdXQ9bi5pbnB1dCkscn1mdW5jdGlvbiBJcihuKXtyZXR1cm4gbj1uLmNvbnN0cnVjdG9yLHR5cGVvZiBuPT1cImZ1bmN0aW9uXCImJm4gaW5zdGFuY2VvZiBufHwobj1WZSksXG5uZXcgbn1mdW5jdGlvbiBScihuLHQscil7dmFyIGU9bi5jb25zdHJ1Y3Rvcjtzd2l0Y2godCl7Y2FzZSBKOnJldHVybiBEdChuKTtjYXNlIE06Y2FzZSBxOnJldHVybiBuZXcgZSgrbik7Y2FzZSBYOmNhc2UgSDpjYXNlIFE6Y2FzZSBubjpjYXNlIHRuOmNhc2Ugcm46Y2FzZSBlbjpjYXNlIHVuOmNhc2Ugb246cmV0dXJuIHQ9bi5idWZmZXIsbmV3IGUocj9EdCh0KTp0LG4uYnl0ZU9mZnNldCxuLmxlbmd0aCk7Y2FzZSBWOmNhc2UgRzpyZXR1cm4gbmV3IGUobik7Y2FzZSBZOnZhciB1PW5ldyBlKG4uc291cmNlLGtuLmV4ZWMobikpO3UubGFzdEluZGV4PW4ubGFzdEluZGV4fXJldHVybiB1fWZ1bmN0aW9uIE9yKG4sdCxyKXtyZXR1cm4gbnVsbD09bnx8V3IodCxuKXx8KHQ9RHIodCksbj0xPT10Lmxlbmd0aD9uOnl0KG4sRXQodCwwLC0xKSksdD1acih0KSksdD1udWxsPT1uP246blt0XSxudWxsPT10P3c6dC5hcHBseShuLHIpfWZ1bmN0aW9uIEVyKG4pe3JldHVybiBudWxsIT1uJiZTcihCdShuKSk7XG59ZnVuY3Rpb24gQ3Iobix0KXtyZXR1cm4gbj10eXBlb2Ygbj09XCJudW1iZXJcInx8T24udGVzdChuKT8rbjotMSx0PW51bGw9PXQ/Q3U6dCwtMTxuJiYwPT1uJTEmJm48dH1mdW5jdGlvbiBVcihuLHQscil7aWYoIWdlKHIpKXJldHVybiBmYWxzZTt2YXIgZT10eXBlb2YgdDtyZXR1cm4oXCJudW1iZXJcIj09ZT9FcihyKSYmQ3IodCxyLmxlbmd0aCk6XCJzdHJpbmdcIj09ZSYmdCBpbiByKT8odD1yW3RdLG49PT1uP249PT10OnQhPT10KTpmYWxzZX1mdW5jdGlvbiBXcihuLHQpe3ZhciByPXR5cGVvZiBuO3JldHVyblwic3RyaW5nXCI9PXImJmRuLnRlc3Qobil8fFwibnVtYmVyXCI9PXI/dHJ1ZTpPbyhuKT9mYWxzZToheW4udGVzdChuKXx8bnVsbCE9dCYmbiBpbiBCcih0KX1mdW5jdGlvbiAkcihuKXt2YXIgdD1icihuKTtyZXR1cm4gdCBpbiB6bi5wcm90b3R5cGU/KHQ9Tm5bdF0sbj09PXQ/dHJ1ZToodD16dSh0KSwhIXQmJm49PT10WzBdKSk6ZmFsc2V9ZnVuY3Rpb24gU3Iobil7cmV0dXJuIHR5cGVvZiBuPT1cIm51bWJlclwiJiYtMTxuJiYwPT1uJTEmJm48PUN1O1xufWZ1bmN0aW9uIEZyKG4sdCl7cmV0dXJuIG49PT13P3Q6RW8obix0LEZyKX1mdW5jdGlvbiBOcihuLHQpe249QnIobik7Zm9yKHZhciByPS0xLGU9dC5sZW5ndGgsdT17fTsrK3I8ZTspe3ZhciBvPXRbcl07byBpbiBuJiYodVtvXT1uW29dKX1yZXR1cm4gdX1mdW5jdGlvbiBUcihuLHQpe3ZhciByPXt9O3JldHVybiBodChuLGZ1bmN0aW9uKG4sZSx1KXt0KG4sZSx1KSYmKHJbZV09bil9KSxyfWZ1bmN0aW9uIExyKG4pe2Zvcih2YXIgdD1SZShuKSxyPXQubGVuZ3RoLGU9ciYmbi5sZW5ndGgsdT0hIWUmJlNyKGUpJiYoT28obil8fHBlKG4pKSxvPS0xLGk9W107KytvPHI7KXt2YXIgZj10W29dOyh1JiZDcihmLGUpfHxudS5jYWxsKG4sZikpJiZpLnB1c2goZil9cmV0dXJuIGl9ZnVuY3Rpb24genIobil7cmV0dXJuIG51bGw9PW4/W106RXIobik/Z2Uobik/bjpWZShuKTpFZShuKX1mdW5jdGlvbiBCcihuKXtyZXR1cm4gZ2Uobik/bjpWZShuKX1mdW5jdGlvbiBEcihuKXtpZihPbyhuKSlyZXR1cm4gbjtcbnZhciB0PVtdO3JldHVybiB1KG4pLnJlcGxhY2UobW4sZnVuY3Rpb24obixyLGUsdSl7dC5wdXNoKGU/dS5yZXBsYWNlKEFuLFwiJDFcIik6cnx8bil9KSx0fWZ1bmN0aW9uIE1yKG4pe3JldHVybiBuIGluc3RhbmNlb2Ygem4/bi5jbG9uZSgpOm5ldyBMbihuLl9fd3JhcHBlZF9fLG4uX19jaGFpbl9fLHFuKG4uX19hY3Rpb25zX18pKX1mdW5jdGlvbiBxcihuLHQscil7cmV0dXJuIG4mJm4ubGVuZ3RoPygocj9VcihuLHQscik6bnVsbD09dCkmJih0PTEpLEV0KG4sMD50PzA6dCkpOltdfWZ1bmN0aW9uIFByKG4sdCxyKXt2YXIgZT1uP24ubGVuZ3RoOjA7cmV0dXJuIGU/KChyP1VyKG4sdCxyKTpudWxsPT10KSYmKHQ9MSksdD1lLSgrdHx8MCksRXQobiwwLDA+dD8wOnQpKTpbXX1mdW5jdGlvbiBLcihuKXtyZXR1cm4gbj9uWzBdOnd9ZnVuY3Rpb24gVnIobix0LGUpe3ZhciB1PW4/bi5sZW5ndGg6MDtpZighdSlyZXR1cm4tMTtpZih0eXBlb2YgZT09XCJudW1iZXJcIillPTA+ZT9idSh1K2UsMCk6ZTtlbHNlIGlmKGUpcmV0dXJuIGU9THQobix0KSxcbmU8dSYmKHQ9PT10P3Q9PT1uW2VdOm5bZV0hPT1uW2VdKT9lOi0xO3JldHVybiByKG4sdCxlfHwwKX1mdW5jdGlvbiBacihuKXt2YXIgdD1uP24ubGVuZ3RoOjA7cmV0dXJuIHQ/blt0LTFdOnd9ZnVuY3Rpb24gWXIobil7cmV0dXJuIHFyKG4sMSl9ZnVuY3Rpb24gR3Iobix0LGUsdSl7aWYoIW58fCFuLmxlbmd0aClyZXR1cm5bXTtudWxsIT10JiZ0eXBlb2YgdCE9XCJib29sZWFuXCImJih1PWUsZT1VcihuLHQsdSk/dzp0LHQ9ZmFsc2UpO3ZhciBvPXdyKCk7aWYoKG51bGwhPWV8fG8hPT11dCkmJihlPW8oZSx1LDMpKSx0JiZ4cigpPT1yKXt0PWU7dmFyIGk7ZT0tMSx1PW4ubGVuZ3RoO2Zvcih2YXIgbz0tMSxmPVtdOysrZTx1Oyl7dmFyIGE9bltlXSxjPXQ/dChhLGUsbik6YTtlJiZpPT09Y3x8KGk9YyxmWysrb109YSl9bj1mfWVsc2Ugbj1TdChuLGUpO3JldHVybiBufWZ1bmN0aW9uIEpyKG4pe2lmKCFufHwhbi5sZW5ndGgpcmV0dXJuW107dmFyIHQ9LTEscj0wO249Vm4obixmdW5jdGlvbihuKXtcbnJldHVybiBFcihuKT8ocj1idShuLmxlbmd0aCxyKSx0cnVlKTp2b2lkIDB9KTtmb3IodmFyIGU9QmUocik7Kyt0PHI7KWVbdF09R24obixqdCh0KSk7cmV0dXJuIGV9ZnVuY3Rpb24gWHIobix0LHIpe3JldHVybiBuJiZuLmxlbmd0aD8obj1KcihuKSxudWxsPT10P246KHQ9QnQodCxyLDQpLEduKG4sZnVuY3Rpb24obil7cmV0dXJuIFhuKG4sdCx3LHRydWUpfSkpKTpbXX1mdW5jdGlvbiBIcihuLHQpe3ZhciByPS0xLGU9bj9uLmxlbmd0aDowLHU9e307Zm9yKCFlfHx0fHxPbyhuWzBdKXx8KHQ9W10pOysrcjxlOyl7dmFyIG89bltyXTt0P3Vbb109dFtyXTpvJiYodVtvWzBdXT1vWzFdKX1yZXR1cm4gdX1mdW5jdGlvbiBRcihuKXtyZXR1cm4gbj1ObihuKSxuLl9fY2hhaW5fXz10cnVlLG59ZnVuY3Rpb24gbmUobix0LHIpe3JldHVybiB0LmNhbGwocixuKX1mdW5jdGlvbiB0ZShuLHQscil7dmFyIGU9T28obik/S246YXQ7cmV0dXJuIHImJlVyKG4sdCxyKSYmKHQ9dyksKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCJ8fHIhPT13KSYmKHQ9d3IodCxyLDMpKSxcbmUobix0KX1mdW5jdGlvbiByZShuLHQscil7dmFyIGU9T28obik/Vm46bHQ7cmV0dXJuIHQ9d3IodCxyLDMpLGUobix0KX1mdW5jdGlvbiBlZShuLHQscixlKXt2YXIgdT1uP0J1KG4pOjA7cmV0dXJuIFNyKHUpfHwobj1FZShuKSx1PW4ubGVuZ3RoKSxyPXR5cGVvZiByIT1cIm51bWJlclwifHxlJiZVcih0LHIsZSk/MDowPnI/YnUodStyLDApOnJ8fDAsdHlwZW9mIG49PVwic3RyaW5nXCJ8fCFPbyhuKSYmYmUobik/cjw9dSYmLTE8bi5pbmRleE9mKHQscik6ISF1JiYtMTx4cihuLHQscil9ZnVuY3Rpb24gdWUobix0LHIpe3ZhciBlPU9vKG4pP0duOnd0O3JldHVybiB0PXdyKHQsciwzKSxlKG4sdCl9ZnVuY3Rpb24gb2Uobix0LHIpe2lmKHI/VXIobix0LHIpOm51bGw9PXQpe249enIobik7dmFyIGU9bi5sZW5ndGg7cmV0dXJuIDA8ZT9uW1J0KDAsZS0xKV06d31yPS0xLG49amUobik7dmFyIGU9bi5sZW5ndGgsdT1lLTE7Zm9yKHQ9eHUoMD50PzA6K3R8fDAsZSk7KytyPHQ7KXt2YXIgZT1SdChyLHUpLG89bltlXTtcbm5bZV09bltyXSxuW3JdPW99cmV0dXJuIG4ubGVuZ3RoPXQsbn1mdW5jdGlvbiBpZShuLHQscil7dmFyIGU9T28obik/SG46Q3Q7cmV0dXJuIHImJlVyKG4sdCxyKSYmKHQ9dyksKHR5cGVvZiB0IT1cImZ1bmN0aW9uXCJ8fHIhPT13KSYmKHQ9d3IodCxyLDMpKSxlKG4sdCl9ZnVuY3Rpb24gZmUobix0KXt2YXIgcjtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTt2YXIgZT1uO249dCx0PWV9cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIDA8LS1uJiYocj10LmFwcGx5KHRoaXMsYXJndW1lbnRzKSksMT49biYmKHQ9dykscn19ZnVuY3Rpb24gYWUobix0LHIpe2Z1bmN0aW9uIGUodCxyKXtyJiZpdShyKSxhPXA9aD13LHQmJihfPWhvKCksYz1uLmFwcGx5KHMsZikscHx8YXx8KGY9cz13KSl9ZnVuY3Rpb24gdSgpe3ZhciBuPXQtKGhvKCktbCk7MD49bnx8bj50P2UoaCxhKTpwPXN1KHUsbil9ZnVuY3Rpb24gbygpe2UoZyxwKTtcbn1mdW5jdGlvbiBpKCl7aWYoZj1hcmd1bWVudHMsbD1obygpLHM9dGhpcyxoPWcmJihwfHwheSksZmFsc2U9PT12KXZhciByPXkmJiFwO2Vsc2V7YXx8eXx8KF89bCk7dmFyIGU9di0obC1fKSxpPTA+PWV8fGU+djtpPyhhJiYoYT1pdShhKSksXz1sLGM9bi5hcHBseShzLGYpKTphfHwoYT1zdShvLGUpKX1yZXR1cm4gaSYmcD9wPWl1KHApOnB8fHQ9PT12fHwocD1zdSh1LHQpKSxyJiYoaT10cnVlLGM9bi5hcHBseShzLGYpKSwhaXx8cHx8YXx8KGY9cz13KSxjfXZhciBmLGEsYyxsLHMscCxoLF89MCx2PWZhbHNlLGc9dHJ1ZTtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTtpZih0PTA+dD8wOit0fHwwLHRydWU9PT1yKXZhciB5PXRydWUsZz1mYWxzZTtlbHNlIGdlKHIpJiYoeT0hIXIubGVhZGluZyx2PVwibWF4V2FpdFwiaW4gciYmYnUoK3IubWF4V2FpdHx8MCx0KSxnPVwidHJhaWxpbmdcImluIHI/ISFyLnRyYWlsaW5nOmcpO3JldHVybiBpLmNhbmNlbD1mdW5jdGlvbigpe3AmJml1KHApLGEmJml1KGEpLFxuXz0wLGE9cD1oPXd9LGl9ZnVuY3Rpb24gY2Uobix0KXtmdW5jdGlvbiByKCl7dmFyIGU9YXJndW1lbnRzLHU9dD90LmFwcGx5KHRoaXMsZSk6ZVswXSxvPXIuY2FjaGU7cmV0dXJuIG8uaGFzKHUpP28uZ2V0KHUpOihlPW4uYXBwbHkodGhpcyxlKSxyLmNhY2hlPW8uc2V0KHUsZSksZSl9aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cInx8dCYmdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgR2UoTCk7cmV0dXJuIHIuY2FjaGU9bmV3IGNlLkNhY2hlLHJ9ZnVuY3Rpb24gbGUobix0KXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTtyZXR1cm4gdD1idSh0PT09dz9uLmxlbmd0aC0xOit0fHwwLDApLGZ1bmN0aW9uKCl7Zm9yKHZhciByPWFyZ3VtZW50cyxlPS0xLHU9YnUoci5sZW5ndGgtdCwwKSxvPUJlKHUpOysrZTx1OylvW2VdPXJbdCtlXTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBuLmNhbGwodGhpcyxvKTtjYXNlIDE6cmV0dXJuIG4uY2FsbCh0aGlzLHJbMF0sbyk7XG5jYXNlIDI6cmV0dXJuIG4uY2FsbCh0aGlzLHJbMF0sclsxXSxvKX1mb3IodT1CZSh0KzEpLGU9LTE7KytlPHQ7KXVbZV09cltlXTtyZXR1cm4gdVt0XT1vLG4uYXBwbHkodGhpcyx1KX19ZnVuY3Rpb24gc2Uobix0KXtyZXR1cm4gbj50fWZ1bmN0aW9uIHBlKG4pe3JldHVybiBoKG4pJiZFcihuKSYmbnUuY2FsbChuLFwiY2FsbGVlXCIpJiYhY3UuY2FsbChuLFwiY2FsbGVlXCIpfWZ1bmN0aW9uIGhlKG4sdCxyLGUpe3JldHVybiBlPShyPXR5cGVvZiByPT1cImZ1bmN0aW9uXCI/QnQocixlLDMpOncpP3Iobix0KTp3LGU9PT13P2R0KG4sdCxyKTohIWV9ZnVuY3Rpb24gX2Uobil7cmV0dXJuIGgobikmJnR5cGVvZiBuLm1lc3NhZ2U9PVwic3RyaW5nXCImJnJ1LmNhbGwobik9PVB9ZnVuY3Rpb24gdmUobil7cmV0dXJuIGdlKG4pJiZydS5jYWxsKG4pPT1LfWZ1bmN0aW9uIGdlKG4pe3ZhciB0PXR5cGVvZiBuO3JldHVybiEhbiYmKFwib2JqZWN0XCI9PXR8fFwiZnVuY3Rpb25cIj09dCl9ZnVuY3Rpb24geWUobil7XG5yZXR1cm4gbnVsbD09bj9mYWxzZTp2ZShuKT91dS50ZXN0KFFlLmNhbGwobikpOmgobikmJlJuLnRlc3Qobil9ZnVuY3Rpb24gZGUobil7cmV0dXJuIHR5cGVvZiBuPT1cIm51bWJlclwifHxoKG4pJiZydS5jYWxsKG4pPT1WfWZ1bmN0aW9uIG1lKG4pe3ZhciB0O2lmKCFoKG4pfHxydS5jYWxsKG4pIT1afHxwZShuKXx8IShudS5jYWxsKG4sXCJjb25zdHJ1Y3RvclwiKXx8KHQ9bi5jb25zdHJ1Y3Rvcix0eXBlb2YgdCE9XCJmdW5jdGlvblwifHx0IGluc3RhbmNlb2YgdCkpKXJldHVybiBmYWxzZTt2YXIgcjtyZXR1cm4gaHQobixmdW5jdGlvbihuLHQpe3I9dH0pLHI9PT13fHxudS5jYWxsKG4scil9ZnVuY3Rpb24gd2Uobil7cmV0dXJuIGdlKG4pJiZydS5jYWxsKG4pPT1ZfWZ1bmN0aW9uIGJlKG4pe3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcInx8aChuKSYmcnUuY2FsbChuKT09R31mdW5jdGlvbiB4ZShuKXtyZXR1cm4gaChuKSYmU3Iobi5sZW5ndGgpJiYhIVNuW3J1LmNhbGwobildfWZ1bmN0aW9uIEFlKG4sdCl7XG5yZXR1cm4gbjx0fWZ1bmN0aW9uIGplKG4pe3ZhciB0PW4/QnUobik6MDtyZXR1cm4gU3IodCk/dD9xbihuKTpbXTpFZShuKX1mdW5jdGlvbiBrZShuKXtyZXR1cm4gZXQobixSZShuKSl9ZnVuY3Rpb24gSWUobil7cmV0dXJuIGd0KG4sUmUobikpfWZ1bmN0aW9uIFJlKG4pe2lmKG51bGw9PW4pcmV0dXJuW107Z2Uobil8fChuPVZlKG4pKTtmb3IodmFyIHQ9bi5sZW5ndGgsdD10JiZTcih0KSYmKE9vKG4pfHxwZShuKSkmJnR8fDAscj1uLmNvbnN0cnVjdG9yLGU9LTEscj10eXBlb2Ygcj09XCJmdW5jdGlvblwiJiZyLnByb3RvdHlwZT09PW4sdT1CZSh0KSxvPTA8dDsrK2U8dDspdVtlXT1lK1wiXCI7Zm9yKHZhciBpIGluIG4pbyYmQ3IoaSx0KXx8XCJjb25zdHJ1Y3RvclwiPT1pJiYocnx8IW51LmNhbGwobixpKSl8fHUucHVzaChpKTtyZXR1cm4gdX1mdW5jdGlvbiBPZShuKXtuPUJyKG4pO2Zvcih2YXIgdD0tMSxyPXpvKG4pLGU9ci5sZW5ndGgsdT1CZShlKTsrK3Q8ZTspe3ZhciBvPXJbdF07XG51W3RdPVtvLG5bb11dfXJldHVybiB1fWZ1bmN0aW9uIEVlKG4pe3JldHVybiBGdChuLHpvKG4pKX1mdW5jdGlvbiBDZShuKXtyZXR1cm4obj11KG4pKSYmbi5yZXBsYWNlKEVuLGEpLnJlcGxhY2UoeG4sXCJcIil9ZnVuY3Rpb24gVWUobix0KXt2YXIgcj1cIlwiO2lmKG49dShuKSx0PSt0LDE+dHx8IW58fCFtdSh0KSlyZXR1cm4gcjtkbyB0JTImJihyKz1uKSx0PXl1KHQvMiksbis9bjt3aGlsZSh0KTtyZXR1cm4gcn1mdW5jdGlvbiBXZShuLHQscil7dmFyIGU9bjtyZXR1cm4obj11KG4pKT8ocj9VcihlLHQscik6bnVsbD09dCk/bi5zbGljZShnKG4pLHkobikrMSk6KHQrPVwiXCIsbi5zbGljZShvKG4sdCksaShuLHQpKzEpKTpufWZ1bmN0aW9uICRlKG4sdCxyKXtyZXR1cm4gciYmVXIobix0LHIpJiYodD13KSxuPXUobiksbi5tYXRjaCh0fHxXbil8fFtdfWZ1bmN0aW9uIFNlKG4sdCxyKXtyZXR1cm4gciYmVXIobix0LHIpJiYodD13KSxoKG4pP05lKG4pOnV0KG4sdCl9ZnVuY3Rpb24gRmUobil7XG5yZXR1cm4gbn1mdW5jdGlvbiBOZShuKXtyZXR1cm4gYnQob3Qobix0cnVlKSl9ZnVuY3Rpb24gVGUobix0LHIpe2lmKG51bGw9PXIpe3ZhciBlPWdlKHQpLHU9ZT96byh0KTp3OygodT11JiZ1Lmxlbmd0aD9ndCh0LHUpOncpP3UubGVuZ3RoOmUpfHwodT1mYWxzZSxyPXQsdD1uLG49dGhpcyl9dXx8KHU9Z3QodCx6byh0KSkpO3ZhciBvPXRydWUsZT0tMSxpPXZlKG4pLGY9dS5sZW5ndGg7ZmFsc2U9PT1yP289ZmFsc2U6Z2UocikmJlwiY2hhaW5cImluIHImJihvPXIuY2hhaW4pO2Zvcig7KytlPGY7KXtyPXVbZV07dmFyIGE9dFtyXTtuW3JdPWEsaSYmKG4ucHJvdG90eXBlW3JdPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciByPXRoaXMuX19jaGFpbl9fO2lmKG98fHIpe3ZhciBlPW4odGhpcy5fX3dyYXBwZWRfXyk7cmV0dXJuKGUuX19hY3Rpb25zX189cW4odGhpcy5fX2FjdGlvbnNfXykpLnB1c2goe2Z1bmM6dCxhcmdzOmFyZ3VtZW50cyx0aGlzQXJnOm59KSxlLl9fY2hhaW5fXz1yLGV9cmV0dXJuIHQuYXBwbHkobixKbihbdGhpcy52YWx1ZSgpXSxhcmd1bWVudHMpKTtcbn19KGEpKX1yZXR1cm4gbn1mdW5jdGlvbiBMZSgpe31mdW5jdGlvbiB6ZShuKXtyZXR1cm4gV3Iobik/anQobik6a3Qobil9Xz1fP1luLmRlZmF1bHRzKFpuLk9iamVjdCgpLF8sWW4ucGljayhabiwkbikpOlpuO3ZhciBCZT1fLkFycmF5LERlPV8uRGF0ZSxNZT1fLkVycm9yLHFlPV8uRnVuY3Rpb24sUGU9Xy5NYXRoLEtlPV8uTnVtYmVyLFZlPV8uT2JqZWN0LFplPV8uUmVnRXhwLFllPV8uU3RyaW5nLEdlPV8uVHlwZUVycm9yLEplPUJlLnByb3RvdHlwZSxYZT1WZS5wcm90b3R5cGUsSGU9WWUucHJvdG90eXBlLFFlPXFlLnByb3RvdHlwZS50b1N0cmluZyxudT1YZS5oYXNPd25Qcm9wZXJ0eSx0dT0wLHJ1PVhlLnRvU3RyaW5nLGV1PVpuLl8sdXU9WmUoXCJeXCIrUWUuY2FsbChudSkucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZyxcIiQxLio/XCIpK1wiJFwiKSxvdT1fLkFycmF5QnVmZmVyLGl1PV8uY2xlYXJUaW1lb3V0LGZ1PV8ucGFyc2VGbG9hdCxhdT1QZS5wb3csY3U9WGUucHJvcGVydHlJc0VudW1lcmFibGUsbHU9anIoXyxcIlNldFwiKSxzdT1fLnNldFRpbWVvdXQscHU9SmUuc3BsaWNlLGh1PV8uVWludDhBcnJheSxfdT1qcihfLFwiV2Vha01hcFwiKSx2dT1QZS5jZWlsLGd1PWpyKFZlLFwiY3JlYXRlXCIpLHl1PVBlLmZsb29yLGR1PWpyKEJlLFwiaXNBcnJheVwiKSxtdT1fLmlzRmluaXRlLHd1PWpyKFZlLFwia2V5c1wiKSxidT1QZS5tYXgseHU9UGUubWluLEF1PWpyKERlLFwibm93XCIpLGp1PV8ucGFyc2VJbnQsa3U9UGUucmFuZG9tLEl1PUtlLk5FR0FUSVZFX0lORklOSVRZLFJ1PUtlLlBPU0lUSVZFX0lORklOSVRZLE91PTQyOTQ5NjcyOTQsRXU9MjE0NzQ4MzY0NyxDdT05MDA3MTk5MjU0NzQwOTkxLFV1PV91JiZuZXcgX3UsV3U9e307XG5Obi5zdXBwb3J0PXt9LE5uLnRlbXBsYXRlU2V0dGluZ3M9e2VzY2FwZTpfbixldmFsdWF0ZTp2bixpbnRlcnBvbGF0ZTpnbix2YXJpYWJsZTpcIlwiLGltcG9ydHM6e186Tm59fTt2YXIgJHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKCl7fXJldHVybiBmdW5jdGlvbih0KXtpZihnZSh0KSl7bi5wcm90b3R5cGU9dDt2YXIgcj1uZXcgbjtuLnByb3RvdHlwZT13fXJldHVybiByfHx7fX19KCksU3U9VnQoX3QpLEZ1PVZ0KHZ0LHRydWUpLE51PVp0KCksVHU9WnQodHJ1ZSksTHU9VXU/ZnVuY3Rpb24obix0KXtyZXR1cm4gVXUuc2V0KG4sdCksbn06RmUsenU9VXU/ZnVuY3Rpb24obil7cmV0dXJuIFV1LmdldChuKX06TGUsQnU9anQoXCJsZW5ndGhcIiksRHU9ZnVuY3Rpb24oKXt2YXIgbj0wLHQ9MDtyZXR1cm4gZnVuY3Rpb24ocixlKXt2YXIgdT1obygpLG89Uy0odS10KTtpZih0PXUsMDxvKXtpZigrK24+PSQpcmV0dXJuIHJ9ZWxzZSBuPTA7cmV0dXJuIEx1KHIsZSl9fSgpLE11PWxlKGZ1bmN0aW9uKG4sdCl7XG5yZXR1cm4gaChuKSYmRXIobik/ZnQobixwdCh0LGZhbHNlLHRydWUpKTpbXX0pLHF1PXRyKCksUHU9dHIodHJ1ZSksS3U9bGUoZnVuY3Rpb24obil7Zm9yKHZhciB0PW4ubGVuZ3RoLGU9dCx1PUJlKGwpLG89eHIoKSxpPW89PXIsZj1bXTtlLS07KXt2YXIgYT1uW2VdPUVyKGE9bltlXSk/YTpbXTt1W2VdPWkmJjEyMDw9YS5sZW5ndGgmJmd1JiZsdT9uZXcgRG4oZSYmYSk6bnVsbH12YXIgaT1uWzBdLGM9LTEsbD1pP2kubGVuZ3RoOjAscz11WzBdO246Zm9yKDsrK2M8bDspaWYoYT1pW2NdLDA+KHM/TW4ocyxhKTpvKGYsYSwwKSkpe2ZvcihlPXQ7LS1lOyl7dmFyIHA9dVtlXTtpZigwPihwP01uKHAsYSk6byhuW2VdLGEsMCkpKWNvbnRpbnVlIG59cyYmcy5wdXNoKGEpLGYucHVzaChhKX1yZXR1cm4gZn0pLFZ1PWxlKGZ1bmN0aW9uKHQscil7cj1wdChyKTt2YXIgZT1ydCh0LHIpO3JldHVybiBJdCh0LHIuc29ydChuKSksZX0pLFp1PXZyKCksWXU9dnIodHJ1ZSksR3U9bGUoZnVuY3Rpb24obil7cmV0dXJuIFN0KHB0KG4sZmFsc2UsdHJ1ZSkpO1xufSksSnU9bGUoZnVuY3Rpb24obix0KXtyZXR1cm4gRXIobik/ZnQobix0KTpbXX0pLFh1PWxlKEpyKSxIdT1sZShmdW5jdGlvbihuKXt2YXIgdD1uLmxlbmd0aCxyPTI8dD9uW3QtMl06dyxlPTE8dD9uW3QtMV06dztyZXR1cm4gMjx0JiZ0eXBlb2Ygcj09XCJmdW5jdGlvblwiP3QtPTI6KHI9MTx0JiZ0eXBlb2YgZT09XCJmdW5jdGlvblwiPygtLXQsZSk6dyxlPXcpLG4ubGVuZ3RoPXQsWHIobixyLGUpfSksUXU9bGUoZnVuY3Rpb24obil7cmV0dXJuIG49cHQobiksdGhpcy50aHJ1KGZ1bmN0aW9uKHQpe3Q9T28odCk/dDpbQnIodCldO2Zvcih2YXIgcj1uLGU9LTEsdT10Lmxlbmd0aCxvPS0xLGk9ci5sZW5ndGgsZj1CZSh1K2kpOysrZTx1OylmW2VdPXRbZV07Zm9yKDsrK288aTspZltlKytdPXJbb107cmV0dXJuIGZ9KX0pLG5vPWxlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIHJ0KG4scHQodCkpfSksdG89UHQoZnVuY3Rpb24obix0LHIpe251LmNhbGwobixyKT8rK25bcl06bltyXT0xfSkscm89bnIoU3UpLGVvPW5yKEZ1LHRydWUpLHVvPXVyKFBuLFN1KSxvbz11cihmdW5jdGlvbihuLHQpe1xuZm9yKHZhciByPW4ubGVuZ3RoO3ItLSYmZmFsc2UhPT10KG5bcl0scixuKTspO3JldHVybiBufSxGdSksaW89UHQoZnVuY3Rpb24obix0LHIpe251LmNhbGwobixyKT9uW3JdLnB1c2godCk6bltyXT1bdF19KSxmbz1QdChmdW5jdGlvbihuLHQscil7bltyXT10fSksYW89bGUoZnVuY3Rpb24obix0LHIpe3ZhciBlPS0xLHU9dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIixvPVdyKHQpLGk9RXIobik/QmUobi5sZW5ndGgpOltdO3JldHVybiBTdShuLGZ1bmN0aW9uKG4pe3ZhciBmPXU/dDpvJiZudWxsIT1uP25bdF06dztpWysrZV09Zj9mLmFwcGx5KG4scik6T3Iobix0LHIpfSksaX0pLGNvPVB0KGZ1bmN0aW9uKG4sdCxyKXtuW3I/MDoxXS5wdXNoKHQpfSxmdW5jdGlvbigpe3JldHVybltbXSxbXV19KSxsbz1scihYbixTdSksc289bHIoZnVuY3Rpb24obix0LHIsZSl7dmFyIHU9bi5sZW5ndGg7Zm9yKGUmJnUmJihyPW5bLS11XSk7dS0tOylyPXQocixuW3VdLHUsbik7cmV0dXJuIHJ9LEZ1KSxwbz1sZShmdW5jdGlvbihuLHQpe1xuaWYobnVsbD09bilyZXR1cm5bXTt2YXIgcj10WzJdO3JldHVybiByJiZVcih0WzBdLHRbMV0scikmJih0Lmxlbmd0aD0xKSxXdChuLHB0KHQpLFtdKX0pLGhvPUF1fHxmdW5jdGlvbigpe3JldHVybihuZXcgRGUpLmdldFRpbWUoKX0sX289bGUoZnVuY3Rpb24obix0LHIpe3ZhciBlPXg7aWYoci5sZW5ndGgpdmFyIHU9dihyLF9vLnBsYWNlaG9sZGVyKSxlPWV8UjtyZXR1cm4gZ3IobixlLHQscix1KX0pLHZvPWxlKGZ1bmN0aW9uKG4sdCl7dD10Lmxlbmd0aD9wdCh0KTpJZShuKTtmb3IodmFyIHI9LTEsZT10Lmxlbmd0aDsrK3I8ZTspe3ZhciB1PXRbcl07blt1XT1ncihuW3VdLHgsbil9cmV0dXJuIG59KSxnbz1sZShmdW5jdGlvbihuLHQscil7dmFyIGU9eHxBO2lmKHIubGVuZ3RoKXZhciB1PXYocixnby5wbGFjZWhvbGRlciksZT1lfFI7cmV0dXJuIGdyKHQsZSxuLHIsdSl9KSx5bz1YdChrKSxtbz1YdChJKSx3bz1sZShmdW5jdGlvbihuLHQpe3JldHVybiBpdChuLDEsdCl9KSxibz1sZShmdW5jdGlvbihuLHQscil7XG5yZXR1cm4gaXQobix0LHIpfSkseG89ZXIoKSxBbz1lcih0cnVlKSxqbz1sZShmdW5jdGlvbihuLHQpe2lmKHQ9cHQodCksdHlwZW9mIG4hPVwiZnVuY3Rpb25cInx8IUtuKHQsZSkpdGhyb3cgbmV3IEdlKEwpO3ZhciByPXQubGVuZ3RoO3JldHVybiBsZShmdW5jdGlvbihlKXtmb3IodmFyIHU9eHUoZS5sZW5ndGgscik7dS0tOyllW3VdPXRbdV0oZVt1XSk7cmV0dXJuIG4uYXBwbHkodGhpcyxlKX0pfSksa289Y3IoUiksSW89Y3IoTyksUm89bGUoZnVuY3Rpb24obix0KXtyZXR1cm4gZ3IobixDLHcsdyx3LHB0KHQpKX0pLE9vPWR1fHxmdW5jdGlvbihuKXtyZXR1cm4gaChuKSYmU3Iobi5sZW5ndGgpJiZydS5jYWxsKG4pPT1EfSxFbz1LdChBdCksQ289S3QoZnVuY3Rpb24obix0LHIpe3JldHVybiByP250KG4sdCxyKTp0dChuLHQpfSksVW89SHQoQ28sZnVuY3Rpb24obix0KXtyZXR1cm4gbj09PXc/dDpufSksV289SHQoRW8sRnIpLCRvPXJyKF90KSxTbz1ycih2dCksRm89b3IoTnUpLE5vPW9yKFR1KSxUbz1pcihfdCksTG89aXIodnQpLHpvPXd1P2Z1bmN0aW9uKG4pe1xudmFyIHQ9bnVsbD09bj93Om4uY29uc3RydWN0b3I7cmV0dXJuIHR5cGVvZiB0PT1cImZ1bmN0aW9uXCImJnQucHJvdG90eXBlPT09bnx8dHlwZW9mIG4hPVwiZnVuY3Rpb25cIiYmRXIobik/THIobik6Z2Uobik/d3Uobik6W119OkxyLEJvPWZyKHRydWUpLERvPWZyKCksTW89bGUoZnVuY3Rpb24obix0KXtpZihudWxsPT1uKXJldHVybnt9O2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRbMF0pcmV0dXJuIHQ9R24ocHQodCksWWUpLE5yKG4sZnQoUmUobiksdCkpO3ZhciByPUJ0KHRbMF0sdFsxXSwzKTtyZXR1cm4gVHIobixmdW5jdGlvbihuLHQsZSl7cmV0dXJuIXIobix0LGUpfSl9KSxxbz1sZShmdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP3t9OlwiZnVuY3Rpb25cIj09dHlwZW9mIHRbMF0/VHIobixCdCh0WzBdLHRbMV0sMykpOk5yKG4scHQodCkpfSksUG89R3QoZnVuY3Rpb24obix0LHIpe3JldHVybiB0PXQudG9Mb3dlckNhc2UoKSxuKyhyP3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKTp0KTtcbn0pLEtvPUd0KGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbisocj9cIi1cIjpcIlwiKSt0LnRvTG93ZXJDYXNlKCl9KSxWbz1hcigpLFpvPWFyKHRydWUpLFlvPUd0KGZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbisocj9cIl9cIjpcIlwiKSt0LnRvTG93ZXJDYXNlKCl9KSxHbz1HdChmdW5jdGlvbihuLHQscil7cmV0dXJuIG4rKHI/XCIgXCI6XCJcIikrKHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSl9KSxKbz1sZShmdW5jdGlvbihuLHQpe3RyeXtyZXR1cm4gbi5hcHBseSh3LHQpfWNhdGNoKHIpe3JldHVybiBfZShyKT9yOm5ldyBNZShyKX19KSxYbz1sZShmdW5jdGlvbihuLHQpe3JldHVybiBmdW5jdGlvbihyKXtyZXR1cm4gT3IocixuLHQpfX0pLEhvPWxlKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiBPcihuLHIsdCl9fSksUW89X3IoXCJjZWlsXCIpLG5pPV9yKFwiZmxvb3JcIiksdGk9UXQoc2UsSXUpLHJpPVF0KEFlLFJ1KSxlaT1fcihcInJvdW5kXCIpO3JldHVybiBObi5wcm90b3R5cGU9VG4ucHJvdG90eXBlLFxuTG4ucHJvdG90eXBlPSR1KFRuLnByb3RvdHlwZSksTG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPUxuLHpuLnByb3RvdHlwZT0kdShUbi5wcm90b3R5cGUpLHpuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj16bixCbi5wcm90b3R5cGVbXCJkZWxldGVcIl09ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuaGFzKG4pJiZkZWxldGUgdGhpcy5fX2RhdGFfX1tuXX0sQm4ucHJvdG90eXBlLmdldD1mdW5jdGlvbihuKXtyZXR1cm5cIl9fcHJvdG9fX1wiPT1uP3c6dGhpcy5fX2RhdGFfX1tuXX0sQm4ucHJvdG90eXBlLmhhcz1mdW5jdGlvbihuKXtyZXR1cm5cIl9fcHJvdG9fX1wiIT1uJiZudS5jYWxsKHRoaXMuX19kYXRhX18sbil9LEJuLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obix0KXtyZXR1cm5cIl9fcHJvdG9fX1wiIT1uJiYodGhpcy5fX2RhdGFfX1tuXT10KSx0aGlzfSxEbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihuKXt2YXIgdD10aGlzLmRhdGE7dHlwZW9mIG49PVwic3RyaW5nXCJ8fGdlKG4pP3Quc2V0LmFkZChuKTp0Lmhhc2hbbl09dHJ1ZTtcbn0sY2UuQ2FjaGU9Qm4sTm4uYWZ0ZXI9ZnVuY3Rpb24obix0KXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTt2YXIgcj1uO249dCx0PXJ9cmV0dXJuIG49bXUobj0rbik/bjowLGZ1bmN0aW9uKCl7cmV0dXJuIDE+LS1uP3QuYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH19LE5uLmFyeT1mdW5jdGlvbihuLHQscil7cmV0dXJuIHImJlVyKG4sdCxyKSYmKHQ9dyksdD1uJiZudWxsPT10P24ubGVuZ3RoOmJ1KCt0fHwwLDApLGdyKG4sRSx3LHcsdyx3LHQpfSxObi5hc3NpZ249Q28sTm4uYXQ9bm8sTm4uYmVmb3JlPWZlLE5uLmJpbmQ9X28sTm4uYmluZEFsbD12byxObi5iaW5kS2V5PWdvLE5uLmNhbGxiYWNrPVNlLE5uLmNoYWluPVFyLE5uLmNodW5rPWZ1bmN0aW9uKG4sdCxyKXt0PShyP1VyKG4sdCxyKTpudWxsPT10KT8xOmJ1KHl1KHQpfHwxLDEpLHI9MDtmb3IodmFyIGU9bj9uLmxlbmd0aDowLHU9LTEsbz1CZSh2dShlL3QpKTtyPGU7KW9bKyt1XT1FdChuLHIscis9dCk7XG5yZXR1cm4gb30sTm4uY29tcGFjdD1mdW5jdGlvbihuKXtmb3IodmFyIHQ9LTEscj1uP24ubGVuZ3RoOjAsZT0tMSx1PVtdOysrdDxyOyl7dmFyIG89blt0XTtvJiYodVsrK2VdPW8pfXJldHVybiB1fSxObi5jb25zdGFudD1mdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbn19LE5uLmNvdW50Qnk9dG8sTm4uY3JlYXRlPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT0kdShuKTtyZXR1cm4gciYmVXIobix0LHIpJiYodD13KSx0P3R0KGUsdCk6ZX0sTm4uY3Vycnk9eW8sTm4uY3VycnlSaWdodD1tbyxObi5kZWJvdW5jZT1hZSxObi5kZWZhdWx0cz1VbyxObi5kZWZhdWx0c0RlZXA9V28sTm4uZGVmZXI9d28sTm4uZGVsYXk9Ym8sTm4uZGlmZmVyZW5jZT1NdSxObi5kcm9wPXFyLE5uLmRyb3BSaWdodD1QcixObi5kcm9wUmlnaHRXaGlsZT1mdW5jdGlvbihuLHQscil7cmV0dXJuIG4mJm4ubGVuZ3RoP050KG4sd3IodCxyLDMpLHRydWUsdHJ1ZSk6W119LE5uLmRyb3BXaGlsZT1mdW5jdGlvbihuLHQscil7XG5yZXR1cm4gbiYmbi5sZW5ndGg/TnQobix3cih0LHIsMyksdHJ1ZSk6W119LE5uLmZpbGw9ZnVuY3Rpb24obix0LHIsZSl7dmFyIHU9bj9uLmxlbmd0aDowO2lmKCF1KXJldHVybltdO2ZvcihyJiZ0eXBlb2YgciE9XCJudW1iZXJcIiYmVXIobix0LHIpJiYocj0wLGU9dSksdT1uLmxlbmd0aCxyPW51bGw9PXI/MDorcnx8MCwwPnImJihyPS1yPnU/MDp1K3IpLGU9ZT09PXd8fGU+dT91OitlfHwwLDA+ZSYmKGUrPXUpLHU9cj5lPzA6ZT4+PjAscj4+Pj0wO3I8dTspbltyKytdPXQ7cmV0dXJuIG59LE5uLmZpbHRlcj1yZSxObi5mbGF0dGVuPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1uP24ubGVuZ3RoOjA7cmV0dXJuIHImJlVyKG4sdCxyKSYmKHQ9ZmFsc2UpLGU/cHQobix0KTpbXX0sTm4uZmxhdHRlbkRlZXA9ZnVuY3Rpb24obil7cmV0dXJuIG4mJm4ubGVuZ3RoP3B0KG4sdHJ1ZSk6W119LE5uLmZsb3c9eG8sTm4uZmxvd1JpZ2h0PUFvLE5uLmZvckVhY2g9dW8sTm4uZm9yRWFjaFJpZ2h0PW9vLE5uLmZvckluPUZvLFxuTm4uZm9ySW5SaWdodD1ObyxObi5mb3JPd249VG8sTm4uZm9yT3duUmlnaHQ9TG8sTm4uZnVuY3Rpb25zPUllLE5uLmdyb3VwQnk9aW8sTm4uaW5kZXhCeT1mbyxObi5pbml0aWFsPWZ1bmN0aW9uKG4pe3JldHVybiBQcihuLDEpfSxObi5pbnRlcnNlY3Rpb249S3UsTm4uaW52ZXJ0PWZ1bmN0aW9uKG4sdCxyKXtyJiZVcihuLHQscikmJih0PXcpLHI9LTE7Zm9yKHZhciBlPXpvKG4pLHU9ZS5sZW5ndGgsbz17fTsrK3I8dTspe3ZhciBpPWVbcl0sZj1uW2ldO3Q/bnUuY2FsbChvLGYpP29bZl0ucHVzaChpKTpvW2ZdPVtpXTpvW2ZdPWl9cmV0dXJuIG99LE5uLmludm9rZT1hbyxObi5rZXlzPXpvLE5uLmtleXNJbj1SZSxObi5tYXA9dWUsTm4ubWFwS2V5cz1CbyxObi5tYXBWYWx1ZXM9RG8sTm4ubWF0Y2hlcz1OZSxObi5tYXRjaGVzUHJvcGVydHk9ZnVuY3Rpb24obix0KXtyZXR1cm4geHQobixvdCh0LHRydWUpKX0sTm4ubWVtb2l6ZT1jZSxObi5tZXJnZT1FbyxObi5tZXRob2Q9WG8sTm4ubWV0aG9kT2Y9SG8sXG5Obi5taXhpbj1UZSxObi5tb2RBcmdzPWpvLE5uLm5lZ2F0ZT1mdW5jdGlvbihuKXtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBHZShMKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4hbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSxObi5vbWl0PU1vLE5uLm9uY2U9ZnVuY3Rpb24obil7cmV0dXJuIGZlKDIsbil9LE5uLnBhaXJzPU9lLE5uLnBhcnRpYWw9a28sTm4ucGFydGlhbFJpZ2h0PUlvLE5uLnBhcnRpdGlvbj1jbyxObi5waWNrPXFvLE5uLnBsdWNrPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHVlKG4semUodCkpfSxObi5wcm9wZXJ0eT16ZSxObi5wcm9wZXJ0eU9mPWZ1bmN0aW9uKG4pe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4geXQobixEcih0KSx0K1wiXCIpfX0sTm4ucHVsbD1mdW5jdGlvbigpe3ZhciBuPWFyZ3VtZW50cyx0PW5bMF07aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm4gdDtmb3IodmFyIHI9MCxlPXhyKCksdT1uLmxlbmd0aDsrK3I8dTspZm9yKHZhciBvPTAsaT1uW3JdOy0xPChvPWUodCxpLG8pKTspcHUuY2FsbCh0LG8sMSk7XG5yZXR1cm4gdH0sTm4ucHVsbEF0PVZ1LE5uLnJhbmdlPWZ1bmN0aW9uKG4sdCxyKXtyJiZVcihuLHQscikmJih0PXI9dyksbj0rbnx8MCxyPW51bGw9PXI/MTorcnx8MCxudWxsPT10Pyh0PW4sbj0wKTp0PSt0fHwwO3ZhciBlPS0xO3Q9YnUodnUoKHQtbikvKHJ8fDEpKSwwKTtmb3IodmFyIHU9QmUodCk7KytlPHQ7KXVbZV09bixuKz1yO3JldHVybiB1fSxObi5yZWFyZz1SbyxObi5yZWplY3Q9ZnVuY3Rpb24obix0LHIpe3ZhciBlPU9vKG4pP1ZuOmx0O3JldHVybiB0PXdyKHQsciwzKSxlKG4sZnVuY3Rpb24obixyLGUpe3JldHVybiF0KG4scixlKX0pfSxObi5yZW1vdmU9ZnVuY3Rpb24obix0LHIpe3ZhciBlPVtdO2lmKCFufHwhbi5sZW5ndGgpcmV0dXJuIGU7dmFyIHU9LTEsbz1bXSxpPW4ubGVuZ3RoO2Zvcih0PXdyKHQsciwzKTsrK3U8aTspcj1uW3VdLHQocix1LG4pJiYoZS5wdXNoKHIpLG8ucHVzaCh1KSk7cmV0dXJuIEl0KG4sbyksZX0sTm4ucmVzdD1ZcixObi5yZXN0UGFyYW09bGUsXG5Obi5zZXQ9ZnVuY3Rpb24obix0LHIpe2lmKG51bGw9PW4pcmV0dXJuIG47dmFyIGU9dCtcIlwiO3Q9bnVsbCE9bltlXXx8V3IodCxuKT9bZV06RHIodCk7Zm9yKHZhciBlPS0xLHU9dC5sZW5ndGgsbz11LTEsaT1uO251bGwhPWkmJisrZTx1Oyl7dmFyIGY9dFtlXTtnZShpKSYmKGU9PW8/aVtmXT1yOm51bGw9PWlbZl0mJihpW2ZdPUNyKHRbZSsxXSk/W106e30pKSxpPWlbZl19cmV0dXJuIG59LE5uLnNodWZmbGU9ZnVuY3Rpb24obil7cmV0dXJuIG9lKG4sUnUpfSxObi5zbGljZT1mdW5jdGlvbihuLHQscil7dmFyIGU9bj9uLmxlbmd0aDowO3JldHVybiBlPyhyJiZ0eXBlb2YgciE9XCJudW1iZXJcIiYmVXIobix0LHIpJiYodD0wLHI9ZSksRXQobix0LHIpKTpbXX0sTm4uc29ydEJ5PWZ1bmN0aW9uKG4sdCxyKXtpZihudWxsPT1uKXJldHVybltdO3ImJlVyKG4sdCxyKSYmKHQ9dyk7dmFyIGU9LTE7cmV0dXJuIHQ9d3IodCxyLDMpLG49d3QobixmdW5jdGlvbihuLHIsdSl7cmV0dXJue2E6dChuLHIsdSksXG5iOisrZSxjOm59fSksVXQobixmKX0sTm4uc29ydEJ5QWxsPXBvLE5uLnNvcnRCeU9yZGVyPWZ1bmN0aW9uKG4sdCxyLGUpe3JldHVybiBudWxsPT1uP1tdOihlJiZVcih0LHIsZSkmJihyPXcpLE9vKHQpfHwodD1udWxsPT10P1tdOlt0XSksT28ocil8fChyPW51bGw9PXI/W106W3JdKSxXdChuLHQscikpfSxObi5zcHJlYWQ9ZnVuY3Rpb24obil7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgR2UoTCk7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBuLmFwcGx5KHRoaXMsdCl9fSxObi50YWtlPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbiYmbi5sZW5ndGg/KChyP1VyKG4sdCxyKTpudWxsPT10KSYmKHQ9MSksRXQobiwwLDA+dD8wOnQpKTpbXX0sTm4udGFrZVJpZ2h0PWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1uP24ubGVuZ3RoOjA7cmV0dXJuIGU/KChyP1VyKG4sdCxyKTpudWxsPT10KSYmKHQ9MSksdD1lLSgrdHx8MCksRXQobiwwPnQ/MDp0KSk6W119LE5uLnRha2VSaWdodFdoaWxlPWZ1bmN0aW9uKG4sdCxyKXtcbnJldHVybiBuJiZuLmxlbmd0aD9OdChuLHdyKHQsciwzKSxmYWxzZSx0cnVlKTpbXX0sTm4udGFrZVdoaWxlPWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbiYmbi5sZW5ndGg/TnQobix3cih0LHIsMykpOltdfSxObi50YXA9ZnVuY3Rpb24obix0LHIpe3JldHVybiB0LmNhbGwocixuKSxufSxObi50aHJvdHRsZT1mdW5jdGlvbihuLHQscil7dmFyIGU9dHJ1ZSx1PXRydWU7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgR2UoTCk7cmV0dXJuIGZhbHNlPT09cj9lPWZhbHNlOmdlKHIpJiYoZT1cImxlYWRpbmdcImluIHI/ISFyLmxlYWRpbmc6ZSx1PVwidHJhaWxpbmdcImluIHI/ISFyLnRyYWlsaW5nOnUpLGFlKG4sdCx7bGVhZGluZzplLG1heFdhaXQ6K3QsdHJhaWxpbmc6dX0pfSxObi50aHJ1PW5lLE5uLnRpbWVzPWZ1bmN0aW9uKG4sdCxyKXtpZihuPXl1KG4pLDE+bnx8IW11KG4pKXJldHVybltdO3ZhciBlPS0xLHU9QmUoeHUobiw0Mjk0OTY3Mjk1KSk7Zm9yKHQ9QnQodCxyLDEpOysrZTxuOyk0Mjk0OTY3Mjk1PmU/dVtlXT10KGUpOnQoZSk7XG5yZXR1cm4gdX0sTm4udG9BcnJheT1qZSxObi50b1BsYWluT2JqZWN0PWtlLE5uLnRyYW5zZm9ybT1mdW5jdGlvbihuLHQscixlKXt2YXIgdT1PbyhuKXx8eGUobik7cmV0dXJuIHQ9d3IodCxlLDQpLG51bGw9PXImJih1fHxnZShuKT8oZT1uLmNvbnN0cnVjdG9yLHI9dT9PbyhuKT9uZXcgZTpbXTokdSh2ZShlKT9lLnByb3RvdHlwZTp3KSk6cj17fSksKHU/UG46X3QpKG4sZnVuY3Rpb24obixlLHUpe3JldHVybiB0KHIsbixlLHUpfSkscn0sTm4udW5pb249R3UsTm4udW5pcT1HcixObi51bnppcD1KcixObi51bnppcFdpdGg9WHIsTm4udmFsdWVzPUVlLE5uLnZhbHVlc0luPWZ1bmN0aW9uKG4pe3JldHVybiBGdChuLFJlKG4pKX0sTm4ud2hlcmU9ZnVuY3Rpb24obix0KXtyZXR1cm4gcmUobixidCh0KSl9LE5uLndpdGhvdXQ9SnUsTm4ud3JhcD1mdW5jdGlvbihuLHQpe3JldHVybiB0PW51bGw9PXQ/RmU6dCxncih0LFIsdyxbbl0sW10pfSxObi54b3I9ZnVuY3Rpb24oKXtmb3IodmFyIG49LTEsdD1hcmd1bWVudHMubGVuZ3RoOysrbjx0Oyl7XG52YXIgcj1hcmd1bWVudHNbbl07aWYoRXIocikpdmFyIGU9ZT9KbihmdChlLHIpLGZ0KHIsZSkpOnJ9cmV0dXJuIGU/U3QoZSk6W119LE5uLnppcD1YdSxObi56aXBPYmplY3Q9SHIsTm4uemlwV2l0aD1IdSxObi5iYWNrZmxvdz1BbyxObi5jb2xsZWN0PXVlLE5uLmNvbXBvc2U9QW8sTm4uZWFjaD11byxObi5lYWNoUmlnaHQ9b28sTm4uZXh0ZW5kPUNvLE5uLml0ZXJhdGVlPVNlLE5uLm1ldGhvZHM9SWUsTm4ub2JqZWN0PUhyLE5uLnNlbGVjdD1yZSxObi50YWlsPVlyLE5uLnVuaXF1ZT1HcixUZShObixObiksTm4uYWRkPWZ1bmN0aW9uKG4sdCl7cmV0dXJuKCtufHwwKSsoK3R8fDApfSxObi5hdHRlbXB0PUpvLE5uLmNhbWVsQ2FzZT1QbyxObi5jYXBpdGFsaXplPWZ1bmN0aW9uKG4pe3JldHVybihuPXUobikpJiZuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSl9LE5uLmNlaWw9UW8sTm4uY2xvbmU9ZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIHQmJnR5cGVvZiB0IT1cImJvb2xlYW5cIiYmVXIobix0LHIpP3Q9ZmFsc2U6dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIiYmKGU9cixcbnI9dCx0PWZhbHNlKSx0eXBlb2Ygcj09XCJmdW5jdGlvblwiP290KG4sdCxCdChyLGUsMSkpOm90KG4sdCl9LE5uLmNsb25lRGVlcD1mdW5jdGlvbihuLHQscil7cmV0dXJuIHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/b3Qobix0cnVlLEJ0KHQsciwxKSk6b3Qobix0cnVlKX0sTm4uZGVidXJyPUNlLE5uLmVuZHNXaXRoPWZ1bmN0aW9uKG4sdCxyKXtuPXUobiksdCs9XCJcIjt2YXIgZT1uLmxlbmd0aDtyZXR1cm4gcj1yPT09dz9lOnh1KDA+cj8wOityfHwwLGUpLHItPXQubGVuZ3RoLDA8PXImJm4uaW5kZXhPZih0LHIpPT1yfSxObi5lc2NhcGU9ZnVuY3Rpb24obil7cmV0dXJuKG49dShuKSkmJmhuLnRlc3Qobik/bi5yZXBsYWNlKHNuLGMpOm59LE5uLmVzY2FwZVJlZ0V4cD1mdW5jdGlvbihuKXtyZXR1cm4obj11KG4pKSYmYm4udGVzdChuKT9uLnJlcGxhY2Uod24sbCk6bnx8XCIoPzopXCJ9LE5uLmV2ZXJ5PXRlLE5uLmZpbmQ9cm8sTm4uZmluZEluZGV4PXF1LE5uLmZpbmRLZXk9JG8sTm4uZmluZExhc3Q9ZW8sXG5Obi5maW5kTGFzdEluZGV4PVB1LE5uLmZpbmRMYXN0S2V5PVNvLE5uLmZpbmRXaGVyZT1mdW5jdGlvbihuLHQpe3JldHVybiBybyhuLGJ0KHQpKX0sTm4uZmlyc3Q9S3IsTm4uZmxvb3I9bmksTm4uZ2V0PWZ1bmN0aW9uKG4sdCxyKXtyZXR1cm4gbj1udWxsPT1uP3c6eXQobixEcih0KSx0K1wiXCIpLG49PT13P3I6bn0sTm4uZ3Q9c2UsTm4uZ3RlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4+PXR9LE5uLmhhcz1mdW5jdGlvbihuLHQpe2lmKG51bGw9PW4pcmV0dXJuIGZhbHNlO3ZhciByPW51LmNhbGwobix0KTtpZighciYmIVdyKHQpKXtpZih0PURyKHQpLG49MT09dC5sZW5ndGg/bjp5dChuLEV0KHQsMCwtMSkpLG51bGw9PW4pcmV0dXJuIGZhbHNlO3Q9WnIodCkscj1udS5jYWxsKG4sdCl9cmV0dXJuIHJ8fFNyKG4ubGVuZ3RoKSYmQ3IodCxuLmxlbmd0aCkmJihPbyhuKXx8cGUobikpfSxObi5pZGVudGl0eT1GZSxObi5pbmNsdWRlcz1lZSxObi5pbmRleE9mPVZyLE5uLmluUmFuZ2U9ZnVuY3Rpb24obix0LHIpe1xucmV0dXJuIHQ9K3R8fDAscj09PXc/KHI9dCx0PTApOnI9K3J8fDAsbj49eHUodCxyKSYmbjxidSh0LHIpfSxObi5pc0FyZ3VtZW50cz1wZSxObi5pc0FycmF5PU9vLE5uLmlzQm9vbGVhbj1mdW5jdGlvbihuKXtyZXR1cm4gdHJ1ZT09PW58fGZhbHNlPT09bnx8aChuKSYmcnUuY2FsbChuKT09TX0sTm4uaXNEYXRlPWZ1bmN0aW9uKG4pe3JldHVybiBoKG4pJiZydS5jYWxsKG4pPT1xfSxObi5pc0VsZW1lbnQ9ZnVuY3Rpb24obil7cmV0dXJuISFuJiYxPT09bi5ub2RlVHlwZSYmaChuKSYmIW1lKG4pfSxObi5pc0VtcHR5PWZ1bmN0aW9uKG4pe3JldHVybiBudWxsPT1uP3RydWU6RXIobikmJihPbyhuKXx8YmUobil8fHBlKG4pfHxoKG4pJiZ2ZShuLnNwbGljZSkpPyFuLmxlbmd0aDohem8obikubGVuZ3RofSxObi5pc0VxdWFsPWhlLE5uLmlzRXJyb3I9X2UsTm4uaXNGaW5pdGU9ZnVuY3Rpb24obil7cmV0dXJuIHR5cGVvZiBuPT1cIm51bWJlclwiJiZtdShuKX0sTm4uaXNGdW5jdGlvbj12ZSxObi5pc01hdGNoPWZ1bmN0aW9uKG4sdCxyLGUpe1xucmV0dXJuIHI9dHlwZW9mIHI9PVwiZnVuY3Rpb25cIj9CdChyLGUsMyk6dyxtdChuLEFyKHQpLHIpfSxObi5pc05hTj1mdW5jdGlvbihuKXtyZXR1cm4gZGUobikmJm4hPStufSxObi5pc05hdGl2ZT15ZSxObi5pc051bGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGw9PT1ufSxObi5pc051bWJlcj1kZSxObi5pc09iamVjdD1nZSxObi5pc1BsYWluT2JqZWN0PW1lLE5uLmlzUmVnRXhwPXdlLE5uLmlzU3RyaW5nPWJlLE5uLmlzVHlwZWRBcnJheT14ZSxObi5pc1VuZGVmaW5lZD1mdW5jdGlvbihuKXtyZXR1cm4gbj09PXd9LE5uLmtlYmFiQ2FzZT1LbyxObi5sYXN0PVpyLE5uLmxhc3RJbmRleE9mPWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1uP24ubGVuZ3RoOjA7aWYoIWUpcmV0dXJuLTE7dmFyIHU9ZTtpZih0eXBlb2Ygcj09XCJudW1iZXJcIil1PSgwPnI/YnUoZStyLDApOnh1KHJ8fDAsZS0xKSkrMTtlbHNlIGlmKHIpcmV0dXJuIHU9THQobix0LHRydWUpLTEsbj1uW3VdLCh0PT09dD90PT09bjpuIT09bik/dTotMTtcbmlmKHQhPT10KXJldHVybiBwKG4sdSx0cnVlKTtmb3IoO3UtLTspaWYoblt1XT09PXQpcmV0dXJuIHU7cmV0dXJuLTF9LE5uLmx0PUFlLE5uLmx0ZT1mdW5jdGlvbihuLHQpe3JldHVybiBuPD10fSxObi5tYXg9dGksTm4ubWluPXJpLE5uLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gWm4uXz1ldSx0aGlzfSxObi5ub29wPUxlLE5uLm5vdz1obyxObi5wYWQ9ZnVuY3Rpb24obix0LHIpe249dShuKSx0PSt0O3ZhciBlPW4ubGVuZ3RoO3JldHVybiBlPHQmJm11KHQpPyhlPSh0LWUpLzIsdD15dShlKSxlPXZ1KGUpLHI9cHIoXCJcIixlLHIpLHIuc2xpY2UoMCx0KStuK3IpOm59LE5uLnBhZExlZnQ9Vm8sTm4ucGFkUmlnaHQ9Wm8sTm4ucGFyc2VJbnQ9ZnVuY3Rpb24obix0LHIpe3JldHVybihyP1VyKG4sdCxyKTpudWxsPT10KT90PTA6dCYmKHQ9K3QpLG49V2UobiksanUobix0fHwoSW4udGVzdChuKT8xNjoxMCkpfSxObi5yYW5kb209ZnVuY3Rpb24obix0LHIpe3ImJlVyKG4sdCxyKSYmKHQ9cj13KTtcbnZhciBlPW51bGw9PW4sdT1udWxsPT10O3JldHVybiBudWxsPT1yJiYodSYmdHlwZW9mIG49PVwiYm9vbGVhblwiPyhyPW4sbj0xKTp0eXBlb2YgdD09XCJib29sZWFuXCImJihyPXQsdT10cnVlKSksZSYmdSYmKHQ9MSx1PWZhbHNlKSxuPStufHwwLHU/KHQ9bixuPTApOnQ9K3R8fDAscnx8biUxfHx0JTE/KHI9a3UoKSx4dShuK3IqKHQtbitmdShcIjFlLVwiKygocitcIlwiKS5sZW5ndGgtMSkpKSx0KSk6UnQobix0KX0sTm4ucmVkdWNlPWxvLE5uLnJlZHVjZVJpZ2h0PXNvLE5uLnJlcGVhdD1VZSxObi5yZXN1bHQ9ZnVuY3Rpb24obix0LHIpe3ZhciBlPW51bGw9PW4/dzpuW3RdO3JldHVybiBlPT09dyYmKG51bGw9PW58fFdyKHQsbil8fCh0PURyKHQpLG49MT09dC5sZW5ndGg/bjp5dChuLEV0KHQsMCwtMSkpLGU9bnVsbD09bj93Om5bWnIodCldKSxlPWU9PT13P3I6ZSksdmUoZSk/ZS5jYWxsKG4pOmV9LE5uLnJvdW5kPWVpLE5uLnJ1bkluQ29udGV4dD1tLE5uLnNpemU9ZnVuY3Rpb24obil7dmFyIHQ9bj9CdShuKTowO1xucmV0dXJuIFNyKHQpP3Q6em8obikubGVuZ3RofSxObi5zbmFrZUNhc2U9WW8sTm4uc29tZT1pZSxObi5zb3J0ZWRJbmRleD1adSxObi5zb3J0ZWRMYXN0SW5kZXg9WXUsTm4uc3RhcnRDYXNlPUdvLE5uLnN0YXJ0c1dpdGg9ZnVuY3Rpb24obix0LHIpe3JldHVybiBuPXUobikscj1udWxsPT1yPzA6eHUoMD5yPzA6K3J8fDAsbi5sZW5ndGgpLG4ubGFzdEluZGV4T2YodCxyKT09cn0sTm4uc3VtPWZ1bmN0aW9uKG4sdCxyKXtpZihyJiZVcihuLHQscikmJih0PXcpLHQ9d3IodCxyLDMpLDE9PXQubGVuZ3RoKXtuPU9vKG4pP246enIobikscj1uLmxlbmd0aDtmb3IodmFyIGU9MDtyLS07KWUrPSt0KG5bcl0pfHwwO249ZX1lbHNlIG49JHQobix0KTtyZXR1cm4gbn0sTm4udGVtcGxhdGU9ZnVuY3Rpb24obix0LHIpe3ZhciBlPU5uLnRlbXBsYXRlU2V0dGluZ3M7ciYmVXIobix0LHIpJiYodD1yPXcpLG49dShuKSx0PW50KHR0KHt9LHJ8fHQpLGUsUW4pLHI9bnQodHQoe30sdC5pbXBvcnRzKSxlLmltcG9ydHMsUW4pO1xudmFyIG8saSxmPXpvKHIpLGE9RnQocixmKSxjPTA7cj10LmludGVycG9sYXRlfHxDbjt2YXIgbD1cIl9fcCs9J1wiO3I9WmUoKHQuZXNjYXBlfHxDbikuc291cmNlK1wifFwiK3Iuc291cmNlK1wifFwiKyhyPT09Z24/am46Q24pLnNvdXJjZStcInxcIisodC5ldmFsdWF0ZXx8Q24pLnNvdXJjZStcInwkXCIsXCJnXCIpO3ZhciBwPVwic291cmNlVVJMXCJpbiB0P1wiLy8jIHNvdXJjZVVSTD1cIit0LnNvdXJjZVVSTCtcIlxcblwiOlwiXCI7aWYobi5yZXBsYWNlKHIsZnVuY3Rpb24odCxyLGUsdSxmLGEpe3JldHVybiBlfHwoZT11KSxsKz1uLnNsaWNlKGMsYSkucmVwbGFjZShVbixzKSxyJiYobz10cnVlLGwrPVwiJytfX2UoXCIrcitcIikrJ1wiKSxmJiYoaT10cnVlLGwrPVwiJztcIitmK1wiO1xcbl9fcCs9J1wiKSxlJiYobCs9XCInKygoX190PShcIitlK1wiKSk9PW51bGw/Jyc6X190KSsnXCIpLGM9YSt0Lmxlbmd0aCx0fSksbCs9XCInO1wiLCh0PXQudmFyaWFibGUpfHwobD1cIndpdGgob2JqKXtcIitsK1wifVwiKSxsPShpP2wucmVwbGFjZShmbixcIlwiKTpsKS5yZXBsYWNlKGFuLFwiJDFcIikucmVwbGFjZShjbixcIiQxO1wiKSxcbmw9XCJmdW5jdGlvbihcIisodHx8XCJvYmpcIikrXCIpe1wiKyh0P1wiXCI6XCJvYmp8fChvYmo9e30pO1wiKStcInZhciBfX3QsX19wPScnXCIrKG8/XCIsX19lPV8uZXNjYXBlXCI6XCJcIikrKGk/XCIsX19qPUFycmF5LnByb3RvdHlwZS5qb2luO2Z1bmN0aW9uIHByaW50KCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpfVwiOlwiO1wiKStsK1wicmV0dXJuIF9fcH1cIix0PUpvKGZ1bmN0aW9uKCl7cmV0dXJuIHFlKGYscCtcInJldHVybiBcIitsKS5hcHBseSh3LGEpfSksdC5zb3VyY2U9bCxfZSh0KSl0aHJvdyB0O3JldHVybiB0fSxObi50cmltPVdlLE5uLnRyaW1MZWZ0PWZ1bmN0aW9uKG4sdCxyKXt2YXIgZT1uO3JldHVybihuPXUobikpP24uc2xpY2UoKHI/VXIoZSx0LHIpOm51bGw9PXQpP2cobik6byhuLHQrXCJcIikpOm59LE5uLnRyaW1SaWdodD1mdW5jdGlvbihuLHQscil7dmFyIGU9bjtyZXR1cm4obj11KG4pKT8ocj9VcihlLHQscik6bnVsbD09dCk/bi5zbGljZSgwLHkobikrMSk6bi5zbGljZSgwLGkobix0K1wiXCIpKzEpOm47XG59LE5uLnRydW5jPWZ1bmN0aW9uKG4sdCxyKXtyJiZVcihuLHQscikmJih0PXcpO3ZhciBlPVU7aWYocj1XLG51bGwhPXQpaWYoZ2UodCkpe3ZhciBvPVwic2VwYXJhdG9yXCJpbiB0P3Quc2VwYXJhdG9yOm8sZT1cImxlbmd0aFwiaW4gdD8rdC5sZW5ndGh8fDA6ZTtyPVwib21pc3Npb25cImluIHQ/dSh0Lm9taXNzaW9uKTpyfWVsc2UgZT0rdHx8MDtpZihuPXUobiksZT49bi5sZW5ndGgpcmV0dXJuIG47aWYoZS09ci5sZW5ndGgsMT5lKXJldHVybiByO2lmKHQ9bi5zbGljZSgwLGUpLG51bGw9PW8pcmV0dXJuIHQrcjtpZih3ZShvKSl7aWYobi5zbGljZShlKS5zZWFyY2gobykpe3ZhciBpLGY9bi5zbGljZSgwLGUpO2ZvcihvLmdsb2JhbHx8KG89WmUoby5zb3VyY2UsKGtuLmV4ZWMobyl8fFwiXCIpK1wiZ1wiKSksby5sYXN0SW5kZXg9MDtuPW8uZXhlYyhmKTspaT1uLmluZGV4O3Q9dC5zbGljZSgwLG51bGw9PWk/ZTppKX19ZWxzZSBuLmluZGV4T2YobyxlKSE9ZSYmKG89dC5sYXN0SW5kZXhPZihvKSxcbi0xPG8mJih0PXQuc2xpY2UoMCxvKSkpO3JldHVybiB0K3J9LE5uLnVuZXNjYXBlPWZ1bmN0aW9uKG4pe3JldHVybihuPXUobikpJiZwbi50ZXN0KG4pP24ucmVwbGFjZShsbixkKTpufSxObi51bmlxdWVJZD1mdW5jdGlvbihuKXt2YXIgdD0rK3R1O3JldHVybiB1KG4pK3R9LE5uLndvcmRzPSRlLE5uLmFsbD10ZSxObi5hbnk9aWUsTm4uY29udGFpbnM9ZWUsTm4uZXE9aGUsTm4uZGV0ZWN0PXJvLE5uLmZvbGRsPWxvLE5uLmZvbGRyPXNvLE5uLmhlYWQ9S3IsTm4uaW5jbHVkZT1lZSxObi5pbmplY3Q9bG8sVGUoTm4sZnVuY3Rpb24oKXt2YXIgbj17fTtyZXR1cm4gX3QoTm4sZnVuY3Rpb24odCxyKXtObi5wcm90b3R5cGVbcl18fChuW3JdPXQpfSksbn0oKSxmYWxzZSksTm4uc2FtcGxlPW9lLE5uLnByb3RvdHlwZS5zYW1wbGU9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuX19jaGFpbl9ffHxudWxsIT1uP3RoaXMudGhydShmdW5jdGlvbih0KXtyZXR1cm4gb2UodCxuKX0pOm9lKHRoaXMudmFsdWUoKSk7XG59LE5uLlZFUlNJT049YixQbihcImJpbmQgYmluZEtleSBjdXJyeSBjdXJyeVJpZ2h0IHBhcnRpYWwgcGFydGlhbFJpZ2h0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKG4pe05uW25dLnBsYWNlaG9sZGVyPU5ufSksUG4oW1wiZHJvcFwiLFwidGFrZVwiXSxmdW5jdGlvbihuLHQpe3puLnByb3RvdHlwZVtuXT1mdW5jdGlvbihyKXt2YXIgZT10aGlzLl9fZmlsdGVyZWRfXztpZihlJiYhdClyZXR1cm4gbmV3IHpuKHRoaXMpO3I9bnVsbD09cj8xOmJ1KHl1KHIpfHwwLDApO3ZhciB1PXRoaXMuY2xvbmUoKTtyZXR1cm4gZT91Ll9fdGFrZUNvdW50X189eHUodS5fX3Rha2VDb3VudF9fLHIpOnUuX192aWV3c19fLnB1c2goe3NpemU6cix0eXBlOm4rKDA+dS5fX2Rpcl9fP1wiUmlnaHRcIjpcIlwiKX0pLHV9LHpuLnByb3RvdHlwZVtuK1wiUmlnaHRcIl09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmV2ZXJzZSgpW25dKHQpLnJldmVyc2UoKX19KSxQbihbXCJmaWx0ZXJcIixcIm1hcFwiLFwidGFrZVdoaWxlXCJdLGZ1bmN0aW9uKG4sdCl7XG52YXIgcj10KzEsZT1yIT1UO3puLnByb3RvdHlwZVtuXT1mdW5jdGlvbihuLHQpe3ZhciB1PXRoaXMuY2xvbmUoKTtyZXR1cm4gdS5fX2l0ZXJhdGVlc19fLnB1c2goe2l0ZXJhdGVlOndyKG4sdCwxKSx0eXBlOnJ9KSx1Ll9fZmlsdGVyZWRfXz11Ll9fZmlsdGVyZWRfX3x8ZSx1fX0pLFBuKFtcImZpcnN0XCIsXCJsYXN0XCJdLGZ1bmN0aW9uKG4sdCl7dmFyIHI9XCJ0YWtlXCIrKHQ/XCJSaWdodFwiOlwiXCIpO3puLnByb3RvdHlwZVtuXT1mdW5jdGlvbigpe3JldHVybiB0aGlzW3JdKDEpLnZhbHVlKClbMF19fSksUG4oW1wiaW5pdGlhbFwiLFwicmVzdFwiXSxmdW5jdGlvbihuLHQpe3ZhciByPVwiZHJvcFwiKyh0P1wiXCI6XCJSaWdodFwiKTt6bi5wcm90b3R5cGVbbl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18/bmV3IHpuKHRoaXMpOnRoaXNbcl0oMSl9fSksUG4oW1wicGx1Y2tcIixcIndoZXJlXCJdLGZ1bmN0aW9uKG4sdCl7dmFyIHI9dD9cImZpbHRlclwiOlwibWFwXCIsZT10P2J0OnplO3puLnByb3RvdHlwZVtuXT1mdW5jdGlvbihuKXtcbnJldHVybiB0aGlzW3JdKGUobikpfX0pLHpuLnByb3RvdHlwZS5jb21wYWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyKEZlKX0sem4ucHJvdG90eXBlLnJlamVjdD1mdW5jdGlvbihuLHQpe3JldHVybiBuPXdyKG4sdCwxKSx0aGlzLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hbih0KX0pfSx6bi5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24obix0KXtuPW51bGw9PW4/MDorbnx8MDt2YXIgcj10aGlzO3JldHVybiByLl9fZmlsdGVyZWRfXyYmKDA8bnx8MD50KT9uZXcgem4ocik6KDA+bj9yPXIudGFrZVJpZ2h0KC1uKTpuJiYocj1yLmRyb3AobikpLHQhPT13JiYodD0rdHx8MCxyPTA+dD9yLmRyb3BSaWdodCgtdCk6ci50YWtlKHQtbikpLHIpfSx6bi5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGU9ZnVuY3Rpb24obix0KXtyZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKG4sdCkucmV2ZXJzZSgpfSx6bi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRha2UoUnUpO1xufSxfdCh6bi5wcm90b3R5cGUsZnVuY3Rpb24obix0KXt2YXIgcj0vXig/OmZpbHRlcnxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QodCksZT0vXig/OmZpcnN0fGxhc3QpJC8udGVzdCh0KSx1PU5uW2U/XCJ0YWtlXCIrKFwibGFzdFwiPT10P1wiUmlnaHRcIjpcIlwiKTp0XTt1JiYoTm4ucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChuKXtyZXR1cm4gZSYmaT91KG4sMSlbMF06dS5hcHBseSh3LEpuKFtuXSxvKSl9dmFyIG89ZT9bMV06YXJndW1lbnRzLGk9dGhpcy5fX2NoYWluX18sZj10aGlzLl9fd3JhcHBlZF9fLGE9ISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxjPWYgaW5zdGFuY2VvZiB6bixsPW9bMF0scz1jfHxPbyhmKTtyZXR1cm4gcyYmciYmdHlwZW9mIGw9PVwiZnVuY3Rpb25cIiYmMSE9bC5sZW5ndGgmJihjPXM9ZmFsc2UpLGw9e2Z1bmM6bmUsYXJnczpbdF0sdGhpc0FyZzp3fSxhPWMmJiFhLGUmJiFpP2E/KGY9Zi5jbG9uZSgpLGYuX19hY3Rpb25zX18ucHVzaChsKSxuLmNhbGwoZikpOnUuY2FsbCh3LHRoaXMudmFsdWUoKSlbMF06IWUmJnM/KGY9YT9mOm5ldyB6bih0aGlzKSxcbmY9bi5hcHBseShmLG8pLGYuX19hY3Rpb25zX18ucHVzaChsKSxuZXcgTG4oZixpKSk6dGhpcy50aHJ1KHQpfSl9KSxQbihcImpvaW4gcG9wIHB1c2ggcmVwbGFjZSBzaGlmdCBzb3J0IHNwbGljZSBzcGxpdCB1bnNoaWZ0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKG4pe3ZhciB0PSgvXig/OnJlcGxhY2V8c3BsaXQpJC8udGVzdChuKT9IZTpKZSlbbl0scj0vXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3Qobik/XCJ0YXBcIjpcInRocnVcIixlPS9eKD86am9pbnxwb3B8cmVwbGFjZXxzaGlmdCkkLy50ZXN0KG4pO05uLnByb3RvdHlwZVtuXT1mdW5jdGlvbigpe3ZhciBuPWFyZ3VtZW50cztyZXR1cm4gZSYmIXRoaXMuX19jaGFpbl9fP3QuYXBwbHkodGhpcy52YWx1ZSgpLG4pOnRoaXNbcl0oZnVuY3Rpb24ocil7cmV0dXJuIHQuYXBwbHkocixuKX0pfX0pLF90KHpuLnByb3RvdHlwZSxmdW5jdGlvbihuLHQpe3ZhciByPU5uW3RdO2lmKHIpe3ZhciBlPXIubmFtZTsoV3VbZV18fChXdVtlXT1bXSkpLnB1c2goe1xubmFtZTp0LGZ1bmM6cn0pfX0pLFd1W3NyKHcsQSkubmFtZV09W3tuYW1lOlwid3JhcHBlclwiLGZ1bmM6d31dLHpuLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBuPW5ldyB6bih0aGlzLl9fd3JhcHBlZF9fKTtyZXR1cm4gbi5fX2FjdGlvbnNfXz1xbih0aGlzLl9fYWN0aW9uc19fKSxuLl9fZGlyX189dGhpcy5fX2Rpcl9fLG4uX19maWx0ZXJlZF9fPXRoaXMuX19maWx0ZXJlZF9fLG4uX19pdGVyYXRlZXNfXz1xbih0aGlzLl9faXRlcmF0ZWVzX18pLG4uX190YWtlQ291bnRfXz10aGlzLl9fdGFrZUNvdW50X18sbi5fX3ZpZXdzX189cW4odGhpcy5fX3ZpZXdzX18pLG59LHpuLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKCl7aWYodGhpcy5fX2ZpbHRlcmVkX18pe3ZhciBuPW5ldyB6bih0aGlzKTtuLl9fZGlyX189LTEsbi5fX2ZpbHRlcmVkX189dHJ1ZX1lbHNlIG49dGhpcy5jbG9uZSgpLG4uX19kaXJfXyo9LTE7cmV0dXJuIG59LHpuLnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe1xudmFyIG4sdD10aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCkscj10aGlzLl9fZGlyX18sZT1Pbyh0KSx1PTA+cixvPWU/dC5sZW5ndGg6MDtuPW87Zm9yKHZhciBpPXRoaXMuX192aWV3c19fLGY9MCxhPS0xLGM9aS5sZW5ndGg7KythPGM7KXt2YXIgbD1pW2FdLHM9bC5zaXplO3N3aXRjaChsLnR5cGUpe2Nhc2VcImRyb3BcIjpmKz1zO2JyZWFrO2Nhc2VcImRyb3BSaWdodFwiOm4tPXM7YnJlYWs7Y2FzZVwidGFrZVwiOm49eHUobixmK3MpO2JyZWFrO2Nhc2VcInRha2VSaWdodFwiOmY9YnUoZixuLXMpfX1pZihuPXtzdGFydDpmLGVuZDpufSxpPW4uc3RhcnQsZj1uLmVuZCxuPWYtaSxpPXU/ZjppLTEsZj10aGlzLl9faXRlcmF0ZWVzX18sYT1mLmxlbmd0aCxjPTAsbD14dShuLHRoaXMuX190YWtlQ291bnRfXyksIWV8fG88Rnx8bz09biYmbD09bilyZXR1cm4gVHQodSYmZT90LnJldmVyc2UoKTp0LHRoaXMuX19hY3Rpb25zX18pO2U9W107bjpmb3IoO24tLSYmYzxsOyl7Zm9yKGkrPXIsdT0tMSxvPXRbaV07Kyt1PGE7KXtcbnZhciBwPWZbdV0scz1wLnR5cGUscD1wLml0ZXJhdGVlKG8pO2lmKHM9PVQpbz1wO2Vsc2UgaWYoIXApe2lmKHM9PU4pY29udGludWUgbjticmVhayBufX1lW2MrK109b31yZXR1cm4gZX0sTm4ucHJvdG90eXBlLmNoYWluPWZ1bmN0aW9uKCl7cmV0dXJuIFFyKHRoaXMpfSxObi5wcm90b3R5cGUuY29tbWl0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMbih0aGlzLnZhbHVlKCksdGhpcy5fX2NoYWluX18pfSxObi5wcm90b3R5cGUuY29uY2F0PVF1LE5uLnByb3RvdHlwZS5wbGFudD1mdW5jdGlvbihuKXtmb3IodmFyIHQscj10aGlzO3IgaW5zdGFuY2VvZiBUbjspe3ZhciBlPU1yKHIpO3Q/dS5fX3dyYXBwZWRfXz1lOnQ9ZTt2YXIgdT1lLHI9ci5fX3dyYXBwZWRfX31yZXR1cm4gdS5fX3dyYXBwZWRfXz1uLHR9LE5uLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuKXtyZXR1cm4gciYmMD5yLl9fZGlyX18/bjpuLnJldmVyc2UoKX12YXIgdD10aGlzLl9fd3JhcHBlZF9fO1xuaWYodCBpbnN0YW5jZW9mIHpuKXt2YXIgcj10O3JldHVybiB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCYmKHI9bmV3IHpuKHRoaXMpKSxyPXIucmV2ZXJzZSgpLHIuX19hY3Rpb25zX18ucHVzaCh7ZnVuYzpuZSxhcmdzOltuXSx0aGlzQXJnOnd9KSxuZXcgTG4ocix0aGlzLl9fY2hhaW5fXyl9cmV0dXJuIHRoaXMudGhydShuKX0sTm4ucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWUoKStcIlwifSxObi5wcm90b3R5cGUucnVuPU5uLnByb3RvdHlwZS50b0pTT049Tm4ucHJvdG90eXBlLnZhbHVlT2Y9Tm4ucHJvdG90eXBlLnZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIFR0KHRoaXMuX193cmFwcGVkX18sdGhpcy5fX2FjdGlvbnNfXyl9LE5uLnByb3RvdHlwZS5jb2xsZWN0PU5uLnByb3RvdHlwZS5tYXAsTm4ucHJvdG90eXBlLmhlYWQ9Tm4ucHJvdG90eXBlLmZpcnN0LE5uLnByb3RvdHlwZS5zZWxlY3Q9Tm4ucHJvdG90eXBlLmZpbHRlcixObi5wcm90b3R5cGUudGFpbD1Obi5wcm90b3R5cGUucmVzdCxcbk5ufXZhciB3LGI9XCIzLjEwLjBcIix4PTEsQT0yLGo9NCxrPTgsST0xNixSPTMyLE89NjQsRT0xMjgsQz0yNTYsVT0zMCxXPVwiLi4uXCIsJD0xNTAsUz0xNixGPTIwMCxOPTEsVD0yLEw9XCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsej1cIl9fbG9kYXNoX3BsYWNlaG9sZGVyX19cIixCPVwiW29iamVjdCBBcmd1bWVudHNdXCIsRD1cIltvYmplY3QgQXJyYXldXCIsTT1cIltvYmplY3QgQm9vbGVhbl1cIixxPVwiW29iamVjdCBEYXRlXVwiLFA9XCJbb2JqZWN0IEVycm9yXVwiLEs9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFY9XCJbb2JqZWN0IE51bWJlcl1cIixaPVwiW29iamVjdCBPYmplY3RdXCIsWT1cIltvYmplY3QgUmVnRXhwXVwiLEc9XCJbb2JqZWN0IFN0cmluZ11cIixKPVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIixYPVwiW29iamVjdCBGbG9hdDMyQXJyYXldXCIsSD1cIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiLFE9XCJbb2JqZWN0IEludDhBcnJheV1cIixubj1cIltvYmplY3QgSW50MTZBcnJheV1cIix0bj1cIltvYmplY3QgSW50MzJBcnJheV1cIixybj1cIltvYmplY3QgVWludDhBcnJheV1cIixlbj1cIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsdW49XCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiLG9uPVwiW29iamVjdCBVaW50MzJBcnJheV1cIixmbj0vXFxiX19wXFwrPScnOy9nLGFuPS9cXGIoX19wXFwrPSknJ1xcKy9nLGNuPS8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSlcXCsnJzsvZyxsbj0vJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLHNuPS9bJjw+XCInYF0vZyxwbj1SZWdFeHAobG4uc291cmNlKSxobj1SZWdFeHAoc24uc291cmNlKSxfbj0vPCUtKFtcXHNcXFNdKz8pJT4vZyx2bj0vPCUoW1xcc1xcU10rPyklPi9nLGduPS88JT0oW1xcc1xcU10rPyklPi9nLHluPS9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcblxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sZG49L15cXHcqJC8sbW49L1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcblxcXFxdfFxcXFwuKSo/KVxcMilcXF0vZyx3bj0vXls6ISxdfFtcXFxcXiQuKis/KClbXFxde318XFwvXXwoXlswLTlhLWZBLUZucnR1dnhdKXwoW1xcblxcclxcdTIwMjhcXHUyMDI5XSkvZyxibj1SZWdFeHAod24uc291cmNlKSx4bj0vW1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyM10vZyxBbj0vXFxcXChcXFxcKT8vZyxqbj0vXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2csa249L1xcdyokLyxJbj0vXjBbeFhdLyxSbj0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvLE9uPS9eXFxkKyQvLEVuPS9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2csQ249LygkXikvLFVuPS9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZyxXbj1SZWdFeHAoXCJbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXSsoPz1bQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXVthLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZdKyl8W0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZV0/W2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl0rfFtBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdK3xbMC05XStcIixcImdcIiksJG49XCJBcnJheSBBcnJheUJ1ZmZlciBEYXRlIEVycm9yIEZsb2F0MzJBcnJheSBGbG9hdDY0QXJyYXkgRnVuY3Rpb24gSW50OEFycmF5IEludDE2QXJyYXkgSW50MzJBcnJheSBNYXRoIE51bWJlciBPYmplY3QgUmVnRXhwIFNldCBTdHJpbmcgXyBjbGVhclRpbWVvdXQgaXNGaW5pdGUgcGFyc2VGbG9hdCBwYXJzZUludCBzZXRUaW1lb3V0IFR5cGVFcnJvciBVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5IFdlYWtNYXBcIi5zcGxpdChcIiBcIiksU249e307XG5TbltYXT1TbltIXT1TbltRXT1Tbltubl09U25bdG5dPVNuW3JuXT1Tbltlbl09U25bdW5dPVNuW29uXT10cnVlLFNuW0JdPVNuW0RdPVNuW0pdPVNuW01dPVNuW3FdPVNuW1BdPVNuW0tdPVNuW1wiW29iamVjdCBNYXBdXCJdPVNuW1ZdPVNuW1pdPVNuW1ldPVNuW1wiW29iamVjdCBTZXRdXCJdPVNuW0ddPVNuW1wiW29iamVjdCBXZWFrTWFwXVwiXT1mYWxzZTt2YXIgRm49e307Rm5bQl09Rm5bRF09Rm5bSl09Rm5bTV09Rm5bcV09Rm5bWF09Rm5bSF09Rm5bUV09Rm5bbm5dPUZuW3RuXT1GbltWXT1GbltaXT1GbltZXT1GbltHXT1Gbltybl09Rm5bZW5dPUZuW3VuXT1Gbltvbl09dHJ1ZSxGbltQXT1GbltLXT1GbltcIltvYmplY3QgTWFwXVwiXT1GbltcIltvYmplY3QgU2V0XVwiXT1GbltcIltvYmplY3QgV2Vha01hcF1cIl09ZmFsc2U7dmFyIE5uPXtcIlxceGMwXCI6XCJBXCIsXCJcXHhjMVwiOlwiQVwiLFwiXFx4YzJcIjpcIkFcIixcIlxceGMzXCI6XCJBXCIsXCJcXHhjNFwiOlwiQVwiLFwiXFx4YzVcIjpcIkFcIixcIlxceGUwXCI6XCJhXCIsXCJcXHhlMVwiOlwiYVwiLFwiXFx4ZTJcIjpcImFcIixcblwiXFx4ZTNcIjpcImFcIixcIlxceGU0XCI6XCJhXCIsXCJcXHhlNVwiOlwiYVwiLFwiXFx4YzdcIjpcIkNcIixcIlxceGU3XCI6XCJjXCIsXCJcXHhkMFwiOlwiRFwiLFwiXFx4ZjBcIjpcImRcIixcIlxceGM4XCI6XCJFXCIsXCJcXHhjOVwiOlwiRVwiLFwiXFx4Y2FcIjpcIkVcIixcIlxceGNiXCI6XCJFXCIsXCJcXHhlOFwiOlwiZVwiLFwiXFx4ZTlcIjpcImVcIixcIlxceGVhXCI6XCJlXCIsXCJcXHhlYlwiOlwiZVwiLFwiXFx4Y2NcIjpcIklcIixcIlxceGNkXCI6XCJJXCIsXCJcXHhjZVwiOlwiSVwiLFwiXFx4Y2ZcIjpcIklcIixcIlxceGVjXCI6XCJpXCIsXCJcXHhlZFwiOlwiaVwiLFwiXFx4ZWVcIjpcImlcIixcIlxceGVmXCI6XCJpXCIsXCJcXHhkMVwiOlwiTlwiLFwiXFx4ZjFcIjpcIm5cIixcIlxceGQyXCI6XCJPXCIsXCJcXHhkM1wiOlwiT1wiLFwiXFx4ZDRcIjpcIk9cIixcIlxceGQ1XCI6XCJPXCIsXCJcXHhkNlwiOlwiT1wiLFwiXFx4ZDhcIjpcIk9cIixcIlxceGYyXCI6XCJvXCIsXCJcXHhmM1wiOlwib1wiLFwiXFx4ZjRcIjpcIm9cIixcIlxceGY1XCI6XCJvXCIsXCJcXHhmNlwiOlwib1wiLFwiXFx4ZjhcIjpcIm9cIixcIlxceGQ5XCI6XCJVXCIsXCJcXHhkYVwiOlwiVVwiLFwiXFx4ZGJcIjpcIlVcIixcIlxceGRjXCI6XCJVXCIsXCJcXHhmOVwiOlwidVwiLFwiXFx4ZmFcIjpcInVcIixcIlxceGZiXCI6XCJ1XCIsXCJcXHhmY1wiOlwidVwiLFwiXFx4ZGRcIjpcIllcIixcblwiXFx4ZmRcIjpcInlcIixcIlxceGZmXCI6XCJ5XCIsXCJcXHhjNlwiOlwiQWVcIixcIlxceGU2XCI6XCJhZVwiLFwiXFx4ZGVcIjpcIlRoXCIsXCJcXHhmZVwiOlwidGhcIixcIlxceGRmXCI6XCJzc1wifSxUbj17XCImXCI6XCImYW1wO1wiLFwiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLCdcIic6XCImcXVvdDtcIixcIidcIjpcIiYjMzk7XCIsXCJgXCI6XCImIzk2O1wifSxMbj17XCImYW1wO1wiOlwiJlwiLFwiJmx0O1wiOlwiPFwiLFwiJmd0O1wiOlwiPlwiLFwiJnF1b3Q7XCI6J1wiJyxcIiYjMzk7XCI6XCInXCIsXCImIzk2O1wiOlwiYFwifSx6bj17XCJmdW5jdGlvblwiOnRydWUsb2JqZWN0OnRydWV9LEJuPXswOlwieDMwXCIsMTpcIngzMVwiLDI6XCJ4MzJcIiwzOlwieDMzXCIsNDpcIngzNFwiLDU6XCJ4MzVcIiw2OlwieDM2XCIsNzpcIngzN1wiLDg6XCJ4MzhcIiw5OlwieDM5XCIsQTpcIng0MVwiLEI6XCJ4NDJcIixDOlwieDQzXCIsRDpcIng0NFwiLEU6XCJ4NDVcIixGOlwieDQ2XCIsYTpcIng2MVwiLGI6XCJ4NjJcIixjOlwieDYzXCIsZDpcIng2NFwiLGU6XCJ4NjVcIixmOlwieDY2XCIsbjpcIng2ZVwiLHI6XCJ4NzJcIix0OlwieDc0XCIsdTpcIng3NVwiLHY6XCJ4NzZcIix4OlwieDc4XCJ9LERuPXtcIlxcXFxcIjpcIlxcXFxcIixcblwiJ1wiOlwiJ1wiLFwiXFxuXCI6XCJuXCIsXCJcXHJcIjpcInJcIixcIlxcdTIwMjhcIjpcInUyMDI4XCIsXCJcXHUyMDI5XCI6XCJ1MjAyOVwifSxNbj16blt0eXBlb2YgZXhwb3J0c10mJmV4cG9ydHMmJiFleHBvcnRzLm5vZGVUeXBlJiZleHBvcnRzLHFuPXpuW3R5cGVvZiBtb2R1bGVdJiZtb2R1bGUmJiFtb2R1bGUubm9kZVR5cGUmJm1vZHVsZSxQbj16blt0eXBlb2Ygc2VsZl0mJnNlbGYmJnNlbGYuT2JqZWN0JiZzZWxmLEtuPXpuW3R5cGVvZiB3aW5kb3ddJiZ3aW5kb3cmJndpbmRvdy5PYmplY3QmJndpbmRvdyxWbj1xbiYmcW4uZXhwb3J0cz09PU1uJiZNbixabj1NbiYmcW4mJnR5cGVvZiBnbG9iYWw9PVwib2JqZWN0XCImJmdsb2JhbCYmZ2xvYmFsLk9iamVjdCYmZ2xvYmFsfHxLbiE9PSh0aGlzJiZ0aGlzLndpbmRvdykmJktufHxQbnx8dGhpcyxZbj1tKCk7dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZGVmaW5lLmFtZD09XCJvYmplY3RcIiYmZGVmaW5lLmFtZD8oWm4uXz1ZbiwgZGVmaW5lKGZ1bmN0aW9uKCl7XG5yZXR1cm4gWW59KSk6TW4mJnFuP1ZuPyhxbi5leHBvcnRzPVluKS5fPVluOk1uLl89WW46Wm4uXz1Zbn0pLmNhbGwodGhpcyk7XG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBfICE9IFwidW5kZWZpbmVkXCIgPyBfIDogd2luZG93Ll8pO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG47IHJlcXVpcmUoXCIvVXNlcnMvc2FtZWxpZS9Eb2N1bWVudHMvcmFkL2dhbGxlcnktdml6L2NsaWVudC9hc3NldHMvdmVuZG9yL2JhY2tib25lL2JhY2tib25lLmpzXCIpO1xuOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLy8gTWFyaW9uZXR0ZUpTIChCYWNrYm9uZS5NYXJpb25ldHRlKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdjIuNC4yXG4vL1xuLy8gQ29weXJpZ2h0IChjKTIwMTUgRGVyaWNrIEJhaWxleSwgTXV0ZWQgU29sdXRpb25zLCBMTEMuXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZVxuLy9cbi8vIGh0dHA6Ly9tYXJpb25ldHRlanMuY29tXG5cblxuLyohXG4gKiBJbmNsdWRlcyBCYWJ5U2l0dGVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLmJhYnlzaXR0ZXIvXG4gKlxuICogSW5jbHVkZXMgV3JlcXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpb25ldHRlanMvYmFja2JvbmUud3JlcXIvXG4gKi9cblxuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydiYWNrYm9uZScsICd1bmRlcnNjb3JlJ10sIGZ1bmN0aW9uKEJhY2tib25lLCBfKSB7XG4gICAgICByZXR1cm4gKHJvb3QuTWFyaW9uZXR0ZSA9IHJvb3QuTW4gPSBmYWN0b3J5KHJvb3QsIEJhY2tib25lLCBfKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIEJhY2tib25lID0gX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fKCdiYWNrYm9uZScpO1xuICAgIHZhciBfID0gX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fKCd1bmRlcnNjb3JlJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QsIEJhY2tib25lLCBfKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk1hcmlvbmV0dGUgPSByb290Lk1uID0gZmFjdG9yeShyb290LCByb290LkJhY2tib25lLCByb290Ll8pO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24ocm9vdCwgQmFja2JvbmUsIF8pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIC8vIEJhY2tib25lLkJhYnlTaXR0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB2MC4xLjdcbiAgLy9cbiAgLy8gQ29weXJpZ2h0IChjKTIwMTUgRGVyaWNrIEJhaWxleSwgTXV0ZWQgU29sdXRpb25zLCBMTEMuXG4gIC8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlXG4gIC8vXG4gIC8vIGh0dHA6Ly9naXRodWIuY29tL21hcmlvbmV0dGVqcy9iYWNrYm9uZS5iYWJ5c2l0dGVyXG4gIChmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwcmV2aW91c0NoaWxkVmlld0NvbnRhaW5lciA9IEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lcjtcbiAgICAvLyBCYWJ5U2l0dGVyLkNoaWxkVmlld0NvbnRhaW5lclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBQcm92aWRlIGEgY29udGFpbmVyIHRvIHN0b3JlLCByZXRyaWV2ZSBhbmRcbiAgICAvLyBzaHV0IGRvd24gY2hpbGQgdmlld3MuXG4gICAgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgICAgIC8vIENvbnRhaW5lciBDb25zdHJ1Y3RvclxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICB2YXIgQ29udGFpbmVyID0gZnVuY3Rpb24odmlld3MpIHtcbiAgICAgICAgdGhpcy5fdmlld3MgPSB7fTtcbiAgICAgICAgdGhpcy5faW5kZXhCeU1vZGVsID0ge307XG4gICAgICAgIHRoaXMuX2luZGV4QnlDdXN0b20gPSB7fTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgIF8uZWFjaCh2aWV3cywgdGhpcy5hZGQsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIC8vIENvbnRhaW5lciBNZXRob2RzXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgXy5leHRlbmQoQ29udGFpbmVyLnByb3RvdHlwZSwge1xuICAgICAgICAvLyBBZGQgYSB2aWV3IHRvIHRoaXMgY29udGFpbmVyLiBTdG9yZXMgdGhlIHZpZXdcbiAgICAgICAgLy8gYnkgYGNpZGAgYW5kIG1ha2VzIGl0IHNlYXJjaGFibGUgYnkgdGhlIG1vZGVsXG4gICAgICAgIC8vIGNpZCAoYW5kIG1vZGVsIGl0c2VsZikuIE9wdGlvbmFsbHkgc3BlY2lmeVxuICAgICAgICAvLyBhIGN1c3RvbSBrZXkgdG8gc3RvcmUgYW4gcmV0cmlldmUgdGhlIHZpZXcuXG4gICAgICAgIGFkZDogZnVuY3Rpb24odmlldywgY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgdmlld0NpZCA9IHZpZXcuY2lkO1xuICAgICAgICAgIC8vIHN0b3JlIHRoZSB2aWV3XG4gICAgICAgICAgdGhpcy5fdmlld3Nbdmlld0NpZF0gPSB2aWV3O1xuICAgICAgICAgIC8vIGluZGV4IGl0IGJ5IG1vZGVsXG4gICAgICAgICAgaWYgKHZpZXcubW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4QnlNb2RlbFt2aWV3Lm1vZGVsLmNpZF0gPSB2aWV3Q2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbmRleCBieSBjdXN0b21cbiAgICAgICAgICBpZiAoY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4QnlDdXN0b21bY3VzdG9tSW5kZXhdID0gdmlld0NpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZpbmQgYSB2aWV3IGJ5IHRoZSBtb2RlbCB0aGF0IHdhcyBhdHRhY2hlZCB0b1xuICAgICAgICAvLyBpdC4gVXNlcyB0aGUgbW9kZWwncyBgY2lkYCB0byBmaW5kIGl0LlxuICAgICAgICBmaW5kQnlNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlNb2RlbENpZChtb2RlbC5jaWQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBGaW5kIGEgdmlldyBieSB0aGUgYGNpZGAgb2YgdGhlIG1vZGVsIHRoYXQgd2FzIGF0dGFjaGVkIHRvXG4gICAgICAgIC8vIGl0LiBVc2VzIHRoZSBtb2RlbCdzIGBjaWRgIHRvIGZpbmQgdGhlIHZpZXcgYGNpZGAgYW5kXG4gICAgICAgIC8vIHJldHJpZXZlIHRoZSB2aWV3IHVzaW5nIGl0LlxuICAgICAgICBmaW5kQnlNb2RlbENpZDogZnVuY3Rpb24obW9kZWxDaWQpIHtcbiAgICAgICAgICB2YXIgdmlld0NpZCA9IHRoaXMuX2luZGV4QnlNb2RlbFttb2RlbENpZF07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJ5Q2lkKHZpZXdDaWQpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBGaW5kIGEgdmlldyBieSBhIGN1c3RvbSBpbmRleGVyLlxuICAgICAgICBmaW5kQnlDdXN0b206IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgdmFyIHZpZXdDaWQgPSB0aGlzLl9pbmRleEJ5Q3VzdG9tW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlDaWQodmlld0NpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZpbmQgYnkgaW5kZXguIFRoaXMgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYVxuICAgICAgICAvLyBzdGFibGUgaW5kZXguXG4gICAgICAgIGZpbmRCeUluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHJldHVybiBfLnZhbHVlcyh0aGlzLl92aWV3cylbaW5kZXhdO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXRyaWV2ZSBhIHZpZXcgYnkgaXRzIGBjaWRgIGRpcmVjdGx5XG4gICAgICAgIGZpbmRCeUNpZDogZnVuY3Rpb24oY2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdzW2NpZF07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBhIHZpZXdcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgdmFyIHZpZXdDaWQgPSB2aWV3LmNpZDtcbiAgICAgICAgICAvLyBkZWxldGUgbW9kZWwgaW5kZXhcbiAgICAgICAgICBpZiAodmlldy5tb2RlbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4QnlNb2RlbFt2aWV3Lm1vZGVsLmNpZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRlbGV0ZSBjdXN0b20gaW5kZXhcbiAgICAgICAgICBfLmFueSh0aGlzLl9pbmRleEJ5Q3VzdG9tLCBmdW5jdGlvbihjaWQsIGtleSkge1xuICAgICAgICAgICAgaWYgKGNpZCA9PT0gdmlld0NpZCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faW5kZXhCeUN1c3RvbVtrZXldO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIHZpZXcgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3ZpZXdzW3ZpZXdDaWRdO1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbGVuZ3RoXG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENhbGwgYSBtZXRob2Qgb24gZXZlcnkgdmlldyBpbiB0aGUgY29udGFpbmVyLFxuICAgICAgICAvLyBwYXNzaW5nIHBhcmFtZXRlcnMgdG8gdGhlIGNhbGwgbWV0aG9kIG9uZSBhdCBhXG4gICAgICAgIC8vIHRpbWUsIGxpa2UgYGZ1bmN0aW9uLmNhbGxgLlxuICAgICAgICBjYWxsOiBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5KG1ldGhvZCwgXy50YWlsKGFyZ3VtZW50cykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBcHBseSBhIG1ldGhvZCBvbiBldmVyeSB2aWV3IGluIHRoZSBjb250YWluZXIsXG4gICAgICAgIC8vIHBhc3NpbmcgcGFyYW1ldGVycyB0byB0aGUgY2FsbCBtZXRob2Qgb25lIGF0IGFcbiAgICAgICAgLy8gdGltZSwgbGlrZSBgZnVuY3Rpb24uYXBwbHlgLlxuICAgICAgICBhcHBseTogZnVuY3Rpb24obWV0aG9kLCBhcmdzKSB7XG4gICAgICAgICAgXy5lYWNoKHRoaXMuX3ZpZXdzLCBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpZXdbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgdmlld1ttZXRob2RdLmFwcGx5KHZpZXcsIGFyZ3MgfHwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBVcGRhdGUgdGhlIGAubGVuZ3RoYCBhdHRyaWJ1dGUgb24gdGhpcyBjb250YWluZXJcbiAgICAgICAgX3VwZGF0ZUxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSBfLnNpemUodGhpcy5fdmlld3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJvcnJvd2luZyB0aGlzIGNvZGUgZnJvbSBCYWNrYm9uZS5Db2xsZWN0aW9uOlxuICAgICAgLy8gaHR0cDovL2JhY2tib25lanMub3JnL2RvY3MvYmFja2JvbmUuaHRtbCNzZWN0aW9uLTEwNlxuICAgICAgLy9cbiAgICAgIC8vIE1peCBpbiBtZXRob2RzIGZyb20gVW5kZXJzY29yZSwgZm9yIGl0ZXJhdGlvbiwgYW5kIG90aGVyXG4gICAgICAvLyBjb2xsZWN0aW9uIHJlbGF0ZWQgZmVhdHVyZXMuXG4gICAgICB2YXIgbWV0aG9kcyA9IFsgXCJmb3JFYWNoXCIsIFwiZWFjaFwiLCBcIm1hcFwiLCBcImZpbmRcIiwgXCJkZXRlY3RcIiwgXCJmaWx0ZXJcIiwgXCJzZWxlY3RcIiwgXCJyZWplY3RcIiwgXCJldmVyeVwiLCBcImFsbFwiLCBcInNvbWVcIiwgXCJhbnlcIiwgXCJpbmNsdWRlXCIsIFwiY29udGFpbnNcIiwgXCJpbnZva2VcIiwgXCJ0b0FycmF5XCIsIFwiZmlyc3RcIiwgXCJpbml0aWFsXCIsIFwicmVzdFwiLCBcImxhc3RcIiwgXCJ3aXRob3V0XCIsIFwiaXNFbXB0eVwiLCBcInBsdWNrXCIsIFwicmVkdWNlXCIgXTtcbiAgICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgQ29udGFpbmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZpZXdzID0gXy52YWx1ZXModGhpcy5fdmlld3MpO1xuICAgICAgICAgIHZhciBhcmdzID0gWyB2aWV3cyBdLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgcmV0dXJuIF9bbWV0aG9kXS5hcHBseShfLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgLy8gcmV0dXJuIHRoZSBwdWJsaWMgQVBJXG4gICAgICByZXR1cm4gQ29udGFpbmVyO1xuICAgIH0oQmFja2JvbmUsIF8pO1xuICAgIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lci5WRVJTSU9OID0gXCIwLjEuN1wiO1xuICAgIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIgPSBwcmV2aW91c0NoaWxkVmlld0NvbnRhaW5lcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lcjtcbiAgfSkoQmFja2JvbmUsIF8pO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIC8vIEJhY2tib25lLldyZXFyIChCYWNrYm9uZS5NYXJpb25ldHRlKVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHYxLjMuM1xuICAvL1xuICAvLyBDb3B5cmlnaHQgKGMpMjAxNSBEZXJpY2sgQmFpbGV5LCBNdXRlZCBTb2x1dGlvbnMsIExMQy5cbiAgLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAgLy9cbiAgLy8gaHR0cDovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLndyZXFyXG4gIChmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwcmV2aW91c1dyZXFyID0gQmFja2JvbmUuV3JlcXI7XG4gICAgdmFyIFdyZXFyID0gQmFja2JvbmUuV3JlcXIgPSB7fTtcbiAgICBCYWNrYm9uZS5XcmVxci5WRVJTSU9OID0gXCIxLjMuM1wiO1xuICAgIEJhY2tib25lLldyZXFyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLldyZXFyID0gcHJldmlvdXNXcmVxcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSGFuZGxlcnNcbiAgICAvLyAtLS0tLS0tLVxuICAgIC8vIEEgcmVnaXN0cnkgb2YgZnVuY3Rpb25zIHRvIGNhbGwsIGdpdmVuIGEgbmFtZVxuICAgIFdyZXFyLkhhbmRsZXJzID0gZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLy8gQ29uc3RydWN0b3JcbiAgICAgIC8vIC0tLS0tLS0tLS0tXG4gICAgICB2YXIgSGFuZGxlcnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3dyZXFySGFuZGxlcnMgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmluaXRpYWxpemUpKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgSGFuZGxlcnMuZXh0ZW5kID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kO1xuICAgICAgLy8gSW5zdGFuY2UgTWVtYmVyc1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgXy5leHRlbmQoSGFuZGxlcnMucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgICAgICAgLy8gQWRkIG11bHRpcGxlIGhhbmRsZXJzIHVzaW5nIGFuIG9iamVjdCBsaXRlcmFsIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgc2V0SGFuZGxlcnM6IGZ1bmN0aW9uKGhhbmRsZXJzKSB7XG4gICAgICAgICAgXy5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChoYW5kbGVyKSAmJiAhXy5pc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSBoYW5kbGVyLmNvbnRleHQ7XG4gICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRIYW5kbGVyKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbmFtZSwgd2l0aCBhblxuICAgICAgICAvLyBvcHRpb25hbCBjb250ZXh0IHRvIHJ1biB0aGUgaGFuZGxlciB3aXRoaW5cbiAgICAgICAgc2V0SGFuZGxlcjogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogaGFuZGxlcixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX3dyZXFySGFuZGxlcnNbbmFtZV0gPSBjb25maWc7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFwiaGFuZGxlcjphZGRcIiwgbmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZFxuICAgICAgICBoYXNIYW5kbGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fd3JlcXJIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBoYW5kbGVyIGZvclxuICAgICAgICAvLyB0aGUgc3BlY2lmaWVkIG5hbWUuIFRocm93cyBhbiBleGNlcHRpb24gaWZcbiAgICAgICAgLy8gbm8gaGFuZGxlciBpcyBmb3VuZC5cbiAgICAgICAgZ2V0SGFuZGxlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLl93cmVxckhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuY2FsbGJhY2suYXBwbHkoY29uZmlnLmNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGEgaGFuZGxlciBmb3IgdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICAgIHJlbW92ZUhhbmRsZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fd3JlcXJIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBoYW5kbGVycyBmcm9tIHRoaXMgcmVnaXN0cnlcbiAgICAgICAgcmVtb3ZlQWxsSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX3dyZXFySGFuZGxlcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSGFuZGxlcnM7XG4gICAgfShCYWNrYm9uZSwgXyk7XG4gICAgLy8gV3JlcXIuQ29tbWFuZFN0b3JhZ2VcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gU3RvcmUgYW5kIHJldHJpZXZlIGNvbW1hbmRzIGZvciBleGVjdXRpb24uXG4gICAgV3JlcXIuQ29tbWFuZFN0b3JhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgIHZhciBDb21tYW5kU3RvcmFnZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fY29tbWFuZHMgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmluaXRpYWxpemUpKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gSW5zdGFuY2UgbWV0aG9kc1xuICAgICAgXy5leHRlbmQoQ29tbWFuZFN0b3JhZ2UucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgICAgICAgLy8gR2V0IGFuIG9iamVjdCBsaXRlcmFsIGJ5IGNvbW1hbmQgbmFtZSwgdGhhdCBjb250YWluc1xuICAgICAgICAvLyB0aGUgYGNvbW1hbmROYW1lYCBhbmQgdGhlIGBpbnN0YW5jZXNgIG9mIGFsbCBjb21tYW5kc1xuICAgICAgICAvLyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICBnZXRDb21tYW5kczogZnVuY3Rpb24oY29tbWFuZE5hbWUpIHtcbiAgICAgICAgICB2YXIgY29tbWFuZHMgPSB0aGlzLl9jb21tYW5kc1tjb21tYW5kTmFtZV07XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBpdCwgc28gYWRkIGl0XG4gICAgICAgICAgaWYgKCFjb21tYW5kcykge1xuICAgICAgICAgICAgLy8gYnVpbGQgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGNvbW1hbmRzID0ge1xuICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kTmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGl0XG4gICAgICAgICAgICB0aGlzLl9jb21tYW5kc1tjb21tYW5kTmFtZV0gPSBjb21tYW5kcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBZGQgYSBjb21tYW5kIGJ5IG5hbWUsIHRvIHRoZSBzdG9yYWdlIGFuZCBzdG9yZSB0aGVcbiAgICAgICAgLy8gYXJncyBmb3IgdGhlIGNvbW1hbmRcbiAgICAgICAgYWRkQ29tbWFuZDogZnVuY3Rpb24oY29tbWFuZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuZ2V0Q29tbWFuZHMoY29tbWFuZE5hbWUpO1xuICAgICAgICAgIGNvbW1hbmQuaW5zdGFuY2VzLnB1c2goYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENsZWFyIGFsbCBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIGBjb21tYW5kTmFtZWBcbiAgICAgICAgY2xlYXJDb21tYW5kczogZnVuY3Rpb24oY29tbWFuZE5hbWUpIHtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuZ2V0Q29tbWFuZHMoY29tbWFuZE5hbWUpO1xuICAgICAgICAgIGNvbW1hbmQuaW5zdGFuY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbW1hbmRTdG9yYWdlO1xuICAgIH0oKTtcbiAgICAvLyBXcmVxci5Db21tYW5kc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBBIHNpbXBsZSBjb21tYW5kIHBhdHRlcm4gaW1wbGVtZW50YXRpb24uIFJlZ2lzdGVyIGEgY29tbWFuZFxuICAgIC8vIGhhbmRsZXIgYW5kIGV4ZWN1dGUgaXQuXG4gICAgV3JlcXIuQ29tbWFuZHMgPSBmdW5jdGlvbihXcmVxciwgXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICByZXR1cm4gV3JlcXIuSGFuZGxlcnMuZXh0ZW5kKHtcbiAgICAgICAgLy8gZGVmYXVsdCBzdG9yYWdlIHR5cGVcbiAgICAgICAgc3RvcmFnZVR5cGU6IFdyZXFyLkNvbW1hbmRTdG9yYWdlLFxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVN0b3JhZ2UodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB0aGlzLm9uKFwiaGFuZGxlcjphZGRcIiwgdGhpcy5fZXhlY3V0ZUNvbW1hbmRzLCB0aGlzKTtcbiAgICAgICAgICBXcmVxci5IYW5kbGVycy5wcm90b3R5cGUuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRXhlY3V0ZSBhIG5hbWVkIGNvbW1hbmQgd2l0aCB0aGUgc3VwcGxpZWQgYXJnc1xuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB2YXIgYXJncyA9IF8ucmVzdChhcmd1bWVudHMpO1xuICAgICAgICAgIGlmICh0aGlzLmhhc0hhbmRsZXIobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0SGFuZGxlcihuYW1lKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZENvbW1hbmQobmFtZSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGJ1bGsgZXhlY3V0aW9uIG9mIHN0b3JlZCBjb21tYW5kc1xuICAgICAgICBfZXhlY3V0ZUNvbW1hbmRzOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLnN0b3JhZ2UuZ2V0Q29tbWFuZHMobmFtZSk7XG4gICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFuZCBleGVjdXRlIGFsbCB0aGUgc3RvcmVkIGNvbW1hbmQgaW5zdGFuY2VzXG4gICAgICAgICAgXy5lYWNoKGNvbW1hbmQuaW5zdGFuY2VzLCBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc3RvcmFnZS5jbGVhckNvbW1hbmRzKG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gaW5pdGlhbGl6ZSBzdG9yYWdlIGVpdGhlciBmcm9tIHRoZSB0eXBlJ3NcbiAgICAgICAgLy8gYHN0b3JhZ2VUeXBlYCBvciB0aGUgaW5zdGFuY2UgYG9wdGlvbnMuc3RvcmFnZVR5cGVgLlxuICAgICAgICBfaW5pdGlhbGl6ZVN0b3JhZ2U6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgc3RvcmFnZTtcbiAgICAgICAgICB2YXIgU3RvcmFnZVR5cGUgPSBvcHRpb25zLnN0b3JhZ2VUeXBlIHx8IHRoaXMuc3RvcmFnZVR5cGU7XG4gICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihTdG9yYWdlVHlwZSkpIHtcbiAgICAgICAgICAgIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZVR5cGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RvcmFnZSA9IFN0b3JhZ2VUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KFdyZXFyLCBfKTtcbiAgICAvLyBXcmVxci5SZXF1ZXN0UmVzcG9uc2VcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIEEgc2ltcGxlIHJlcXVlc3QvcmVzcG9uc2UgaW1wbGVtZW50YXRpb24uIFJlZ2lzdGVyIGFcbiAgICAvLyByZXF1ZXN0IGhhbmRsZXIsIGFuZCByZXR1cm4gYSByZXNwb25zZSBmcm9tIGl0XG4gICAgV3JlcXIuUmVxdWVzdFJlc3BvbnNlID0gZnVuY3Rpb24oV3JlcXIsIF8pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgcmV0dXJuIFdyZXFyLkhhbmRsZXJzLmV4dGVuZCh7XG4gICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNIYW5kbGVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIYW5kbGVyKG5hbWUpLmFwcGx5KHRoaXMsIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0oV3JlcXIsIF8pO1xuICAgIC8vIEV2ZW50IEFnZ3JlZ2F0b3JcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQSBwdWItc3ViIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY291cGxlIHZhcmlvdXMgcGFydHNcbiAgICAvLyBvZiBhbiBhcHBsaWNhdGlvbiB0aHJvdWdoIGV2ZW50LWRyaXZlbiBhcmNoaXRlY3R1cmUuXG4gICAgV3JlcXIuRXZlbnRBZ2dyZWdhdG9yID0gZnVuY3Rpb24oQmFja2JvbmUsIF8pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIEVBID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIC8vIENvcHkgdGhlIGBleHRlbmRgIGZ1bmN0aW9uIHVzZWQgYnkgQmFja2JvbmUncyBjbGFzc2VzXG4gICAgICBFQS5leHRlbmQgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQ7XG4gICAgICAvLyBDb3B5IHRoZSBiYXNpYyBCYWNrYm9uZS5FdmVudHMgb24gdG8gdGhlIGV2ZW50IGFnZ3JlZ2F0b3JcbiAgICAgIF8uZXh0ZW5kKEVBLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzKTtcbiAgICAgIHJldHVybiBFQTtcbiAgICB9KEJhY2tib25lLCBfKTtcbiAgICAvLyBXcmVxci5DaGFubmVsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIEFuIG9iamVjdCB0aGF0IHdyYXBzIHRoZSB0aHJlZSBtZXNzYWdpbmcgc3lzdGVtczpcbiAgICAvLyBFdmVudEFnZ3JlZ2F0b3IsIFJlcXVlc3RSZXNwb25zZSwgQ29tbWFuZHNcbiAgICBXcmVxci5DaGFubmVsID0gZnVuY3Rpb24oV3JlcXIpIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgICAgICB0aGlzLnZlbnQgPSBuZXcgQmFja2JvbmUuV3JlcXIuRXZlbnRBZ2dyZWdhdG9yKCk7XG4gICAgICAgIHRoaXMucmVxcmVzID0gbmV3IEJhY2tib25lLldyZXFyLlJlcXVlc3RSZXNwb25zZSgpO1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gbmV3IEJhY2tib25lLldyZXFyLkNvbW1hbmRzKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBjaGFubmVsTmFtZTtcbiAgICAgIH07XG4gICAgICBfLmV4dGVuZChDaGFubmVsLnByb3RvdHlwZSwge1xuICAgICAgICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZyb20gdGhlIG1lc3NhZ2luZyBzeXN0ZW1zIG9mIHRoaXMgY2hhbm5lbFxuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy52ZW50Lm9mZigpO1xuICAgICAgICAgIHRoaXMudmVudC5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgICAgdGhpcy5yZXFyZXMucmVtb3ZlQWxsSGFuZGxlcnMoKTtcbiAgICAgICAgICB0aGlzLmNvbW1hbmRzLnJlbW92ZUFsbEhhbmRsZXJzKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENvbm5lY3QgYSBoYXNoIG9mIGV2ZW50czsgb25lIGZvciBlYWNoIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgICAgY29ubmVjdEV2ZW50czogZnVuY3Rpb24oaGFzaCwgY29udGV4dCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3QoXCJ2ZW50XCIsIGhhc2gsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0Q29tbWFuZHM6IGZ1bmN0aW9uKGhhc2gsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0KFwiY29tbWFuZHNcIiwgaGFzaCwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RSZXF1ZXN0czogZnVuY3Rpb24oaGFzaCwgY29udGV4dCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3QoXCJyZXFyZXNcIiwgaGFzaCwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgaGFuZGxlcnMgdG8gYSBnaXZlbiBtZXNzYWdlIHN5c3RlbSBgdHlwZWBcbiAgICAgICAgX2Nvbm5lY3Q6IGZ1bmN0aW9uKHR5cGUsIGhhc2gsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgICB2YXIgbWV0aG9kID0gdHlwZSA9PT0gXCJ2ZW50XCIgPyBcIm9uXCIgOiBcInNldEhhbmRsZXJcIjtcbiAgICAgICAgICBfLmVhY2goaGFzaCwgZnVuY3Rpb24oZm4sIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGhpc1t0eXBlXVttZXRob2RdKGV2ZW50TmFtZSwgXy5iaW5kKGZuLCBjb250ZXh0KSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENoYW5uZWw7XG4gICAgfShXcmVxcik7XG4gICAgLy8gV3JlcXIuUmFkaW9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gQW4gb2JqZWN0IHRoYXQgbGV0cyB5b3UgY29tbXVuaWNhdGUgd2l0aCBtYW55IGNoYW5uZWxzLlxuICAgIFdyZXFyLnJhZGlvID0gZnVuY3Rpb24oV3JlcXIsIF8pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIFJhZGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NoYW5uZWxzID0ge307XG4gICAgICAgIHRoaXMudmVudCA9IHt9O1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0ge307XG4gICAgICAgIHRoaXMucmVxcmVzID0ge307XG4gICAgICAgIHRoaXMuX3Byb3h5TWV0aG9kcygpO1xuICAgICAgfTtcbiAgICAgIF8uZXh0ZW5kKFJhZGlvLnByb3RvdHlwZSwge1xuICAgICAgICBjaGFubmVsOiBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgICAgICAgIGlmICghY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYW5uZWwgbXVzdCByZWNlaXZlIGEgbmFtZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Q2hhbm5lbDogZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBuZXcgV3JlcXIuQ2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFubmVsc1tjaGFubmVsTmFtZV0gPSBjaGFubmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICAgICAgfSxcbiAgICAgICAgX3Byb3h5TWV0aG9kczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgXy5lYWNoKFsgXCJ2ZW50XCIsIFwiY29tbWFuZHNcIiwgXCJyZXFyZXNcIiBdLCBmdW5jdGlvbihzeXN0ZW0pIHtcbiAgICAgICAgICAgIF8uZWFjaChtZXNzYWdlU3lzdGVtc1tzeXN0ZW1dLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgdGhpc1tzeXN0ZW1dW21ldGhvZF0gPSBwcm94eU1ldGhvZCh0aGlzLCBzeXN0ZW0sIG1ldGhvZCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbWVzc2FnZVN5c3RlbXMgPSB7XG4gICAgICAgIHZlbnQ6IFsgXCJvblwiLCBcIm9mZlwiLCBcInRyaWdnZXJcIiwgXCJvbmNlXCIsIFwic3RvcExpc3RlbmluZ1wiLCBcImxpc3RlblRvXCIsIFwibGlzdGVuVG9PbmNlXCIgXSxcbiAgICAgICAgY29tbWFuZHM6IFsgXCJleGVjdXRlXCIsIFwic2V0SGFuZGxlclwiLCBcInNldEhhbmRsZXJzXCIsIFwicmVtb3ZlSGFuZGxlclwiLCBcInJlbW92ZUFsbEhhbmRsZXJzXCIgXSxcbiAgICAgICAgcmVxcmVzOiBbIFwicmVxdWVzdFwiLCBcInNldEhhbmRsZXJcIiwgXCJzZXRIYW5kbGVyc1wiLCBcInJlbW92ZUhhbmRsZXJcIiwgXCJyZW1vdmVBbGxIYW5kbGVyc1wiIF1cbiAgICAgIH07XG4gICAgICB2YXIgcHJveHlNZXRob2QgPSBmdW5jdGlvbihyYWRpbywgc3lzdGVtLCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VTeXN0ZW0gPSByYWRpby5fZ2V0Q2hhbm5lbChjaGFubmVsTmFtZSlbc3lzdGVtXTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZVN5c3RlbVttZXRob2RdLmFwcGx5KG1lc3NhZ2VTeXN0ZW0sIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFJhZGlvKCk7XG4gICAgfShXcmVxciwgXyk7XG4gICAgcmV0dXJuIEJhY2tib25lLldyZXFyO1xuICB9KShCYWNrYm9uZSwgXyk7XG5cbiAgdmFyIHByZXZpb3VzTWFyaW9uZXR0ZSA9IHJvb3QuTWFyaW9uZXR0ZTtcbiAgdmFyIHByZXZpb3VzTW4gPSByb290Lk1uO1xuXG4gIHZhciBNYXJpb25ldHRlID0gQmFja2JvbmUuTWFyaW9uZXR0ZSA9IHt9O1xuXG4gIE1hcmlvbmV0dGUuVkVSU0lPTiA9ICcyLjQuMic7XG5cbiAgTWFyaW9uZXR0ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5NYXJpb25ldHRlID0gcHJldmlvdXNNYXJpb25ldHRlO1xuICAgIHJvb3QuTW4gPSBwcmV2aW91c01uO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJhY2tib25lLk1hcmlvbmV0dGUgPSBNYXJpb25ldHRlO1xuXG4gIC8vIEdldCB0aGUgRGVmZXJyZWQgY3JlYXRvciBmb3IgbGF0ZXIgdXNlXG4gIE1hcmlvbmV0dGUuRGVmZXJyZWQgPSBCYWNrYm9uZS4kLkRlZmVycmVkO1xuXG4gIC8qIGpzaGludCB1bnVzZWQ6IGZhbHNlICovLyogZ2xvYmFsIGNvbnNvbGUgKi9cbiAgXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuICBcbiAgLy8gTWFyaW9uZXR0ZS5leHRlbmRcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIEJvcnJvdyB0aGUgQmFja2JvbmUgYGV4dGVuZGAgbWV0aG9kIHNvIHdlIGNhbiB1c2UgaXQgYXMgbmVlZGVkXG4gIE1hcmlvbmV0dGUuZXh0ZW5kID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kO1xuICBcbiAgLy8gTWFyaW9uZXR0ZS5pc05vZGVBdHRhY2hlZFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBEZXRlcm1pbmUgaWYgYGVsYCBpcyBhIGNoaWxkIG9mIHRoZSBkb2N1bWVudFxuICBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gQmFja2JvbmUuJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGVsKTtcbiAgfTtcbiAgXG4gIC8vIE1lcmdlIGBrZXlzYCBmcm9tIGBvcHRpb25zYCBvbnRvIGB0aGlzYFxuICBNYXJpb25ldHRlLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGtleXMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHsgcmV0dXJuOyB9XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIGtleXMpKTtcbiAgfTtcbiAgXG4gIC8vIE1hcmlvbmV0dGUuZ2V0T3B0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBSZXRyaWV2ZSBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIG90aGVyIHZhbHVlIGZyb20gYSB0YXJnZXRcbiAgLy8gb2JqZWN0IG9yIGl0cyBgb3B0aW9uc2AsIHdpdGggYG9wdGlvbnNgIHRha2luZyBwcmVjZWRlbmNlLlxuICBNYXJpb25ldHRlLmdldE9wdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9uTmFtZSkge1xuICAgIGlmICghdGFyZ2V0IHx8ICFvcHRpb25OYW1lKSB7IHJldHVybjsgfVxuICAgIGlmICh0YXJnZXQub3B0aW9ucyAmJiAodGFyZ2V0Lm9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQub3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRhcmdldFtvcHRpb25OYW1lXTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBQcm94eSBgTWFyaW9uZXR0ZS5nZXRPcHRpb25gXG4gIE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24gPSBmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgcmV0dXJuIE1hcmlvbmV0dGUuZ2V0T3B0aW9uKHRoaXMsIG9wdGlvbk5hbWUpO1xuICB9O1xuICBcbiAgLy8gU2ltaWxhciB0byBgXy5yZXN1bHRgLCB0aGlzIGlzIGEgc2ltcGxlIGhlbHBlclxuICAvLyBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdlIGNhbGwgaXQgd2l0aCBjb250ZXh0XG4gIC8vIG90aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgdmFsdWUuIElmIHRoZSB2YWx1ZSBpc1xuICAvLyB1bmRlZmluZWQgcmV0dXJuIGEgZGVmYXVsdCB2YWx1ZVxuICBNYXJpb25ldHRlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBwYXJhbXMpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBwYXJhbXMgPyB2YWx1ZS5hcHBseShjb250ZXh0LCBwYXJhbXMpIDogdmFsdWUuY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBcbiAgLy8gTWFyaW9uZXR0ZS5ub3JtYWxpemVNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIFBhc3MgaW4gYSBtYXBwaW5nIG9mIGV2ZW50cyA9PiBmdW5jdGlvbnMgb3IgZnVuY3Rpb24gbmFtZXNcbiAgLy8gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgZXZlbnRzID0+IGZ1bmN0aW9uc1xuICBNYXJpb25ldHRlLm5vcm1hbGl6ZU1ldGhvZHMgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGhhc2gsIGZ1bmN0aW9uKG5vcm1hbGl6ZWRIYXNoLCBtZXRob2QsIG5hbWUpIHtcbiAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgbWV0aG9kID0gdGhpc1ttZXRob2RdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBub3JtYWxpemVkSGFzaFtuYW1lXSA9IG1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVkSGFzaDtcbiAgICB9LCB7fSwgdGhpcyk7XG4gIH07XG4gIFxuICAvLyB1dGlsaXR5IG1ldGhvZCBmb3IgcGFyc2luZyBAdWkuIHN5bnRheCBzdHJpbmdzXG4gIC8vIGludG8gYXNzb2NpYXRlZCBzZWxlY3RvclxuICBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJU3RyaW5nID0gZnVuY3Rpb24odWlTdHJpbmcsIHVpKSB7XG4gICAgcmV0dXJuIHVpU3RyaW5nLnJlcGxhY2UoL0B1aVxcLlthLXpBLVpfJDAtOV0qL2csIGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB1aVtyLnNsaWNlKDQpXTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8vIGFsbG93cyBmb3IgdGhlIHVzZSBvZiB0aGUgQHVpLiBzeW50YXggd2l0aGluXG4gIC8vIGEgZ2l2ZW4ga2V5IGZvciB0cmlnZ2VycyBhbmQgZXZlbnRzXG4gIC8vIHN3YXBzIHRoZSBAdWkgd2l0aCB0aGUgYXNzb2NpYXRlZCBzZWxlY3Rvci5cbiAgLy8gUmV0dXJucyBhIG5ldywgbm9uLW11dGF0ZWQsIHBhcnNlZCBldmVudHMgaGFzaC5cbiAgTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXMgPSBmdW5jdGlvbihoYXNoLCB1aSkge1xuICAgIHJldHVybiBfLnJlZHVjZShoYXNoLCBmdW5jdGlvbihtZW1vLCB2YWwsIGtleSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRLZXkgPSBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJU3RyaW5nKGtleSwgdWkpO1xuICAgICAgbWVtb1tub3JtYWxpemVkS2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfTtcbiAgXG4gIC8vIGFsbG93cyBmb3IgdGhlIHVzZSBvZiB0aGUgQHVpLiBzeW50YXggd2l0aGluXG4gIC8vIGEgZ2l2ZW4gdmFsdWUgZm9yIHJlZ2lvbnNcbiAgLy8gc3dhcHMgdGhlIEB1aSB3aXRoIHRoZSBhc3NvY2lhdGVkIHNlbGVjdG9yXG4gIE1hcmlvbmV0dGUubm9ybWFsaXplVUlWYWx1ZXMgPSBmdW5jdGlvbihoYXNoLCB1aSwgcHJvcGVydGllcykge1xuICAgIF8uZWFjaChoYXNoLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcodmFsKSkge1xuICAgICAgICBoYXNoW2tleV0gPSBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJU3RyaW5nKHZhbCwgdWkpO1xuICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbCkgJiYgXy5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIF8uZXh0ZW5kKHZhbCwgTWFyaW9uZXR0ZS5ub3JtYWxpemVVSVZhbHVlcyhfLnBpY2sodmFsLCBwcm9wZXJ0aWVzKSwgdWkpKTtcbiAgICAgICAgLyogVmFsdWUgaXMgYW4gb2JqZWN0LCBhbmQgd2UgZ290IGFuIGFycmF5IG9mIGVtYmVkZGVkIHByb3BlcnR5IG5hbWVzIHRvIG5vcm1hbGl6ZS4gKi9cbiAgICAgICAgXy5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIHByb3BlcnR5VmFsID0gdmFsW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhwcm9wZXJ0eVZhbCkpIHtcbiAgICAgICAgICAgIHZhbFtwcm9wZXJ0eV0gPSBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJU3RyaW5nKHByb3BlcnR5VmFsLCB1aSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcbiAgXG4gIC8vIE1peCBpbiBtZXRob2RzIGZyb20gVW5kZXJzY29yZSwgZm9yIGl0ZXJhdGlvbiwgYW5kIG90aGVyXG4gIC8vIGNvbGxlY3Rpb24gcmVsYXRlZCBmZWF0dXJlcy5cbiAgLy8gQm9ycm93aW5nIHRoaXMgY29kZSBmcm9tIEJhY2tib25lLkNvbGxlY3Rpb246XG4gIC8vIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy9kb2NzL2JhY2tib25lLmh0bWwjc2VjdGlvbi0xMjFcbiAgTWFyaW9uZXR0ZS5hY3RBc0NvbGxlY3Rpb24gPSBmdW5jdGlvbihvYmplY3QsIGxpc3RQcm9wZXJ0eSkge1xuICAgIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsXG4gICAgICAnc2VsZWN0JywgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsXG4gICAgICAnY29udGFpbnMnLCAnaW52b2tlJywgJ3RvQXJyYXknLCAnZmlyc3QnLCAnaW5pdGlhbCcsICdyZXN0JyxcbiAgICAgICdsYXN0JywgJ3dpdGhvdXQnLCAnaXNFbXB0eScsICdwbHVjayddO1xuICBcbiAgICBfLmVhY2gobWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBvYmplY3RbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGlzdCA9IF8udmFsdWVzKF8ucmVzdWx0KHRoaXMsIGxpc3RQcm9wZXJ0eSkpO1xuICAgICAgICB2YXIgYXJncyA9IFtsaXN0XS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIHZhciBkZXByZWNhdGUgPSBNYXJpb25ldHRlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRlc3QpIHtcbiAgICBpZiAoXy5pc09iamVjdChtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IChcbiAgICAgICAgbWVzc2FnZS5wcmV2ICsgJyBpcyBnb2luZyB0byBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSAnICsgbWVzc2FnZS5uZXh0ICsgJyBpbnN0ZWFkLicgK1xuICAgICAgICAobWVzc2FnZS51cmwgPyAnIFNlZTogJyArIG1lc3NhZ2UudXJsIDogJycpXG4gICAgICApO1xuICAgIH1cbiAgXG4gICAgaWYgKCh0ZXN0ID09PSB1bmRlZmluZWQgfHwgIXRlc3QpICYmICFkZXByZWNhdGUuX2NhY2hlW21lc3NhZ2VdKSB7XG4gICAgICBkZXByZWNhdGUuX3dhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtZXNzYWdlKTtcbiAgICAgIGRlcHJlY2F0ZS5fY2FjaGVbbWVzc2FnZV0gPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgXG4gIGRlcHJlY2F0ZS5fd2FybiA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiAoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKSB8fCBmdW5jdGlvbigpIHt9O1xuICBkZXByZWNhdGUuX2NhY2hlID0ge307XG4gIFxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMTQsIG1heGNvbXBsZXhpdHk6IDcgKi9cbiAgXG4gIC8vIFRyaWdnZXIgTWV0aG9kXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vIHNwbGl0IHRoZSBldmVudCBuYW1lIG9uIHRoZSBcIjpcIlxuICAgIHZhciBzcGxpdHRlciA9IC8oXnw6KShcXHcpL2dpO1xuICBcbiAgICAvLyB0YWtlIHRoZSBldmVudCBzZWN0aW9uIChcInNlY3Rpb24xOnNlY3Rpb24yOnNlY3Rpb24zXCIpXG4gICAgLy8gYW5kIHR1cm4gaXQgaW4gdG8gdXBwZXJjYXNlIG5hbWVcbiAgICBmdW5jdGlvbiBnZXRFdmVudE5hbWUobWF0Y2gsIHByZWZpeCwgZXZlbnROYW1lKSB7XG4gICAgICByZXR1cm4gZXZlbnROYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dCwgZXZlbnQsIGFyZ3MpIHtcbiAgICAgIHZhciBub0V2ZW50QXJnID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBpZiAobm9FdmVudEFyZykge1xuICAgICAgICBhcmdzID0gZXZlbnQ7XG4gICAgICAgIGV2ZW50ID0gYXJnc1swXTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBnZXQgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIGV2ZW50IG5hbWVcbiAgICAgIHZhciBtZXRob2ROYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2Uoc3BsaXR0ZXIsIGdldEV2ZW50TmFtZSk7XG4gICAgICB2YXIgbWV0aG9kID0gY29udGV4dFttZXRob2ROYW1lXTtcbiAgICAgIHZhciByZXN1bHQ7XG4gIFxuICAgICAgLy8gY2FsbCB0aGUgb25NZXRob2ROYW1lIGlmIGl0IGV4aXN0c1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgICAgIC8vIHBhc3MgYWxsIGFyZ3MsIGV4Y2VwdCB0aGUgZXZlbnQgbmFtZVxuICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoY29udGV4dCwgbm9FdmVudEFyZyA/IF8ucmVzdChhcmdzKSA6IGFyZ3MpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50LCBpZiBhIHRyaWdnZXIgbWV0aG9kIGV4aXN0c1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb250ZXh0LnRyaWdnZXIpKSB7XG4gICAgICAgIGlmIChub0V2ZW50QXJnICsgYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29udGV4dC50cmlnZ2VyLmFwcGx5KGNvbnRleHQsIG5vRXZlbnRBcmcgPyBhcmdzIDogW2V2ZW50XS5jb25jYXQoXy5kcm9wKGFyZ3MsIDApKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC50cmlnZ2VyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSkoKTtcbiAgXG4gIC8vIFRyaWdnZXIgYW4gZXZlbnQgYW5kL29yIGEgY29ycmVzcG9uZGluZyBtZXRob2QgbmFtZS4gRXhhbXBsZXM6XG4gIC8vXG4gIC8vIGB0aGlzLnRyaWdnZXJNZXRob2QoXCJmb29cIilgIHdpbGwgdHJpZ2dlciB0aGUgXCJmb29cIiBldmVudCBhbmRcbiAgLy8gY2FsbCB0aGUgXCJvbkZvb1wiIG1ldGhvZC5cbiAgLy9cbiAgLy8gYHRoaXMudHJpZ2dlck1ldGhvZChcImZvbzpiYXJcIilgIHdpbGwgdHJpZ2dlciB0aGUgXCJmb286YmFyXCIgZXZlbnQgYW5kXG4gIC8vIGNhbGwgdGhlIFwib25Gb29CYXJcIiBtZXRob2QuXG4gIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXG4gIC8vIHRyaWdnZXJNZXRob2RPbiBpbnZva2VzIHRyaWdnZXJNZXRob2Qgb24gYSBzcGVjaWZpYyBjb250ZXh0XG4gIC8vXG4gIC8vIGUuZy4gYE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdzaG93JylgXG4gIC8vIHdpbGwgdHJpZ2dlciBhIFwic2hvd1wiIGV2ZW50IG9yIGludm9rZSBvblNob3cgdGhlIHZpZXcuXG4gIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBmbmMgPSBfLmlzRnVuY3Rpb24oY29udGV4dC50cmlnZ2VyTWV0aG9kKSA/XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnRyaWdnZXJNZXRob2QgOlxuICAgICAgICAgICAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kO1xuICBcbiAgICByZXR1cm4gZm5jLmFwcGx5KGNvbnRleHQsIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgfTtcbiAgXG4gIC8vIERPTSBSZWZyZXNoXG4gIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAvLyBNb25pdG9yIGEgdmlldydzIHN0YXRlLCBhbmQgYWZ0ZXIgaXQgaGFzIGJlZW4gcmVuZGVyZWQgYW5kIHNob3duXG4gIC8vIGluIHRoZSBET00sIHRyaWdnZXIgYSBcImRvbTpyZWZyZXNoXCIgZXZlbnQgZXZlcnkgdGltZSBpdCBpc1xuICAvLyByZS1yZW5kZXJlZC5cbiAgXG4gIE1hcmlvbmV0dGUuTW9uaXRvckRPTVJlZnJlc2ggPSBmdW5jdGlvbih2aWV3KSB7XG4gIFxuICAgIC8vIHRyYWNrIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW4gc2hvd24gaW4gdGhlIERPTSxcbiAgICAvLyB1c2luZyBhIE1hcmlvbmV0dGUuUmVnaW9uIChvciBieSBvdGhlciBtZWFucyBvZiB0cmlnZ2VyaW5nIFwic2hvd1wiKVxuICAgIGZ1bmN0aW9uIGhhbmRsZVNob3coKSB7XG4gICAgICB2aWV3Ll9pc1Nob3duID0gdHJ1ZTtcbiAgICAgIHRyaWdnZXJET01SZWZyZXNoKCk7XG4gICAgfVxuICBcbiAgICAvLyB0cmFjayB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuIHJlbmRlcmVkXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKCkge1xuICAgICAgdmlldy5faXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0cmlnZ2VyRE9NUmVmcmVzaCgpO1xuICAgIH1cbiAgXG4gICAgLy8gVHJpZ2dlciB0aGUgXCJkb206cmVmcmVzaFwiIGV2ZW50IGFuZCBjb3JyZXNwb25kaW5nIFwib25Eb21SZWZyZXNoXCIgbWV0aG9kXG4gICAgZnVuY3Rpb24gdHJpZ2dlckRPTVJlZnJlc2goKSB7XG4gICAgICBpZiAodmlldy5faXNTaG93biAmJiB2aWV3Ll9pc1JlbmRlcmVkICYmIE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQodmlldy5lbCkpIHtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih2aWV3LnRyaWdnZXJNZXRob2QpKSB7XG4gICAgICAgICAgdmlldy50cmlnZ2VyTWV0aG9kKCdkb206cmVmcmVzaCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBcbiAgICB2aWV3Lm9uKHtcbiAgICAgIHNob3c6IGhhbmRsZVNob3csXG4gICAgICByZW5kZXI6IGhhbmRsZVJlbmRlclxuICAgIH0pO1xuICB9O1xuICBcbiAgLyoganNoaW50IG1heHBhcmFtczogNSAqL1xuICBcbiAgLy8gQmluZCBFbnRpdHkgRXZlbnRzICYgVW5iaW5kIEVudGl0eSBFdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgdXNlZCB0byBiaW5kL3VuYmluZCBhIGJhY2tib25lIFwiZW50aXR5XCIgKGUuZy4gY29sbGVjdGlvbi9tb2RlbClcbiAgLy8gdG8gbWV0aG9kcyBvbiBhIHRhcmdldCBvYmplY3QuXG4gIC8vXG4gIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIsIGB0YXJnZXRgLCBtdXN0IGhhdmUgdGhlIEJhY2tib25lLkV2ZW50cyBtb2R1bGUgbWl4ZWQgaW4uXG4gIC8vXG4gIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBgZW50aXR5YCAoQmFja2JvbmUuTW9kZWwsIEJhY2tib25lLkNvbGxlY3Rpb24gb3JcbiAgLy8gYW55IG9iamVjdCB0aGF0IGhhcyBCYWNrYm9uZS5FdmVudHMgbWl4ZWQgaW4pIHRvIGJpbmQgdGhlIGV2ZW50cyBmcm9tLlxuICAvL1xuICAvLyBUaGUgdGhpcmQgcGFyYW1ldGVyIGlzIGEgaGFzaCBvZiB7IFwiZXZlbnQ6bmFtZVwiOiBcImV2ZW50SGFuZGxlclwiIH1cbiAgLy8gY29uZmlndXJhdGlvbi4gTXVsdGlwbGUgaGFuZGxlcnMgY2FuIGJlIHNlcGFyYXRlZCBieSBhIHNwYWNlLiBBXG4gIC8vIGZ1bmN0aW9uIGNhbiBiZSBzdXBwbGllZCBpbnN0ZWFkIG9mIGEgc3RyaW5nIGhhbmRsZXIgbmFtZS5cbiAgXG4gIChmdW5jdGlvbihNYXJpb25ldHRlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICBcbiAgICAvLyBCaW5kIHRoZSBldmVudCB0byBoYW5kbGVycyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgb2ZcbiAgICAvLyBoYW5kbGVyIG5hbWVzIG9uIHRoZSB0YXJnZXQgb2JqZWN0XG4gICAgZnVuY3Rpb24gYmluZEZyb21TdHJpbmdzKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpIHtcbiAgICAgIHZhciBtZXRob2ROYW1lcyA9IG1ldGhvZHMuc3BsaXQoL1xccysvKTtcbiAgXG4gICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgXG4gICAgICAgIHZhciBtZXRob2QgPSB0YXJnZXRbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3IoJ01ldGhvZCBcIicgKyBtZXRob2ROYW1lICtcbiAgICAgICAgICAgICdcIiB3YXMgY29uZmlndXJlZCBhcyBhbiBldmVudCBoYW5kbGVyLCBidXQgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRhcmdldC5saXN0ZW5UbyhlbnRpdHksIGV2dCwgbWV0aG9kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgdG8gYSBzdXBwbGllZCBjYWxsYmFjayBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGJpbmRUb0Z1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZCkge1xuICAgICAgdGFyZ2V0Lmxpc3RlblRvKGVudGl0eSwgZXZ0LCBtZXRob2QpO1xuICAgIH1cbiAgXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgdG8gaGFuZGxlcnMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIG9mXG4gICAgLy8gaGFuZGxlciBuYW1lcyBvbiB0aGUgdGFyZ2V0IG9iamVjdFxuICAgIGZ1bmN0aW9uIHVuYmluZEZyb21TdHJpbmdzKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpIHtcbiAgICAgIHZhciBtZXRob2ROYW1lcyA9IG1ldGhvZHMuc3BsaXQoL1xccysvKTtcbiAgXG4gICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgICAgICAgdGFyZ2V0LnN0b3BMaXN0ZW5pbmcoZW50aXR5LCBldnQsIG1ldGhvZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIC8vIEJpbmQgdGhlIGV2ZW50IHRvIGEgc3VwcGxpZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBmdW5jdGlvbiB1bmJpbmRUb0Z1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZCkge1xuICAgICAgdGFyZ2V0LnN0b3BMaXN0ZW5pbmcoZW50aXR5LCBldnQsIG1ldGhvZCk7XG4gICAgfVxuICBcbiAgICAvLyBnZW5lcmljIGxvb3BpbmcgZnVuY3Rpb25cbiAgICBmdW5jdGlvbiBpdGVyYXRlRXZlbnRzKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncywgZnVuY3Rpb25DYWxsYmFjaywgc3RyaW5nQ2FsbGJhY2spIHtcbiAgICAgIGlmICghZW50aXR5IHx8ICFiaW5kaW5ncykgeyByZXR1cm47IH1cbiAgXG4gICAgICAvLyB0eXBlLWNoZWNrIGJpbmRpbmdzXG4gICAgICBpZiAoIV8uaXNPYmplY3QoYmluZGluZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnQmluZGluZ3MgbXVzdCBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJyxcbiAgICAgICAgICB1cmw6ICdtYXJpb25ldHRlLmZ1bmN0aW9ucy5odG1sI21hcmlvbmV0dGViaW5kZW50aXR5ZXZlbnRzJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBhbGxvdyB0aGUgYmluZGluZ3MgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgYmluZGluZ3MgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShiaW5kaW5ncywgdGFyZ2V0KTtcbiAgXG4gICAgICAvLyBpdGVyYXRlIHRoZSBiaW5kaW5ncyBhbmQgYmluZCB0aGVtXG4gICAgICBfLmVhY2goYmluZGluZ3MsIGZ1bmN0aW9uKG1ldGhvZHMsIGV2dCkge1xuICBcbiAgICAgICAgLy8gYWxsb3cgZm9yIGEgZnVuY3Rpb24gYXMgdGhlIGhhbmRsZXIsXG4gICAgICAgIC8vIG9yIGEgbGlzdCBvZiBldmVudCBuYW1lcyBhcyBhIHN0cmluZ1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG1ldGhvZHMpKSB7XG4gICAgICAgICAgZnVuY3Rpb25DYWxsYmFjayh0YXJnZXQsIGVudGl0eSwgZXZ0LCBtZXRob2RzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmdDYWxsYmFjayh0YXJnZXQsIGVudGl0eSwgZXZ0LCBtZXRob2RzKTtcbiAgICAgICAgfVxuICBcbiAgICAgIH0pO1xuICAgIH1cbiAgXG4gICAgLy8gRXhwb3J0IFB1YmxpYyBBUElcbiAgICBNYXJpb25ldHRlLmJpbmRFbnRpdHlFdmVudHMgPSBmdW5jdGlvbih0YXJnZXQsIGVudGl0eSwgYmluZGluZ3MpIHtcbiAgICAgIGl0ZXJhdGVFdmVudHModGFyZ2V0LCBlbnRpdHksIGJpbmRpbmdzLCBiaW5kVG9GdW5jdGlvbiwgYmluZEZyb21TdHJpbmdzKTtcbiAgICB9O1xuICBcbiAgICBNYXJpb25ldHRlLnVuYmluZEVudGl0eUV2ZW50cyA9IGZ1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgaXRlcmF0ZUV2ZW50cyh0YXJnZXQsIGVudGl0eSwgYmluZGluZ3MsIHVuYmluZFRvRnVuY3Rpb24sIHVuYmluZEZyb21TdHJpbmdzKTtcbiAgICB9O1xuICBcbiAgICAvLyBQcm94eSBgYmluZEVudGl0eUV2ZW50c2BcbiAgICBNYXJpb25ldHRlLnByb3h5QmluZEVudGl0eUV2ZW50cyA9IGZ1bmN0aW9uKGVudGl0eSwgYmluZGluZ3MpIHtcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLmJpbmRFbnRpdHlFdmVudHModGhpcywgZW50aXR5LCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgXG4gICAgLy8gUHJveHkgYHVuYmluZEVudGl0eUV2ZW50c2BcbiAgICBNYXJpb25ldHRlLnByb3h5VW5iaW5kRW50aXR5RXZlbnRzID0gZnVuY3Rpb24oZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUudW5iaW5kRW50aXR5RXZlbnRzKHRoaXMsIGVudGl0eSwgYmluZGluZ3MpO1xuICAgIH07XG4gIH0pKE1hcmlvbmV0dGUpO1xuICBcblxuICAvLyBFcnJvclxuICAvLyAtLS0tLVxuICBcbiAgdmFyIGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbmFtZScsICdtZXNzYWdlJywgJ251bWJlciddO1xuICBcbiAgTWFyaW9uZXR0ZS5FcnJvciA9IE1hcmlvbmV0dGUuZXh0ZW5kLmNhbGwoRXJyb3IsIHtcbiAgICB1cmxSb290OiAnaHR0cDovL21hcmlvbmV0dGVqcy5jb20vZG9jcy92JyArIE1hcmlvbmV0dGUuVkVSU0lPTiArICcvJyxcbiAgXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KG1lc3NhZ2UpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBtZXNzYWdlO1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGVycm9yID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgIF8uZXh0ZW5kKHRoaXMsIF8ucGljayhlcnJvciwgZXJyb3JQcm9wcyksIF8ucGljayhvcHRpb25zLCBlcnJvclByb3BzKSk7XG4gIFxuICAgICAgdGhpcy5jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICBcbiAgICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsUm9vdCArIG9wdGlvbnMudXJsO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIGNhcHR1cmVTdGFja1RyYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNYXJpb25ldHRlLkVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIHRoaXMubWVzc2FnZSArICh0aGlzLnVybCA/ICcgU2VlOiAnICsgdGhpcy51cmwgOiAnJyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIE1hcmlvbmV0dGUuRXJyb3IuZXh0ZW5kID0gTWFyaW9uZXR0ZS5leHRlbmQ7XG4gIFxuICAvLyBDYWxsYmFja3NcbiAgLy8gLS0tLS0tLS0tXG4gIFxuICAvLyBBIHNpbXBsZSB3YXkgb2YgbWFuYWdpbmcgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrc1xuICAvLyBhbmQgZXhlY3V0aW5nIHRoZW0gYXQgYSBsYXRlciBwb2ludCBpbiB0aW1lLCB1c2luZyBqUXVlcnknc1xuICAvLyBgRGVmZXJyZWRgIG9iamVjdC5cbiAgTWFyaW9uZXR0ZS5DYWxsYmFja3MgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IE1hcmlvbmV0dGUuRGVmZXJyZWQoKTtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfTtcbiAgXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuQ2FsbGJhY2tzLnByb3RvdHlwZSwge1xuICBcbiAgICAvLyBBZGQgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZC4gQ2FsbGJhY2tzIGFkZGVkIGhlcmUgYXJlXG4gICAgLy8gZ3VhcmFudGVlZCB0byBleGVjdXRlLCBldmVuIGlmIHRoZXkgYXJlIGFkZGVkIGFmdGVyIHRoZVxuICAgIC8vIGBydW5gIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgYWRkOiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dE92ZXJyaWRlKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9IF8ucmVzdWx0KHRoaXMuX2RlZmVycmVkLCAncHJvbWlzZScpO1xuICBcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKHtjYjogY2FsbGJhY2ssIGN0eDogY29udGV4dE92ZXJyaWRlfSk7XG4gIFxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbnRleHRPdmVycmlkZSkgeyBhcmdzLmNvbnRleHQgPSBjb250ZXh0T3ZlcnJpZGU7IH1cbiAgICAgICAgY2FsbGJhY2suY2FsbChhcmdzLmNvbnRleHQsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBSdW4gYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGNvbnRleHQgc3BlY2lmaWVkLlxuICAgIC8vIEFkZGl0aW9uYWwgY2FsbGJhY2tzIGNhbiBiZSBhZGRlZCBhZnRlciB0aGlzIGhhcyBiZWVuIHJ1blxuICAgIC8vIGFuZCB0aGV5IHdpbGwgc3RpbGwgYmUgZXhlY3V0ZWQuXG4gICAgcnVuOiBmdW5jdGlvbihvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICB0aGlzLl9kZWZlcnJlZC5yZXNvbHZlKHtcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVzZXRzIHRoZSBsaXN0IG9mIGNhbGxiYWNrcyB0byBiZSBydW4sIGFsbG93aW5nIHRoZSBzYW1lIGxpc3RcbiAgICAvLyB0byBiZSBydW4gbXVsdGlwbGUgdGltZXMgLSB3aGVuZXZlciB0aGUgYHJ1bmAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgICAgdGhpcy5fZGVmZXJyZWQgPSBNYXJpb25ldHRlLkRlZmVycmVkKCk7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgXG4gICAgICBfLmVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbihjYikge1xuICAgICAgICB0aGlzLmFkZChjYi5jYiwgY2IuY3R4KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBDb250cm9sbGVyXG4gIC8vIC0tLS0tLS0tLS1cbiAgXG4gIC8vIEEgbXVsdGktcHVycG9zZSBvYmplY3QgdG8gdXNlIGFzIGEgY29udHJvbGxlciBmb3JcbiAgLy8gbW9kdWxlcyBhbmQgcm91dGVycywgYW5kIGFzIGEgbWVkaWF0b3IgZm9yIHdvcmtmbG93XG4gIC8vIGFuZCBjb29yZGluYXRpb24gb2Ygb3RoZXIgb2JqZWN0cywgdmlld3MsIGFuZCBtb3JlLlxuICBNYXJpb25ldHRlLkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmluaXRpYWxpemUpKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLkNvbnRyb2xsZXIuZXh0ZW5kID0gTWFyaW9uZXR0ZS5leHRlbmQ7XG4gIFxuICAvLyBDb250cm9sbGVyIE1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIEVuc3VyZSBpdCBjYW4gdHJpZ2dlciBldmVudHMgd2l0aCBCYWNrYm9uZS5FdmVudHNcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5Db250cm9sbGVyLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdiZWZvcmU6ZGVzdHJveScsIGFyZ3VtZW50cyk7XG4gICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdkZXN0cm95JywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgIHRoaXMub2ZmKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBpbXBvcnQgdGhlIGB0cmlnZ2VyTWV0aG9kYCB0byB0cmlnZ2VyIGV2ZW50cyB3aXRoIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBtZXRob2RzIGlmIHRoZSBtZXRob2QgZXhpc3RzXG4gICAgdHJpZ2dlck1ldGhvZDogTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kLFxuICBcbiAgICAvLyBBIGhhbmR5IHdheSB0byBtZXJnZSBvcHRpb25zIG9udG8gdGhlIGluc3RhbmNlXG4gICAgbWVyZ2VPcHRpb25zOiBNYXJpb25ldHRlLm1lcmdlT3B0aW9ucyxcbiAgXG4gICAgLy8gUHJveHkgYGdldE9wdGlvbmAgdG8gZW5hYmxlIGdldHRpbmcgb3B0aW9ucyBmcm9tIHRoaXMgb3IgdGhpcy5vcHRpb25zIGJ5IG5hbWUuXG4gICAgZ2V0T3B0aW9uOiBNYXJpb25ldHRlLnByb3h5R2V0T3B0aW9uXG4gIFxuICB9KTtcbiAgXG4gIC8vIE9iamVjdFxuICAvLyAtLS0tLS1cbiAgXG4gIC8vIEEgQmFzZSBDbGFzcyB0aGF0IG90aGVyIENsYXNzZXMgc2hvdWxkIGRlc2NlbmQgZnJvbS5cbiAgLy8gT2JqZWN0IGJvcnJvd3MgbWFueSBjb252ZW50aW9ucyBhbmQgdXRpbGl0aWVzIGZyb20gQmFja2JvbmUuXG4gIE1hcmlvbmV0dGUuT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBfLnJlc3VsdCh0aGlzLCAnb3B0aW9ucycpLCBvcHRpb25zKTtcbiAgXG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLk9iamVjdC5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIE9iamVjdCBNZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBFbnN1cmUgaXQgY2FuIHRyaWdnZXIgZXZlbnRzIHdpdGggQmFja2JvbmUuRXZlbnRzXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuT2JqZWN0LnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzLCB7XG4gIFxuICAgIC8vdGhpcyBpcyBhIG5vb3AgbWV0aG9kIGludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIHRoaXMgYmFzZVxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG4gIFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6ZGVzdHJveScpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdkZXN0cm95Jyk7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBJbXBvcnQgdGhlIGB0cmlnZ2VyTWV0aG9kYCB0byB0cmlnZ2VyIGV2ZW50cyB3aXRoIGNvcnJlc3BvbmRpbmdcbiAgICAvLyBtZXRob2RzIGlmIHRoZSBtZXRob2QgZXhpc3RzXG4gICAgdHJpZ2dlck1ldGhvZDogTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kLFxuICBcbiAgICAvLyBBIGhhbmR5IHdheSB0byBtZXJnZSBvcHRpb25zIG9udG8gdGhlIGluc3RhbmNlXG4gICAgbWVyZ2VPcHRpb25zOiBNYXJpb25ldHRlLm1lcmdlT3B0aW9ucyxcbiAgXG4gICAgLy8gUHJveHkgYGdldE9wdGlvbmAgdG8gZW5hYmxlIGdldHRpbmcgb3B0aW9ucyBmcm9tIHRoaXMgb3IgdGhpcy5vcHRpb25zIGJ5IG5hbWUuXG4gICAgZ2V0T3B0aW9uOiBNYXJpb25ldHRlLnByb3h5R2V0T3B0aW9uLFxuICBcbiAgICAvLyBQcm94eSBgYmluZEVudGl0eUV2ZW50c2AgdG8gZW5hYmxlIGJpbmRpbmcgdmlldydzIGV2ZW50cyBmcm9tIGFub3RoZXIgZW50aXR5LlxuICAgIGJpbmRFbnRpdHlFdmVudHM6IE1hcmlvbmV0dGUucHJveHlCaW5kRW50aXR5RXZlbnRzLFxuICBcbiAgICAvLyBQcm94eSBgdW5iaW5kRW50aXR5RXZlbnRzYCB0byBlbmFibGUgdW5iaW5kaW5nIHZpZXcncyBldmVudHMgZnJvbSBhbm90aGVyIGVudGl0eS5cbiAgICB1bmJpbmRFbnRpdHlFdmVudHM6IE1hcmlvbmV0dGUucHJveHlVbmJpbmRFbnRpdHlFdmVudHNcbiAgfSk7XG4gIFxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTYsIG1heHN0YXRlbWVudHM6IDQ1LCBtYXhsZW46IDEyMCAqL1xuICBcbiAgLy8gUmVnaW9uXG4gIC8vIC0tLS0tLVxuICBcbiAgLy8gTWFuYWdlIHRoZSB2aXN1YWwgcmVnaW9ucyBvZiB5b3VyIGNvbXBvc2l0ZSBhcHBsaWNhdGlvbi4gU2VlXG4gIC8vIGh0dHA6Ly9sb3N0ZWNoaWVzLmNvbS9kZXJpY2tiYWlsZXkvMjAxMS8xMi8xMi9jb21wb3NpdGUtanMtYXBwcy1yZWdpb25zLWFuZC1yZWdpb24tbWFuYWdlcnMvXG4gIFxuICBNYXJpb25ldHRlLlJlZ2lvbiA9IE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgXG4gICAgICAvLyBzZXQgb3B0aW9ucyB0ZW1wb3JhcmlseSBzbyB0aGF0IHdlIGNhbiBnZXQgYGVsYC5cbiAgICAgIC8vIG9wdGlvbnMgd2lsbCBiZSBvdmVycmlkZW4gYnkgT2JqZWN0LmNvbnN0cnVjdG9yXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMuZ2V0T3B0aW9uKCdlbCcpO1xuICBcbiAgICAgIC8vIEhhbmRsZSB3aGVuIHRoaXMuZWwgaXMgcGFzc2VkIGluIGFzIGEgJCB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICB0aGlzLmVsID0gdGhpcy5lbCBpbnN0YW5jZW9mIEJhY2tib25lLiQgPyB0aGlzLmVsWzBdIDogdGhpcy5lbDtcbiAgXG4gICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdOb0VsRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdBbiBcImVsXCIgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGEgcmVnaW9uLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy4kZWwgPSB0aGlzLmdldEVsKHRoaXMuZWwpO1xuICAgICAgTWFyaW9uZXR0ZS5PYmplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBEaXNwbGF5cyBhIGJhY2tib25lIHZpZXcgaW5zdGFuY2UgaW5zaWRlIG9mIHRoZSByZWdpb24uXG4gICAgLy8gSGFuZGxlcyBjYWxsaW5nIHRoZSBgcmVuZGVyYCBtZXRob2QgZm9yIHlvdS4gUmVhZHMgY29udGVudFxuICAgIC8vIGRpcmVjdGx5IGZyb20gdGhlIGBlbGAgYXR0cmlidXRlLiBBbHNvIGNhbGxzIGFuIG9wdGlvbmFsXG4gICAgLy8gYG9uU2hvd2AgYW5kIGBvbkRlc3Ryb3lgIG1ldGhvZCBvbiB5b3VyIHZpZXcsIGp1c3QgYWZ0ZXIgc2hvd2luZ1xuICAgIC8vIG9yIGp1c3QgYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIHZpZXcsIHJlc3BlY3RpdmVseS5cbiAgICAvLyBUaGUgYHByZXZlbnREZXN0cm95YCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcHJldmVudCBhIHZpZXcgZnJvbVxuICAgIC8vIHRoZSBvbGQgdmlldyBiZWluZyBkZXN0cm95ZWQgb24gc2hvdy5cbiAgICAvLyBUaGUgYGZvcmNlU2hvd2Agb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgdmlldyB0byBiZVxuICAgIC8vIHJlLXJlbmRlcmVkIGlmIGl0J3MgYWxyZWFkeSBzaG93biBpbiB0aGUgcmVnaW9uLlxuICAgIHNob3c6IGZ1bmN0aW9uKHZpZXcsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5fZW5zdXJlRWxlbWVudCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLl9lbnN1cmVWaWV3SXNJbnRhY3Qodmlldyk7XG4gIFxuICAgICAgdmFyIHNob3dPcHRpb25zICAgICA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgaXNEaWZmZXJlbnRWaWV3ID0gdmlldyAhPT0gdGhpcy5jdXJyZW50VmlldztcbiAgICAgIHZhciBwcmV2ZW50RGVzdHJveSAgPSAhIXNob3dPcHRpb25zLnByZXZlbnREZXN0cm95O1xuICAgICAgdmFyIGZvcmNlU2hvdyAgICAgICA9ICEhc2hvd09wdGlvbnMuZm9yY2VTaG93O1xuICBcbiAgICAgIC8vIFdlIGFyZSBvbmx5IGNoYW5naW5nIHRoZSB2aWV3IGlmIHRoZXJlIGlzIGEgY3VycmVudCB2aWV3IHRvIGNoYW5nZSB0byBiZWdpbiB3aXRoXG4gICAgICB2YXIgaXNDaGFuZ2luZ1ZpZXcgPSAhIXRoaXMuY3VycmVudFZpZXc7XG4gIFxuICAgICAgLy8gT25seSBkZXN0cm95IHRoZSBjdXJyZW50IHZpZXcgaWYgd2UgZG9uJ3Qgd2FudCB0byBgcHJldmVudERlc3Ryb3lgIGFuZCBpZlxuICAgICAgLy8gdGhlIHZpZXcgZ2l2ZW4gaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGRpZmZlcmVudCB0aGFuIGBjdXJyZW50Vmlld2BcbiAgICAgIHZhciBfc2hvdWxkRGVzdHJveVZpZXcgPSBpc0RpZmZlcmVudFZpZXcgJiYgIXByZXZlbnREZXN0cm95O1xuICBcbiAgICAgIC8vIE9ubHkgc2hvdyB0aGUgdmlldyBnaXZlbiBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQgaXMgZGlmZmVyZW50IHRoYW5cbiAgICAgIC8vIHRoZSBjdXJyZW50IHZpZXcgb3IgaWYgd2Ugd2FudCB0byByZS1zaG93IHRoZSB2aWV3LiBOb3RlIHRoYXQgaWZcbiAgICAgIC8vIGBfc2hvdWxkRGVzdHJveVZpZXdgIGlzIHRydWUsIHRoZW4gYF9zaG91bGRTaG93Vmlld2AgaXMgYWxzbyBuZWNlc3NhcmlseSB0cnVlLlxuICAgICAgdmFyIF9zaG91bGRTaG93VmlldyA9IGlzRGlmZmVyZW50VmlldyB8fCBmb3JjZVNob3c7XG4gIFxuICAgICAgaWYgKGlzQ2hhbmdpbmdWaWV3KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnN3YXBPdXQnLCB0aGlzLmN1cnJlbnRWaWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAodGhpcy5jdXJyZW50Vmlldykge1xuICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50Vmlldy5fcGFyZW50O1xuICAgICAgfVxuICBcbiAgICAgIGlmIChfc2hvdWxkRGVzdHJveVZpZXcpIHtcbiAgICAgICAgdGhpcy5lbXB0eSgpO1xuICBcbiAgICAgIC8vIEEgYGRlc3Ryb3lgIGV2ZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBjbGVhbiB1cCBtYW51YWxseSByZW1vdmVkIHZpZXdzLlxuICAgICAgLy8gV2UgbmVlZCB0byBkZXRhY2ggdGhpcyBldmVudCB3aGVuIGEgbmV3IHZpZXcgaXMgZ29pbmcgdG8gYmUgc2hvd24gYXMgaXRcbiAgICAgIC8vIGlzIG5vIGxvbmdlciByZWxldmFudC5cbiAgICAgIH0gZWxzZSBpZiAoaXNDaGFuZ2luZ1ZpZXcgJiYgX3Nob3VsZFNob3dWaWV3KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcub2ZmKCdkZXN0cm95JywgdGhpcy5lbXB0eSwgdGhpcyk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF9zaG91bGRTaG93Vmlldykge1xuICBcbiAgICAgICAgLy8gV2UgbmVlZCB0byBsaXN0ZW4gZm9yIGlmIGEgdmlldyBpcyBkZXN0cm95ZWRcbiAgICAgICAgLy8gaW4gYSB3YXkgb3RoZXIgdGhhbiB0aHJvdWdoIHRoZSByZWdpb24uXG4gICAgICAgIC8vIElmIHRoaXMgaGFwcGVucyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50VmlldyBzaW5jZSBvbmNlIGEgdmlldyBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICAgICAgLy8gd2UgY2FuIG5vdCByZXVzZSBpdC5cbiAgICAgICAgdmlldy5vbmNlKCdkZXN0cm95JywgdGhpcy5lbXB0eSwgdGhpcyk7XG4gICAgICAgIHZpZXcucmVuZGVyKCk7XG4gIFxuICAgICAgICB2aWV3Ll9wYXJlbnQgPSB0aGlzO1xuICBcbiAgICAgICAgaWYgKGlzQ2hhbmdpbmdWaWV3KSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3dhcCcsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gIFxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzaG93JywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdiZWZvcmU6c2hvdycsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICBcbiAgICAgICAgaWYgKGlzQ2hhbmdpbmdWaWV3KSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzd2FwT3V0JywgdGhpcy5jdXJyZW50VmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIEFuIGFycmF5IG9mIHZpZXdzIHRoYXQgd2UncmUgYWJvdXQgdG8gZGlzcGxheVxuICAgICAgICB2YXIgYXR0YWNoZWRSZWdpb24gPSBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkKHRoaXMuZWwpO1xuICBcbiAgICAgICAgLy8gVGhlIHZpZXdzIHRoYXQgd2UncmUgYWJvdXQgdG8gYXR0YWNoIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIHByZXZlbnQgX2dldE5lc3RlZFZpZXdzIGZyb20gYmVpbmcgZXhlY3V0ZWQgdW5uZWNlc3NhcmlseVxuICAgICAgICAvLyBhcyBpdCdzIGEgcG90ZW50aWFsbHktc2xvdyBtZXRob2RcbiAgICAgICAgdmFyIGRpc3BsYXllZFZpZXdzID0gW107XG4gIFxuICAgICAgICB2YXIgYXR0YWNoT3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgICB0cmlnZ2VyQmVmb3JlQXR0YWNoOiB0aGlzLnRyaWdnZXJCZWZvcmVBdHRhY2gsXG4gICAgICAgICAgdHJpZ2dlckF0dGFjaDogdGhpcy50cmlnZ2VyQXR0YWNoXG4gICAgICAgIH0sIHNob3dPcHRpb25zKTtcbiAgXG4gICAgICAgIGlmIChhdHRhY2hlZFJlZ2lvbiAmJiBhdHRhY2hPcHRpb25zLnRyaWdnZXJCZWZvcmVBdHRhY2gpIHtcbiAgICAgICAgICBkaXNwbGF5ZWRWaWV3cyA9IHRoaXMuX2Rpc3BsYXllZFZpZXdzKHZpZXcpO1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBdHRhY2goZGlzcGxheWVkVmlld3MsICdiZWZvcmU6Jyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMuYXR0YWNoSHRtbCh2aWV3KTtcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZpZXc7XG4gIFxuICAgICAgICBpZiAoYXR0YWNoZWRSZWdpb24gJiYgYXR0YWNoT3B0aW9ucy50cmlnZ2VyQXR0YWNoKSB7XG4gICAgICAgICAgZGlzcGxheWVkVmlld3MgPSB0aGlzLl9kaXNwbGF5ZWRWaWV3cyh2aWV3KTtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXR0YWNoKGRpc3BsYXllZFZpZXdzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGlzQ2hhbmdpbmdWaWV3KSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzd2FwJywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnc2hvdycsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCAnc2hvdycsIHZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgdHJpZ2dlckJlZm9yZUF0dGFjaDogdHJ1ZSxcbiAgICB0cmlnZ2VyQXR0YWNoOiB0cnVlLFxuICBcbiAgICBfdHJpZ2dlckF0dGFjaDogZnVuY3Rpb24odmlld3MsIHByZWZpeCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IChwcmVmaXggfHwgJycpICsgJ2F0dGFjaCc7XG4gICAgICBfLmVhY2godmlld3MsIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgZXZlbnROYW1lLCB2aWV3LCB0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIF9kaXNwbGF5ZWRWaWV3czogZnVuY3Rpb24odmlldykge1xuICAgICAgcmV0dXJuIF8udW5pb24oW3ZpZXddLCBfLnJlc3VsdCh2aWV3LCAnX2dldE5lc3RlZFZpZXdzJykgfHwgW10pO1xuICAgIH0sXG4gIFxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdCh0aGlzLmVsKSkge1xuICAgICAgICB0aGlzLiRlbCA9IHRoaXMuZ2V0RWwodGhpcy5lbCk7XG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIXRoaXMuJGVsIHx8IHRoaXMuJGVsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ2FsbG93TWlzc2luZ0VsJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3IoJ0FuIFwiZWxcIiAnICsgdGhpcy4kZWwuc2VsZWN0b3IgKyAnIG11c3QgZXhpc3QgaW4gRE9NJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gIFxuICAgIF9lbnN1cmVWaWV3SXNJbnRhY3Q6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIGlmICghdmlldykge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdOb3RWYWxpZCcsXG4gICAgICAgICAgbWVzc2FnZTogJ1RoZSB2aWV3IHBhc3NlZCBpcyB1bmRlZmluZWQgYW5kIHRoZXJlZm9yZSBpbnZhbGlkLiBZb3UgbXVzdCBwYXNzIGEgdmlldyBpbnN0YW5jZSB0byBzaG93LidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdWaWV3RGVzdHJveWVkRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdWaWV3IChjaWQ6IFwiJyArIHZpZXcuY2lkICsgJ1wiKSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCBhbmQgY2Fubm90IGJlIHVzZWQuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgaG93IHRoZSByZWdpb24gZmluZHMgdGhlIERPTVxuICAgIC8vIGVsZW1lbnQgdGhhdCBpdCBtYW5hZ2VzLiBSZXR1cm4gYSBqUXVlcnkgc2VsZWN0b3Igb2JqZWN0IHNjb3BlZFxuICAgIC8vIHRvIGEgcHJvdmlkZWQgcGFyZW50IGVsIG9yIHRoZSBkb2N1bWVudCBpZiBub25lIGV4aXN0cy5cbiAgICBnZXRFbDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBCYWNrYm9uZS4kKGVsLCBNYXJpb25ldHRlLl9nZXRWYWx1ZSh0aGlzLm9wdGlvbnMucGFyZW50RWwsIHRoaXMpKTtcbiAgICB9LFxuICBcbiAgICAvLyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgaG93IHRoZSBuZXcgdmlldyBpc1xuICAgIC8vIGFwcGVuZGVkIHRvIHRoZSBgJGVsYCB0aGF0IHRoZSByZWdpb24gaXMgbWFuYWdpbmdcbiAgICBhdHRhY2hIdG1sOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICB0aGlzLiRlbC5jb250ZW50cygpLmRldGFjaCgpO1xuICBcbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodmlldy5lbCk7XG4gICAgfSxcbiAgXG4gICAgLy8gRGVzdHJveSB0aGUgY3VycmVudCB2aWV3LCBpZiB0aGVyZSBpcyBvbmUuIElmIHRoZXJlIGlzIG5vXG4gICAgLy8gY3VycmVudCB2aWV3LCBpdCBkb2VzIG5vdGhpbmcgYW5kIHJldHVybnMgaW1tZWRpYXRlbHkuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICB2YXIgcHJldmVudERlc3Ryb3kgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShvcHRpb25zLCAncHJldmVudERlc3Ryb3knLCB0aGlzKTtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHZpZXcgaW4gdGhlIHJlZ2lvblxuICAgICAgLy8gd2Ugc2hvdWxkIG5vdCByZW1vdmUgYW55dGhpbmdcbiAgICAgIGlmICghdmlldykgeyByZXR1cm47IH1cbiAgXG4gICAgICB2aWV3Lm9mZignZGVzdHJveScsIHRoaXMuZW1wdHksIHRoaXMpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6ZW1wdHknLCB2aWV3KTtcbiAgICAgIGlmICghcHJldmVudERlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveVZpZXcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnZW1wdHknLCB2aWV3KTtcbiAgXG4gICAgICAvLyBSZW1vdmUgcmVnaW9uIHBvaW50ZXIgdG8gdGhlIGN1cnJlbnRWaWV3XG4gICAgICBkZWxldGUgdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICBpZiAocHJldmVudERlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy4kZWwuY29udGVudHMoKS5kZXRhY2goKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBjYWxsICdkZXN0cm95JyBvciAncmVtb3ZlJywgZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGZvdW5kXG4gICAgLy8gb24gdGhlIHZpZXcgKGlmIHNob3dpbmcgYSByYXcgQmFja2JvbmUgdmlldyBvciBhIE1hcmlvbmV0dGUgVmlldylcbiAgICBfZGVzdHJveVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3O1xuICBcbiAgICAgIGlmICh2aWV3LmRlc3Ryb3kgJiYgIXZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICB9IGVsc2UgaWYgKHZpZXcucmVtb3ZlKSB7XG4gICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gIFxuICAgICAgICAvLyBhcHBlbmRpbmcgaXNEZXN0cm95ZWQgdG8gcmF3IEJhY2tib25lIFZpZXcgYWxsb3dzIHJlZ2lvbnNcbiAgICAgICAgLy8gdG8gdGhyb3cgYSBWaWV3RGVzdHJveWVkRXJyb3IgZm9yIHRoaXMgdmlld1xuICAgICAgICB2aWV3LmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBBdHRhY2ggYW4gZXhpc3RpbmcgdmlldyB0byB0aGUgcmVnaW9uLiBUaGlzXG4gICAgLy8gd2lsbCBub3QgY2FsbCBgcmVuZGVyYCBvciBgb25TaG93YCBmb3IgdGhlIG5ldyB2aWV3LFxuICAgIC8vIGFuZCB3aWxsIG5vdCByZXBsYWNlIHRoZSBjdXJyZW50IEhUTUwgZm9yIHRoZSBgZWxgXG4gICAgLy8gb2YgdGhlIHJlZ2lvbi5cbiAgICBhdHRhY2hWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdmlldztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGEgdmlldyBpcyBjdXJyZW50bHkgcHJlc2VudCB3aXRoaW5cbiAgICAvLyB0aGUgcmVnaW9uLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhbmQgYGZhbHNlYCBpZlxuICAgIC8vIG5vIHZpZXcgaXMgcHJlc2VudC5cbiAgICBoYXNWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuY3VycmVudFZpZXc7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVzZXQgdGhlIHJlZ2lvbiBieSBkZXN0cm95aW5nIGFueSBleGlzdGluZyB2aWV3IGFuZFxuICAgIC8vIGNsZWFyaW5nIG91dCB0aGUgY2FjaGVkIGAkZWxgLiBUaGUgbmV4dCB0aW1lIGEgdmlld1xuICAgIC8vIGlzIHNob3duIHZpYSB0aGlzIHJlZ2lvbiwgdGhlIHJlZ2lvbiB3aWxsIHJlLXF1ZXJ5IHRoZVxuICAgIC8vIERPTSBmb3IgdGhlIHJlZ2lvbidzIGBlbGAuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbXB0eSgpO1xuICBcbiAgICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgICB0aGlzLmVsID0gdGhpcy4kZWwuc2VsZWN0b3I7XG4gICAgICB9XG4gIFxuICAgICAgZGVsZXRlIHRoaXMuJGVsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICBcbiAgfSxcbiAgXG4gIC8vIFN0YXRpYyBNZXRob2RzXG4gIHtcbiAgXG4gICAgLy8gQnVpbGQgYW4gaW5zdGFuY2Ugb2YgYSByZWdpb24gYnkgcGFzc2luZyBpbiBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgLy8gYW5kIGEgZGVmYXVsdCByZWdpb24gY2xhc3MgdG8gdXNlIGlmIG5vbmUgaXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcuXG4gICAgLy9cbiAgICAvLyBUaGUgY29uZmlnIG9iamVjdCBzaG91bGQgZWl0aGVyIGJlIGEgc3RyaW5nIGFzIGEgalF1ZXJ5IERPTSBzZWxlY3RvcixcbiAgICAvLyBhIFJlZ2lvbiBjbGFzcyBkaXJlY3RseSwgb3IgYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCBzcGVjaWZpZXMgYSBzZWxlY3RvcixcbiAgICAvLyBhIGN1c3RvbSByZWdpb25DbGFzcywgYW5kIGFueSBvcHRpb25zIHRvIGJlIHN1cHBsaWVkIHRvIHRoZSByZWdpb246XG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIHtcbiAgICAvLyAgIHNlbGVjdG9yOiBcIiNmb29cIixcbiAgICAvLyAgIHJlZ2lvbkNsYXNzOiBNeUN1c3RvbVJlZ2lvbixcbiAgICAvLyAgIGFsbG93TWlzc2luZ0VsOiBmYWxzZVxuICAgIC8vIH1cbiAgICAvLyBgYGBcbiAgICAvL1xuICAgIGJ1aWxkUmVnaW9uOiBmdW5jdGlvbihyZWdpb25Db25maWcsIERlZmF1bHRSZWdpb25DbGFzcykge1xuICAgICAgaWYgKF8uaXNTdHJpbmcocmVnaW9uQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZWdpb25Gcm9tU2VsZWN0b3IocmVnaW9uQ29uZmlnLCBEZWZhdWx0UmVnaW9uQ2xhc3MpO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChyZWdpb25Db25maWcuc2VsZWN0b3IgfHwgcmVnaW9uQ29uZmlnLmVsIHx8IHJlZ2lvbkNvbmZpZy5yZWdpb25DbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZWdpb25Gcm9tT2JqZWN0KHJlZ2lvbkNvbmZpZywgRGVmYXVsdFJlZ2lvbkNsYXNzKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHJlZ2lvbkNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9uRnJvbVJlZ2lvbkNsYXNzKHJlZ2lvbkNvbmZpZyk7XG4gICAgICB9XG4gIFxuICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnSW1wcm9wZXIgcmVnaW9uIGNvbmZpZ3VyYXRpb24gdHlwZS4nLFxuICAgICAgICB1cmw6ICdtYXJpb25ldHRlLnJlZ2lvbi5odG1sI3JlZ2lvbi1jb25maWd1cmF0aW9uLXR5cGVzJ1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gQnVpbGQgdGhlIHJlZ2lvbiBmcm9tIGEgc3RyaW5nIHNlbGVjdG9yIGxpa2UgJyNmb28tcmVnaW9uJ1xuICAgIF9idWlsZFJlZ2lvbkZyb21TZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIERlZmF1bHRSZWdpb25DbGFzcykge1xuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0UmVnaW9uQ2xhc3Moe2VsOiBzZWxlY3Rvcn0pO1xuICAgIH0sXG4gIFxuICAgIC8vIEJ1aWxkIHRoZSByZWdpb24gZnJvbSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgLy8gYGBganNcbiAgICAvLyB7IHNlbGVjdG9yOiAnI2ZvbycsIHJlZ2lvbkNsYXNzOiBGb29SZWdpb24sIGFsbG93TWlzc2luZ0VsOiBmYWxzZSB9XG4gICAgLy8gYGBgXG4gICAgX2J1aWxkUmVnaW9uRnJvbU9iamVjdDogZnVuY3Rpb24ocmVnaW9uQ29uZmlnLCBEZWZhdWx0UmVnaW9uQ2xhc3MpIHtcbiAgICAgIHZhciBSZWdpb25DbGFzcyA9IHJlZ2lvbkNvbmZpZy5yZWdpb25DbGFzcyB8fCBEZWZhdWx0UmVnaW9uQ2xhc3M7XG4gICAgICB2YXIgb3B0aW9ucyA9IF8ub21pdChyZWdpb25Db25maWcsICdzZWxlY3RvcicsICdyZWdpb25DbGFzcycpO1xuICBcbiAgICAgIGlmIChyZWdpb25Db25maWcuc2VsZWN0b3IgJiYgIW9wdGlvbnMuZWwpIHtcbiAgICAgICAgb3B0aW9ucy5lbCA9IHJlZ2lvbkNvbmZpZy5zZWxlY3RvcjtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbmV3IFJlZ2lvbkNsYXNzKG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEJ1aWxkIHRoZSByZWdpb24gZGlyZWN0bHkgZnJvbSBhIGdpdmVuIGBSZWdpb25DbGFzc2BcbiAgICBfYnVpbGRSZWdpb25Gcm9tUmVnaW9uQ2xhc3M6IGZ1bmN0aW9uKFJlZ2lvbkNsYXNzKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ2lvbkNsYXNzKCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIFJlZ2lvbiBNYW5hZ2VyXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBNYW5hZ2Ugb25lIG9yIG1vcmUgcmVsYXRlZCBgTWFyaW9uZXR0ZS5SZWdpb25gIG9iamVjdHMuXG4gIE1hcmlvbmV0dGUuUmVnaW9uTWFuYWdlciA9IE1hcmlvbmV0dGUuQ29udHJvbGxlci5leHRlbmQoe1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9yZWdpb25zID0ge307XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5Db250cm9sbGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFxuICAgICAgdGhpcy5hZGRSZWdpb25zKHRoaXMuZ2V0T3B0aW9uKCdyZWdpb25zJykpO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBtdWx0aXBsZSByZWdpb25zIHVzaW5nIGFuIG9iamVjdCBsaXRlcmFsIG9yIGFcbiAgICAvLyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IGxpdGVyYWwsIHdoZXJlXG4gICAgLy8gZWFjaCBrZXkgYmVjb21lcyB0aGUgcmVnaW9uIG5hbWUsIGFuZCBlYWNoIHZhbHVlIGlzXG4gICAgLy8gdGhlIHJlZ2lvbiBkZWZpbml0aW9uLlxuICAgIGFkZFJlZ2lvbnM6IGZ1bmN0aW9uKHJlZ2lvbkRlZmluaXRpb25zLCBkZWZhdWx0cykge1xuICAgICAgcmVnaW9uRGVmaW5pdGlvbnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShyZWdpb25EZWZpbml0aW9ucywgdGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICByZXR1cm4gXy5yZWR1Y2UocmVnaW9uRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKHJlZ2lvbnMsIGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0ge3NlbGVjdG9yOiBkZWZpbml0aW9ufTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5zZWxlY3Rvcikge1xuICAgICAgICAgIGRlZmluaXRpb24gPSBfLmRlZmF1bHRzKHt9LCBkZWZpbml0aW9uLCBkZWZhdWx0cyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJlZ2lvbnNbbmFtZV0gPSB0aGlzLmFkZFJlZ2lvbihuYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvbnM7XG4gICAgICB9LCB7fSwgdGhpcyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIGFuIGluZGl2aWR1YWwgcmVnaW9uIHRvIHRoZSByZWdpb24gbWFuYWdlcixcbiAgICAvLyBhbmQgcmV0dXJuIHRoZSByZWdpb24gaW5zdGFuY2VcbiAgICBhZGRSZWdpb246IGZ1bmN0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgIHZhciByZWdpb247XG4gIFxuICAgICAgaWYgKGRlZmluaXRpb24gaW5zdGFuY2VvZiBNYXJpb25ldHRlLlJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSBkZWZpbml0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaW9uID0gTWFyaW9uZXR0ZS5SZWdpb24uYnVpbGRSZWdpb24oZGVmaW5pdGlvbiwgTWFyaW9uZXR0ZS5SZWdpb24pO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOmFkZDpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICBcbiAgICAgIHJlZ2lvbi5fcGFyZW50ID0gdGhpcztcbiAgICAgIHRoaXMuX3N0b3JlKG5hbWUsIHJlZ2lvbik7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdhZGQ6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIHJldHVybiByZWdpb247XG4gICAgfSxcbiAgXG4gICAgLy8gR2V0IGEgcmVnaW9uIGJ5IG5hbWVcbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25zW25hbWVdO1xuICAgIH0sXG4gIFxuICAgIC8vIEdldHMgYWxsIHRoZSByZWdpb25zIGNvbnRhaW5lZCB3aXRoaW5cbiAgICAvLyB0aGUgYHJlZ2lvbk1hbmFnZXJgIGluc3RhbmNlLlxuICAgIGdldFJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcmVnaW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVtb3ZlIGEgcmVnaW9uIGJ5IG5hbWVcbiAgICByZW1vdmVSZWdpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZWdpb24gPSB0aGlzLl9yZWdpb25zW25hbWVdO1xuICAgICAgdGhpcy5fcmVtb3ZlKG5hbWUsIHJlZ2lvbik7XG4gIFxuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9LFxuICBcbiAgICAvLyBFbXB0eSBhbGwgcmVnaW9ucyBpbiB0aGUgcmVnaW9uIG1hbmFnZXIsIGFuZFxuICAgIC8vIHJlbW92ZSB0aGVtXG4gICAgcmVtb3ZlUmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVnaW9ucyA9IHRoaXMuZ2V0UmVnaW9ucygpO1xuICAgICAgXy5lYWNoKHRoaXMuX3JlZ2lvbnMsIGZ1bmN0aW9uKHJlZ2lvbiwgbmFtZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmUobmFtZSwgcmVnaW9uKTtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIHJldHVybiByZWdpb25zO1xuICAgIH0sXG4gIFxuICAgIC8vIEVtcHR5IGFsbCByZWdpb25zIGluIHRoZSByZWdpb24gbWFuYWdlciwgYnV0XG4gICAgLy8gbGVhdmUgdGhlbSBhdHRhY2hlZFxuICAgIGVtcHR5UmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVnaW9ucyA9IHRoaXMuZ2V0UmVnaW9ucygpO1xuICAgICAgXy5pbnZva2UocmVnaW9ucywgJ2VtcHR5Jyk7XG4gICAgICByZXR1cm4gcmVnaW9ucztcbiAgICB9LFxuICBcbiAgICAvLyBEZXN0cm95IGFsbCByZWdpb25zIGFuZCBzaHV0IGRvd24gdGhlIHJlZ2lvblxuICAgIC8vIG1hbmFnZXIgZW50aXJlbHlcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVnaW9ucygpO1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuQ29udHJvbGxlci5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBzdG9yZSByZWdpb25zXG4gICAgX3N0b3JlOiBmdW5jdGlvbihuYW1lLCByZWdpb24pIHtcbiAgICAgIGlmICghdGhpcy5fcmVnaW9uc1tuYW1lXSkge1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX3JlZ2lvbnNbbmFtZV0gPSByZWdpb247XG4gICAgfSxcbiAgXG4gICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIHJlbW92ZSBhIHJlZ2lvblxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVtb3ZlOnJlZ2lvbicsIG5hbWUsIHJlZ2lvbik7XG4gICAgICByZWdpb24uZW1wdHkoKTtcbiAgICAgIHJlZ2lvbi5zdG9wTGlzdGVuaW5nKCk7XG4gIFxuICAgICAgZGVsZXRlIHJlZ2lvbi5fcGFyZW50O1xuICAgICAgZGVsZXRlIHRoaXMuX3JlZ2lvbnNbbmFtZV07XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW1vdmU6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgTWFyaW9uZXR0ZS5hY3RBc0NvbGxlY3Rpb24oTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyLnByb3RvdHlwZSwgJ19yZWdpb25zJyk7XG4gIFxuXG4gIC8vIFRlbXBsYXRlIENhY2hlXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBNYW5hZ2UgdGVtcGxhdGVzIHN0b3JlZCBpbiBgPHNjcmlwdD5gIGJsb2NrcyxcbiAgLy8gY2FjaGluZyB0aGVtIGZvciBmYXN0ZXIgYWNjZXNzLlxuICBNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUgPSBmdW5jdGlvbih0ZW1wbGF0ZUlkKSB7XG4gICAgdGhpcy50ZW1wbGF0ZUlkID0gdGVtcGxhdGVJZDtcbiAgfTtcbiAgXG4gIC8vIFRlbXBsYXRlQ2FjaGUgb2JqZWN0LWxldmVsIG1ldGhvZHMuIE1hbmFnZSB0aGUgdGVtcGxhdGVcbiAgLy8gY2FjaGVzIGZyb20gdGhlc2UgbWV0aG9kIGNhbGxzIGluc3RlYWQgb2YgY3JlYXRpbmdcbiAgLy8geW91ciBvd24gVGVtcGxhdGVDYWNoZSBpbnN0YW5jZXNcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5UZW1wbGF0ZUNhY2hlLCB7XG4gICAgdGVtcGxhdGVDYWNoZXM6IHt9LFxuICBcbiAgICAvLyBHZXQgdGhlIHNwZWNpZmllZCB0ZW1wbGF0ZSBieSBpZC4gRWl0aGVyXG4gICAgLy8gcmV0cmlldmVzIHRoZSBjYWNoZWQgdmVyc2lvbiwgb3IgbG9hZHMgaXRcbiAgICAvLyBmcm9tIHRoZSBET00uXG4gICAgZ2V0OiBmdW5jdGlvbih0ZW1wbGF0ZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVkVGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlQ2FjaGVzW3RlbXBsYXRlSWRdO1xuICBcbiAgICAgIGlmICghY2FjaGVkVGVtcGxhdGUpIHtcbiAgICAgICAgY2FjaGVkVGVtcGxhdGUgPSBuZXcgTWFyaW9uZXR0ZS5UZW1wbGF0ZUNhY2hlKHRlbXBsYXRlSWQpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQ2FjaGVzW3RlbXBsYXRlSWRdID0gY2FjaGVkVGVtcGxhdGU7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIGNhY2hlZFRlbXBsYXRlLmxvYWQob3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ2xlYXIgdGVtcGxhdGVzIGZyb20gdGhlIGNhY2hlLiBJZiBubyBhcmd1bWVudHNcbiAgICAvLyBhcmUgc3BlY2lmaWVkLCBjbGVhcnMgYWxsIHRlbXBsYXRlczpcbiAgICAvLyBgY2xlYXIoKWBcbiAgICAvL1xuICAgIC8vIElmIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkLCBjbGVhcnMgZWFjaCBvZiB0aGVcbiAgICAvLyBzcGVjaWZpZWQgdGVtcGxhdGVzIGZyb20gdGhlIGNhY2hlOlxuICAgIC8vIGBjbGVhcihcIiN0MVwiLCBcIiN0MlwiLCBcIi4uLlwiKWBcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIFxuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGVtcGxhdGVDYWNoZXNbYXJnc1tpXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVDYWNoZXMgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gVGVtcGxhdGVDYWNoZSBpbnN0YW5jZSBtZXRob2RzLCBhbGxvd2luZyBlYWNoXG4gIC8vIHRlbXBsYXRlIGNhY2hlIG9iamVjdCB0byBtYW5hZ2UgaXRzIG93biBzdGF0ZVxuICAvLyBhbmQga25vdyB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgYmVlbiBsb2FkZWRcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5UZW1wbGF0ZUNhY2hlLnByb3RvdHlwZSwge1xuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gbG9hZCB0aGUgdGVtcGxhdGVcbiAgICBsb2FkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBHdWFyZCBjbGF1c2UgdG8gcHJldmVudCBsb2FkaW5nIHRoaXMgdGVtcGxhdGUgbW9yZSB0aGFuIG9uY2VcbiAgICAgIGlmICh0aGlzLmNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBMb2FkIHRoZSB0ZW1wbGF0ZSBhbmQgY29tcGlsZSBpdFxuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5sb2FkVGVtcGxhdGUodGhpcy50ZW1wbGF0ZUlkLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZFRlbXBsYXRlO1xuICAgIH0sXG4gIFxuICAgIC8vIExvYWQgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBET00sIGJ5IGRlZmF1bHQuIE92ZXJyaWRlXG4gICAgLy8gdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB5b3VyIG93biB0ZW1wbGF0ZSByZXRyaWV2YWxcbiAgICAvLyBGb3IgYXN5bmNocm9ub3VzIGxvYWRpbmcgd2l0aCBBTUQvUmVxdWlyZUpTLCBjb25zaWRlclxuICAgIC8vIHVzaW5nIGEgdGVtcGxhdGUtbG9hZGVyIHBsdWdpbiBhcyBkZXNjcmliZWQgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLm1hcmlvbmV0dGUvd2lraS9Vc2luZy1tYXJpb25ldHRlLXdpdGgtcmVxdWlyZWpzXG4gICAgbG9hZFRlbXBsYXRlOiBmdW5jdGlvbih0ZW1wbGF0ZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBCYWNrYm9uZS4kKHRlbXBsYXRlSWQpLmh0bWwoKTtcbiAgXG4gICAgICBpZiAoIXRlbXBsYXRlIHx8IHRlbXBsYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ05vVGVtcGxhdGVFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlOiBcIicgKyB0ZW1wbGF0ZUlkICsgJ1wiJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfSxcbiAgXG4gICAgLy8gUHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlIGJlZm9yZSBjYWNoaW5nIGl0LiBPdmVycmlkZVxuICAgIC8vIHRoaXMgbWV0aG9kIGlmIHlvdSBkbyBub3QgbmVlZCB0byBwcmUtY29tcGlsZSBhIHRlbXBsYXRlXG4gICAgLy8gKEpTVCAvIFJlcXVpcmVKUyBmb3IgZXhhbXBsZSkgb3IgaWYgeW91IHdhbnQgdG8gY2hhbmdlXG4gICAgLy8gdGhlIHRlbXBsYXRlIGVuZ2luZSB1c2VkIChIYW5kZWJhcnMsIGV0YykuXG4gICAgY29tcGlsZVRlbXBsYXRlOiBmdW5jdGlvbihyYXdUZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF8udGVtcGxhdGUocmF3VGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBSZW5kZXJlclxuICAvLyAtLS0tLS0tLVxuICBcbiAgLy8gUmVuZGVyIGEgdGVtcGxhdGUgd2l0aCBkYXRhIGJ5IHBhc3NpbmcgaW4gdGhlIHRlbXBsYXRlXG4gIC8vIHNlbGVjdG9yIGFuZCB0aGUgZGF0YSB0byByZW5kZXIuXG4gIE1hcmlvbmV0dGUuUmVuZGVyZXIgPSB7XG4gIFxuICAgIC8vIFJlbmRlciBhIHRlbXBsYXRlIHdpdGggZGF0YS4gVGhlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIGlzXG4gICAgLy8gcGFzc2VkIHRvIHRoZSBgVGVtcGxhdGVDYWNoZWAgb2JqZWN0IHRvIHJldHJpZXZlIHRoZVxuICAgIC8vIHRlbXBsYXRlIGZ1bmN0aW9uLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHlvdXIgb3duXG4gICAgLy8gY3VzdG9tIHJlbmRlcmluZyBhbmQgdGVtcGxhdGUgaGFuZGxpbmcgZm9yIGFsbCBvZiBNYXJpb25ldHRlLlxuICAgIHJlbmRlcjogZnVuY3Rpb24odGVtcGxhdGUsIGRhdGEpIHtcbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdUZW1wbGF0ZU5vdEZvdW5kRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgcmVuZGVyIHRoZSB0ZW1wbGF0ZSBzaW5jZSBpdHMgZmFsc2UsIG51bGwgb3IgdW5kZWZpbmVkLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHRlbXBsYXRlRnVuYyA9IF8uaXNGdW5jdGlvbih0ZW1wbGF0ZSkgPyB0ZW1wbGF0ZSA6IE1hcmlvbmV0dGUuVGVtcGxhdGVDYWNoZS5nZXQodGVtcGxhdGUpO1xuICBcbiAgICAgIHJldHVybiB0ZW1wbGF0ZUZ1bmMoZGF0YSk7XG4gICAgfVxuICB9O1xuICBcblxuICAvKiBqc2hpbnQgbWF4bGVuOiAxMTQsIG5vbmV3OiBmYWxzZSAqL1xuICAvLyBWaWV3XG4gIC8vIC0tLS1cbiAgXG4gIC8vIFRoZSBjb3JlIHZpZXcgY2xhc3MgdGhhdCBvdGhlciBNYXJpb25ldHRlIHZpZXdzIGV4dGVuZCBmcm9tLlxuICBNYXJpb25ldHRlLlZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICBcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgXy5iaW5kQWxsKHRoaXMsICdyZW5kZXInKTtcbiAgXG4gICAgICBvcHRpb25zID0gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUob3B0aW9ucywgdGhpcyk7XG4gIFxuICAgICAgLy8gdGhpcyBleHBvc2VzIHZpZXcgb3B0aW9ucyB0byB0aGUgdmlldyBpbml0aWFsaXplclxuICAgICAgLy8gdGhpcyBpcyBhIGJhY2tmaWxsIHNpbmNlIGJhY2tib25lIHJlbW92ZWQgdGhlIGFzc2lnbm1lbnRcbiAgICAgIC8vIG9mIHRoaXMub3B0aW9uc1xuICAgICAgLy8gYXQgc29tZSBwb2ludCBob3dldmVyIHRoaXMgbWF5IGJlIHJlbW92ZWRcbiAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBfLnJlc3VsdCh0aGlzLCAnb3B0aW9ucycpLCBvcHRpb25zKTtcbiAgXG4gICAgICB0aGlzLl9iZWhhdmlvcnMgPSBNYXJpb25ldHRlLkJlaGF2aW9ycyh0aGlzKTtcbiAgXG4gICAgICBCYWNrYm9uZS5WaWV3LmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgXG4gICAgICBNYXJpb25ldHRlLk1vbml0b3JET01SZWZyZXNoKHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEdldCB0aGUgdGVtcGxhdGUgZm9yIHRoaXMgdmlld1xuICAgIC8vIGluc3RhbmNlLiBZb3UgY2FuIHNldCBhIGB0ZW1wbGF0ZWAgYXR0cmlidXRlIGluIHRoZSB2aWV3XG4gICAgLy8gZGVmaW5pdGlvbiBvciBwYXNzIGEgYHRlbXBsYXRlOiBcIndoYXRldmVyXCJgIHBhcmFtZXRlciBpblxuICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgIGdldFRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbigndGVtcGxhdGUnKTtcbiAgICB9LFxuICBcbiAgICAvLyBTZXJpYWxpemUgYSBtb2RlbCBieSByZXR1cm5pbmcgaXRzIGF0dHJpYnV0ZXMuIENsb25lc1xuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRvIGFsbG93IG1vZGlmaWNhdGlvbi5cbiAgICBzZXJpYWxpemVNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbC50b0pTT04uYXBwbHkobW9kZWwsIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgICB9LFxuICBcbiAgICAvLyBNaXggaW4gdGVtcGxhdGUgaGVscGVyIG1ldGhvZHMuIExvb2tzIGZvciBhXG4gICAgLy8gYHRlbXBsYXRlSGVscGVyc2AgYXR0cmlidXRlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGFuXG4gICAgLy8gb2JqZWN0IGxpdGVyYWwsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdFxuICAgIC8vIGxpdGVyYWwuIEFsbCBtZXRob2RzIGFuZCBhdHRyaWJ1dGVzIGZyb20gdGhpcyBvYmplY3RcbiAgICAvLyBhcmUgY29waWVzIHRvIHRoZSBvYmplY3QgcGFzc2VkIGluLlxuICAgIG1peGluVGVtcGxhdGVIZWxwZXJzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICAgIHZhciB0ZW1wbGF0ZUhlbHBlcnMgPSB0aGlzLmdldE9wdGlvbigndGVtcGxhdGVIZWxwZXJzJyk7XG4gICAgICB0ZW1wbGF0ZUhlbHBlcnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZSh0ZW1wbGF0ZUhlbHBlcnMsIHRoaXMpO1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHRhcmdldCwgdGVtcGxhdGVIZWxwZXJzKTtcbiAgICB9LFxuICBcbiAgICAvLyBub3JtYWxpemUgdGhlIGtleXMgb2YgcGFzc2VkIGhhc2ggd2l0aCB0aGUgdmlld3MgYHVpYCBzZWxlY3RvcnMuXG4gICAgLy8gYHtcIkB1aS5mb29cIjogXCJiYXJcIn1gXG4gICAgbm9ybWFsaXplVUlLZXlzOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgICB2YXIgdWlCaW5kaW5ncyA9IF8ucmVzdWx0KHRoaXMsICdfdWlCaW5kaW5ncycpO1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUubm9ybWFsaXplVUlLZXlzKGhhc2gsIHVpQmluZGluZ3MgfHwgXy5yZXN1bHQodGhpcywgJ3VpJykpO1xuICAgIH0sXG4gIFxuICAgIC8vIG5vcm1hbGl6ZSB0aGUgdmFsdWVzIG9mIHBhc3NlZCBoYXNoIHdpdGggdGhlIHZpZXdzIGB1aWAgc2VsZWN0b3JzLlxuICAgIC8vIGB7Zm9vOiBcIkB1aS5iYXJcIn1gXG4gICAgbm9ybWFsaXplVUlWYWx1ZXM6IGZ1bmN0aW9uKGhhc2gsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciB1aSA9IF8ucmVzdWx0KHRoaXMsICd1aScpO1xuICAgICAgdmFyIHVpQmluZGluZ3MgPSBfLnJlc3VsdCh0aGlzLCAnX3VpQmluZGluZ3MnKTtcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJVmFsdWVzKGhhc2gsIHVpQmluZGluZ3MgfHwgdWksIHByb3BlcnRpZXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIENvbmZpZ3VyZSBgdHJpZ2dlcnNgIHRvIGZvcndhcmQgRE9NIGV2ZW50cyB0byB2aWV3XG4gICAgLy8gZXZlbnRzLiBgdHJpZ2dlcnM6IHtcImNsaWNrIC5mb29cIjogXCJkbzpmb29cIn1gXG4gICAgY29uZmlndXJlVHJpZ2dlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnRyaWdnZXJzKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIEFsbG93IGB0cmlnZ2Vyc2AgdG8gYmUgY29uZmlndXJlZCBhcyBhIGZ1bmN0aW9uXG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLm5vcm1hbGl6ZVVJS2V5cyhfLnJlc3VsdCh0aGlzLCAndHJpZ2dlcnMnKSk7XG4gIFxuICAgICAgLy8gQ29uZmlndXJlIHRoZSB0cmlnZ2VycywgcHJldmVudCBkZWZhdWx0XG4gICAgICAvLyBhY3Rpb24gYW5kIHN0b3AgcHJvcGFnYXRpb24gb2YgRE9NIGV2ZW50c1xuICAgICAgcmV0dXJuIF8ucmVkdWNlKHRyaWdnZXJzLCBmdW5jdGlvbihldmVudHMsIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgZXZlbnRzW2tleV0gPSB0aGlzLl9idWlsZFZpZXdUcmlnZ2VyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgIH0sIHt9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBPdmVycmlkaW5nIEJhY2tib25lLlZpZXcncyBkZWxlZ2F0ZUV2ZW50cyB0byBoYW5kbGVcbiAgICAvLyB0aGUgYHRyaWdnZXJzYCwgYG1vZGVsRXZlbnRzYCwgYW5kIGBjb2xsZWN0aW9uRXZlbnRzYCBjb25maWd1cmF0aW9uXG4gICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgdGhpcy5fZGVsZWdhdGVET01FdmVudHMoZXZlbnRzKTtcbiAgICAgIHRoaXMuYmluZEVudGl0eUV2ZW50cyh0aGlzLm1vZGVsLCB0aGlzLmdldE9wdGlvbignbW9kZWxFdmVudHMnKSk7XG4gICAgICB0aGlzLmJpbmRFbnRpdHlFdmVudHModGhpcy5jb2xsZWN0aW9uLCB0aGlzLmdldE9wdGlvbignY29sbGVjdGlvbkV2ZW50cycpKTtcbiAgXG4gICAgICBfLmVhY2godGhpcy5fYmVoYXZpb3JzLCBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgICBiZWhhdmlvci5iaW5kRW50aXR5RXZlbnRzKHRoaXMubW9kZWwsIGJlaGF2aW9yLmdldE9wdGlvbignbW9kZWxFdmVudHMnKSk7XG4gICAgICAgIGJlaGF2aW9yLmJpbmRFbnRpdHlFdmVudHModGhpcy5jb2xsZWN0aW9uLCBiZWhhdmlvci5nZXRPcHRpb24oJ2NvbGxlY3Rpb25FdmVudHMnKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gZGVsZWdhdGUgRE9NIGV2ZW50cyBhbmQgdHJpZ2dlcnNcbiAgICBfZGVsZWdhdGVET01FdmVudHM6IGZ1bmN0aW9uKGV2ZW50c0FyZykge1xuICAgICAgdmFyIGV2ZW50cyA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKGV2ZW50c0FyZyB8fCB0aGlzLmV2ZW50cywgdGhpcyk7XG4gIFxuICAgICAgLy8gbm9ybWFsaXplIHVpIGtleXNcbiAgICAgIGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVUlLZXlzKGV2ZW50cyk7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudHNBcmcpKSB7dGhpcy5ldmVudHMgPSBldmVudHM7fVxuICBcbiAgICAgIHZhciBjb21iaW5lZEV2ZW50cyA9IHt9O1xuICBcbiAgICAgIC8vIGxvb2sgdXAgaWYgdGhpcyB2aWV3IGhhcyBiZWhhdmlvciBldmVudHNcbiAgICAgIHZhciBiZWhhdmlvckV2ZW50cyA9IF8ucmVzdWx0KHRoaXMsICdiZWhhdmlvckV2ZW50cycpIHx8IHt9O1xuICAgICAgdmFyIHRyaWdnZXJzID0gdGhpcy5jb25maWd1cmVUcmlnZ2VycygpO1xuICAgICAgdmFyIGJlaGF2aW9yVHJpZ2dlcnMgPSBfLnJlc3VsdCh0aGlzLCAnYmVoYXZpb3JUcmlnZ2VycycpIHx8IHt9O1xuICBcbiAgICAgIC8vIGJlaGF2aW9yIGV2ZW50cyB3aWxsIGJlIG92ZXJyaWRlbiBieSB2aWV3IGV2ZW50cyBhbmQgb3IgdHJpZ2dlcnNcbiAgICAgIF8uZXh0ZW5kKGNvbWJpbmVkRXZlbnRzLCBiZWhhdmlvckV2ZW50cywgZXZlbnRzLCB0cmlnZ2VycywgYmVoYXZpb3JUcmlnZ2Vycyk7XG4gIFxuICAgICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUuZGVsZWdhdGVFdmVudHMuY2FsbCh0aGlzLCBjb21iaW5lZEV2ZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gT3ZlcnJpZGluZyBCYWNrYm9uZS5WaWV3J3MgdW5kZWxlZ2F0ZUV2ZW50cyB0byBoYW5kbGUgdW5iaW5kaW5nXG4gICAgLy8gdGhlIGB0cmlnZ2Vyc2AsIGBtb2RlbEV2ZW50c2AsIGFuZCBgY29sbGVjdGlvbkV2ZW50c2AgY29uZmlnXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS51bmRlbGVnYXRlRXZlbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdGhpcy51bmJpbmRFbnRpdHlFdmVudHModGhpcy5tb2RlbCwgdGhpcy5nZXRPcHRpb24oJ21vZGVsRXZlbnRzJykpO1xuICAgICAgdGhpcy51bmJpbmRFbnRpdHlFdmVudHModGhpcy5jb2xsZWN0aW9uLCB0aGlzLmdldE9wdGlvbignY29sbGVjdGlvbkV2ZW50cycpKTtcbiAgXG4gICAgICBfLmVhY2godGhpcy5fYmVoYXZpb3JzLCBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgICBiZWhhdmlvci51bmJpbmRFbnRpdHlFdmVudHModGhpcy5tb2RlbCwgYmVoYXZpb3IuZ2V0T3B0aW9uKCdtb2RlbEV2ZW50cycpKTtcbiAgICAgICAgYmVoYXZpb3IudW5iaW5kRW50aXR5RXZlbnRzKHRoaXMuY29sbGVjdGlvbiwgYmVoYXZpb3IuZ2V0T3B0aW9uKCdjb2xsZWN0aW9uRXZlbnRzJykpO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB0byB2ZXJpZnkgd2hldGhlciB0aGUgdmlldyBoYXNuJ3QgYmVlbiBkZXN0cm95ZWRcbiAgICBfZW5zdXJlVmlld0lzSW50YWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnVmlld0Rlc3Ryb3llZEVycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVmlldyAoY2lkOiBcIicgKyB0aGlzLmNpZCArICdcIikgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gRGVmYXVsdCBgZGVzdHJveWAgaW1wbGVtZW50YXRpb24sIGZvciByZW1vdmluZyBhIHZpZXcgZnJvbSB0aGVcbiAgICAvLyBET00gYW5kIHVuYmluZGluZyBpdC4gUmVnaW9ucyB3aWxsIGNhbGwgdGhpcyBtZXRob2RcbiAgICAvLyBmb3IgeW91LiBZb3UgY2FuIHNwZWNpZnkgYW4gYG9uRGVzdHJveWAgbWV0aG9kIGluIHlvdXIgdmlldyB0b1xuICAgIC8vIGFkZCBjdXN0b20gY29kZSB0aGF0IGlzIGNhbGxlZCBhZnRlciB0aGUgdmlldyBpcyBkZXN0cm95ZWQuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuICBcbiAgICAgIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kLmFwcGx5KHRoaXMsIFsnYmVmb3JlOmRlc3Ryb3knXS5jb25jYXQoYXJncykpO1xuICBcbiAgICAgIC8vIG1hcmsgYXMgZGVzdHJveWVkIGJlZm9yZSBkb2luZyB0aGUgYWN0dWFsIGRlc3Ryb3ksIHRvXG4gICAgICAvLyBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdpdGhpbiBcImRlc3Ryb3lcIiBldmVudCBoYW5kbGVyc1xuICAgICAgLy8gdGhhdCBhcmUgdHJ5aW5nIHRvIGRlc3Ryb3kgb3RoZXIgdmlld3NcbiAgICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kLmFwcGx5KHRoaXMsIFsnZGVzdHJveSddLmNvbmNhdChhcmdzKSk7XG4gIFxuICAgICAgLy8gdW5iaW5kIFVJIGVsZW1lbnRzXG4gICAgICB0aGlzLnVuYmluZFVJRWxlbWVudHMoKTtcbiAgXG4gICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgXG4gICAgICAvLyByZW1vdmUgdGhlIHZpZXcgZnJvbSB0aGUgRE9NXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICBcbiAgICAgIC8vIENhbGwgZGVzdHJveSBvbiBlYWNoIGJlaGF2aW9yIGFmdGVyXG4gICAgICAvLyBkZXN0cm95aW5nIHRoZSB2aWV3LlxuICAgICAgLy8gVGhpcyB1bmJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgLy8gdGhhdCBiZWhhdmlvcnMgaGF2ZSByZWdpc3RlcmVkIGZvci5cbiAgICAgIF8uaW52b2tlKHRoaXMuX2JlaGF2aW9ycywgJ2Rlc3Ryb3knLCBhcmdzKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICBiaW5kVUlFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9iaW5kVUlFbGVtZW50cygpO1xuICAgICAgXy5pbnZva2UodGhpcy5fYmVoYXZpb3JzLCB0aGlzLl9iaW5kVUlFbGVtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gVGhpcyBtZXRob2QgYmluZHMgdGhlIGVsZW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgXCJ1aVwiIGhhc2ggaW5zaWRlIHRoZSB2aWV3J3MgY29kZSB3aXRoXG4gICAgLy8gdGhlIGFzc29jaWF0ZWQgalF1ZXJ5IHNlbGVjdG9ycy5cbiAgICBfYmluZFVJRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnVpKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIHN0b3JlIHRoZSB1aSBoYXNoIGluIF91aUJpbmRpbmdzIHNvIHRoZXkgY2FuIGJlIHJlc2V0IGxhdGVyXG4gICAgICAvLyBhbmQgc28gcmUtcmVuZGVyaW5nIHRoZSB2aWV3IHdpbGwgYmUgYWJsZSB0byBmaW5kIHRoZSBiaW5kaW5nc1xuICAgICAgaWYgKCF0aGlzLl91aUJpbmRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3VpQmluZGluZ3MgPSB0aGlzLnVpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGdldCB0aGUgYmluZGluZ3MgcmVzdWx0LCBhcyBhIGZ1bmN0aW9uIG9yIG90aGVyd2lzZVxuICAgICAgdmFyIGJpbmRpbmdzID0gXy5yZXN1bHQodGhpcywgJ191aUJpbmRpbmdzJyk7XG4gIFxuICAgICAgLy8gZW1wdHkgdGhlIHVpIHNvIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc3RhcnQgd2l0aFxuICAgICAgdGhpcy51aSA9IHt9O1xuICBcbiAgICAgIC8vIGJpbmQgZWFjaCBvZiB0aGUgc2VsZWN0b3JzXG4gICAgICBfLmVhY2goYmluZGluZ3MsIGZ1bmN0aW9uKHNlbGVjdG9yLCBrZXkpIHtcbiAgICAgICAgdGhpcy51aVtrZXldID0gdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFRoaXMgbWV0aG9kIHVuYmluZHMgdGhlIGVsZW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgXCJ1aVwiIGhhc2hcbiAgICB1bmJpbmRVSUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3VuYmluZFVJRWxlbWVudHMoKTtcbiAgICAgIF8uaW52b2tlKHRoaXMuX2JlaGF2aW9ycywgdGhpcy5fdW5iaW5kVUlFbGVtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgX3VuYmluZFVJRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnVpIHx8ICF0aGlzLl91aUJpbmRpbmdzKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIGRlbGV0ZSBhbGwgb2YgdGhlIGV4aXN0aW5nIHVpIGJpbmRpbmdzXG4gICAgICBfLmVhY2godGhpcy51aSwgZnVuY3Rpb24oJGVsLCBuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVpW25hbWVdO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgLy8gcmVzZXQgdGhlIHVpIGVsZW1lbnQgdG8gdGhlIG9yaWdpbmFsIGJpbmRpbmdzIGNvbmZpZ3VyYXRpb25cbiAgICAgIHRoaXMudWkgPSB0aGlzLl91aUJpbmRpbmdzO1xuICAgICAgZGVsZXRlIHRoaXMuX3VpQmluZGluZ3M7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdpdmVuIGB0cmlnZ2VyRGVmYCBsaWtlXG4gICAgLy8gJ2NsaWNrOmZvbydcbiAgICBfYnVpbGRWaWV3VHJpZ2dlcjogZnVuY3Rpb24odHJpZ2dlckRlZikge1xuICAgICAgdmFyIGhhc09wdGlvbnMgPSBfLmlzT2JqZWN0KHRyaWdnZXJEZWYpO1xuICBcbiAgICAgIHZhciBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgKGhhc09wdGlvbnMgPyB0cmlnZ2VyRGVmIDoge30pLCB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IHRydWVcbiAgICAgIH0pO1xuICBcbiAgICAgIHZhciBldmVudE5hbWUgPSBoYXNPcHRpb25zID8gb3B0aW9ucy5ldmVudCA6IHRyaWdnZXJEZWY7XG4gIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCAmJiBvcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24gJiYgb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICB2aWV3OiB0aGlzLFxuICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMuY29sbGVjdGlvblxuICAgICAgICB9O1xuICBcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKGV2ZW50TmFtZSwgYXJncyk7XG4gICAgICB9O1xuICAgIH0sXG4gIFxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJldCA9IEJhY2tib25lLlZpZXcucHJvdG90eXBlLnNldEVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICAvLyBwcm94eSBiZWhhdmlvciAkZWwgdG8gdGhlIHZpZXcncyAkZWwuXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGEgdmlldydzICRlbCBwcm94eVxuICAgICAgLy8gaXMgbm90IHNldCB1bnRpbCBhZnRlciBzZXRFbGVtZW50IGlzIGNhbGxlZC5cbiAgICAgIF8uaW52b2tlKHRoaXMuX2JlaGF2aW9ycywgJ3Byb3h5Vmlld1Byb3BlcnRpZXMnLCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gIFxuICAgIC8vIGltcG9ydCB0aGUgYHRyaWdnZXJNZXRob2RgIHRvIHRyaWdnZXIgZXZlbnRzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgIC8vIG1ldGhvZHMgaWYgdGhlIG1ldGhvZCBleGlzdHNcbiAgICB0cmlnZ2VyTWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXQgPSBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50T25CZWhhdmlvcnMoYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX3RyaWdnZXJFdmVudE9uUGFyZW50TGF5b3V0KGFyZ3VtZW50c1swXSwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgXG4gICAgX3RyaWdnZXJFdmVudE9uQmVoYXZpb3JzOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICB2YXIgdHJpZ2dlck1ldGhvZCA9IE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2Q7XG4gICAgICB2YXIgYmVoYXZpb3JzID0gdGhpcy5fYmVoYXZpb3JzO1xuICAgICAgLy8gVXNlIGdvb2Qgb2wnIGZvciBhcyB0aGlzIGlzIGEgdmVyeSBob3QgZnVuY3Rpb25cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBiZWhhdmlvcnMgJiYgYmVoYXZpb3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyaWdnZXJNZXRob2QoYmVoYXZpb3JzW2ldLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICBfdHJpZ2dlckV2ZW50T25QYXJlbnRMYXlvdXQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgdmFyIGxheW91dFZpZXcgPSB0aGlzLl9wYXJlbnRMYXlvdXRWaWV3KCk7XG4gICAgICBpZiAoIWxheW91dFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGludm9rZSB0cmlnZ2VyTWV0aG9kIG9uIHBhcmVudCB2aWV3XG4gICAgICB2YXIgZXZlbnRQcmVmaXggPSBNYXJpb25ldHRlLmdldE9wdGlvbihsYXlvdXRWaWV3LCAnY2hpbGRWaWV3RXZlbnRQcmVmaXgnKTtcbiAgICAgIHZhciBwcmVmaXhlZEV2ZW50TmFtZSA9IGV2ZW50UHJlZml4ICsgJzonICsgZXZlbnROYW1lO1xuICBcbiAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QobGF5b3V0VmlldywgW3ByZWZpeGVkRXZlbnROYW1lLCB0aGlzXS5jb25jYXQoYXJncykpO1xuICBcbiAgICAgIC8vIGNhbGwgdGhlIHBhcmVudCB2aWV3J3MgY2hpbGRFdmVudHMgaGFuZGxlclxuICAgICAgdmFyIGNoaWxkRXZlbnRzID0gTWFyaW9uZXR0ZS5nZXRPcHRpb24obGF5b3V0VmlldywgJ2NoaWxkRXZlbnRzJyk7XG4gICAgICB2YXIgbm9ybWFsaXplZENoaWxkRXZlbnRzID0gbGF5b3V0Vmlldy5ub3JtYWxpemVNZXRob2RzKGNoaWxkRXZlbnRzKTtcbiAgXG4gICAgICBpZiAoISFub3JtYWxpemVkQ2hpbGRFdmVudHMgJiYgXy5pc0Z1bmN0aW9uKG5vcm1hbGl6ZWRDaGlsZEV2ZW50c1tldmVudE5hbWVdKSkge1xuICAgICAgICBub3JtYWxpemVkQ2hpbGRFdmVudHNbZXZlbnROYW1lXS5hcHBseShsYXlvdXRWaWV3LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIGFueSB2aWV3cyB0aGF0IGFyZSBpbW1lZGlhdGVcbiAgICAvLyBjaGlsZHJlbiBvZiB0aGlzIHZpZXdcbiAgICBfZ2V0SW1tZWRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gIFxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgZXZlcnkgbmVzdGVkIHZpZXcgd2l0aGluIHRoaXMgdmlld1xuICAgIF9nZXROZXN0ZWRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9nZXRJbW1lZGlhdGVDaGlsZHJlbigpO1xuICBcbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7IHJldHVybiBjaGlsZHJlbjsgfVxuICBcbiAgICAgIHJldHVybiBfLnJlZHVjZShjaGlsZHJlbiwgZnVuY3Rpb24obWVtbywgdmlldykge1xuICAgICAgICBpZiAoIXZpZXcuX2dldE5lc3RlZFZpZXdzKSB7IHJldHVybiBtZW1vOyB9XG4gICAgICAgIHJldHVybiBtZW1vLmNvbmNhdCh2aWV3Ll9nZXROZXN0ZWRWaWV3cygpKTtcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCB1dGlsaXR5IGZvciBidWlsZGluZyBhbiBhbmNlc3RvclxuICAgIC8vIHZpZXcgdHJlZSBsaXN0LlxuICAgIF9nZXRBbmNlc3RvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgICAgdmFyIHBhcmVudCAgPSB0aGlzLl9wYXJlbnQ7XG4gIFxuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH0sXG4gIFxuICAgIC8vIFJldHVybnMgdGhlIGNvbnRhaW5pbmcgcGFyZW50IHZpZXcuXG4gICAgX3BhcmVudExheW91dFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFuY2VzdG9ycyA9IHRoaXMuX2dldEFuY2VzdG9ycygpO1xuICAgICAgcmV0dXJuIF8uZmluZChhbmNlc3RvcnMsIGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50IGluc3RhbmNlb2YgTWFyaW9uZXR0ZS5MYXlvdXRWaWV3O1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW1wb3J0cyB0aGUgXCJub3JtYWxpemVNZXRob2RzXCIgdG8gdHJhbnNmb3JtIGhhc2hlcyBvZlxuICAgIC8vIGV2ZW50cz0+ZnVuY3Rpb24gcmVmZXJlbmNlcy9uYW1lcyB0byBhIGhhc2ggb2YgZXZlbnRzPT5mdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgbm9ybWFsaXplTWV0aG9kczogTWFyaW9uZXR0ZS5ub3JtYWxpemVNZXRob2RzLFxuICBcbiAgICAvLyBBIGhhbmR5IHdheSB0byBtZXJnZSBwYXNzZWQtaW4gb3B0aW9ucyBvbnRvIHRoZSBpbnN0YW5jZVxuICAgIG1lcmdlT3B0aW9uczogTWFyaW9uZXR0ZS5tZXJnZU9wdGlvbnMsXG4gIFxuICAgIC8vIFByb3h5IGBnZXRPcHRpb25gIHRvIGVuYWJsZSBnZXR0aW5nIG9wdGlvbnMgZnJvbSB0aGlzIG9yIHRoaXMub3B0aW9ucyBieSBuYW1lLlxuICAgIGdldE9wdGlvbjogTWFyaW9uZXR0ZS5wcm94eUdldE9wdGlvbixcbiAgXG4gICAgLy8gUHJveHkgYGJpbmRFbnRpdHlFdmVudHNgIHRvIGVuYWJsZSBiaW5kaW5nIHZpZXcncyBldmVudHMgZnJvbSBhbm90aGVyIGVudGl0eS5cbiAgICBiaW5kRW50aXR5RXZlbnRzOiBNYXJpb25ldHRlLnByb3h5QmluZEVudGl0eUV2ZW50cyxcbiAgXG4gICAgLy8gUHJveHkgYHVuYmluZEVudGl0eUV2ZW50c2AgdG8gZW5hYmxlIHVuYmluZGluZyB2aWV3J3MgZXZlbnRzIGZyb20gYW5vdGhlciBlbnRpdHkuXG4gICAgdW5iaW5kRW50aXR5RXZlbnRzOiBNYXJpb25ldHRlLnByb3h5VW5iaW5kRW50aXR5RXZlbnRzXG4gIH0pO1xuICBcbiAgLy8gSXRlbSBWaWV3XG4gIC8vIC0tLS0tLS0tLVxuICBcbiAgLy8gQSBzaW5nbGUgaXRlbSB2aWV3IGltcGxlbWVudGF0aW9uIHRoYXQgY29udGFpbnMgY29kZSBmb3IgcmVuZGVyaW5nXG4gIC8vIHdpdGggdW5kZXJzY29yZS5qcyB0ZW1wbGF0ZXMsIHNlcmlhbGl6aW5nIHRoZSB2aWV3J3MgbW9kZWwgb3IgY29sbGVjdGlvbixcbiAgLy8gYW5kIGNhbGxpbmcgc2V2ZXJhbCBtZXRob2RzIG9uIGV4dGVuZGVkIHZpZXdzLCBzdWNoIGFzIGBvblJlbmRlcmAuXG4gIE1hcmlvbmV0dGUuSXRlbVZpZXcgPSBNYXJpb25ldHRlLlZpZXcuZXh0ZW5kKHtcbiAgXG4gICAgLy8gU2V0dGluZyB1cCB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gd2hpY2ggYWxsb3dzIGNoYW5nZXMgdG9cbiAgICAvLyBNYXJpb25ldHRlLlZpZXcucHJvdG90eXBlLmNvbnN0cnVjdG9yIHdoaWNoIGFsbG93cyBvdmVycmlkaW5nXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgTWFyaW9uZXR0ZS5WaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gU2VyaWFsaXplIHRoZSBtb2RlbCBvciBjb2xsZWN0aW9uIGZvciB0aGUgdmlldy4gSWYgYSBtb2RlbCBpc1xuICAgIC8vIGZvdW5kLCB0aGUgdmlldydzIGBzZXJpYWxpemVNb2RlbGAgaXMgY2FsbGVkLiBJZiBhIGNvbGxlY3Rpb24gaXMgZm91bmQsXG4gICAgLy8gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbiBpcyBzZXJpYWxpemVkIGJ5IGNhbGxpbmdcbiAgICAvLyB0aGUgdmlldydzIGBzZXJpYWxpemVDb2xsZWN0aW9uYCBhbmQgcHV0IGludG8gYW4gYGl0ZW1zYCBhcnJheSBpblxuICAgIC8vIHRoZSByZXN1bHRpbmcgZGF0YS4gSWYgYm90aCBhcmUgZm91bmQsIGRlZmF1bHRzIHRvIHRoZSBtb2RlbC5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoZSBgc2VyaWFsaXplRGF0YWAgbWV0aG9kIGluIHlvdXIgb3duIHZpZXcgZGVmaW5pdGlvbixcbiAgICAvLyB0byBwcm92aWRlIGN1c3RvbSBzZXJpYWxpemF0aW9uIGZvciB5b3VyIHZpZXcncyBkYXRhLlxuICAgIHNlcmlhbGl6ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm1vZGVsICYmICF0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICBcbiAgICAgIHZhciBhcmdzID0gW3RoaXMubW9kZWwgfHwgdGhpcy5jb2xsZWN0aW9uXTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICBcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZU1vZGVsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtczogdGhpcy5zZXJpYWxpemVDb2xsZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gU2VyaWFsaXplIGEgY29sbGVjdGlvbiBieSBzZXJpYWxpemluZyBlYWNoIG9mIGl0cyBtb2RlbHMuXG4gICAgc2VyaWFsaXplQ29sbGVjdGlvbjogZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24udG9KU09OLmFwcGx5KGNvbGxlY3Rpb24sIF8ucmVzdChhcmd1bWVudHMpKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXIgdGhlIHZpZXcsIGRlZmF1bHRpbmcgdG8gdW5kZXJzY29yZS5qcyB0ZW1wbGF0ZXMuXG4gICAgLy8gWW91IGNhbiBvdmVycmlkZSB0aGlzIGluIHlvdXIgdmlldyBkZWZpbml0aW9uIHRvIHByb3ZpZGVcbiAgICAvLyBhIHZlcnkgc3BlY2lmaWMgcmVuZGVyaW5nIGZvciB5b3VyIHZpZXcuIEluIGdlbmVyYWwsIHRob3VnaCxcbiAgICAvLyB5b3Ugc2hvdWxkIG92ZXJyaWRlIHRoZSBgTWFyaW9uZXR0ZS5SZW5kZXJlcmAgb2JqZWN0IHRvXG4gICAgLy8gY2hhbmdlIGhvdyBNYXJpb25ldHRlIHJlbmRlcnMgdmlld3MuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcicsIHRoaXMpO1xuICBcbiAgICAgIHRoaXMuX3JlbmRlclRlbXBsYXRlKCk7XG4gICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgdGhpcy5iaW5kVUlFbGVtZW50cygpO1xuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVuZGVyJywgdGhpcyk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHJlbmRlciB0aGUgdGVtcGxhdGUgd2l0aCB0aGUgc2VyaWFsaXplZCBkYXRhXG4gICAgLy8gYW5kIHRlbXBsYXRlIGhlbHBlcnMgdmlhIHRoZSBgTWFyaW9uZXR0ZS5SZW5kZXJlcmAgb2JqZWN0LlxuICAgIC8vIFRocm93cyBhbiBgVW5kZWZpbmVkVGVtcGxhdGVFcnJvcmAgZXJyb3IgaWYgdGhlIHRlbXBsYXRlIGlzXG4gICAgLy8gYW55IGZhbHNlbHkgdmFsdWUgYnV0IGxpdGVyYWwgYGZhbHNlYC5cbiAgICBfcmVuZGVyVGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5nZXRUZW1wbGF0ZSgpO1xuICBcbiAgICAgIC8vIEFsbG93IHRlbXBsYXRlLWxlc3MgaXRlbSB2aWV3c1xuICAgICAgaWYgKHRlbXBsYXRlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1VuZGVmaW5lZFRlbXBsYXRlRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgcmVuZGVyIHRoZSB0ZW1wbGF0ZSBzaW5jZSBpdCBpcyBudWxsIG9yIHVuZGVmaW5lZC4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICBcbiAgICAgIC8vIEFkZCBpbiBlbnRpdHkgZGF0YSBhbmQgdGVtcGxhdGUgaGVscGVyc1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLm1peGluVGVtcGxhdGVIZWxwZXJzKHRoaXMuc2VyaWFsaXplRGF0YSgpKTtcbiAgXG4gICAgICAvLyBSZW5kZXIgYW5kIGFkZCB0byBlbFxuICAgICAgdmFyIGh0bWwgPSBNYXJpb25ldHRlLlJlbmRlcmVyLnJlbmRlcih0ZW1wbGF0ZSwgZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLmF0dGFjaEVsQ29udGVudChodG1sKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBBdHRhY2hlcyB0aGUgY29udGVudCBvZiBhIGdpdmVuIHZpZXcuXG4gICAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gb3B0aW1pemUgcmVuZGVyaW5nLFxuICAgIC8vIG9yIHRvIHJlbmRlciBpbiBhIG5vbiBzdGFuZGFyZCB3YXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgdXNpbmcgYGlubmVySFRNTGAgaW5zdGVhZCBvZiBgJGVsLmh0bWxgXG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgIC8vICAgdGhpcy5lbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIC8vICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8vIGBgYFxuICAgIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdGhpcy4kZWwuaHRtbChodG1sKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDIwLCBtYXhjb21wbGV4aXR5OiA3ICovXG4gIFxuICAvLyBDb2xsZWN0aW9uIFZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBBIHZpZXcgdGhhdCBpdGVyYXRlcyBvdmVyIGEgQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyBhbmQgcmVuZGVycyBhbiBpbmRpdmlkdWFsIGNoaWxkIHZpZXcgZm9yIGVhY2ggbW9kZWwuXG4gIE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcgPSBNYXJpb25ldHRlLlZpZXcuZXh0ZW5kKHtcbiAgXG4gICAgLy8gdXNlZCBhcyB0aGUgcHJlZml4IGZvciBjaGlsZCB2aWV3IGV2ZW50c1xuICAgIC8vIHRoYXQgYXJlIGZvcndhcmRlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aW9udmlld1xuICAgIGNoaWxkVmlld0V2ZW50UHJlZml4OiAnY2hpbGR2aWV3JyxcbiAgXG4gICAgLy8gZmxhZyBmb3IgbWFpbnRhaW5pbmcgdGhlIHNvcnRlZCBvcmRlciBvZiB0aGUgY29sbGVjdGlvblxuICAgIHNvcnQ6IHRydWUsXG4gIFxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgLy8gb3B0aW9uIHRvIHBhc3MgYHtzb3J0OiBmYWxzZX1gIHRvIHByZXZlbnQgdGhlIGBDb2xsZWN0aW9uVmlld2AgZnJvbVxuICAgIC8vIG1haW50YWluaW5nIHRoZSBzb3J0ZWQgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgLy8gVGhpcyB3aWxsIGZhbGxiYWNrIG9udG8gYXBwZW5kaW5nIGNoaWxkVmlldydzIHRvIHRoZSBlbmQuXG4gICAgLy9cbiAgICAvLyBvcHRpb24gdG8gcGFzcyBge2NvbXBhcmF0b3I6IGNvbXBGdW5jdGlvbigpfWAgdG8gYWxsb3cgdGhlIGBDb2xsZWN0aW9uVmlld2BcbiAgICAvLyB0byB1c2UgYSBjdXN0b20gc29ydCBvcmRlciBmb3IgdGhlIGNvbGxlY3Rpb24uXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub25jZSgncmVuZGVyJywgdGhpcy5faW5pdGlhbEV2ZW50cyk7XG4gICAgICB0aGlzLl9pbml0Q2hpbGRWaWV3U3RvcmFnZSgpO1xuICBcbiAgICAgIE1hcmlvbmV0dGUuVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcbiAgICAgIHRoaXMub24oe1xuICAgICAgICAnYmVmb3JlOnNob3cnOiAgIHRoaXMuX29uQmVmb3JlU2hvd0NhbGxlZCxcbiAgICAgICAgJ3Nob3cnOiAgICAgICAgICB0aGlzLl9vblNob3dDYWxsZWQsXG4gICAgICAgICdiZWZvcmU6YXR0YWNoJzogdGhpcy5fb25CZWZvcmVBdHRhY2hDYWxsZWQsXG4gICAgICAgICdhdHRhY2gnOiAgICAgICAgdGhpcy5fb25BdHRhY2hDYWxsZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbml0UmVuZGVyQnVmZmVyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW5zdGVhZCBvZiBpbnNlcnRpbmcgZWxlbWVudHMgb25lIGJ5IG9uZSBpbnRvIHRoZSBwYWdlLFxuICAgIC8vIGl0J3MgbXVjaCBtb3JlIHBlcmZvcm1hbnQgdG8gaW5zZXJ0IGVsZW1lbnRzIGludG8gYSBkb2N1bWVudFxuICAgIC8vIGZyYWdtZW50IGFuZCB0aGVuIGluc2VydCB0aGF0IGRvY3VtZW50IGZyYWdtZW50IGludG8gdGhlIHBhZ2VcbiAgICBpbml0UmVuZGVyQnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQ2hpbGRyZW4gPSBbXTtcbiAgICB9LFxuICBcbiAgICBzdGFydEJ1ZmZlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRSZW5kZXJCdWZmZXIoKTtcbiAgICAgIHRoaXMuaXNCdWZmZXJpbmcgPSB0cnVlO1xuICAgIH0sXG4gIFxuICAgIGVuZEJ1ZmZlcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBPbmx5IHRyaWdnZXIgYXR0YWNoIGlmIGFscmVhZHkgc2hvd24gYW5kIGF0dGFjaGVkLCBvdGhlcndpc2UgUmVnaW9uI3Nob3coKSBoYW5kbGVzIHRoaXMuXG4gICAgICB2YXIgY2FuVHJpZ2dlckF0dGFjaCA9IHRoaXMuX2lzU2hvd24gJiYgTWFyaW9uZXR0ZS5pc05vZGVBdHRhY2hlZCh0aGlzLmVsKTtcbiAgICAgIHZhciBuZXN0ZWRWaWV3cztcbiAgXG4gICAgICB0aGlzLmlzQnVmZmVyaW5nID0gZmFsc2U7XG4gIFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkodGhpcy5fYnVmZmVyZWRDaGlsZHJlbiwgdGhpcywgJ2JlZm9yZTpzaG93Jyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuVHJpZ2dlckF0dGFjaCAmJiB0aGlzLl90cmlnZ2VyQmVmb3JlQXR0YWNoKSB7XG4gICAgICAgIG5lc3RlZFZpZXdzID0gdGhpcy5fZ2V0TmVzdGVkVmlld3MoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkobmVzdGVkVmlld3MsIHRoaXMsICdiZWZvcmU6YXR0YWNoJyk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5hdHRhY2hCdWZmZXIodGhpcywgdGhpcy5fY3JlYXRlQnVmZmVyKCkpO1xuICBcbiAgICAgIGlmIChjYW5UcmlnZ2VyQXR0YWNoICYmIHRoaXMuX3RyaWdnZXJBdHRhY2gpIHtcbiAgICAgICAgbmVzdGVkVmlld3MgPSB0aGlzLl9nZXROZXN0ZWRWaWV3cygpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueShuZXN0ZWRWaWV3cywgdGhpcywgJ2F0dGFjaCcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkodGhpcy5fYnVmZmVyZWRDaGlsZHJlbiwgdGhpcywgJ3Nob3cnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFJlbmRlckJ1ZmZlcigpO1xuICAgIH0sXG4gIFxuICAgIF90cmlnZ2VyTWV0aG9kTWFueTogZnVuY3Rpb24odGFyZ2V0cywgc291cmNlLCBldmVudE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gXy5kcm9wKGFyZ3VtZW50cywgMyk7XG4gIFxuICAgICAgXy5lYWNoKHRhcmdldHMsIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbi5hcHBseSh0YXJnZXQsIFt0YXJnZXQsIGV2ZW50TmFtZSwgdGFyZ2V0LCBzb3VyY2VdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBDb25maWd1cmVkIHRoZSBpbml0aWFsIGV2ZW50cyB0aGF0IHRoZSBjb2xsZWN0aW9uIHZpZXdcbiAgICAvLyBiaW5kcyB0by5cbiAgICBfaW5pdGlhbEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnYWRkJywgdGhpcy5fb25Db2xsZWN0aW9uQWRkKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdyZW1vdmUnLCB0aGlzLl9vbkNvbGxlY3Rpb25SZW1vdmUpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3Jlc2V0JywgdGhpcy5yZW5kZXIpO1xuICBcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdzb3J0JykpIHtcbiAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3NvcnQnLCB0aGlzLl9zb3J0Vmlld3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSGFuZGxlIGEgY2hpbGQgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICBfb25Db2xsZWN0aW9uQWRkOiBmdW5jdGlvbihjaGlsZCwgY29sbGVjdGlvbiwgb3B0cykge1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgaWYgKG9wdHMuYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IG9wdHMuYXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IF8uaW5kZXhPZih0aGlzLl9maWx0ZXJlZFNvcnRlZE1vZGVscygpLCBjaGlsZCk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHRoaXMuX3Nob3VsZEFkZENoaWxkKGNoaWxkLCBpbmRleCkpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RW1wdHlWaWV3KCk7XG4gICAgICAgIHZhciBDaGlsZFZpZXcgPSB0aGlzLmdldENoaWxkVmlldyhjaGlsZCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGQsIENoaWxkVmlldywgaW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIGdldCB0aGUgY2hpbGQgdmlldyBieSBtb2RlbCBpdCBob2xkcywgYW5kIHJlbW92ZSBpdFxuICAgIF9vbkNvbGxlY3Rpb25SZW1vdmU6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICB2YXIgdmlldyA9IHRoaXMuY2hpbGRyZW4uZmluZEJ5TW9kZWwobW9kZWwpO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICB0aGlzLmNoZWNrRW1wdHkoKTtcbiAgICB9LFxuICBcbiAgICBfb25CZWZvcmVTaG93Q2FsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFJlc2V0IGF0dGFjaCBldmVudCBmbGFncyBhdCB0aGUgdG9wIG9mIHRoZSBSZWdpb24jc2hvdygpIGV2ZW50IGxpZmVjeWNsZTsgaWYgdGhlIFJlZ2lvbidzXG4gICAgICAvLyBzaG93KCkgb3B0aW9ucyBwZXJtaXQgb25CZWZvcmVBdHRhY2gvb25BdHRhY2ggZXZlbnRzLCB0aGVzZSBmbGFncyB3aWxsIGJlIHNldCB0cnVlIGFnYWluLlxuICAgICAgdGhpcy5fdHJpZ2dlckJlZm9yZUF0dGFjaCA9IHRoaXMuX3RyaWdnZXJBdHRhY2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24oY2hpbGRWaWV3LCAnYmVmb3JlOnNob3cnLCBjaGlsZFZpZXcpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgX29uU2hvd0NhbGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKGNoaWxkVmlldywgJ3Nob3cnLCBjaGlsZFZpZXcpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gSWYgZHVyaW5nIFJlZ2lvbiNzaG93KCkgb25CZWZvcmVBdHRhY2ggd2FzIGZpcmVkLCBjb250aW51ZSBmaXJpbmcgaXQgZm9yIGNoaWxkIHZpZXdzXG4gICAgX29uQmVmb3JlQXR0YWNoQ2FsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJCZWZvcmVBdHRhY2ggPSB0cnVlO1xuICAgIH0sXG4gIFxuICAgIC8vIElmIGR1cmluZyBSZWdpb24jc2hvdygpIG9uQXR0YWNoIHdhcyBmaXJlZCwgY29udGludWUgZmlyaW5nIGl0IGZvciBjaGlsZCB2aWV3c1xuICAgIF9vbkF0dGFjaENhbGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXR0YWNoID0gdHJ1ZTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXIgY2hpbGRyZW4gdmlld3MuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvXG4gICAgLy8gcHJvdmlkZSB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlbmRlciBmdW5jdGlvbiBmb3JcbiAgICAvLyB0aGUgY29sbGVjdGlvbiB2aWV3LlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9lbnN1cmVWaWV3SXNJbnRhY3QoKTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcicsIHRoaXMpO1xuICAgICAgdGhpcy5fcmVuZGVyQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcicsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVvcmRlciBET00gYWZ0ZXIgc29ydGluZy4gV2hlbiB5b3VyIGVsZW1lbnQncyByZW5kZXJpbmdcbiAgICAvLyBkbyBub3QgdXNlIHRoZWlyIGluZGV4LCB5b3UgY2FuIHBhc3MgcmVvcmRlck9uU29ydDogdHJ1ZVxuICAgIC8vIHRvIG9ubHkgcmVvcmRlciB0aGUgRE9NIGFmdGVyIGEgc29ydCBpbnN0ZWFkIG9mIHJlbmRlcmluZ1xuICAgIC8vIGFsbCB0aGUgY29sbGVjdGlvblZpZXdcbiAgICByZW9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB2YXIgbW9kZWxzID0gdGhpcy5fZmlsdGVyZWRTb3J0ZWRNb2RlbHMoKTtcbiAgICAgIHZhciBtb2RlbHNDaGFuZ2VkID0gXy5maW5kKG1vZGVscywgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICFjaGlsZHJlbi5maW5kQnlNb2RlbChtb2RlbCk7XG4gICAgICB9KTtcbiAgXG4gICAgICAvLyBJZiB0aGUgbW9kZWxzIHdlJ3JlIGRpc3BsYXlpbmcgaGF2ZSBjaGFuZ2VkIGR1ZSB0byBmaWx0ZXJpbmdcbiAgICAgIC8vIFdlIG5lZWQgdG8gYWRkIGFuZC9vciByZW1vdmUgY2hpbGQgdmlld3NcbiAgICAgIC8vIFNvIHJlbmRlciBhcyBub3JtYWxcbiAgICAgIGlmIChtb2RlbHNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXQgdGhlIERPTSBub2RlcyBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgbW9kZWxzXG4gICAgICAgIHZhciBlbHMgPSBfLm1hcChtb2RlbHMsIGZ1bmN0aW9uKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgIHZhciB2aWV3ID0gY2hpbGRyZW4uZmluZEJ5TW9kZWwobW9kZWwpO1xuICAgICAgICAgIHZpZXcuX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHZpZXcuZWw7XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgLy8gc2luY2UgYXBwZW5kIG1vdmVzIGVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW4gdGhlIERPTSxcbiAgICAgICAgLy8gYXBwZW5kaW5nIHRoZSBlbGVtZW50cyB3aWxsIGVmZmVjdGl2ZWx5IHJlb3JkZXIgdGhlbVxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW9yZGVyJyk7XG4gICAgICAgIHRoaXMuX2FwcGVuZFJlb3JkZXJlZENoaWxkcmVuKGVscyk7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVvcmRlcicpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB2aWV3IGFmdGVyIHNvcnRpbmcuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvXG4gICAgLy8gY2hhbmdlIGhvdyB0aGUgdmlldyByZW5kZXJzIGFmdGVyIGEgYHNvcnRgIG9uIHRoZSBjb2xsZWN0aW9uLlxuICAgIC8vIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSB0byBvbmx5IGByZW5kZXJDaGlsZHJlbmAgaW4gYSBgQ29tcG9zaXRlVmlld2BcbiAgICAvLyByYXRoZXIgdGhhbiB0aGUgZnVsbCB2aWV3LlxuICAgIHJlc29ydFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKE1hcmlvbmV0dGUuZ2V0T3B0aW9uKHRoaXMsICdyZW9yZGVyT25Tb3J0JykpIHtcbiAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gVGhpcyBjaGVja3MgZm9yIGFueSBjaGFuZ2VzIGluIHRoZSBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAvLyBJZiB0aGUgaW5kZXggb2YgYW55IHZpZXcgZG9lc24ndCBtYXRjaCwgaXQgd2lsbCByZW5kZXIuXG4gICAgX3NvcnRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbW9kZWxzID0gdGhpcy5fZmlsdGVyZWRTb3J0ZWRNb2RlbHMoKTtcbiAgXG4gICAgICAvLyBjaGVjayBmb3IgYW55IGNoYW5nZXMgaW4gc29ydCBvcmRlciBvZiB2aWV3c1xuICAgICAgdmFyIG9yZGVyQ2hhbmdlZCA9IF8uZmluZChtb2RlbHMsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5jaGlsZHJlbi5maW5kQnlNb2RlbChpdGVtKTtcbiAgICAgICAgcmV0dXJuICF2aWV3IHx8IHZpZXcuX2luZGV4ICE9PSBpbmRleDtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIGlmIChvcmRlckNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZXNvcnRWaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHdoYXQgaW5kZXggYSBgZW1wdHlWaWV3YCBpcy5cbiAgICBfZW1wdHlWaWV3SW5kZXg6IC0xLFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIFNlcGFyYXRlZCBzbyB0aGF0IENvbXBvc2l0ZVZpZXcgY2FuIGFwcGVuZCB0byB0aGUgY2hpbGRWaWV3Q29udGFpbmVyXG4gICAgLy8gaWYgbmVjZXNzYXJ5XG4gICAgX2FwcGVuZFJlb3JkZXJlZENoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKGNoaWxkcmVuKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIFNlcGFyYXRlZCBzbyB0aGF0IENvbXBvc2l0ZVZpZXcgY2FuIGhhdmVcbiAgICAvLyBtb3JlIGNvbnRyb2wgb3ZlciBldmVudHMgYmVpbmcgdHJpZ2dlcmVkLCBhcm91bmQgdGhlIHJlbmRlcmluZ1xuICAgIC8vIHByb2Nlc3NcbiAgICBfcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95RW1wdHlWaWV3KCk7XG4gICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbih7Y2hlY2tFbXB0eTogZmFsc2V9KTtcbiAgXG4gICAgICBpZiAodGhpcy5pc0VtcHR5KHRoaXMuY29sbGVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5zaG93RW1wdHlWaWV3KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW5kZXI6Y29sbGVjdGlvbicsIHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXJ0QnVmZmVyaW5nKCk7XG4gICAgICAgIHRoaXMuc2hvd0NvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5lbmRCdWZmZXJpbmcoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXI6Y29sbGVjdGlvbicsIHRoaXMpO1xuICBcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBzaG93biBjaGlsZHJlbiBhbmQgbm9uZSBoYXZlIHBhc3NlZCB0aGUgZmlsdGVyLCBzaG93IHRoZSBlbXB0eSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHRoaXMuc2hvd0VtcHR5VmlldygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGxvb3AgdGhyb3VnaCBjb2xsZWN0aW9uIGFuZCBzaG93IGVhY2ggY2hpbGQgdmlldy5cbiAgICBzaG93Q29sbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgQ2hpbGRWaWV3O1xuICBcbiAgICAgIHZhciBtb2RlbHMgPSB0aGlzLl9maWx0ZXJlZFNvcnRlZE1vZGVscygpO1xuICBcbiAgICAgIF8uZWFjaChtb2RlbHMsIGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xuICAgICAgICBDaGlsZFZpZXcgPSB0aGlzLmdldENoaWxkVmlldyhjaGlsZCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGQsIENoaWxkVmlldywgaW5kZXgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQWxsb3cgdGhlIGNvbGxlY3Rpb24gdG8gYmUgc29ydGVkIGJ5IGEgY3VzdG9tIHZpZXcgY29tcGFyYXRvclxuICAgIF9maWx0ZXJlZFNvcnRlZE1vZGVsczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbW9kZWxzO1xuICAgICAgdmFyIHZpZXdDb21wYXJhdG9yID0gdGhpcy5nZXRWaWV3Q29tcGFyYXRvcigpO1xuICBcbiAgICAgIGlmICh2aWV3Q29tcGFyYXRvcikge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyh2aWV3Q29tcGFyYXRvcikgfHwgdmlld0NvbXBhcmF0b3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbW9kZWxzID0gdGhpcy5jb2xsZWN0aW9uLnNvcnRCeSh2aWV3Q29tcGFyYXRvciwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWxzID0gXy5jbG9uZSh0aGlzLmNvbGxlY3Rpb24ubW9kZWxzKS5zb3J0KF8uYmluZCh2aWV3Q29tcGFyYXRvciwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbHMgPSB0aGlzLmNvbGxlY3Rpb24ubW9kZWxzO1xuICAgICAgfVxuICBcbiAgICAgIC8vIEZpbHRlciBhZnRlciBzb3J0aW5nIGluIGNhc2UgdGhlIGZpbHRlciB1c2VzIHRoZSBpbmRleFxuICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdmaWx0ZXInKSkge1xuICAgICAgICBtb2RlbHMgPSBfLmZpbHRlcihtb2RlbHMsIGZ1bmN0aW9uKG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zaG91bGRBZGRDaGlsZChtb2RlbCwgaW5kZXgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzaG93IGFuIGVtcHR5IHZpZXcgaW4gcGxhY2Ugb2ZcbiAgICAvLyBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgdmlld3MsIHdoZW4gdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHlcbiAgICBzaG93RW1wdHlWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBFbXB0eVZpZXcgPSB0aGlzLmdldEVtcHR5VmlldygpO1xuICBcbiAgICAgIGlmIChFbXB0eVZpZXcgJiYgIXRoaXMuX3Nob3dpbmdFbXB0eVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyOmVtcHR5Jyk7XG4gIFxuICAgICAgICB0aGlzLl9zaG93aW5nRW1wdHlWaWV3ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJhY2tib25lLk1vZGVsKCk7XG4gICAgICAgIHRoaXMuYWRkRW1wdHlWaWV3KG1vZGVsLCBFbXB0eVZpZXcpO1xuICBcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXI6ZW1wdHknKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gZGVzdHJveSBhbiBleGlzdGluZyBlbXB0eVZpZXcgaW5zdGFuY2VcbiAgICAvLyBpZiBvbmUgZXhpc3RzLiBDYWxsZWQgd2hlbiBhIGNvbGxlY3Rpb24gdmlldyBoYXMgYmVlblxuICAgIC8vIHJlbmRlcmVkIGVtcHR5LCBhbmQgdGhlbiBhIGNoaWxkIGlzIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgIGRlc3Ryb3lFbXB0eVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3Nob3dpbmdFbXB0eVZpZXcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVtb3ZlOmVtcHR5Jyk7XG4gIFxuICAgICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbigpO1xuICAgICAgICBkZWxldGUgdGhpcy5fc2hvd2luZ0VtcHR5VmlldztcbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVtb3ZlOmVtcHR5Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gUmV0cmlldmUgdGhlIGVtcHR5IHZpZXcgY2xhc3NcbiAgICBnZXRFbXB0eVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKCdlbXB0eVZpZXcnKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXIgYW5kIHNob3cgdGhlIGVtcHR5Vmlldy4gU2ltaWxhciB0byBhZGRDaGlsZCBtZXRob2RcbiAgICAvLyBidXQgXCJhZGQ6Y2hpbGRcIiBldmVudHMgYXJlIG5vdCBmaXJlZCwgYW5kIHRoZSBldmVudCBmcm9tXG4gICAgLy8gZW1wdHlWaWV3IGFyZSBub3QgZm9yd2FyZGVkXG4gICAgYWRkRW1wdHlWaWV3OiBmdW5jdGlvbihjaGlsZCwgRW1wdHlWaWV3KSB7XG4gICAgICAvLyBPbmx5IHRyaWdnZXIgYXR0YWNoIGlmIGFscmVhZHkgc2hvd24sIGF0dGFjaGVkLCBhbmQgbm90IGJ1ZmZlcmluZywgb3RoZXJ3aXNlIGVuZEJ1ZmZlcigpIG9yXG4gICAgICAvLyBSZWdpb24jc2hvdygpIGhhbmRsZXMgdGhpcy5cbiAgICAgIHZhciBjYW5UcmlnZ2VyQXR0YWNoID0gdGhpcy5faXNTaG93biAmJiAhdGhpcy5pc0J1ZmZlcmluZyAmJiBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkKHRoaXMuZWwpO1xuICAgICAgdmFyIG5lc3RlZFZpZXdzO1xuICBcbiAgICAgIC8vIGdldCB0aGUgZW1wdHlWaWV3T3B0aW9ucywgZmFsbGluZyBiYWNrIHRvIGNoaWxkVmlld09wdGlvbnNcbiAgICAgIHZhciBlbXB0eVZpZXdPcHRpb25zID0gdGhpcy5nZXRPcHRpb24oJ2VtcHR5Vmlld09wdGlvbnMnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uKCdjaGlsZFZpZXdPcHRpb25zJyk7XG4gIFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihlbXB0eVZpZXdPcHRpb25zKSkge1xuICAgICAgICBlbXB0eVZpZXdPcHRpb25zID0gZW1wdHlWaWV3T3B0aW9ucy5jYWxsKHRoaXMsIGNoaWxkLCB0aGlzLl9lbXB0eVZpZXdJbmRleCk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gYnVpbGQgdGhlIGVtcHR5IHZpZXdcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5idWlsZENoaWxkVmlldyhjaGlsZCwgRW1wdHlWaWV3LCBlbXB0eVZpZXdPcHRpb25zKTtcbiAgXG4gICAgICB2aWV3Ll9wYXJlbnQgPSB0aGlzO1xuICBcbiAgICAgIC8vIFByb3h5IGVtcHR5VmlldyBldmVudHNcbiAgICAgIHRoaXMucHJveHlDaGlsZEV2ZW50cyh2aWV3KTtcbiAgXG4gICAgICAvLyB0cmlnZ2VyIHRoZSAnYmVmb3JlOnNob3cnIGV2ZW50IG9uIGB2aWV3YCBpZiB0aGUgY29sbGVjdGlvbiB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gc2hvd25cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdiZWZvcmU6c2hvdycsIHZpZXcpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIFN0b3JlIHRoZSBgZW1wdHlWaWV3YCBsaWtlIGEgYGNoaWxkVmlld2Agc28gd2UgY2FuIHByb3Blcmx5XG4gICAgICAvLyByZW1vdmUgYW5kL29yIGNsb3NlIGl0IGxhdGVyXG4gICAgICB0aGlzLmNoaWxkcmVuLmFkZCh2aWV3KTtcbiAgXG4gICAgICAvLyBUcmlnZ2VyIGBiZWZvcmU6YXR0YWNoYCBmb2xsb3dpbmcgYHJlbmRlcmAgdG8gYXZvaWQgYWRkaW5nIGxvZ2ljIGFuZCBldmVudCB0cmlnZ2Vyc1xuICAgICAgLy8gdG8gcHVibGljIG1ldGhvZCBgcmVuZGVyQ2hpbGRWaWV3KClgLlxuICAgICAgaWYgKGNhblRyaWdnZXJBdHRhY2ggJiYgdGhpcy5fdHJpZ2dlckJlZm9yZUF0dGFjaCkge1xuICAgICAgICBuZXN0ZWRWaWV3cyA9IFt2aWV3XS5jb25jYXQodmlldy5fZ2V0TmVzdGVkVmlld3MoKSk7XG4gICAgICAgIHZpZXcub25jZSgncmVuZGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkobmVzdGVkVmlld3MsIHRoaXMsICdiZWZvcmU6YXR0YWNoJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIFJlbmRlciBpdCBhbmQgc2hvdyBpdFxuICAgICAgdGhpcy5yZW5kZXJDaGlsZFZpZXcodmlldywgdGhpcy5fZW1wdHlWaWV3SW5kZXgpO1xuICBcbiAgICAgIC8vIFRyaWdnZXIgYGF0dGFjaGBcbiAgICAgIGlmIChjYW5UcmlnZ2VyQXR0YWNoICYmIHRoaXMuX3RyaWdnZXJBdHRhY2gpIHtcbiAgICAgICAgbmVzdGVkVmlld3MgPSBbdmlld10uY29uY2F0KHZpZXcuX2dldE5lc3RlZFZpZXdzKCkpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueShuZXN0ZWRWaWV3cywgdGhpcywgJ2F0dGFjaCcpO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCB0aGUgJ3Nob3cnIG1ldGhvZCBpZiB0aGUgY29sbGVjdGlvbiB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gc2hvd25cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdzaG93Jywgdmlldyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gUmV0cmlldmUgdGhlIGBjaGlsZFZpZXdgIGNsYXNzLCBlaXRoZXIgZnJvbSBgdGhpcy5vcHRpb25zLmNoaWxkVmlld2BcbiAgICAvLyBvciBmcm9tIHRoZSBgY2hpbGRWaWV3YCBpbiB0aGUgb2JqZWN0IGRlZmluaXRpb24uIFRoZSBcIm9wdGlvbnNcIlxuICAgIC8vIHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhpcyBtZXRob2QgcmVjZWl2ZXMgdGhlIG1vZGVsIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGluc3RhbmNlXG4gICAgLy8gY3JlYXRlZCBmcm9tIHRoaXMgYGNoaWxkVmlld2AuIE92ZXJyaWRpbmcgbWV0aG9kcyBtYXkgdXNlIHRoZSBjaGlsZFxuICAgIC8vIHRvIGRldGVybWluZSB3aGF0IGBjaGlsZFZpZXdgIGNsYXNzIHRvIHJldHVybi5cbiAgICBnZXRDaGlsZFZpZXc6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRWaWV3ID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlldycpO1xuICBcbiAgICAgIGlmICghY2hpbGRWaWV3KSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnTm9DaGlsZFZpZXdFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0EgXCJjaGlsZFZpZXdcIiBtdXN0IGJlIHNwZWNpZmllZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIGNoaWxkVmlldztcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXIgdGhlIGNoaWxkJ3MgdmlldyBhbmQgYWRkIGl0IHRvIHRoZVxuICAgIC8vIEhUTUwgZm9yIHRoZSBjb2xsZWN0aW9uIHZpZXcgYXQgYSBnaXZlbiBpbmRleC5cbiAgICAvLyBUaGlzIHdpbGwgYWxzbyB1cGRhdGUgdGhlIGluZGljZXMgb2YgbGF0ZXIgdmlld3MgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpbiBvcmRlciB0byBrZWVwIHRoZSBjaGlsZHJlbiBpbiBzeW5jIHdpdGggdGhlIGNvbGxlY3Rpb24uXG4gICAgYWRkQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkLCBDaGlsZFZpZXcsIGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGRWaWV3T3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9uKCdjaGlsZFZpZXdPcHRpb25zJyk7XG4gICAgICBjaGlsZFZpZXdPcHRpb25zID0gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUoY2hpbGRWaWV3T3B0aW9ucywgdGhpcywgW2NoaWxkLCBpbmRleF0pO1xuICBcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5idWlsZENoaWxkVmlldyhjaGlsZCwgQ2hpbGRWaWV3LCBjaGlsZFZpZXdPcHRpb25zKTtcbiAgXG4gICAgICAvLyBpbmNyZW1lbnQgaW5kaWNlcyBvZiB2aWV3cyBhZnRlciB0aGlzIG9uZVxuICAgICAgdGhpcy5fdXBkYXRlSW5kaWNlcyh2aWV3LCB0cnVlLCBpbmRleCk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6YWRkOmNoaWxkJywgdmlldyk7XG4gICAgICB0aGlzLl9hZGRDaGlsZFZpZXcodmlldywgaW5kZXgpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdhZGQ6Y2hpbGQnLCB2aWV3KTtcbiAgXG4gICAgICB2aWV3Ll9wYXJlbnQgPSB0aGlzO1xuICBcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gVGhpcyBkZWNyZW1lbnRzIG9yIGluY3JlbWVudHMgdGhlIGluZGljZXMgb2Ygdmlld3MgYWZ0ZXIgdGhlXG4gICAgLy8gYWRkZWQvcmVtb3ZlZCB2aWV3IHRvIGtlZXAgaW4gc3luYyB3aXRoIHRoZSBjb2xsZWN0aW9uLlxuICAgIF91cGRhdGVJbmRpY2VzOiBmdW5jdGlvbih2aWV3LCBpbmNyZW1lbnQsIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0T3B0aW9uKCdzb3J0JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChpbmNyZW1lbnQpIHtcbiAgICAgICAgLy8gYXNzaWduIHRoZSBpbmRleCB0byB0aGUgdmlld1xuICAgICAgICB2aWV3Ll9pbmRleCA9IGluZGV4O1xuICAgICAgfVxuICBcbiAgICAgIC8vIHVwZGF0ZSB0aGUgaW5kZXhlcyBvZiB2aWV3cyBhZnRlciB0aGlzIG9uZVxuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGxhdGVyVmlldykge1xuICAgICAgICBpZiAobGF0ZXJWaWV3Ll9pbmRleCA+PSB2aWV3Ll9pbmRleCkge1xuICAgICAgICAgIGxhdGVyVmlldy5faW5kZXggKz0gaW5jcmVtZW50ID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBNZXRob2QuIEFkZCB0aGUgdmlldyB0byBjaGlsZHJlbiBhbmQgcmVuZGVyIGl0IGF0XG4gICAgLy8gdGhlIGdpdmVuIGluZGV4LlxuICAgIF9hZGRDaGlsZFZpZXc6IGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICAvLyBPbmx5IHRyaWdnZXIgYXR0YWNoIGlmIGFscmVhZHkgc2hvd24sIGF0dGFjaGVkLCBhbmQgbm90IGJ1ZmZlcmluZywgb3RoZXJ3aXNlIGVuZEJ1ZmZlcigpIG9yXG4gICAgICAvLyBSZWdpb24jc2hvdygpIGhhbmRsZXMgdGhpcy5cbiAgICAgIHZhciBjYW5UcmlnZ2VyQXR0YWNoID0gdGhpcy5faXNTaG93biAmJiAhdGhpcy5pc0J1ZmZlcmluZyAmJiBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkKHRoaXMuZWwpO1xuICAgICAgdmFyIG5lc3RlZFZpZXdzO1xuICBcbiAgICAgIC8vIHNldCB1cCB0aGUgY2hpbGQgdmlldyBldmVudCBmb3J3YXJkaW5nXG4gICAgICB0aGlzLnByb3h5Q2hpbGRFdmVudHModmlldyk7XG4gIFxuICAgICAgLy8gdHJpZ2dlciB0aGUgJ2JlZm9yZTpzaG93JyBldmVudCBvbiBgdmlld2AgaWYgdGhlIGNvbGxlY3Rpb24gdmlldyBoYXMgYWxyZWFkeSBiZWVuIHNob3duXG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiAhdGhpcy5pc0J1ZmZlcmluZykge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCAnYmVmb3JlOnNob3cnLCB2aWV3KTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBTdG9yZSB0aGUgY2hpbGQgdmlldyBpdHNlbGYgc28gd2UgY2FuIHByb3Blcmx5IHJlbW92ZSBhbmQvb3IgZGVzdHJveSBpdCBsYXRlclxuICAgICAgdGhpcy5jaGlsZHJlbi5hZGQodmlldyk7XG4gIFxuICAgICAgLy8gVHJpZ2dlciBgYmVmb3JlOmF0dGFjaGAgZm9sbG93aW5nIGByZW5kZXJgIHRvIGF2b2lkIGFkZGluZyBsb2dpYyBhbmQgZXZlbnQgdHJpZ2dlcnNcbiAgICAgIC8vIHRvIHB1YmxpYyBtZXRob2QgYHJlbmRlckNoaWxkVmlldygpYC5cbiAgICAgIGlmIChjYW5UcmlnZ2VyQXR0YWNoICYmIHRoaXMuX3RyaWdnZXJCZWZvcmVBdHRhY2gpIHtcbiAgICAgICAgbmVzdGVkVmlld3MgPSBbdmlld10uY29uY2F0KHZpZXcuX2dldE5lc3RlZFZpZXdzKCkpO1xuICAgICAgICB2aWV3Lm9uY2UoJ3JlbmRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJNZXRob2RNYW55KG5lc3RlZFZpZXdzLCB0aGlzLCAnYmVmb3JlOmF0dGFjaCcpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLnJlbmRlckNoaWxkVmlldyh2aWV3LCBpbmRleCk7XG4gIFxuICAgICAgLy8gVHJpZ2dlciBgYXR0YWNoYFxuICAgICAgaWYgKGNhblRyaWdnZXJBdHRhY2ggJiYgdGhpcy5fdHJpZ2dlckF0dGFjaCkge1xuICAgICAgICBuZXN0ZWRWaWV3cyA9IFt2aWV3XS5jb25jYXQodmlldy5fZ2V0TmVzdGVkVmlld3MoKSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJNZXRob2RNYW55KG5lc3RlZFZpZXdzLCB0aGlzLCAnYXR0YWNoJyk7XG4gICAgICB9XG4gICAgICAvLyBUcmlnZ2VyIGBzaG93YFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuaXNCdWZmZXJpbmcpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ3Nob3cnLCB2aWV3KTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyByZW5kZXIgdGhlIGNoaWxkIHZpZXdcbiAgICByZW5kZXJDaGlsZFZpZXc6IGZ1bmN0aW9uKHZpZXcsIGluZGV4KSB7XG4gICAgICB2aWV3LnJlbmRlcigpO1xuICAgICAgdGhpcy5hdHRhY2hIdG1sKHRoaXMsIHZpZXcsIGluZGV4KTtcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIEJ1aWxkIGEgYGNoaWxkVmlld2AgZm9yIGEgbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgYnVpbGRDaGlsZFZpZXc6IGZ1bmN0aW9uKGNoaWxkLCBDaGlsZFZpZXdDbGFzcywgY2hpbGRWaWV3T3B0aW9ucykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfLmV4dGVuZCh7bW9kZWw6IGNoaWxkfSwgY2hpbGRWaWV3T3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IENoaWxkVmlld0NsYXNzKG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbW92ZSB0aGUgY2hpbGQgdmlldyBhbmQgZGVzdHJveSBpdC5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsc28gdXBkYXRlcyB0aGUgaW5kaWNlcyBvZlxuICAgIC8vIGxhdGVyIHZpZXdzIGluIHRoZSBjb2xsZWN0aW9uIGluIG9yZGVyIHRvIGtlZXBcbiAgICAvLyB0aGUgY2hpbGRyZW4gaW4gc3luYyB3aXRoIHRoZSBjb2xsZWN0aW9uLlxuICAgIHJlbW92ZUNoaWxkVmlldzogZnVuY3Rpb24odmlldykge1xuICBcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbW92ZTpjaGlsZCcsIHZpZXcpO1xuICBcbiAgICAgICAgLy8gY2FsbCAnZGVzdHJveScgb3IgJ3JlbW92ZScsIGRlcGVuZGluZyBvbiB3aGljaCBpcyBmb3VuZFxuICAgICAgICBpZiAodmlldy5kZXN0cm95KSB7XG4gICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlldy5yZW1vdmUpIHtcbiAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBkZWxldGUgdmlldy5fcGFyZW50O1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodmlldyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucmVtb3ZlKHZpZXcpO1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbW92ZTpjaGlsZCcsIHZpZXcpO1xuICBcbiAgICAgICAgLy8gZGVjcmVtZW50IHRoZSBpbmRleCBvZiB2aWV3cyBhZnRlciB0aGlzIG9uZVxuICAgICAgICB0aGlzLl91cGRhdGVJbmRpY2VzKHZpZXcsIGZhbHNlKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuICBcbiAgICAvLyBjaGVjayBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmNvbGxlY3Rpb24gfHwgdGhpcy5jb2xsZWN0aW9uLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuICBcbiAgICAvLyBJZiBlbXB0eSwgc2hvdyB0aGUgZW1wdHkgdmlld1xuICAgIGNoZWNrRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSh0aGlzLmNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMuc2hvd0VtcHR5VmlldygpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFlvdSBtaWdodCBuZWVkIHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3ZlIG92ZXJyaWRkZW4gYXR0YWNoSHRtbFxuICAgIGF0dGFjaEJ1ZmZlcjogZnVuY3Rpb24oY29sbGVjdGlvblZpZXcsIGJ1ZmZlcikge1xuICAgICAgY29sbGVjdGlvblZpZXcuJGVsLmFwcGVuZChidWZmZXIpO1xuICAgIH0sXG4gIFxuICAgIC8vIENyZWF0ZSBhIGZyYWdtZW50IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50bHkgYnVmZmVyZWQgY2hpbGRyZW5cbiAgICBfY3JlYXRlQnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbEJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIF8uZWFjaCh0aGlzLl9idWZmZXJlZENoaWxkcmVuLCBmdW5jdGlvbihiKSB7XG4gICAgICAgIGVsQnVmZmVyLmFwcGVuZENoaWxkKGIuZWwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxCdWZmZXI7XG4gICAgfSxcbiAgXG4gICAgLy8gQXBwZW5kIHRoZSBIVE1MIHRvIHRoZSBjb2xsZWN0aW9uJ3MgYGVsYC5cbiAgICAvLyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkbyBzb21ldGhpbmcgb3RoZXJcbiAgICAvLyB0aGFuIGAuYXBwZW5kYC5cbiAgICBhdHRhY2hIdG1sOiBmdW5jdGlvbihjb2xsZWN0aW9uVmlldywgY2hpbGRWaWV3LCBpbmRleCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb25WaWV3LmlzQnVmZmVyaW5nKSB7XG4gICAgICAgIC8vIGJ1ZmZlcmluZyBoYXBwZW5zIG9uIHJlc2V0IGV2ZW50cyBhbmQgaW5pdGlhbCByZW5kZXJzXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGluc2VydHMgaW50byB0aGVcbiAgICAgICAgLy8gZG9jdW1lbnQsIHdoaWNoIGFyZSBleHBlbnNpdmUuXG4gICAgICAgIGNvbGxlY3Rpb25WaWV3Ll9idWZmZXJlZENoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGRWaWV3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgcmVuZGVyZWQgdGhlIG1haW4gY29sbGVjdGlvbiwgYXBwZW5kXG4gICAgICAgIC8vIHRoZSBuZXcgY2hpbGQgaW50byB0aGUgY29ycmVjdCBvcmRlciBpZiB3ZSBuZWVkIHRvLiBPdGhlcndpc2VcbiAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBlbmQuXG4gICAgICAgIGlmICghY29sbGVjdGlvblZpZXcuX2luc2VydEJlZm9yZShjaGlsZFZpZXcsIGluZGV4KSkge1xuICAgICAgICAgIGNvbGxlY3Rpb25WaWV3Ll9pbnNlcnRBZnRlcihjaGlsZFZpZXcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBDaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSB2aWV3IGludG9cbiAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbi5cbiAgICBfaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZFZpZXcsIGluZGV4KSB7XG4gICAgICB2YXIgY3VycmVudFZpZXc7XG4gICAgICB2YXIgZmluZFBvc2l0aW9uID0gdGhpcy5nZXRPcHRpb24oJ3NvcnQnKSAmJiAoaW5kZXggPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGZpbmRQb3NpdGlvbikge1xuICAgICAgICAvLyBGaW5kIHRoZSB2aWV3IGFmdGVyIHRoaXMgb25lXG4gICAgICAgIGN1cnJlbnRWaWV3ID0gdGhpcy5jaGlsZHJlbi5maW5kKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICByZXR1cm4gdmlldy5faW5kZXggPT09IGluZGV4ICsgMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGN1cnJlbnRWaWV3KSB7XG4gICAgICAgIGN1cnJlbnRWaWV3LiRlbC5iZWZvcmUoY2hpbGRWaWV3LmVsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gQXBwZW5kIGEgdmlldyB0byB0aGUgZW5kIG9mIHRoZSAkZWxcbiAgICBfaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgdGhpcy4kZWwuYXBwZW5kKGNoaWxkVmlldy5lbCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldCB1cCB0aGUgYGNoaWxkcmVuYCBvYmplY3QgZm9yXG4gICAgLy8gc3RvcmluZyBhbGwgb2YgdGhlIGNoaWxkIHZpZXdzXG4gICAgX2luaXRDaGlsZFZpZXdTdG9yYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSGFuZGxlIGNsZWFudXAgYW5kIG90aGVyIGRlc3Ryb3lpbmcgbmVlZHMgZm9yIHRoZSBjb2xsZWN0aW9uIG9mIHZpZXdzXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOmRlc3Ryb3k6Y29sbGVjdGlvbicpO1xuICAgICAgdGhpcy5kZXN0cm95Q2hpbGRyZW4oe2NoZWNrRW1wdHk6IGZhbHNlfSk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2Rlc3Ryb3k6Y29sbGVjdGlvbicpO1xuICBcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLlZpZXcucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBEZXN0cm95IHRoZSBjaGlsZCB2aWV3cyB0aGF0IHRoaXMgY29sbGVjdGlvbiB2aWV3XG4gICAgLy8gaXMgaG9sZGluZyBvbiB0bywgaWYgYW55XG4gICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZGVzdHJveU9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHNob3VsZENoZWNrRW1wdHkgPSB0cnVlO1xuICAgICAgdmFyIGNoaWxkVmlld3MgPSB0aGlzLmNoaWxkcmVuLm1hcChfLmlkZW50aXR5KTtcbiAgXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQoZGVzdHJveU9wdGlvbnMuY2hlY2tFbXB0eSkpIHtcbiAgICAgICAgc2hvdWxkQ2hlY2tFbXB0eSA9IGRlc3Ryb3lPcHRpb25zLmNoZWNrRW1wdHk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKHRoaXMucmVtb3ZlQ2hpbGRWaWV3LCB0aGlzKTtcbiAgXG4gICAgICBpZiAoc2hvdWxkQ2hlY2tFbXB0eSkge1xuICAgICAgICB0aGlzLmNoZWNrRW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZFZpZXdzO1xuICAgIH0sXG4gIFxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBjaGlsZCBzaG91bGQgYmUgc2hvd25cbiAgICAvLyBSZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlXG4gICAgLy8gVGhlIGZpbHRlciB3aWxsIGJlIHBhc3NlZCAoY2hpbGQsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgIC8vIFdoZXJlXG4gICAgLy8gICdjaGlsZCcgaXMgdGhlIGdpdmVuIG1vZGVsXG4gICAgLy8gICdpbmRleCcgaXMgdGhlIGluZGV4IG9mIHRoYXQgbW9kZWwgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyAgJ2NvbGxlY3Rpb24nIGlzIHRoZSBjb2xsZWN0aW9uIHJlZmVyZW5jZWQgYnkgdGhpcyBDb2xsZWN0aW9uVmlld1xuICAgIF9zaG91bGRBZGRDaGlsZDogZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRPcHRpb24oJ2ZpbHRlcicpO1xuICAgICAgcmV0dXJuICFfLmlzRnVuY3Rpb24oZmlsdGVyKSB8fCBmaWx0ZXIuY2FsbCh0aGlzLCBjaGlsZCwgaW5kZXgsIHRoaXMuY29sbGVjdGlvbik7XG4gICAgfSxcbiAgXG4gICAgLy8gU2V0IHVwIHRoZSBjaGlsZCB2aWV3IGV2ZW50IGZvcndhcmRpbmcuIFVzZXMgYSBcImNoaWxkdmlldzpcIlxuICAgIC8vIHByZWZpeCBpbiBmcm9udCBvZiBhbGwgZm9yd2FyZGVkIGV2ZW50cy5cbiAgICBwcm94eUNoaWxkRXZlbnRzOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICB2YXIgcHJlZml4ID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlld0V2ZW50UHJlZml4Jyk7XG4gIFxuICAgICAgLy8gRm9yd2FyZCBhbGwgY2hpbGQgdmlldyBldmVudHMgdGhyb3VnaCB0aGUgcGFyZW50LFxuICAgICAgLy8gcHJlcGVuZGluZyBcImNoaWxkdmlldzpcIiB0byB0aGUgZXZlbnQgbmFtZVxuICAgICAgdGhpcy5saXN0ZW5Ubyh2aWV3LCAnYWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciByb290RXZlbnQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY2hpbGRFdmVudHMgPSB0aGlzLm5vcm1hbGl6ZU1ldGhvZHMoXy5yZXN1bHQodGhpcywgJ2NoaWxkRXZlbnRzJykpO1xuICBcbiAgICAgICAgYXJnc1swXSA9IHByZWZpeCArICc6JyArIHJvb3RFdmVudDtcbiAgICAgICAgYXJncy5zcGxpY2UoMSwgMCwgdmlldyk7XG4gIFxuICAgICAgICAvLyBjYWxsIGNvbGxlY3Rpb25WaWV3IGNoaWxkRXZlbnQgaWYgZGVmaW5lZFxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkRXZlbnRzICE9PSAndW5kZWZpbmVkJyAmJiBfLmlzRnVuY3Rpb24oY2hpbGRFdmVudHNbcm9vdEV2ZW50XSkpIHtcbiAgICAgICAgICBjaGlsZEV2ZW50c1tyb290RXZlbnRdLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICB9XG4gIFxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICBfZ2V0SW1tZWRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8udmFsdWVzKHRoaXMuY2hpbGRyZW4uX3ZpZXdzKTtcbiAgICB9LFxuICBcbiAgICBnZXRWaWV3Q29tcGFyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oJ3ZpZXdDb21wYXJhdG9yJyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAxNywgbWF4bGVuOiAxMTcgKi9cbiAgXG4gIC8vIENvbXBvc2l0ZSBWaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAvLyBVc2VkIGZvciByZW5kZXJpbmcgYSBicmFuY2gtbGVhZiwgaGllcmFyY2hpY2FsIHN0cnVjdHVyZS5cbiAgLy8gRXh0ZW5kcyBkaXJlY3RseSBmcm9tIENvbGxlY3Rpb25WaWV3IGFuZCBhbHNvIHJlbmRlcnMgYW5cbiAgLy8gYSBjaGlsZCB2aWV3IGFzIGBtb2RlbFZpZXdgLCBmb3IgdGhlIHRvcCBsZWFmXG4gIE1hcmlvbmV0dGUuQ29tcG9zaXRlVmlldyA9IE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcuZXh0ZW5kKHtcbiAgXG4gICAgLy8gU2V0dGluZyB1cCB0aGUgaW5oZXJpdGFuY2UgY2hhaW4gd2hpY2ggYWxsb3dzIGNoYW5nZXMgdG9cbiAgICAvLyBNYXJpb25ldHRlLkNvbGxlY3Rpb25WaWV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvciB3aGljaCBhbGxvd3Mgb3ZlcnJpZGluZ1xuICAgIC8vIG9wdGlvbiB0byBwYXNzICd7c29ydDogZmFsc2V9JyB0byBwcmV2ZW50IHRoZSBDb21wb3NpdGVWaWV3IGZyb21cbiAgICAvLyBtYWludGFpbmluZyB0aGUgc29ydGVkIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIC8vIFRoaXMgd2lsbCBmYWxsYmFjayBvbnRvIGFwcGVuZGluZyBjaGlsZFZpZXcncyB0byB0aGUgZW5kLlxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBDb25maWd1cmVkIHRoZSBpbml0aWFsIGV2ZW50cyB0aGF0IHRoZSBjb21wb3NpdGUgdmlld1xuICAgIC8vIGJpbmRzIHRvLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcmV2ZW50IHRoZSBpbml0aWFsXG4gICAgLy8gZXZlbnRzLCBvciB0byBhZGQgeW91ciBvd24gaW5pdGlhbCBldmVudHMuXG4gICAgX2luaXRpYWxFdmVudHM6IGZ1bmN0aW9uKCkge1xuICBcbiAgICAgIC8vIEJpbmQgb25seSBhZnRlciBjb21wb3NpdGUgdmlldyBpcyByZW5kZXJlZCB0byBhdm9pZCBhZGRpbmcgY2hpbGQgdmlld3NcbiAgICAgIC8vIHRvIG5vbmV4aXN0ZW50IGNoaWxkVmlld0NvbnRhaW5lclxuICBcbiAgICAgIGlmICh0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdhZGQnLCB0aGlzLl9vbkNvbGxlY3Rpb25BZGQpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3JlbW92ZScsIHRoaXMuX29uQ29sbGVjdGlvblJlbW92ZSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAncmVzZXQnLCB0aGlzLl9yZW5kZXJDaGlsZHJlbik7XG4gIFxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ3NvcnQnKSkge1xuICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnc29ydCcsIHRoaXMuX3NvcnRWaWV3cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZXRyaWV2ZSB0aGUgYGNoaWxkVmlld2AgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBlYWNoIG9mXG4gICAgLy8gdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpcyB0byByZXR1cm5cbiAgICAvLyBgdGhpcy5jaGlsZFZpZXdgIG9yIE1hcmlvbmV0dGUuQ29tcG9zaXRlVmlldyBpZiBubyBgY2hpbGRWaWV3YFxuICAgIC8vIGhhcyBiZWVuIGRlZmluZWRcbiAgICBnZXRDaGlsZFZpZXc6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRWaWV3ID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlldycpIHx8IHRoaXMuY29uc3RydWN0b3I7XG4gIFxuICAgICAgcmV0dXJuIGNoaWxkVmlldztcbiAgICB9LFxuICBcbiAgICAvLyBTZXJpYWxpemUgdGhlIG1vZGVsIGZvciB0aGUgdmlldy5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoZSBgc2VyaWFsaXplRGF0YWAgbWV0aG9kIGluIHlvdXIgb3duIHZpZXdcbiAgICAvLyBkZWZpbml0aW9uLCB0byBwcm92aWRlIGN1c3RvbSBzZXJpYWxpemF0aW9uIGZvciB5b3VyIHZpZXcncyBkYXRhLlxuICAgIHNlcmlhbGl6ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgXG4gICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICBkYXRhID0gXy5wYXJ0aWFsKHRoaXMuc2VyaWFsaXplTW9kZWwsIHRoaXMubW9kZWwpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVuZGVycyB0aGUgbW9kZWwgYW5kIHRoZSBjb2xsZWN0aW9uLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9lbnN1cmVWaWV3SXNJbnRhY3QoKTtcbiAgICAgIHRoaXMuX2lzUmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzZXRDaGlsZFZpZXdDb250YWluZXIoKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW5kZXInLCB0aGlzKTtcbiAgXG4gICAgICB0aGlzLl9yZW5kZXJUZW1wbGF0ZSgpO1xuICAgICAgdGhpcy5fcmVuZGVyQ2hpbGRyZW4oKTtcbiAgXG4gICAgICB0aGlzLl9pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVuZGVyJywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICBfcmVuZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJlZCB8fCB0aGlzLl9pc1JlbmRlcmluZykge1xuICAgICAgICBNYXJpb25ldHRlLkNvbGxlY3Rpb25WaWV3LnByb3RvdHlwZS5fcmVuZGVyQ2hpbGRyZW4uY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXIgdGhlIHJvb3QgdGVtcGxhdGUgdGhhdCB0aGUgY2hpbGRyZW5cbiAgICAvLyB2aWV3cyBhcmUgYXBwZW5kZWQgdG9cbiAgICBfcmVuZGVyVGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgIGRhdGEgPSB0aGlzLnNlcmlhbGl6ZURhdGEoKTtcbiAgICAgIGRhdGEgPSB0aGlzLm1peGluVGVtcGxhdGVIZWxwZXJzKGRhdGEpO1xuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcjp0ZW1wbGF0ZScpO1xuICBcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuZ2V0VGVtcGxhdGUoKTtcbiAgICAgIHZhciBodG1sID0gTWFyaW9uZXR0ZS5SZW5kZXJlci5yZW5kZXIodGVtcGxhdGUsIGRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy5hdHRhY2hFbENvbnRlbnQoaHRtbCk7XG4gIFxuICAgICAgLy8gdGhlIHVpIGJpbmRpbmdzIGlzIGRvbmUgaGVyZSBhbmQgbm90IGF0IHRoZSBlbmQgb2YgcmVuZGVyIHNpbmNlIHRoZXlcbiAgICAgIC8vIHdpbGwgbm90IGJlIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgbW9kZWwgaXMgcmVuZGVyZWQsIGJ1dCBzaG91bGQgYmVcbiAgICAgIC8vIGF2YWlsYWJsZSBiZWZvcmUgdGhlIGNvbGxlY3Rpb24gaXMgcmVuZGVyZWQuXG4gICAgICB0aGlzLmJpbmRVSUVsZW1lbnRzKCk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcjp0ZW1wbGF0ZScpO1xuICAgIH0sXG4gIFxuICAgIC8vIEF0dGFjaGVzIHRoZSBjb250ZW50IG9mIHRoZSByb290LlxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIG9wdGltaXplIHJlbmRlcmluZyxcbiAgICAvLyBvciB0byByZW5kZXIgaW4gYSBub24gc3RhbmRhcmQgd2F5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHVzaW5nIGBpbm5lckhUTUxgIGluc3RlYWQgb2YgYCRlbC5odG1sYFxuICAgIC8vXG4gICAgLy8gYGBganNcbiAgICAvLyBhdHRhY2hFbENvbnRlbnQ6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAvLyAgIHRoaXMuZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAvLyAgIHJldHVybiB0aGlzO1xuICAgIC8vIH1cbiAgICAvLyBgYGBcbiAgICBhdHRhY2hFbENvbnRlbnQ6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHRoaXMuJGVsLmh0bWwoaHRtbCk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gWW91IG1pZ2h0IG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBpZiB5b3UndmUgb3ZlcnJpZGRlbiBhdHRhY2hIdG1sXG4gICAgYXR0YWNoQnVmZmVyOiBmdW5jdGlvbihjb21wb3NpdGVWaWV3LCBidWZmZXIpIHtcbiAgICAgIHZhciAkY29udGFpbmVyID0gdGhpcy5nZXRDaGlsZFZpZXdDb250YWluZXIoY29tcG9zaXRlVmlldyk7XG4gICAgICAkY29udGFpbmVyLmFwcGVuZChidWZmZXIpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gQXBwZW5kIGEgdmlldyB0byB0aGUgZW5kIG9mIHRoZSAkZWwuXG4gICAgLy8gT3ZlcmlkZGVuIGZyb20gQ29sbGVjdGlvblZpZXcgdG8gZW5zdXJlIHZpZXcgaXMgYXBwZW5kZWQgdG9cbiAgICAvLyBjaGlsZFZpZXdDb250YWluZXJcbiAgICBfaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgdmFyICRjb250YWluZXIgPSB0aGlzLmdldENoaWxkVmlld0NvbnRhaW5lcih0aGlzLCBjaGlsZFZpZXcpO1xuICAgICAgJGNvbnRhaW5lci5hcHBlbmQoY2hpbGRWaWV3LmVsKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIEFwcGVuZCByZW9yZGVyZWQgY2hpbGRWaWV3Jy5cbiAgICAvLyBPdmVyaWRkZW4gZnJvbSBDb2xsZWN0aW9uVmlldyB0byBlbnN1cmUgcmVvcmRlcmVkIHZpZXdzXG4gICAgLy8gYXJlIGFwcGVuZGVkIHRvIGNoaWxkVmlld0NvbnRhaW5lclxuICAgIF9hcHBlbmRSZW9yZGVyZWRDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgIHZhciAkY29udGFpbmVyID0gdGhpcy5nZXRDaGlsZFZpZXdDb250YWluZXIodGhpcyk7XG4gICAgICAkY29udGFpbmVyLmFwcGVuZChjaGlsZHJlbik7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGVuc3VyZSBhbiBgJGNoaWxkVmlld0NvbnRhaW5lcmAgZXhpc3RzLCBmb3IgdGhlXG4gICAgLy8gYGF0dGFjaEh0bWxgIG1ldGhvZCB0byB1c2UuXG4gICAgZ2V0Q2hpbGRWaWV3Q29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXJWaWV3LCBjaGlsZFZpZXcpIHtcbiAgICAgIGlmICghIWNvbnRhaW5lclZpZXcuJGNoaWxkVmlld0NvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyVmlldy4kY2hpbGRWaWV3Q29udGFpbmVyO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBjb250YWluZXI7XG4gICAgICB2YXIgY2hpbGRWaWV3Q29udGFpbmVyID0gTWFyaW9uZXR0ZS5nZXRPcHRpb24oY29udGFpbmVyVmlldywgJ2NoaWxkVmlld0NvbnRhaW5lcicpO1xuICAgICAgaWYgKGNoaWxkVmlld0NvbnRhaW5lcikge1xuICBcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUoY2hpbGRWaWV3Q29udGFpbmVyLCBjb250YWluZXJWaWV3KTtcbiAgXG4gICAgICAgIGlmIChzZWxlY3Rvci5jaGFyQXQoMCkgPT09ICdAJyAmJiBjb250YWluZXJWaWV3LnVpKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyVmlldy51aVtzZWxlY3Rvci5zdWJzdHIoNCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclZpZXcuJChzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmIChjb250YWluZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgICBuYW1lOiAnQ2hpbGRWaWV3Q29udGFpbmVyTWlzc2luZ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgc3BlY2lmaWVkIFwiY2hpbGRWaWV3Q29udGFpbmVyXCIgd2FzIG5vdCBmb3VuZDogJyArIGNvbnRhaW5lclZpZXcuY2hpbGRWaWV3Q29udGFpbmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJWaWV3LiRlbDtcbiAgICAgIH1cbiAgXG4gICAgICBjb250YWluZXJWaWV3LiRjaGlsZFZpZXdDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byByZXNldCB0aGUgYCRjaGlsZFZpZXdDb250YWluZXJgIG9uIHJlbmRlclxuICAgIHJlc2V0Q2hpbGRWaWV3Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRjaGlsZFZpZXdDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy4kY2hpbGRWaWV3Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBMYXlvdXQgVmlld1xuICAvLyAtLS0tLS0tLS0tLVxuICBcbiAgLy8gVXNlZCBmb3IgbWFuYWdpbmcgYXBwbGljYXRpb24gbGF5b3V0Vmlld3MsIG5lc3RlZCBsYXlvdXRWaWV3cyBhbmRcbiAgLy8gbXVsdGlwbGUgcmVnaW9ucyB3aXRoaW4gYW4gYXBwbGljYXRpb24gb3Igc3ViLWFwcGxpY2F0aW9uLlxuICAvL1xuICAvLyBBIHNwZWNpYWxpemVkIHZpZXcgY2xhc3MgdGhhdCByZW5kZXJzIGFuIGFyZWEgb2YgSFRNTCBhbmQgdGhlblxuICAvLyBhdHRhY2hlcyBgUmVnaW9uYCBpbnN0YW5jZXMgdG8gdGhlIHNwZWNpZmllZCBgcmVnaW9uc2AuXG4gIC8vIFVzZWQgZm9yIGNvbXBvc2l0ZSB2aWV3IG1hbmFnZW1lbnQgYW5kIHN1Yi1hcHBsaWNhdGlvbiBhcmVhcy5cbiAgTWFyaW9uZXR0ZS5MYXlvdXRWaWV3ID0gTWFyaW9uZXR0ZS5JdGVtVmlldy5leHRlbmQoe1xuICAgIHJlZ2lvbkNsYXNzOiBNYXJpb25ldHRlLlJlZ2lvbixcbiAgXG4gICAgb3B0aW9uczoge1xuICAgICAgZGVzdHJveUltbWVkaWF0ZTogZmFsc2VcbiAgICB9LFxuICBcbiAgICAvLyB1c2VkIGFzIHRoZSBwcmVmaXggZm9yIGNoaWxkIHZpZXcgZXZlbnRzXG4gICAgLy8gdGhhdCBhcmUgZm9yd2FyZGVkIHRocm91Z2ggdGhlIGxheW91dHZpZXdcbiAgICBjaGlsZFZpZXdFdmVudFByZWZpeDogJ2NoaWxkdmlldycsXG4gIFxuICAgIC8vIEVuc3VyZSB0aGUgcmVnaW9ucyBhcmUgYXZhaWxhYmxlIHdoZW4gdGhlIGBpbml0aWFsaXplYCBtZXRob2RcbiAgICAvLyBpcyBjYWxsZWQuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICAgIHRoaXMuX2ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVSZWdpb25zKG9wdGlvbnMpO1xuICBcbiAgICAgIE1hcmlvbmV0dGUuSXRlbVZpZXcuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBMYXlvdXRWaWV3J3MgcmVuZGVyIHdpbGwgdXNlIHRoZSBleGlzdGluZyByZWdpb24gb2JqZWN0cyB0aGVcbiAgICAvLyBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC4gU3Vic2VxdWVudCBjYWxscyB3aWxsIGRlc3Ryb3kgdGhlXG4gICAgLy8gdmlld3MgdGhhdCB0aGUgcmVnaW9ucyBhcmUgc2hvd2luZyBhbmQgdGhlbiByZXNldCB0aGUgYGVsYFxuICAgIC8vIGZvciB0aGUgcmVnaW9ucyB0byB0aGUgbmV3bHkgcmVuZGVyZWQgRE9NIGVsZW1lbnRzLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9lbnN1cmVWaWV3SXNJbnRhY3QoKTtcbiAgXG4gICAgICBpZiAodGhpcy5fZmlyc3RSZW5kZXIpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyLCBkb24ndCBkbyBhbnl0aGluZyB0b1xuICAgICAgICAvLyByZXNldCB0aGUgcmVnaW9uc1xuICAgICAgICB0aGlzLl9maXJzdFJlbmRlciA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IHJlbmRlciBjYWxsLCB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgYGVsYCBmb3IgZWFjaCByZWdpb25cbiAgICAgICAgdGhpcy5fcmVJbml0aWFsaXplUmVnaW9ucygpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBNYXJpb25ldHRlLkl0ZW1WaWV3LnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBIYW5kbGUgZGVzdHJveWluZyByZWdpb25zLCBhbmQgdGhlbiBkZXN0cm95IHRoZSB2aWV3IGl0c2VsZi5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICAvLyAjMjEzNDogcmVtb3ZlIHBhcmVudCBlbGVtZW50IGJlZm9yZSBkZXN0cm95aW5nIHRoZSBjaGlsZCB2aWV3cywgc29cbiAgICAgIC8vIHJlbW92aW5nIHRoZSBjaGlsZCB2aWV3cyBkb2Vzbid0IHJldHJpZ2dlciByZXBhaW50c1xuICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdkZXN0cm95SW1tZWRpYXRlJykgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2lvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuSXRlbVZpZXcucHJvdG90eXBlLmRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICBzaG93Q2hpbGRWaWV3OiBmdW5jdGlvbihyZWdpb25OYW1lLCB2aWV3KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSZWdpb24ocmVnaW9uTmFtZSkuc2hvdyh2aWV3KTtcbiAgICB9LFxuICBcbiAgICBnZXRDaGlsZFZpZXc6IGZ1bmN0aW9uKHJlZ2lvbk5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlZ2lvbihyZWdpb25OYW1lKS5jdXJyZW50VmlldztcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgYSBzaW5nbGUgcmVnaW9uLCBieSBuYW1lLCB0byB0aGUgbGF5b3V0Vmlld1xuICAgIGFkZFJlZ2lvbjogZnVuY3Rpb24obmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgdmFyIHJlZ2lvbnMgPSB7fTtcbiAgICAgIHJlZ2lvbnNbbmFtZV0gPSBkZWZpbml0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9ucyhyZWdpb25zKVtuYW1lXTtcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgbXVsdGlwbGUgcmVnaW9ucyBhcyBhIHtuYW1lOiBkZWZpbml0aW9uLCBuYW1lMjogZGVmMn0gb2JqZWN0IGxpdGVyYWxcbiAgICBhZGRSZWdpb25zOiBmdW5jdGlvbihyZWdpb25zKSB7XG4gICAgICB0aGlzLnJlZ2lvbnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5yZWdpb25zLCByZWdpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLl9idWlsZFJlZ2lvbnMocmVnaW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVtb3ZlIGEgc2luZ2xlIHJlZ2lvbiBmcm9tIHRoZSBMYXlvdXRWaWV3LCBieSBuYW1lXG4gICAgcmVtb3ZlUmVnaW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5yZWdpb25zW25hbWVdO1xuICAgICAgcmV0dXJuIHRoaXMucmVnaW9uTWFuYWdlci5yZW1vdmVSZWdpb24obmFtZSk7XG4gICAgfSxcbiAgXG4gICAgLy8gUHJvdmlkZXMgYWx0ZXJuYXRpdmUgYWNjZXNzIHRvIHJlZ2lvbnNcbiAgICAvLyBBY2NlcHRzIHRoZSByZWdpb24gbmFtZVxuICAgIC8vIGdldFJlZ2lvbignbWFpbicpXG4gICAgZ2V0UmVnaW9uOiBmdW5jdGlvbihyZWdpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lvbk1hbmFnZXIuZ2V0KHJlZ2lvbik7XG4gICAgfSxcbiAgXG4gICAgLy8gR2V0IGFsbCByZWdpb25zXG4gICAgZ2V0UmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbnMoKTtcbiAgICB9LFxuICBcbiAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gYnVpbGQgcmVnaW9uc1xuICAgIF9idWlsZFJlZ2lvbnM6IGZ1bmN0aW9uKHJlZ2lvbnMpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgcmVnaW9uQ2xhc3M6IHRoaXMuZ2V0T3B0aW9uKCdyZWdpb25DbGFzcycpLFxuICAgICAgICBwYXJlbnRFbDogXy5wYXJ0aWFsKF8ucmVzdWx0LCB0aGlzLCAnZWwnKVxuICAgICAgfTtcbiAgXG4gICAgICByZXR1cm4gdGhpcy5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbnMocmVnaW9ucywgZGVmYXVsdHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBpbml0aWFsaXplIHRoZSByZWdpb25zIHRoYXQgaGF2ZSBiZWVuIGRlZmluZWQgaW4gYVxuICAgIC8vIGByZWdpb25zYCBhdHRyaWJ1dGUgb24gdGhpcyBsYXlvdXRWaWV3LlxuICAgIF9pbml0aWFsaXplUmVnaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHJlZ2lvbnM7XG4gICAgICB0aGlzLl9pbml0UmVnaW9uTWFuYWdlcigpO1xuICBcbiAgICAgIHJlZ2lvbnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZSh0aGlzLnJlZ2lvbnMsIHRoaXMsIFtvcHRpb25zXSkgfHwge307XG4gIFxuICAgICAgLy8gRW5hYmxlIHVzZXJzIHRvIGRlZmluZSBgcmVnaW9uc2AgYXMgaW5zdGFuY2Ugb3B0aW9ucy5cbiAgICAgIHZhciByZWdpb25PcHRpb25zID0gdGhpcy5nZXRPcHRpb24uY2FsbChvcHRpb25zLCAncmVnaW9ucycpO1xuICBcbiAgICAgIC8vIGVuYWJsZSByZWdpb24gb3B0aW9ucyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICByZWdpb25PcHRpb25zID0gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUocmVnaW9uT3B0aW9ucywgdGhpcywgW29wdGlvbnNdKTtcbiAgXG4gICAgICBfLmV4dGVuZChyZWdpb25zLCByZWdpb25PcHRpb25zKTtcbiAgXG4gICAgICAvLyBOb3JtYWxpemUgcmVnaW9uIHNlbGVjdG9ycyBoYXNoIHRvIGFsbG93XG4gICAgICAvLyBhIHVzZXIgdG8gdXNlIHRoZSBAdWkuIHN5bnRheC5cbiAgICAgIHJlZ2lvbnMgPSB0aGlzLm5vcm1hbGl6ZVVJVmFsdWVzKHJlZ2lvbnMsIFsnc2VsZWN0b3InLCAnZWwnXSk7XG4gIFxuICAgICAgdGhpcy5hZGRSZWdpb25zKHJlZ2lvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byByZS1pbml0aWFsaXplIGFsbCBvZiB0aGUgcmVnaW9ucyBieSB1cGRhdGluZyB0aGUgYGVsYCB0aGF0XG4gICAgLy8gdGhleSBwb2ludCB0b1xuICAgIF9yZUluaXRpYWxpemVSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5pbnZva2UoJ3Jlc2V0Jyk7XG4gICAgfSxcbiAgXG4gICAgLy8gRW5hYmxlIGVhc3kgb3ZlcnJpZGluZyBvZiB0aGUgZGVmYXVsdCBgUmVnaW9uTWFuYWdlcmBcbiAgICAvLyBmb3IgY3VzdG9taXplZCByZWdpb24gaW50ZXJhY3Rpb25zIGFuZCBidXNpbmVzcyBzcGVjaWZpY1xuICAgIC8vIHZpZXcgbG9naWMgZm9yIGJldHRlciBjb250cm9sIG92ZXIgc2luZ2xlIHJlZ2lvbnMuXG4gICAgZ2V0UmVnaW9uTWFuYWdlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcmlvbmV0dGUuUmVnaW9uTWFuYWdlcigpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBpbml0aWFsaXplIHRoZSByZWdpb24gbWFuYWdlclxuICAgIC8vIGFuZCBhbGwgcmVnaW9ucyBpbiBpdFxuICAgIF9pbml0UmVnaW9uTWFuYWdlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlZ2lvbk1hbmFnZXIgPSB0aGlzLmdldFJlZ2lvbk1hbmFnZXIoKTtcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5fcGFyZW50ID0gdGhpcztcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMucmVnaW9uTWFuYWdlciwgJ2JlZm9yZTphZGQ6cmVnaW9uJywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTphZGQ6cmVnaW9uJywgbmFtZSk7XG4gICAgICB9KTtcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMucmVnaW9uTWFuYWdlciwgJ2FkZDpyZWdpb24nLCBmdW5jdGlvbihuYW1lLCByZWdpb24pIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdhZGQ6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBuYW1lKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAncmVtb3ZlOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW1vdmU6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIF9nZXRJbW1lZGlhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jaGFpbih0aGlzLnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9ucygpKVxuICAgICAgICAucGx1Y2soJ2N1cnJlbnRWaWV3JylcbiAgICAgICAgLmNvbXBhY3QoKVxuICAgICAgICAudmFsdWUoKTtcbiAgICB9XG4gIH0pO1xuICBcblxuICAvLyBCZWhhdmlvclxuICAvLyAtLS0tLS0tLVxuICBcbiAgLy8gQSBCZWhhdmlvciBpcyBhbiBpc29sYXRlZCBzZXQgb2YgRE9NIC9cbiAgLy8gdXNlciBpbnRlcmFjdGlvbnMgdGhhdCBjYW4gYmUgbWl4ZWQgaW50byBhbnkgVmlldy5cbiAgLy8gQmVoYXZpb3JzIGFsbG93IHlvdSB0byBibGFja2JveCBWaWV3IHNwZWNpZmljIGludGVyYWN0aW9uc1xuICAvLyBpbnRvIHBvcnRhYmxlIGxvZ2ljYWwgY2h1bmtzLCBrZWVwaW5nIHlvdXIgdmlld3Mgc2ltcGxlIGFuZCB5b3VyIGNvZGUgRFJZLlxuICBcbiAgTWFyaW9uZXR0ZS5CZWhhdmlvciA9IE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMsIHZpZXcpIHtcbiAgICAgIC8vIFNldHVwIHJlZmVyZW5jZSB0byB0aGUgdmlldy5cbiAgICAgIC8vIHRoaXMgY29tZXMgaW4gaGFuZGxlIHdoZW4gYSBiZWhhdmlvclxuICAgICAgLy8gd2FudHMgdG8gZGlyZWN0bHkgdGFsayB1cCB0aGUgY2hhaW5cbiAgICAgIC8vIHRvIHRoZSB2aWV3LlxuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSB8fCB7fTtcbiAgICAgIHRoaXMub3B0aW9ucyAgPSBfLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAvLyBDb25zdHJ1Y3QgYW4gaW50ZXJuYWwgVUkgaGFzaCB1c2luZ1xuICAgICAgLy8gdGhlIHZpZXdzIFVJIGhhc2ggYW5kIHRoZW4gdGhlIGJlaGF2aW9ycyBVSSBoYXNoLlxuICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gdXNlIFVJIGhhc2ggZWxlbWVudHNcbiAgICAgIC8vIGRlZmluZWQgaW4gdGhlIHBhcmVudCB2aWV3IGFzIHdlbGwgYXMgdGhvc2VcbiAgICAgIC8vIGRlZmluZWQgaW4gdGhlIGdpdmVuIGJlaGF2aW9yLlxuICAgICAgdGhpcy51aSA9IF8uZXh0ZW5kKHt9LCBfLnJlc3VsdCh2aWV3LCAndWknKSwgXy5yZXN1bHQodGhpcywgJ3VpJykpO1xuICBcbiAgICAgIE1hcmlvbmV0dGUuT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gcHJveHkgYmVoYXZpb3IgJCBtZXRob2QgdG8gdGhlIHZpZXdcbiAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZG9pbmcganF1ZXJ5IERPTSBsb29rdXBzXG4gICAgLy8gc2NvcGVkIHRvIGJlaGF2aW9ycyB2aWV3LlxuICAgICQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlldy4kLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBTdG9wcyB0aGUgYmVoYXZpb3IgZnJvbSBsaXN0ZW5pbmcgdG8gZXZlbnRzLlxuICAgIC8vIE92ZXJyaWRlcyBPYmplY3QjZGVzdHJveSB0byBwcmV2ZW50IGFkZGl0aW9uYWwgZXZlbnRzIGZyb20gYmVpbmcgdHJpZ2dlcmVkLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgcHJveHlWaWV3UHJvcGVydGllczogZnVuY3Rpb24odmlldykge1xuICAgICAgdGhpcy4kZWwgPSB2aWV3LiRlbDtcbiAgICAgIHRoaXMuZWwgPSB2aWV3LmVsO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvKiBqc2hpbnQgbWF4bGVuOiAxNDMgKi9cbiAgLy8gQmVoYXZpb3JzXG4gIC8vIC0tLS0tLS0tLVxuICBcbiAgLy8gQmVoYXZpb3JzIGlzIGEgdXRpbGl0eSBjbGFzcyB0aGF0IHRha2VzIGNhcmUgb2ZcbiAgLy8gZ2x1aW5nIHlvdXIgYmVoYXZpb3IgaW5zdGFuY2VzIHRvIHRoZWlyIGdpdmVuIFZpZXcuXG4gIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IG9mIHRoaXMgY2xhc3MgaXMgdGhhdCB5b3VcbiAgLy8gKipNVVNUKiogb3ZlcnJpZGUgdGhlIGNsYXNzIGxldmVsIGJlaGF2aW9yc0xvb2t1cFxuICAvLyBtZXRob2QgZm9yIHRoaW5ncyB0byB3b3JrIHByb3Blcmx5LlxuICBcbiAgTWFyaW9uZXR0ZS5CZWhhdmlvcnMgPSAoZnVuY3Rpb24oTWFyaW9uZXR0ZSwgXykge1xuICAgIC8vIEJvcnJvdyBldmVudCBzcGxpdHRlciBmcm9tIEJhY2tib25lXG4gICAgdmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcbiAgXG4gICAgZnVuY3Rpb24gQmVoYXZpb3JzKHZpZXcsIGJlaGF2aW9ycykge1xuICBcbiAgICAgIGlmICghXy5pc09iamVjdCh2aWV3LmJlaGF2aW9ycykpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICBcbiAgICAgIC8vIEJlaGF2aW9ycyBkZWZpbmVkIG9uIGEgdmlldyBjYW4gYmUgYSBmbGF0IG9iamVjdCBsaXRlcmFsXG4gICAgICAvLyBvciBpdCBjYW4gYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0LlxuICAgICAgYmVoYXZpb3JzID0gQmVoYXZpb3JzLnBhcnNlQmVoYXZpb3JzKHZpZXcsIGJlaGF2aW9ycyB8fCBfLnJlc3VsdCh2aWV3LCAnYmVoYXZpb3JzJykpO1xuICBcbiAgICAgIC8vIFdyYXBzIHNldmVyYWwgb2YgdGhlIHZpZXcncyBtZXRob2RzXG4gICAgICAvLyBjYWxsaW5nIHRoZSBtZXRob2RzIGZpcnN0IG9uIGVhY2ggYmVoYXZpb3JcbiAgICAgIC8vIGFuZCB0aGVuIGV2ZW50dWFsbHkgY2FsbGluZyB0aGUgbWV0aG9kIG9uIHRoZSB2aWV3LlxuICAgICAgQmVoYXZpb3JzLndyYXAodmlldywgYmVoYXZpb3JzLCBfLmtleXMobWV0aG9kcykpO1xuICAgICAgcmV0dXJuIGJlaGF2aW9ycztcbiAgICB9XG4gIFxuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgYmVoYXZpb3JUcmlnZ2VyczogZnVuY3Rpb24oYmVoYXZpb3JUcmlnZ2VycywgYmVoYXZpb3JzKSB7XG4gICAgICAgIHZhciB0cmlnZ2VyQnVpbGRlciA9IG5ldyBCZWhhdmlvclRyaWdnZXJzQnVpbGRlcih0aGlzLCBiZWhhdmlvcnMpO1xuICAgICAgICByZXR1cm4gdHJpZ2dlckJ1aWxkZXIuYnVpbGRCZWhhdmlvclRyaWdnZXJzKCk7XG4gICAgICB9LFxuICBcbiAgICAgIGJlaGF2aW9yRXZlbnRzOiBmdW5jdGlvbihiZWhhdmlvckV2ZW50cywgYmVoYXZpb3JzKSB7XG4gICAgICAgIHZhciBfYmVoYXZpb3JzRXZlbnRzID0ge307XG4gIFxuICAgICAgICBfLmVhY2goYmVoYXZpb3JzLCBmdW5jdGlvbihiLCBpKSB7XG4gICAgICAgICAgdmFyIF9ldmVudHMgPSB7fTtcbiAgICAgICAgICB2YXIgYmVoYXZpb3JFdmVudHMgPSBfLmNsb25lKF8ucmVzdWx0KGIsICdldmVudHMnKSkgfHwge307XG4gIFxuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBiZWhhdmlvciBldmVudHMgaGFzaCB0byBhbGxvd1xuICAgICAgICAgIC8vIGEgdXNlciB0byB1c2UgdGhlIEB1aS4gc3ludGF4LlxuICAgICAgICAgIGJlaGF2aW9yRXZlbnRzID0gTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXMoYmVoYXZpb3JFdmVudHMsIGdldEJlaGF2aW9yc1VJKGIpKTtcbiAgXG4gICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgIF8uZWFjaChiZWhhdmlvckV2ZW50cywgZnVuY3Rpb24oYmVoYXZpb3VyLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCAgICAgPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgXG4gICAgICAgICAgICAvLyBTZXQgZXZlbnQgbmFtZSB0byBiZSBuYW1lc3BhY2VkIHVzaW5nIHRoZSB2aWV3IGNpZCxcbiAgICAgICAgICAgIC8vIHRoZSBiZWhhdmlvciBpbmRleCwgYW5kIHRoZSBiZWhhdmlvciBldmVudCBpbmRleFxuICAgICAgICAgICAgLy8gdG8gZ2VuZXJhdGUgYSBub24gY29sbGlkaW5nIGV2ZW50IG5hbWVzcGFjZVxuICAgICAgICAgICAgLy8gaHR0cDovL2FwaS5qcXVlcnkuY29tL2V2ZW50Lm5hbWVzcGFjZS9cbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBtYXRjaFsxXSArICcuJyArIFt0aGlzLmNpZCwgaSwgaisrLCAnICddLmpvaW4oJycpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yICA9IG1hdGNoWzJdO1xuICBcbiAgICAgICAgICAgIHZhciBldmVudEtleSAgPSBldmVudE5hbWUgKyBzZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyICAgPSBfLmlzRnVuY3Rpb24oYmVoYXZpb3VyKSA/IGJlaGF2aW91ciA6IGJbYmVoYXZpb3VyXTtcbiAgXG4gICAgICAgICAgICBfZXZlbnRzW2V2ZW50S2V5XSA9IF8uYmluZChoYW5kbGVyLCBiKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICAgICAgX2JlaGF2aW9yc0V2ZW50cyA9IF8uZXh0ZW5kKF9iZWhhdmlvcnNFdmVudHMsIF9ldmVudHMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICAgIHJldHVybiBfYmVoYXZpb3JzRXZlbnRzO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIF8uZXh0ZW5kKEJlaGF2aW9ycywge1xuICBcbiAgICAgIC8vIFBsYWNlaG9sZGVyIG1ldGhvZCB0byBiZSBleHRlbmRlZCBieSB0aGUgdXNlci5cbiAgICAgIC8vIFRoZSBtZXRob2Qgc2hvdWxkIGRlZmluZSB0aGUgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBiZWhhdmlvcnMuXG4gICAgICAvLyBpLmUuXG4gICAgICAvL1xuICAgICAgLy8gYGBganNcbiAgICAgIC8vIE1hcmlvbmV0dGUuQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIHJldHVybiBBcHAuQmVoYXZpb3JzXG4gICAgICAvLyB9XG4gICAgICAvLyBgYGBcbiAgICAgIGJlaGF2aW9yc0xvb2t1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnWW91IG11c3QgZGVmaW5lIHdoZXJlIHlvdXIgYmVoYXZpb3JzIGFyZSBzdG9yZWQuJyxcbiAgICAgICAgICB1cmw6ICdtYXJpb25ldHRlLmJlaGF2aW9ycy5odG1sI2JlaGF2aW9yc2xvb2t1cCdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFRha2VzIGNhcmUgb2YgZ2V0dGluZyB0aGUgYmVoYXZpb3IgY2xhc3NcbiAgICAgIC8vIGdpdmVuIG9wdGlvbnMgYW5kIGEga2V5LlxuICAgICAgLy8gSWYgYSB1c2VyIHBhc3NlcyBpbiBvcHRpb25zLmJlaGF2aW9yQ2xhc3NcbiAgICAgIC8vIGRlZmF1bHQgdG8gdXNpbmcgdGhhdC4gT3RoZXJ3aXNlIGRlbGVnYXRlXG4gICAgICAvLyB0aGUgbG9va3VwIHRvIHRoZSB1c2VycyBgYmVoYXZpb3JzTG9va3VwYCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIGdldEJlaGF2aW9yQ2xhc3M6IGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWhhdmlvckNsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuYmVoYXZpb3JDbGFzcztcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gR2V0IGJlaGF2aW9yIGNsYXNzIGNhbiBiZSBlaXRoZXIgYSBmbGF0IG9iamVjdCBvciBhIG1ldGhvZFxuICAgICAgICByZXR1cm4gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUoQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cCwgdGhpcywgW29wdGlvbnMsIGtleV0pW2tleV07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgYmVoYXZpb3JzIG9iamVjdCwgZm9yIGVhY2ggYmVoYXZpb3JcbiAgICAgIC8vIGluc3RhbnRpYXRlIGl0IGFuZCBnZXQgaXRzIGdyb3VwZWQgYmVoYXZpb3JzLlxuICAgICAgcGFyc2VCZWhhdmlvcnM6IGZ1bmN0aW9uKHZpZXcsIGJlaGF2aW9ycykge1xuICAgICAgICByZXR1cm4gXy5jaGFpbihiZWhhdmlvcnMpLm1hcChmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgICB2YXIgQmVoYXZpb3JDbGFzcyA9IEJlaGF2aW9ycy5nZXRCZWhhdmlvckNsYXNzKG9wdGlvbnMsIGtleSk7XG4gIFxuICAgICAgICAgIHZhciBiZWhhdmlvciA9IG5ldyBCZWhhdmlvckNsYXNzKG9wdGlvbnMsIHZpZXcpO1xuICAgICAgICAgIHZhciBuZXN0ZWRCZWhhdmlvcnMgPSBCZWhhdmlvcnMucGFyc2VCZWhhdmlvcnModmlldywgXy5yZXN1bHQoYmVoYXZpb3IsICdiZWhhdmlvcnMnKSk7XG4gIFxuICAgICAgICAgIHJldHVybiBbYmVoYXZpb3JdLmNvbmNhdChuZXN0ZWRCZWhhdmlvcnMpO1xuICAgICAgICB9KS5mbGF0dGVuKCkudmFsdWUoKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gV3JhcCB2aWV3IGludGVybmFsIG1ldGhvZHMgc28gdGhhdCB0aGV5IGRlbGVnYXRlIHRvIGJlaGF2aW9ycy4gRm9yIGV4YW1wbGUsXG4gICAgICAvLyBgb25EZXN0cm95YCBzaG91bGQgdHJpZ2dlciBkZXN0cm95IG9uIGFsbCBvZiB0aGUgYmVoYXZpb3JzIGFuZCB0aGVuIGRlc3Ryb3kgaXRzZWxmLlxuICAgICAgLy8gaS5lLlxuICAgICAgLy9cbiAgICAgIC8vIGB2aWV3LmRlbGVnYXRlRXZlbnRzID0gXy5wYXJ0aWFsKG1ldGhvZHMuZGVsZWdhdGVFdmVudHMsIHZpZXcuZGVsZWdhdGVFdmVudHMsIGJlaGF2aW9ycyk7YFxuICAgICAgd3JhcDogZnVuY3Rpb24odmlldywgYmVoYXZpb3JzLCBtZXRob2ROYW1lcykge1xuICAgICAgICBfLmVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB2aWV3W21ldGhvZE5hbWVdID0gXy5wYXJ0aWFsKG1ldGhvZHNbbWV0aG9kTmFtZV0sIHZpZXdbbWV0aG9kTmFtZV0sIGJlaGF2aW9ycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICAvLyBDbGFzcyB0byBidWlsZCBoYW5kbGVycyBmb3IgYHRyaWdnZXJzYCBvbiBiZWhhdmlvcnNcbiAgICAvLyBmb3Igdmlld3NcbiAgICBmdW5jdGlvbiBCZWhhdmlvclRyaWdnZXJzQnVpbGRlcih2aWV3LCBiZWhhdmlvcnMpIHtcbiAgICAgIHRoaXMuX3ZpZXcgICAgICA9IHZpZXc7XG4gICAgICB0aGlzLl9iZWhhdmlvcnMgPSBiZWhhdmlvcnM7XG4gICAgICB0aGlzLl90cmlnZ2VycyAgPSB7fTtcbiAgICB9XG4gIFxuICAgIF8uZXh0ZW5kKEJlaGF2aW9yVHJpZ2dlcnNCdWlsZGVyLnByb3RvdHlwZSwge1xuICAgICAgLy8gTWFpbiBtZXRob2QgdG8gYnVpbGQgdGhlIHRyaWdnZXJzIGhhc2ggd2l0aCBldmVudCBrZXlzIGFuZCBoYW5kbGVyc1xuICAgICAgYnVpbGRCZWhhdmlvclRyaWdnZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuX2JlaGF2aW9ycywgdGhpcy5fYnVpbGRUcmlnZ2VySGFuZGxlcnNGb3JCZWhhdmlvciwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VycztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGJ1aWxkIGFsbCB0cmlnZ2VyIGhhbmRsZXJzIGZvciBhIGdpdmVuIGJlaGF2aW9yXG4gICAgICBfYnVpbGRUcmlnZ2VySGFuZGxlcnNGb3JCZWhhdmlvcjogZnVuY3Rpb24oYmVoYXZpb3IsIGkpIHtcbiAgICAgICAgdmFyIHRyaWdnZXJzSGFzaCA9IF8uY2xvbmUoXy5yZXN1bHQoYmVoYXZpb3IsICd0cmlnZ2VycycpKSB8fCB7fTtcbiAgXG4gICAgICAgIHRyaWdnZXJzSGFzaCA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlLZXlzKHRyaWdnZXJzSGFzaCwgZ2V0QmVoYXZpb3JzVUkoYmVoYXZpb3IpKTtcbiAgXG4gICAgICAgIF8uZWFjaCh0cmlnZ2Vyc0hhc2gsIF8uYmluZCh0aGlzLl9zZXRIYW5kbGVyRm9yQmVoYXZpb3IsIHRoaXMsIGJlaGF2aW9yLCBpKSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYW5kIGFzc2lnbiB0aGUgdHJpZ2dlciBoYW5kbGVyIGZvciBhIGdpdmVuXG4gICAgICAvLyBiZWhhdmlvclxuICAgICAgX3NldEhhbmRsZXJGb3JCZWhhdmlvcjogZnVuY3Rpb24oYmVoYXZpb3IsIGksIGV2ZW50TmFtZSwgdHJpZ2dlcikge1xuICAgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGB0aGlzLl90cmlnZ2Vyc2AgaGFzaFxuICAgICAgICB2YXIgdHJpZ2dlcktleSA9IHRyaWdnZXIucmVwbGFjZSgvXlxcUysvLCBmdW5jdGlvbih0cmlnZ2VyTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmlnZ2VyTmFtZSArICcuJyArICdiZWhhdmlvcnRyaWdnZXJzJyArIGk7XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnNbdHJpZ2dlcktleV0gPSB0aGlzLl92aWV3Ll9idWlsZFZpZXdUcmlnZ2VyKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIGZ1bmN0aW9uIGdldEJlaGF2aW9yc1VJKGJlaGF2aW9yKSB7XG4gICAgICByZXR1cm4gYmVoYXZpb3IuX3VpQmluZGluZ3MgfHwgYmVoYXZpb3IudWk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gQmVoYXZpb3JzO1xuICBcbiAgfSkoTWFyaW9uZXR0ZSwgXyk7XG4gIFxuXG4gIC8vIEFwcCBSb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLVxuICBcbiAgLy8gUmVkdWNlIHRoZSBib2lsZXJwbGF0ZSBjb2RlIG9mIGhhbmRsaW5nIHJvdXRlIGV2ZW50c1xuICAvLyBhbmQgdGhlbiBjYWxsaW5nIGEgc2luZ2xlIG1ldGhvZCBvbiBhbm90aGVyIG9iamVjdC5cbiAgLy8gSGF2ZSB5b3VyIHJvdXRlcnMgY29uZmlndXJlZCB0byBjYWxsIHRoZSBtZXRob2Qgb25cbiAgLy8geW91ciBvYmplY3QsIGRpcmVjdGx5LlxuICAvL1xuICAvLyBDb25maWd1cmUgYW4gQXBwUm91dGVyIHdpdGggYGFwcFJvdXRlc2AuXG4gIC8vXG4gIC8vIEFwcCByb3V0ZXJzIGNhbiBvbmx5IHRha2Ugb25lIGBjb250cm9sbGVyYCBvYmplY3QuXG4gIC8vIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IGRpdmlkZSB5b3VyIGNvbnRyb2xsZXJcbiAgLy8gb2JqZWN0cyBpbiB0byBzbWFsbGVyIHBpZWNlcyBvZiByZWxhdGVkIGZ1bmN0aW9uYWxpdHlcbiAgLy8gYW5kIGhhdmUgbXVsdGlwbGUgcm91dGVycyAvIGNvbnRyb2xsZXJzLCBpbnN0ZWFkIG9mXG4gIC8vIGp1c3Qgb25lIGdpYW50IHJvdXRlciBhbmQgY29udHJvbGxlci5cbiAgLy9cbiAgLy8gWW91IGNhbiBhbHNvIGFkZCBzdGFuZGFyZCByb3V0ZXMgdG8gYW4gQXBwUm91dGVyLlxuICBcbiAgTWFyaW9uZXR0ZS5BcHBSb3V0ZXIgPSBCYWNrYm9uZS5Sb3V0ZXIuZXh0ZW5kKHtcbiAgXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgICAgQmFja2JvbmUuUm91dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdmFyIGFwcFJvdXRlcyA9IHRoaXMuZ2V0T3B0aW9uKCdhcHBSb3V0ZXMnKTtcbiAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fZ2V0Q29udHJvbGxlcigpO1xuICAgICAgdGhpcy5wcm9jZXNzQXBwUm91dGVzKGNvbnRyb2xsZXIsIGFwcFJvdXRlcyk7XG4gICAgICB0aGlzLm9uKCdyb3V0ZScsIHRoaXMuX3Byb2Nlc3NPblJvdXRlLCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBTaW1pbGFyIHRvIHJvdXRlIG1ldGhvZCBvbiBhIEJhY2tib25lIFJvdXRlciBidXRcbiAgICAvLyBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBjb250cm9sbGVyXG4gICAgYXBwUm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2dldENvbnRyb2xsZXIoKTtcbiAgICAgIHRoaXMuX2FkZEFwcFJvdXRlKGNvbnRyb2xsZXIsIHJvdXRlLCBtZXRob2ROYW1lKTtcbiAgICB9LFxuICBcbiAgICAvLyBwcm9jZXNzIHRoZSByb3V0ZSBldmVudCBhbmQgdHJpZ2dlciB0aGUgb25Sb3V0ZVxuICAgIC8vIG1ldGhvZCBjYWxsLCBpZiBpdCBleGlzdHNcbiAgICBfcHJvY2Vzc09uUm91dGU6IGZ1bmN0aW9uKHJvdXRlTmFtZSwgcm91dGVBcmdzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYW4gb25Sb3V0ZSBiZWZvcmUgdHJ5aW5nIHRvIGNhbGwgaXRcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5vblJvdXRlKSkge1xuICAgICAgICAvLyBmaW5kIHRoZSBwYXRoIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCByb3V0ZVxuICAgICAgICB2YXIgcm91dGVQYXRoID0gXy5pbnZlcnQodGhpcy5nZXRPcHRpb24oJ2FwcFJvdXRlcycpKVtyb3V0ZU5hbWVdO1xuICAgICAgICB0aGlzLm9uUm91dGUocm91dGVOYW1lLCByb3V0ZVBhdGgsIHJvdXRlQXJncyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHByb2Nlc3MgdGhlIGBhcHBSb3V0ZXNgIGZvciB0aGVcbiAgICAvLyByb3V0ZXIsIGFuZCB0dXJuIHRoZW0gaW4gdG8gcm91dGVzIHRoYXQgdHJpZ2dlciB0aGVcbiAgICAvLyBzcGVjaWZpZWQgbWV0aG9kIG9uIHRoZSBzcGVjaWZpZWQgYGNvbnRyb2xsZXJgLlxuICAgIHByb2Nlc3NBcHBSb3V0ZXM6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIGFwcFJvdXRlcykge1xuICAgICAgaWYgKCFhcHBSb3V0ZXMpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgdmFyIHJvdXRlTmFtZXMgPSBfLmtleXMoYXBwUm91dGVzKS5yZXZlcnNlKCk7IC8vIEJhY2tib25lIHJlcXVpcmVzIHJldmVydGVkIG9yZGVyIG9mIHJvdXRlc1xuICBcbiAgICAgIF8uZWFjaChyb3V0ZU5hbWVzLCBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICB0aGlzLl9hZGRBcHBSb3V0ZShjb250cm9sbGVyLCByb3V0ZSwgYXBwUm91dGVzW3JvdXRlXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICBfZ2V0Q29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oJ2NvbnRyb2xsZXInKTtcbiAgICB9LFxuICBcbiAgICBfYWRkQXBwUm91dGU6IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIHJvdXRlLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbWV0aG9kID0gY29udHJvbGxlclttZXRob2ROYW1lXTtcbiAgXG4gICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcignTWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgd2FzIG5vdCBmb3VuZCBvbiB0aGUgY29udHJvbGxlcicpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMucm91dGUocm91dGUsIG1ldGhvZE5hbWUsIF8uYmluZChtZXRob2QsIGNvbnRyb2xsZXIpKTtcbiAgICB9LFxuICBcbiAgICBtZXJnZU9wdGlvbnM6IE1hcmlvbmV0dGUubWVyZ2VPcHRpb25zLFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24sXG4gIFxuICAgIHRyaWdnZXJNZXRob2Q6IE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZCxcbiAgXG4gICAgYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eUJpbmRFbnRpdHlFdmVudHMsXG4gIFxuICAgIHVuYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eVVuYmluZEVudGl0eUV2ZW50c1xuICB9KTtcbiAgXG4gIC8vIEFwcGxpY2F0aW9uXG4gIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAvLyBDb250YWluIGFuZCBtYW5hZ2UgdGhlIGNvbXBvc2l0ZSBhcHBsaWNhdGlvbiBhcyBhIHdob2xlLlxuICAvLyBTdG9yZXMgYW5kIHN0YXJ0cyB1cCBgUmVnaW9uYCBvYmplY3RzLCBpbmNsdWRlcyBhblxuICAvLyBldmVudCBhZ2dyZWdhdG9yIGFzIGBhcHAudmVudGBcbiAgTWFyaW9uZXR0ZS5BcHBsaWNhdGlvbiA9IE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVSZWdpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdENhbGxiYWNrcyA9IG5ldyBNYXJpb25ldHRlLkNhbGxiYWNrcygpO1xuICAgICAgdGhpcy5zdWJtb2R1bGVzID0ge307XG4gICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRDaGFubmVsKCk7XG4gICAgICBNYXJpb25ldHRlLk9iamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIENvbW1hbmQgZXhlY3V0aW9uLCBmYWNpbGl0YXRlZCBieSBCYWNrYm9uZS5XcmVxci5Db21tYW5kc1xuICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jb21tYW5kcy5leGVjdXRlLmFwcGx5KHRoaXMuY29tbWFuZHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVxdWVzdC9yZXNwb25zZSwgZmFjaWxpdGF0ZWQgYnkgQmFja2JvbmUuV3JlcXIuUmVxdWVzdFJlc3BvbnNlXG4gICAgcmVxdWVzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXFyZXMucmVxdWVzdC5hcHBseSh0aGlzLnJlcXJlcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgYW4gaW5pdGlhbGl6ZXIgdGhhdCBpcyBlaXRoZXIgcnVuIGF0IHdoZW4gdGhlIGBzdGFydGBcbiAgICAvLyBtZXRob2QgaXMgY2FsbGVkLCBvciBydW4gaW1tZWRpYXRlbHkgaWYgYWRkZWQgYWZ0ZXIgYHN0YXJ0YFxuICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLlxuICAgIGFkZEluaXRpYWxpemVyOiBmdW5jdGlvbihpbml0aWFsaXplcikge1xuICAgICAgdGhpcy5faW5pdENhbGxiYWNrcy5hZGQoaW5pdGlhbGl6ZXIpO1xuICAgIH0sXG4gIFxuICAgIC8vIGtpY2sgb2ZmIGFsbCBvZiB0aGUgYXBwbGljYXRpb24ncyBwcm9jZXNzZXMuXG4gICAgLy8gaW5pdGlhbGl6ZXMgYWxsIG9mIHRoZSByZWdpb25zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkXG4gICAgLy8gdG8gdGhlIGFwcCwgYW5kIHJ1bnMgYWxsIG9mIHRoZSBpbml0aWFsaXplciBmdW5jdGlvbnNcbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3RhcnQnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRDYWxsYmFja3MucnVuKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzdGFydCcsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCByZWdpb25zIHRvIHlvdXIgYXBwLlxuICAgIC8vIEFjY2VwdHMgYSBoYXNoIG9mIG5hbWVkIHN0cmluZ3Mgb3IgUmVnaW9uIG9iamVjdHNcbiAgICAvLyBhZGRSZWdpb25zKHtzb21ldGhpbmc6IFwiI3NvbWVSZWdpb25cIn0pXG4gICAgLy8gYWRkUmVnaW9ucyh7c29tZXRoaW5nOiBSZWdpb24uZXh0ZW5kKHtlbDogXCIjc29tZVJlZ2lvblwifSkgfSk7XG4gICAgYWRkUmVnaW9uczogZnVuY3Rpb24ocmVnaW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbk1hbmFnZXIuYWRkUmVnaW9ucyhyZWdpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBFbXB0eSBhbGwgcmVnaW9ucyBpbiB0aGUgYXBwLCB3aXRob3V0IHJlbW92aW5nIHRoZW1cbiAgICBlbXB0eVJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbk1hbmFnZXIuZW1wdHlSZWdpb25zKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVtb3ZlcyBhIHJlZ2lvbiBmcm9tIHlvdXIgYXBwLCBieSBuYW1lXG4gICAgLy8gQWNjZXB0cyB0aGUgcmVnaW9ucyBuYW1lXG4gICAgLy8gcmVtb3ZlUmVnaW9uKCdteVJlZ2lvbicpXG4gICAgcmVtb3ZlUmVnaW9uOiBmdW5jdGlvbihyZWdpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25NYW5hZ2VyLnJlbW92ZVJlZ2lvbihyZWdpb24pO1xuICAgIH0sXG4gIFxuICAgIC8vIFByb3ZpZGVzIGFsdGVybmF0aXZlIGFjY2VzcyB0byByZWdpb25zXG4gICAgLy8gQWNjZXB0cyB0aGUgcmVnaW9uIG5hbWVcbiAgICAvLyBnZXRSZWdpb24oJ21haW4nKVxuICAgIGdldFJlZ2lvbjogZnVuY3Rpb24ocmVnaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVnaW9uTWFuYWdlci5nZXQocmVnaW9uKTtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYWxsIHRoZSByZWdpb25zIGZyb20gdGhlIHJlZ2lvbiBtYW5hZ2VyXG4gICAgZ2V0UmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVnaW9uTWFuYWdlci5nZXRSZWdpb25zKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ3JlYXRlIGEgbW9kdWxlLCBhdHRhY2hlZCB0byB0aGUgYXBwbGljYXRpb25cbiAgICBtb2R1bGU6IGZ1bmN0aW9uKG1vZHVsZU5hbWVzLCBtb2R1bGVEZWZpbml0aW9uKSB7XG4gIFxuICAgICAgLy8gT3ZlcndyaXRlIHRoZSBtb2R1bGUgY2xhc3MgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIG9uZVxuICAgICAgdmFyIE1vZHVsZUNsYXNzID0gTWFyaW9uZXR0ZS5Nb2R1bGUuZ2V0Q2xhc3MobW9kdWxlRGVmaW5pdGlvbik7XG4gIFxuICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgXG4gICAgICAvLyBzZWUgdGhlIE1hcmlvbmV0dGUuTW9kdWxlIG9iamVjdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAgcmV0dXJuIE1vZHVsZUNsYXNzLmNyZWF0ZS5hcHBseShNb2R1bGVDbGFzcywgYXJncyk7XG4gICAgfSxcbiAgXG4gICAgLy8gRW5hYmxlIGVhc3kgb3ZlcnJpZGluZyBvZiB0aGUgZGVmYXVsdCBgUmVnaW9uTWFuYWdlcmBcbiAgICAvLyBmb3IgY3VzdG9taXplZCByZWdpb24gaW50ZXJhY3Rpb25zIGFuZCBidXNpbmVzcy1zcGVjaWZpY1xuICAgIC8vIHZpZXcgbG9naWMgZm9yIGJldHRlciBjb250cm9sIG92ZXIgc2luZ2xlIHJlZ2lvbnMuXG4gICAgZ2V0UmVnaW9uTWFuYWdlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcmlvbmV0dGUuUmVnaW9uTWFuYWdlcigpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBpbml0aWFsaXplIHRoZSByZWdpb25zIHRoYXQgaGF2ZSBiZWVuIGRlZmluZWQgaW4gYVxuICAgIC8vIGByZWdpb25zYCBhdHRyaWJ1dGUgb24gdGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAgX2luaXRpYWxpemVSZWdpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVnaW9ucyA9IF8uaXNGdW5jdGlvbih0aGlzLnJlZ2lvbnMpID8gdGhpcy5yZWdpb25zKG9wdGlvbnMpIDogdGhpcy5yZWdpb25zIHx8IHt9O1xuICBcbiAgICAgIHRoaXMuX2luaXRSZWdpb25NYW5hZ2VyKCk7XG4gIFxuICAgICAgLy8gRW5hYmxlIHVzZXJzIHRvIGRlZmluZSBgcmVnaW9uc2AgaW4gaW5zdGFuY2Ugb3B0aW9ucy5cbiAgICAgIHZhciBvcHRpb25SZWdpb25zID0gTWFyaW9uZXR0ZS5nZXRPcHRpb24ob3B0aW9ucywgJ3JlZ2lvbnMnKTtcbiAgXG4gICAgICAvLyBFbmFibGUgcmVnaW9uIG9wdGlvbnMgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25SZWdpb25zKSkge1xuICAgICAgICBvcHRpb25SZWdpb25zID0gb3B0aW9uUmVnaW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIE92ZXJ3cml0ZSBjdXJyZW50IHJlZ2lvbnMgd2l0aCB0aG9zZSBwYXNzZWQgaW4gb3B0aW9uc1xuICAgICAgXy5leHRlbmQocmVnaW9ucywgb3B0aW9uUmVnaW9ucyk7XG4gIFxuICAgICAgdGhpcy5hZGRSZWdpb25zKHJlZ2lvbnMpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXQgdXAgdGhlIHJlZ2lvbiBtYW5hZ2VyXG4gICAgX2luaXRSZWdpb25NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlZ2lvbk1hbmFnZXIgPSB0aGlzLmdldFJlZ2lvbk1hbmFnZXIoKTtcbiAgICAgIHRoaXMuX3JlZ2lvbk1hbmFnZXIuX3BhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOmFkZDpyZWdpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCAnYmVmb3JlOmFkZDpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAnYWRkOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgICB0aGlzW25hbWVdID0gcmVnaW9uO1xuICAgICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdhZGQ6cmVnaW9uJywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5fcmVnaW9uTWFuYWdlciwgJ2JlZm9yZTpyZW1vdmU6cmVnaW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ2JlZm9yZTpyZW1vdmU6cmVnaW9uJywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5fcmVnaW9uTWFuYWdlciwgJ3JlbW92ZTpyZWdpb24nLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdyZW1vdmU6cmVnaW9uJywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXR1cCB0aGUgV3JlcXIucmFkaW8gY2hhbm5lbFxuICAgIF9pbml0Q2hhbm5lbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoYW5uZWxOYW1lID0gXy5yZXN1bHQodGhpcywgJ2NoYW5uZWxOYW1lJykgfHwgJ2dsb2JhbCc7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBfLnJlc3VsdCh0aGlzLCAnY2hhbm5lbCcpIHx8IEJhY2tib25lLldyZXFyLnJhZGlvLmNoYW5uZWwodGhpcy5jaGFubmVsTmFtZSk7XG4gICAgICB0aGlzLnZlbnQgPSBfLnJlc3VsdCh0aGlzLCAndmVudCcpIHx8IHRoaXMuY2hhbm5lbC52ZW50O1xuICAgICAgdGhpcy5jb21tYW5kcyA9IF8ucmVzdWx0KHRoaXMsICdjb21tYW5kcycpIHx8IHRoaXMuY2hhbm5lbC5jb21tYW5kcztcbiAgICAgIHRoaXMucmVxcmVzID0gXy5yZXN1bHQodGhpcywgJ3JlcXJlcycpIHx8IHRoaXMuY2hhbm5lbC5yZXFyZXM7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8qIGpzaGludCBtYXhwYXJhbXM6IDkgKi9cbiAgXG4gIC8vIE1vZHVsZVxuICAvLyAtLS0tLS1cbiAgXG4gIC8vIEEgc2ltcGxlIG1vZHVsZSBzeXN0ZW0sIHVzZWQgdG8gY3JlYXRlIHByaXZhY3kgYW5kIGVuY2Fwc3VsYXRpb24gaW5cbiAgLy8gTWFyaW9uZXR0ZSBhcHBsaWNhdGlvbnNcbiAgTWFyaW9uZXR0ZS5Nb2R1bGUgPSBmdW5jdGlvbihtb2R1bGVOYW1lLCBhcHAsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIC8vIEFsbG93IGZvciBhIHVzZXIgdG8gb3ZlcmlkZSB0aGUgaW5pdGlhbGl6ZVxuICAgIC8vIGZvciBhIGdpdmVuIG1vZHVsZSBpbnN0YW5jZS5cbiAgICB0aGlzLmluaXRpYWxpemUgPSBvcHRpb25zLmluaXRpYWxpemUgfHwgdGhpcy5pbml0aWFsaXplO1xuICBcbiAgICAvLyBTZXQgdXAgYW4gaW50ZXJuYWwgc3RvcmUgZm9yIHN1Yi1tb2R1bGVzLlxuICAgIHRoaXMuc3VibW9kdWxlcyA9IHt9O1xuICBcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxpemVyc0FuZEZpbmFsaXplcnMoKTtcbiAgXG4gICAgLy8gU2V0IGFuIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgYXBwXG4gICAgLy8gd2l0aGluIGEgbW9kdWxlLlxuICAgIHRoaXMuYXBwID0gYXBwO1xuICBcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuaW5pdGlhbGl6ZSkpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShtb2R1bGVOYW1lLCBhcHAsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICBcbiAgTWFyaW9uZXR0ZS5Nb2R1bGUuZXh0ZW5kID0gTWFyaW9uZXR0ZS5leHRlbmQ7XG4gIFxuICAvLyBFeHRlbmQgdGhlIE1vZHVsZSBwcm90b3R5cGUgd2l0aCBldmVudHMgLyBsaXN0ZW5Ubywgc28gdGhhdCB0aGUgbW9kdWxlXG4gIC8vIGNhbiBiZSB1c2VkIGFzIGFuIGV2ZW50IGFnZ3JlZ2F0b3Igb3IgcHViL3N1Yi5cbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5Nb2R1bGUucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgXG4gICAgLy8gQnkgZGVmYXVsdCBtb2R1bGVzIHN0YXJ0IHdpdGggdGhlaXIgcGFyZW50cy5cbiAgICBzdGFydFdpdGhQYXJlbnQ6IHRydWUsXG4gIFxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljIHdoZW4gZXh0ZW5kaW5nIE1hcmlvbmV0dGUuTW9kdWxlLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG4gIFxuICAgIC8vIEluaXRpYWxpemVyIGZvciBhIHNwZWNpZmljIG1vZHVsZS4gSW5pdGlhbGl6ZXJzIGFyZSBydW4gd2hlbiB0aGVcbiAgICAvLyBtb2R1bGUncyBgc3RhcnRgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgYWRkSW5pdGlhbGl6ZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIH0sXG4gIFxuICAgIC8vIEZpbmFsaXplcnMgYXJlIHJ1biB3aGVuIGEgbW9kdWxlIGlzIHN0b3BwZWQuIFRoZXkgYXJlIHVzZWQgdG8gdGVhcmRvd25cbiAgICAvLyBhbmQgZmluYWxpemUgYW55IHZhcmlhYmxlcywgcmVmZXJlbmNlcywgZXZlbnRzIGFuZCBvdGhlciBjb2RlIHRoYXQgdGhlXG4gICAgLy8gbW9kdWxlIGhhZCBzZXQgdXAuXG4gICAgYWRkRmluYWxpemVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgfSxcbiAgXG4gICAgLy8gU3RhcnQgdGhlIG1vZHVsZSwgYW5kIHJ1biBhbGwgb2YgaXRzIGluaXRpYWxpemVyc1xuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlLXN0YXJ0aW5nIGEgbW9kdWxlIHRoYXQgaXMgYWxyZWFkeSBzdGFydGVkXG4gICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgXG4gICAgICAvLyBzdGFydCB0aGUgc3ViLW1vZHVsZXMgKGRlcHRoLWZpcnN0IGhpZXJhcmNoeSlcbiAgICAgIF8uZWFjaCh0aGlzLnN1Ym1vZHVsZXMsIGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIHN0YXJ0IHRoZSBzdWItbW9kdWxlIHdpdGggdGhpcyBwYXJlbnRcbiAgICAgICAgaWYgKG1vZC5zdGFydFdpdGhQYXJlbnQpIHtcbiAgICAgICAgICBtb2Quc3RhcnQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICBcbiAgICAgIC8vIHJ1biB0aGUgY2FsbGJhY2tzIHRvIFwic3RhcnRcIiB0aGUgY3VycmVudCBtb2R1bGVcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnN0YXJ0Jywgb3B0aW9ucyk7XG4gIFxuICAgICAgdGhpcy5faW5pdGlhbGl6ZXJDYWxsYmFja3MucnVuKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzdGFydCcsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFN0b3AgdGhpcyBtb2R1bGUgYnkgcnVubmluZyBpdHMgZmluYWxpemVycyBhbmQgdGhlbiBzdG9wIGFsbCBvZlxuICAgIC8vIHRoZSBzdWItbW9kdWxlcyBmb3IgdGhpcyBtb2R1bGVcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHdlIGFyZSBub3QgaW5pdGlhbGl6ZWQsIGRvbid0IGJvdGhlciBmaW5hbGl6aW5nXG4gICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3RvcCcpO1xuICBcbiAgICAgIC8vIHN0b3AgdGhlIHN1Yi1tb2R1bGVzOyBkZXB0aC1maXJzdCwgdG8gbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gc3ViLW1vZHVsZXMgYXJlIHN0b3BwZWQgLyBmaW5hbGl6ZWQgYmVmb3JlIHBhcmVudHNcbiAgICAgIF8uaW52b2tlKHRoaXMuc3VibW9kdWxlcywgJ3N0b3AnKTtcbiAgXG4gICAgICAvLyBydW4gdGhlIGZpbmFsaXplcnNcbiAgICAgIHRoaXMuX2ZpbmFsaXplckNhbGxiYWNrcy5ydW4odW5kZWZpbmVkLCB0aGlzKTtcbiAgXG4gICAgICAvLyByZXNldCB0aGUgaW5pdGlhbGl6ZXJzIGFuZCBmaW5hbGl6ZXJzXG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcy5yZXNldCgpO1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzLnJlc2V0KCk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzdG9wJyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29uZmlndXJlIHRoZSBtb2R1bGUgd2l0aCBhIGRlZmluaXRpb24gZnVuY3Rpb24gYW5kIGFueSBjdXN0b20gYXJnc1xuICAgIC8vIHRoYXQgYXJlIHRvIGJlIHBhc3NlZCBpbiB0byB0aGUgZGVmaW5pdGlvbiBmdW5jdGlvblxuICAgIGFkZERlZmluaXRpb246IGZ1bmN0aW9uKG1vZHVsZURlZmluaXRpb24sIGN1c3RvbUFyZ3MpIHtcbiAgICAgIHRoaXMuX3J1bk1vZHVsZURlZmluaXRpb24obW9kdWxlRGVmaW5pdGlvbiwgY3VzdG9tQXJncyk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kOiBydW4gdGhlIG1vZHVsZSBkZWZpbml0aW9uIGZ1bmN0aW9uIHdpdGggdGhlIGNvcnJlY3RcbiAgICAvLyBhcmd1bWVudHNcbiAgICBfcnVuTW9kdWxlRGVmaW5pdGlvbjogZnVuY3Rpb24oZGVmaW5pdGlvbiwgY3VzdG9tQXJncykge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZGVmaW5pdGlvbiBzaG9ydCBjaXJjdXQgdGhlIG1ldGhvZC5cbiAgICAgIGlmICghZGVmaW5pdGlvbikgeyByZXR1cm47IH1cbiAgXG4gICAgICAvLyBidWlsZCB0aGUgY29ycmVjdCBsaXN0IG9mIGFyZ3VtZW50cyBmb3IgdGhlIG1vZHVsZSBkZWZpbml0aW9uXG4gICAgICB2YXIgYXJncyA9IF8uZmxhdHRlbihbXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuYXBwLFxuICAgICAgICBCYWNrYm9uZSxcbiAgICAgICAgTWFyaW9uZXR0ZSxcbiAgICAgICAgQmFja2JvbmUuJCwgXyxcbiAgICAgICAgY3VzdG9tQXJnc1xuICAgICAgXSk7XG4gIFxuICAgICAgZGVmaW5pdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2Q6IHNldCB1cCBuZXcgY29waWVzIG9mIGluaXRpYWxpemVycyBhbmQgZmluYWxpemVycy5cbiAgICAvLyBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgd2lwZSBvdXQgYWxsIGV4aXN0aW5nIGluaXRpYWxpemVycyBhbmRcbiAgICAvLyBmaW5hbGl6ZXJzLlxuICAgIF9zZXR1cEluaXRpYWxpemVyc0FuZEZpbmFsaXplcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZXJDYWxsYmFja3MgPSBuZXcgTWFyaW9uZXR0ZS5DYWxsYmFja3MoKTtcbiAgICAgIHRoaXMuX2ZpbmFsaXplckNhbGxiYWNrcyA9IG5ldyBNYXJpb25ldHRlLkNhbGxiYWNrcygpO1xuICAgIH0sXG4gIFxuICAgIC8vIGltcG9ydCB0aGUgYHRyaWdnZXJNZXRob2RgIHRvIHRyaWdnZXIgZXZlbnRzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgIC8vIG1ldGhvZHMgaWYgdGhlIG1ldGhvZCBleGlzdHNcbiAgICB0cmlnZ2VyTWV0aG9kOiBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RcbiAgfSk7XG4gIFxuICAvLyBDbGFzcyBtZXRob2RzIHRvIGNyZWF0ZSBtb2R1bGVzXG4gIF8uZXh0ZW5kKE1hcmlvbmV0dGUuTW9kdWxlLCB7XG4gIFxuICAgIC8vIENyZWF0ZSBhIG1vZHVsZSwgaGFuZ2luZyBvZmYgdGhlIGFwcCBwYXJhbWV0ZXIgYXMgdGhlIHBhcmVudCBvYmplY3QuXG4gICAgY3JlYXRlOiBmdW5jdGlvbihhcHAsIG1vZHVsZU5hbWVzLCBtb2R1bGVEZWZpbml0aW9uKSB7XG4gICAgICB2YXIgbW9kdWxlID0gYXBwO1xuICBcbiAgICAgIC8vIGdldCB0aGUgY3VzdG9tIGFyZ3MgcGFzc2VkIGluIGFmdGVyIHRoZSBtb2R1bGUgZGVmaW5pdGlvbiBhbmRcbiAgICAgIC8vIGdldCByaWQgb2YgdGhlIG1vZHVsZSBuYW1lIGFuZCBkZWZpbml0aW9uIGZ1bmN0aW9uXG4gICAgICB2YXIgY3VzdG9tQXJncyA9IF8uZHJvcChhcmd1bWVudHMsIDMpO1xuICBcbiAgICAgIC8vIFNwbGl0IHRoZSBtb2R1bGUgbmFtZXMgYW5kIGdldCB0aGUgbnVtYmVyIG9mIHN1Ym1vZHVsZXMuXG4gICAgICAvLyBpLmUuIGFuIGV4YW1wbGUgbW9kdWxlIG5hbWUgb2YgYERvZ2UuV293LkFtYXplYCB3b3VsZFxuICAgICAgLy8gdGhlbiBoYXZlIHRoZSBwb3RlbnRpYWwgZm9yIDMgbW9kdWxlIGRlZmluaXRpb25zLlxuICAgICAgbW9kdWxlTmFtZXMgPSBtb2R1bGVOYW1lcy5zcGxpdCgnLicpO1xuICAgICAgdmFyIGxlbmd0aCA9IG1vZHVsZU5hbWVzLmxlbmd0aDtcbiAgXG4gICAgICAvLyBzdG9yZSB0aGUgbW9kdWxlIGRlZmluaXRpb24gZm9yIHRoZSBsYXN0IG1vZHVsZSBpbiB0aGUgY2hhaW5cbiAgICAgIHZhciBtb2R1bGVEZWZpbml0aW9ucyA9IFtdO1xuICAgICAgbW9kdWxlRGVmaW5pdGlvbnNbbGVuZ3RoIC0gMV0gPSBtb2R1bGVEZWZpbml0aW9uO1xuICBcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHBhcnRzIG9mIHRoZSBtb2R1bGUgZGVmaW5pdGlvblxuICAgICAgXy5lYWNoKG1vZHVsZU5hbWVzLCBmdW5jdGlvbihtb2R1bGVOYW1lLCBpKSB7XG4gICAgICAgIHZhciBwYXJlbnRNb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIG1vZHVsZSA9IHRoaXMuX2dldE1vZHVsZShwYXJlbnRNb2R1bGUsIG1vZHVsZU5hbWUsIGFwcCwgbW9kdWxlRGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuX2FkZE1vZHVsZURlZmluaXRpb24ocGFyZW50TW9kdWxlLCBtb2R1bGUsIG1vZHVsZURlZmluaXRpb25zW2ldLCBjdXN0b21BcmdzKTtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIC8vIFJldHVybiB0aGUgbGFzdCBtb2R1bGUgaW4gdGhlIGRlZmluaXRpb24gY2hhaW5cbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfSxcbiAgXG4gICAgX2dldE1vZHVsZTogZnVuY3Rpb24ocGFyZW50TW9kdWxlLCBtb2R1bGVOYW1lLCBhcHAsIGRlZiwgYXJncykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgZGVmKTtcbiAgICAgIHZhciBNb2R1bGVDbGFzcyA9IHRoaXMuZ2V0Q2xhc3MoZGVmKTtcbiAgXG4gICAgICAvLyBHZXQgYW4gZXhpc3RpbmcgbW9kdWxlIG9mIHRoaXMgbmFtZSBpZiB3ZSBoYXZlIG9uZVxuICAgICAgdmFyIG1vZHVsZSA9IHBhcmVudE1vZHVsZVttb2R1bGVOYW1lXTtcbiAgXG4gICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIGlmIHdlIGRvbid0IGhhdmUgb25lXG4gICAgICAgIG1vZHVsZSA9IG5ldyBNb2R1bGVDbGFzcyhtb2R1bGVOYW1lLCBhcHAsIG9wdGlvbnMpO1xuICAgICAgICBwYXJlbnRNb2R1bGVbbW9kdWxlTmFtZV0gPSBtb2R1bGU7XG4gICAgICAgIC8vIHN0b3JlIHRoZSBtb2R1bGUgb24gdGhlIHBhcmVudFxuICAgICAgICBwYXJlbnRNb2R1bGUuc3VibW9kdWxlc1ttb2R1bGVOYW1lXSA9IG1vZHVsZTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH0sXG4gIFxuICAgIC8vICMjIE1vZHVsZSBDbGFzc2VzXG4gICAgLy9cbiAgICAvLyBNb2R1bGUgY2xhc3NlcyBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmaW5lIHBhdHRlcm4uXG4gICAgLy8gVGhlIGV4dGVuZCBmdW5jdGlvbiBvZiBhIE1vZHVsZSBpcyBpZGVudGljYWwgdG8gdGhlIGV4dGVuZCBmdW5jdGlvbnNcbiAgICAvLyBvbiBvdGhlciBCYWNrYm9uZSBhbmQgTWFyaW9uZXR0ZSBjbGFzc2VzLlxuICAgIC8vIFRoaXMgYWxsb3dzIG1vZHVsZSBsaWZlY3lsZSBldmVudHMgbGlrZSBgb25TdGFydGAgYW5kIGBvblN0b3BgIHRvIGJlIGNhbGxlZCBkaXJlY3RseS5cbiAgICBnZXRDbGFzczogZnVuY3Rpb24obW9kdWxlRGVmaW5pdGlvbikge1xuICAgICAgdmFyIE1vZHVsZUNsYXNzID0gTWFyaW9uZXR0ZS5Nb2R1bGU7XG4gIFxuICAgICAgaWYgKCFtb2R1bGVEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBNb2R1bGVDbGFzcztcbiAgICAgIH1cbiAgXG4gICAgICAvLyBJZiBhbGwgb2YgdGhlIG1vZHVsZSdzIGZ1bmN0aW9uYWxpdHkgaXMgZGVmaW5lZCBpbnNpZGUgaXRzIGNsYXNzLFxuICAgICAgLy8gdGhlbiB0aGUgY2xhc3MgY2FuIGJlIHBhc3NlZCBpbiBkaXJlY3RseS4gYE15QXBwLm1vZHVsZShcIkZvb1wiLCBGb29Nb2R1bGUpYC5cbiAgICAgIGlmIChtb2R1bGVEZWZpbml0aW9uLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZHVsZUNsYXNzKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9uO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9uLm1vZHVsZUNsYXNzIHx8IE1vZHVsZUNsYXNzO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCB0aGUgbW9kdWxlIGRlZmluaXRpb24gYW5kIGFkZCBhIHN0YXJ0V2l0aFBhcmVudCBpbml0aWFsaXplciBmdW5jdGlvbi5cbiAgICAvLyBUaGlzIGlzIGNvbXBsaWNhdGVkIGJlY2F1c2UgbW9kdWxlIGRlZmluaXRpb25zIGFyZSBoZWF2aWx5IG92ZXJsb2FkZWRcbiAgICAvLyBhbmQgc3VwcG9ydCBhbiBhbm9ueW1vdXMgZnVuY3Rpb24sIG1vZHVsZSBjbGFzcywgb3Igb3B0aW9ucyBvYmplY3RcbiAgICBfYWRkTW9kdWxlRGVmaW5pdGlvbjogZnVuY3Rpb24ocGFyZW50TW9kdWxlLCBtb2R1bGUsIGRlZiwgYXJncykge1xuICAgICAgdmFyIGZuID0gdGhpcy5fZ2V0RGVmaW5lKGRlZik7XG4gICAgICB2YXIgc3RhcnRXaXRoUGFyZW50ID0gdGhpcy5fZ2V0U3RhcnRXaXRoUGFyZW50KGRlZiwgbW9kdWxlKTtcbiAgXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgbW9kdWxlLmFkZERlZmluaXRpb24oZm4sIGFyZ3MpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX2FkZFN0YXJ0V2l0aFBhcmVudChwYXJlbnRNb2R1bGUsIG1vZHVsZSwgc3RhcnRXaXRoUGFyZW50KTtcbiAgICB9LFxuICBcbiAgICBfZ2V0U3RhcnRXaXRoUGFyZW50OiBmdW5jdGlvbihkZWYsIG1vZHVsZSkge1xuICAgICAgdmFyIHN3cDtcbiAgXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGRlZikgJiYgKGRlZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNYXJpb25ldHRlLk1vZHVsZSkpIHtcbiAgICAgICAgc3dwID0gbW9kdWxlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5zdGFydFdpdGhQYXJlbnQ7XG4gICAgICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHN3cCkgPyB0cnVlIDogc3dwO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChfLmlzT2JqZWN0KGRlZikpIHtcbiAgICAgICAgc3dwID0gZGVmLnN0YXJ0V2l0aFBhcmVudDtcbiAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQoc3dwKSA/IHRydWUgOiBzd3A7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgXG4gICAgX2dldERlZmluZTogZnVuY3Rpb24oZGVmKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGRlZikgJiYgIShkZWYucHJvdG90eXBlIGluc3RhbmNlb2YgTWFyaW9uZXR0ZS5Nb2R1bGUpKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF8uaXNPYmplY3QoZGVmKSkge1xuICAgICAgICByZXR1cm4gZGVmLmRlZmluZTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICBcbiAgICBfYWRkU3RhcnRXaXRoUGFyZW50OiBmdW5jdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZSwgc3RhcnRXaXRoUGFyZW50KSB7XG4gICAgICBtb2R1bGUuc3RhcnRXaXRoUGFyZW50ID0gbW9kdWxlLnN0YXJ0V2l0aFBhcmVudCAmJiBzdGFydFdpdGhQYXJlbnQ7XG4gIFxuICAgICAgaWYgKCFtb2R1bGUuc3RhcnRXaXRoUGFyZW50IHx8ICEhbW9kdWxlLnN0YXJ0V2l0aFBhcmVudElzQ29uZmlndXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIFxuICAgICAgbW9kdWxlLnN0YXJ0V2l0aFBhcmVudElzQ29uZmlndXJlZCA9IHRydWU7XG4gIFxuICAgICAgcGFyZW50TW9kdWxlLmFkZEluaXRpYWxpemVyKGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5zdGFydFdpdGhQYXJlbnQpIHtcbiAgICAgICAgICBtb2R1bGUuc3RhcnQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIFxuXG4gIHJldHVybiBNYXJpb25ldHRlO1xufSkpO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBNYXJpb25ldHRlICE9IFwidW5kZWZpbmVkXCIgPyBNYXJpb25ldHRlIDogd2luZG93Lk1hcmlvbmV0dGUpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG47IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBQcmVmZXIgd2luZG93IG92ZXIgc2VsZiBmb3IgYWRkLW9uIHNjcmlwdHMuIFVzZSBzZWxmIGZvclxuICAgICAgICAvLyBub24td2luZG93ZWQgY29udGV4dHMuXG4gICAgICAgIHZhciBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogc2VsZjtcblxuICAgICAgICAvLyBHZXQgdGhlIGB3aW5kb3dgIG9iamVjdCwgc2F2ZSB0aGUgcHJldmlvdXMgUSBnbG9iYWxcbiAgICAgICAgLy8gYW5kIGluaXRpYWxpemUgUSBhcyBhIGdsb2JhbC5cbiAgICAgICAgdmFyIHByZXZpb3VzUSA9IGdsb2JhbC5RO1xuICAgICAgICBnbG9iYWwuUSA9IGRlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgYSBub0NvbmZsaWN0IGZ1bmN0aW9uIHNvIFEgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZ2xvYmFsLlEubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsb2JhbC5RID0gcHJldmlvdXNRO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpcGF0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG4gICAgLy8gcXVldWUgZm9yIGxhdGUgdGFza3MsIHVzZWQgYnkgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZ1xuICAgIHZhciBsYXRlclF1ZXVlID0gW107XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIHZhciB0YXNrLCBkb21haW47XG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2ssIGRvbWFpbik7XG5cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGF0ZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhc2sgPSBsYXRlclF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgcnVuU2luZ2xlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJ1bnMgYSBzaW5nbGUgZnVuY3Rpb24gaW4gdGhlIGFzeW5jIHF1ZXVlXG4gICAgZnVuY3Rpb24gcnVuU2luZ2xlKHRhc2ssIGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgcHJvY2Vzcy50b1N0cmluZygpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIEVuc3VyZSBRIGlzIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50LCB3aXRoIGEgYHByb2Nlc3MubmV4dFRpY2tgLlxuICAgICAgICAvLyBUbyBzZWUgdGhyb3VnaCBmYWtlIE5vZGUgZW52aXJvbm1lbnRzOlxuICAgICAgICAvLyAqIE1vY2hhIHRlc3QgcnVubmVyIC0gZXhwb3NlcyBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2BcbiAgICAgICAgLy8gKiBCcm93c2VyaWZ5IC0gZXhwb3NlcyBhIGBwcm9jZXNzLm5leFRpY2tgIGZ1bmN0aW9uIHRoYXQgdXNlc1xuICAgICAgICAvLyAgIGBzZXRUaW1lb3V0YC4gSW4gdGhpcyBjYXNlIGBzZXRJbW1lZGlhdGVgIGlzIHByZWZlcnJlZCBiZWNhdXNlXG4gICAgICAgIC8vICAgIGl0IGlzIGZhc3Rlci4gQnJvd3NlcmlmeSdzIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkc1xuICAgICAgICAvLyAgIFwiW29iamVjdCBPYmplY3RdXCIsIHdoaWxlIGluIGEgcmVhbCBOb2RlIGVudmlyb25tZW50XG4gICAgICAgIC8vICAgYHByb2Nlc3MubmV4dFRpY2soKWAgeWllbGRzIFwiW29iamVjdCBwcm9jZXNzXVwiLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJ1bnMgYSB0YXNrIGFmdGVyIGFsbCBvdGhlciB0YXNrcyBoYXZlIGJlZW4gcnVuXG4gICAgLy8gdGhpcyBpcyB1c2VmdWwgZm9yIHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmcgdGhhdCBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciBhbGwgYHRoZW5gZCB0YXNrcyBoYXZlIGJlZW4gcnVuLlxuICAgIG5leHRUaWNrLnJ1bkFmdGVyID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgbGF0ZXJRdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIG9uY2Ugd2UgY2FuIGFzc3VtZSBhdCBsZWFzdCBFUzVcbiAgICAgICAgLy8gYW5zd2VyUHMuZm9yRWFjaChmdW5jdGlvbiAoYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2sucnVuQWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdFJlcG9ydCA9IGFycmF5X2luZGV4T2YocmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICBpZiAoYXRSZXBvcnQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInJlamVjdGlvbkhhbmRsZWRcIiwgdW5oYW5kbGVkUmVhc29uc1thdF0sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0UmVwb3J0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3BlbmRpbmdDb3VudDtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSBvZiBhbiBhcnJheS4gUHJpb3IgcmVqZWN0ZWQgcHJvbWlzZXMgYXJlXG4gKiBpZ25vcmVkLiAgUmVqZWN0cyBvbmx5IGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgb3IgcHJvbWlzZXMgZm9yIHZhbHVlc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZSxcbiAqIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICovXG5RLmFueSA9IGFueTtcblxuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpO1xuICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaW5kZXhdO1xuXG4gICAgICAgIHBlbmRpbmdDb3VudCsrO1xuXG4gICAgICAgIHdoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpO1xuICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlamVjdGVkKCkge1xuICAgICAgICAgICAgcGVuZGluZ0NvdW50LS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJDYW4ndCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgZnJvbSBhbnkgcHJvbWlzZSwgYWxsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9taXNlcyB3ZXJlIHJlamVjdGVkLlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHVuZGVmaW5lZCk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgdG8gYmUgc2V0dGxlZCwgZWl0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuICBUaGlzIGlzIGRpc3RpbmN0IGZyb20gYGFsbGAgc2luY2UgdGhhdCB3b3VsZCBzdG9wXG4gKiB3YWl0aW5nIGF0IHRoZSBmaXJzdCByZWplY3Rpb24uICBUaGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICogYGFsbFJlc29sdmVkYCB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICogQHBhcmFtIHByb21pc2VzIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgKG9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuICogKG9yIHZhbHVlcylcbiAqIEByZXR1cm4gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlc1xuICovXG5RLmFsbFJlc29sdmVkID0gZGVwcmVjYXRlKGFsbFJlc29sdmVkLCBcImFsbFJlc29sdmVkXCIsIFwiYWxsU2V0dGxlZFwiKTtcbmZ1bmN0aW9uIGFsbFJlc29sdmVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBwcm9taXNlcyA9IGFycmF5X21hcChwcm9taXNlcywgUSk7XG4gICAgICAgIHJldHVybiB3aGVuKGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBub29wLCBub29wKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5mdW5jdGlvbiBhbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZXMpLmFsbFNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlaXIgc3RhdGVzIChhc1xuICogcmV0dXJuZWQgYnkgYGluc3BlY3RgKSB3aGVuIHRoZXkgaGF2ZSBhbGwgc2V0dGxlZC5cbiAqIEBwYXJhbSB7QXJyYXlbQW55Kl19IHZhbHVlcyBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7QXJyYXlbU3RhdGVdfSBhbiBhcnJheSBvZiBzdGF0ZXMgZm9yIHRoZSByZXNwZWN0aXZlIHZhbHVlcy5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWxsU2V0dGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnYXJkbGVzcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBmYWlsdXJlIG9mIGEgcHJvbWlzZSwgZ2l2aW5nIGFuIG9wb3J0dW5pdHkgdG8gcmVjb3ZlclxuICogd2l0aCBhIGNhbGxiYWNrLiAgSWYgdGhlIGdpdmVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAqIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgaWYgdGhlXG4gKiBnaXZlbiBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrXG4gKi9cblEuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGxpc3RlbmVyIHRoYXQgY2FuIHJlc3BvbmQgdG8gcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmcm9tIGFcbiAqIHByb21pc2UncyBvcmlnaW5hdGluZyBkZWZlcnJlZC4gVGhpcyBsaXN0ZW5lciByZWNlaXZlcyB0aGUgZXhhY3QgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gYGBkZWZlcnJlZC5ub3RpZnlgYC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byByZWNlaXZlIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJucyB0aGUgZ2l2ZW4gcHJvbWlzZSwgdW5jaGFuZ2VkXG4gKi9cblEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmZ1bmN0aW9uIHByb2dyZXNzKG9iamVjdCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gb2JzZXJ2ZSB0aGUgc2V0dGxpbmcgb2YgYSBwcm9taXNlLFxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIEZvcndhcmRzXG4gKiB0aGUgcmVzb2x1dGlvbiB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aGVuIHRoZSBjYWxsYmFjayBpcyBkb25lLlxuICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIG9ic2VydmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuXG4gKiBwcm9taXNlLCB0YWtlcyBubyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIHdoZW5cbiAqIGBgZmluYGAgaXMgZG9uZS5cbiAqL1xuUS5maW4gPSAvLyBYWFggbGVnYWN5XG5RW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KVtcImZpbmFsbHlcIl0oY2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtBbnkqfSBjdXN0b20gZXJyb3IgbWVzc2FnZSBvciBFcnJvciBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgZXJyb3IpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIGVycm9yKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGVycm9yKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZXJyb3IgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvciB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblEubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlEubm9Db25mbGljdCBvbmx5IHdvcmtzIHdoZW4gUSBpcyB1c2VkIGFzIGEgZ2xvYmFsXCIpO1xufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgUSAhPSBcInVuZGVmaW5lZFwiID8gUSA6IHdpbmRvdy5RKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIkZXYUFTSFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuOyB2YXIgX19icm93c2VyaWZ5X3NoaW1fcmVxdWlyZV9fPXJlcXVpcmU7KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLy8gc3RhdHMuanMgLSBodHRwOi8vZ2l0aHViLmNvbS9tcmRvb2Ivc3RhdHMuanNcbnZhciBTdGF0cz1mdW5jdGlvbigpe2Z1bmN0aW9uIGYoYSxlLGIpe2E9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhKTthLmlkPWU7YS5zdHlsZS5jc3NUZXh0PWI7cmV0dXJuIGF9ZnVuY3Rpb24gbChhLGUsYil7dmFyIGM9ZihcImRpdlwiLGEsXCJwYWRkaW5nOjAgMCAzcHggM3B4O3RleHQtYWxpZ246bGVmdDtiYWNrZ3JvdW5kOlwiK2IpLGQ9ZihcImRpdlwiLGErXCJUZXh0XCIsXCJmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6OXB4O2ZvbnQtd2VpZ2h0OmJvbGQ7bGluZS1oZWlnaHQ6MTVweDtjb2xvcjpcIitlKTtkLmlubmVySFRNTD1hLnRvVXBwZXJDYXNlKCk7Yy5hcHBlbmRDaGlsZChkKTthPWYoXCJkaXZcIixhK1wiR3JhcGhcIixcIndpZHRoOjc0cHg7aGVpZ2h0OjMwcHg7YmFja2dyb3VuZDpcIitlKTtjLmFwcGVuZENoaWxkKGEpO2ZvcihlPTA7NzQ+ZTtlKyspYS5hcHBlbmRDaGlsZChmKFwic3BhblwiLFwiXCIsXCJ3aWR0aDoxcHg7aGVpZ2h0OjMwcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5OjAuOTtiYWNrZ3JvdW5kOlwiK1xuYikpO3JldHVybiBjfWZ1bmN0aW9uIG0oYSl7Zm9yKHZhciBiPWMuY2hpbGRyZW4sZD0wO2Q8Yi5sZW5ndGg7ZCsrKWJbZF0uc3R5bGUuZGlzcGxheT1kPT09YT9cImJsb2NrXCI6XCJub25lXCI7bj1hfWZ1bmN0aW9uIHAoYSxiKXthLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZCkuc3R5bGUuaGVpZ2h0PU1hdGgubWluKDMwLDMwLTMwKmIpK1wicHhcIn12YXIgcT1zZWxmLnBlcmZvcm1hbmNlJiZzZWxmLnBlcmZvcm1hbmNlLm5vdz9zZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTpEYXRlLm5vdyxrPXEoKSxyPWssdD0wLG49MCxjPWYoXCJkaXZcIixcInN0YXRzXCIsXCJ3aWR0aDo4MHB4O29wYWNpdHk6MC45O2N1cnNvcjpwb2ludGVyXCIpO2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKTttKCsrbiVjLmNoaWxkcmVuLmxlbmd0aCl9LCExKTt2YXIgZD0wLHU9SW5maW5pdHksdj0wLGI9bChcImZwc1wiLFwiIzBmZlwiLFwiIzAwMlwiKSxcbkE9Yi5jaGlsZHJlblswXSxCPWIuY2hpbGRyZW5bMV07Yy5hcHBlbmRDaGlsZChiKTt2YXIgZz0wLHc9SW5maW5pdHkseD0wLGI9bChcIm1zXCIsXCIjMGYwXCIsXCIjMDIwXCIpLEM9Yi5jaGlsZHJlblswXSxEPWIuY2hpbGRyZW5bMV07Yy5hcHBlbmRDaGlsZChiKTtpZihzZWxmLnBlcmZvcm1hbmNlJiZzZWxmLnBlcmZvcm1hbmNlLm1lbW9yeSl7dmFyIGg9MCx5PUluZmluaXR5LHo9MCxiPWwoXCJtYlwiLFwiI2YwOFwiLFwiIzIwMVwiKSxFPWIuY2hpbGRyZW5bMF0sRj1iLmNoaWxkcmVuWzFdO2MuYXBwZW5kQ2hpbGQoYil9bShuKTtyZXR1cm57UkVWSVNJT046MTQsZG9tRWxlbWVudDpjLHNldE1vZGU6bSxiZWdpbjpmdW5jdGlvbigpe2s9cSgpfSxlbmQ6ZnVuY3Rpb24oKXt2YXIgYT1xKCk7Zz1hLWs7dz1NYXRoLm1pbih3LGcpO3g9TWF0aC5tYXgoeCxnKTtDLnRleHRDb250ZW50PShnfDApK1wiIE1TIChcIisod3wwKStcIi1cIisoeHwwKStcIilcIjtwKEQsZy8yMDApO3QrKztpZihhPnIrMUUzJiYoZD1NYXRoLnJvdW5kKDFFMypcbnQvKGEtcikpLHU9TWF0aC5taW4odSxkKSx2PU1hdGgubWF4KHYsZCksQS50ZXh0Q29udGVudD1kK1wiIEZQUyAoXCIrdStcIi1cIit2K1wiKVwiLHAoQixkLzEwMCkscj1hLHQ9MCx2b2lkIDAhPT1oKSl7dmFyIGI9cGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplLGM9cGVyZm9ybWFuY2UubWVtb3J5LmpzSGVhcFNpemVMaW1pdDtoPU1hdGgucm91bmQoOS41NEUtNypiKTt5PU1hdGgubWluKHksaCk7ej1NYXRoLm1heCh6LGgpO0UudGV4dENvbnRlbnQ9aCtcIiBNQiAoXCIreStcIi1cIit6K1wiKVwiO3AoRixiL2MpfXJldHVybiBhfSx1cGRhdGU6ZnVuY3Rpb24oKXtrPXRoaXMuZW5kKCl9fX07XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGUmJihtb2R1bGUuZXhwb3J0cz1TdGF0cyk7XG5cbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIFN0YXRzICE9IFwidW5kZWZpbmVkXCIgPyBTdGF0cyA6IHdpbmRvdy5TdGF0cyk7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG47IHZhciBfX2Jyb3dzZXJpZnlfc2hpbV9yZXF1aXJlX189cmVxdWlyZTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCByZXF1aXJlLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vLyB0d2Vlbi5qcyB2LjAuMTUuMCBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qc1xudm9pZCAwPT09RGF0ZS5ub3cmJihEYXRlLm5vdz1mdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkudmFsdWVPZigpfSk7dmFyIFRXRUVOPVRXRUVOfHxmdW5jdGlvbigpe3ZhciBuPVtdO3JldHVybntSRVZJU0lPTjpcIjE0XCIsZ2V0QWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG59LHJlbW92ZUFsbDpmdW5jdGlvbigpe249W119LGFkZDpmdW5jdGlvbih0KXtuLnB1c2godCl9LHJlbW92ZTpmdW5jdGlvbih0KXt2YXIgcj1uLmluZGV4T2YodCk7LTEhPT1yJiZuLnNwbGljZShyLDEpfSx1cGRhdGU6ZnVuY3Rpb24odCl7aWYoMD09PW4ubGVuZ3RoKXJldHVybiExO3ZhciByPTA7Zm9yKHQ9dm9pZCAwIT09dD90OlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJnZvaWQgMCE9PXdpbmRvdy5wZXJmb3JtYW5jZSYmdm9pZCAwIT09d2luZG93LnBlcmZvcm1hbmNlLm5vdz93aW5kb3cucGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3coKTtyPG4ubGVuZ3RoOyluW3JdLnVwZGF0ZSh0KT9yKys6bi5zcGxpY2UociwxKTtyZXR1cm4hMH19fSgpO1RXRUVOLlR3ZWVuPWZ1bmN0aW9uKG4pe3ZhciB0PW4scj17fSxpPXt9LHU9e30sbz0xZTMsZT0wLGE9ITEsZj0hMSxjPSExLHM9MCxoPW51bGwsbD1UV0VFTi5FYXNpbmcuTGluZWFyLk5vbmUscD1UV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcixFPVtdLGQ9bnVsbCx2PSExLEk9bnVsbCx3PW51bGwsTT1udWxsO2Zvcih2YXIgTyBpbiBuKXJbT109cGFyc2VGbG9hdChuW09dLDEwKTt0aGlzLnRvPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHZvaWQgMCE9PXQmJihvPXQpLGk9bix0aGlzfSx0aGlzLnN0YXJ0PWZ1bmN0aW9uKG4pe1RXRUVOLmFkZCh0aGlzKSxmPSEwLHY9ITEsaD12b2lkIDAhPT1uP246XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmdm9pZCAwIT09d2luZG93LnBlcmZvcm1hbmNlJiZ2b2lkIDAhPT13aW5kb3cucGVyZm9ybWFuY2Uubm93P3dpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTpEYXRlLm5vdygpLGgrPXM7Zm9yKHZhciBvIGluIGkpe2lmKGlbb11pbnN0YW5jZW9mIEFycmF5KXtpZigwPT09aVtvXS5sZW5ndGgpY29udGludWU7aVtvXT1bdFtvXV0uY29uY2F0KGlbb10pfXJbb109dFtvXSxyW29daW5zdGFuY2VvZiBBcnJheT09ITEmJihyW29dKj0xKSx1W29dPXJbb118fDB9cmV0dXJuIHRoaXN9LHRoaXMuc3RvcD1mdW5jdGlvbigpe3JldHVybiBmPyhUV0VFTi5yZW1vdmUodGhpcyksZj0hMSxudWxsIT09TSYmTS5jYWxsKHQpLHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKSx0aGlzKTp0aGlzfSx0aGlzLnN0b3BDaGFpbmVkVHdlZW5zPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsdD1FLmxlbmd0aDt0Pm47bisrKUVbbl0uc3RvcCgpfSx0aGlzLmRlbGF5PWZ1bmN0aW9uKG4pe3JldHVybiBzPW4sdGhpc30sdGhpcy5yZXBlYXQ9ZnVuY3Rpb24obil7cmV0dXJuIGU9bix0aGlzfSx0aGlzLnlveW89ZnVuY3Rpb24obil7cmV0dXJuIGE9bix0aGlzfSx0aGlzLmVhc2luZz1mdW5jdGlvbihuKXtyZXR1cm4gbD1uLHRoaXN9LHRoaXMuaW50ZXJwb2xhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gcD1uLHRoaXN9LHRoaXMuY2hhaW49ZnVuY3Rpb24oKXtyZXR1cm4gRT1hcmd1bWVudHMsdGhpc30sdGhpcy5vblN0YXJ0PWZ1bmN0aW9uKG4pe3JldHVybiBkPW4sdGhpc30sdGhpcy5vblVwZGF0ZT1mdW5jdGlvbihuKXtyZXR1cm4gST1uLHRoaXN9LHRoaXMub25Db21wbGV0ZT1mdW5jdGlvbihuKXtyZXR1cm4gdz1uLHRoaXN9LHRoaXMub25TdG9wPWZ1bmN0aW9uKG4pe3JldHVybiBNPW4sdGhpc30sdGhpcy51cGRhdGU9ZnVuY3Rpb24obil7dmFyIGY7aWYoaD5uKXJldHVybiEwO3Y9PT0hMSYmKG51bGwhPT1kJiZkLmNhbGwodCksdj0hMCk7dmFyIE09KG4taCkvbztNPU0+MT8xOk07dmFyIE89bChNKTtmb3IoZiBpbiBpKXt2YXIgbT1yW2ZdfHwwLE49aVtmXTtOIGluc3RhbmNlb2YgQXJyYXk/dFtmXT1wKE4sTyk6KFwic3RyaW5nXCI9PXR5cGVvZiBOJiYoTj1tK3BhcnNlRmxvYXQoTiwxMCkpLFwibnVtYmVyXCI9PXR5cGVvZiBOJiYodFtmXT1tKyhOLW0pKk8pKX1pZihudWxsIT09SSYmSS5jYWxsKHQsTyksMT09TSl7aWYoZT4wKXtpc0Zpbml0ZShlKSYmZS0tO2ZvcihmIGluIHUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpW2ZdJiYodVtmXT11W2ZdK3BhcnNlRmxvYXQoaVtmXSwxMCkpLGEpe3ZhciBUPXVbZl07dVtmXT1pW2ZdLGlbZl09VH1yW2ZdPXVbZl19cmV0dXJuIGEmJihjPSFjKSxoPW4rcywhMH1udWxsIT09dyYmdy5jYWxsKHQpO2Zvcih2YXIgZz0wLFc9RS5sZW5ndGg7Vz5nO2crKylFW2ddLnN0YXJ0KG4pO3JldHVybiExfXJldHVybiEwfX0sVFdFRU4uRWFzaW5nPXtMaW5lYXI6e05vbmU6ZnVuY3Rpb24obil7cmV0dXJuIG59fSxRdWFkcmF0aWM6e0luOmZ1bmN0aW9uKG4pe3JldHVybiBuKm59LE91dDpmdW5jdGlvbihuKXtyZXR1cm4gbiooMi1uKX0sSW5PdXQ6ZnVuY3Rpb24obil7cmV0dXJuKG4qPTIpPDE/LjUqbipuOi0uNSooLS1uKihuLTIpLTEpfX0sQ3ViaWM6e0luOmZ1bmN0aW9uKG4pe3JldHVybiBuKm4qbn0sT3V0OmZ1bmN0aW9uKG4pe3JldHVybi0tbipuKm4rMX0sSW5PdXQ6ZnVuY3Rpb24obil7cmV0dXJuKG4qPTIpPDE/LjUqbipuKm46LjUqKChuLT0yKSpuKm4rMil9fSxRdWFydGljOntJbjpmdW5jdGlvbihuKXtyZXR1cm4gbipuKm4qbn0sT3V0OmZ1bmN0aW9uKG4pe3JldHVybiAxLSAtLW4qbipuKm59LEluT3V0OmZ1bmN0aW9uKG4pe3JldHVybihuKj0yKTwxPy41Km4qbipuKm46LS41Kigobi09MikqbipuKm4tMil9fSxRdWludGljOntJbjpmdW5jdGlvbihuKXtyZXR1cm4gbipuKm4qbipufSxPdXQ6ZnVuY3Rpb24obil7cmV0dXJuLS1uKm4qbipuKm4rMX0sSW5PdXQ6ZnVuY3Rpb24obil7cmV0dXJuKG4qPTIpPDE/LjUqbipuKm4qbipuOi41Kigobi09MikqbipuKm4qbisyKX19LFNpbnVzb2lkYWw6e0luOmZ1bmN0aW9uKG4pe3JldHVybiAxLU1hdGguY29zKG4qTWF0aC5QSS8yKX0sT3V0OmZ1bmN0aW9uKG4pe3JldHVybiBNYXRoLnNpbihuKk1hdGguUEkvMil9LEluT3V0OmZ1bmN0aW9uKG4pe3JldHVybi41KigxLU1hdGguY29zKE1hdGguUEkqbikpfX0sRXhwb25lbnRpYWw6e0luOmZ1bmN0aW9uKG4pe3JldHVybiAwPT09bj8wOk1hdGgucG93KDEwMjQsbi0xKX0sT3V0OmZ1bmN0aW9uKG4pe3JldHVybiAxPT09bj8xOjEtTWF0aC5wb3coMiwtMTAqbil9LEluT3V0OmZ1bmN0aW9uKG4pe3JldHVybiAwPT09bj8wOjE9PT1uPzE6KG4qPTIpPDE/LjUqTWF0aC5wb3coMTAyNCxuLTEpOi41KigtTWF0aC5wb3coMiwtMTAqKG4tMSkpKzIpfX0sQ2lyY3VsYXI6e0luOmZ1bmN0aW9uKG4pe3JldHVybiAxLU1hdGguc3FydCgxLW4qbil9LE91dDpmdW5jdGlvbihuKXtyZXR1cm4gTWF0aC5zcXJ0KDEtIC0tbipuKX0sSW5PdXQ6ZnVuY3Rpb24obil7cmV0dXJuKG4qPTIpPDE/LS41KihNYXRoLnNxcnQoMS1uKm4pLTEpOi41KihNYXRoLnNxcnQoMS0obi09MikqbikrMSl9fSxFbGFzdGljOntJbjpmdW5jdGlvbihuKXt2YXIgdCxyPS4xLGk9LjQ7cmV0dXJuIDA9PT1uPzA6MT09PW4/MTooIXJ8fDE+cj8ocj0xLHQ9aS80KTp0PWkqTWF0aC5hc2luKDEvcikvKDIqTWF0aC5QSSksLShyKk1hdGgucG93KDIsMTAqKG4tPTEpKSpNYXRoLnNpbigyKihuLXQpKk1hdGguUEkvaSkpKX0sT3V0OmZ1bmN0aW9uKG4pe3ZhciB0LHI9LjEsaT0uNDtyZXR1cm4gMD09PW4/MDoxPT09bj8xOighcnx8MT5yPyhyPTEsdD1pLzQpOnQ9aSpNYXRoLmFzaW4oMS9yKS8oMipNYXRoLlBJKSxyKk1hdGgucG93KDIsLTEwKm4pKk1hdGguc2luKDIqKG4tdCkqTWF0aC5QSS9pKSsxKX0sSW5PdXQ6ZnVuY3Rpb24obil7dmFyIHQscj0uMSxpPS40O3JldHVybiAwPT09bj8wOjE9PT1uPzE6KCFyfHwxPnI/KHI9MSx0PWkvNCk6dD1pKk1hdGguYXNpbigxL3IpLygyKk1hdGguUEkpLChuKj0yKTwxPy0uNSpyKk1hdGgucG93KDIsMTAqKG4tPTEpKSpNYXRoLnNpbigyKihuLXQpKk1hdGguUEkvaSk6cipNYXRoLnBvdygyLC0xMCoobi09MSkpKk1hdGguc2luKDIqKG4tdCkqTWF0aC5QSS9pKSouNSsxKX19LEJhY2s6e0luOmZ1bmN0aW9uKG4pe3ZhciB0PTEuNzAxNTg7cmV0dXJuIG4qbiooKHQrMSkqbi10KX0sT3V0OmZ1bmN0aW9uKG4pe3ZhciB0PTEuNzAxNTg7cmV0dXJuLS1uKm4qKCh0KzEpKm4rdCkrMX0sSW5PdXQ6ZnVuY3Rpb24obil7dmFyIHQ9Mi41OTQ5MDk1O3JldHVybihuKj0yKTwxPy41Km4qbiooKHQrMSkqbi10KTouNSooKG4tPTIpKm4qKCh0KzEpKm4rdCkrMil9fSxCb3VuY2U6e0luOmZ1bmN0aW9uKG4pe3JldHVybiAxLVRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0KDEtbil9LE91dDpmdW5jdGlvbihuKXtyZXR1cm4gMS8yLjc1Pm4/Ny41NjI1Km4qbjoyLzIuNzU+bj83LjU2MjUqKG4tPTEuNS8yLjc1KSpuKy43NToyLjUvMi43NT5uPzcuNTYyNSoobi09Mi4yNS8yLjc1KSpuKy45Mzc1OjcuNTYyNSoobi09Mi42MjUvMi43NSkqbisuOTg0Mzc1fSxJbk91dDpmdW5jdGlvbihuKXtyZXR1cm4uNT5uPy41KlRXRUVOLkVhc2luZy5Cb3VuY2UuSW4oMipuKTouNSpUV0VFTi5FYXNpbmcuQm91bmNlLk91dCgyKm4tMSkrLjV9fX0sVFdFRU4uSW50ZXJwb2xhdGlvbj17TGluZWFyOmZ1bmN0aW9uKG4sdCl7dmFyIHI9bi5sZW5ndGgtMSxpPXIqdCx1PU1hdGguZmxvb3IoaSksbz1UV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtyZXR1cm4gMD50P28oblswXSxuWzFdLGkpOnQ+MT9vKG5bcl0sbltyLTFdLHItaSk6byhuW3VdLG5bdSsxPnI/cjp1KzFdLGktdSl9LEJlemllcjpmdW5jdGlvbihuLHQpe3ZhciByLGk9MCx1PW4ubGVuZ3RoLTEsbz1NYXRoLnBvdyxlPVRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO2ZvcihyPTA7dT49cjtyKyspaSs9bygxLXQsdS1yKSpvKHQscikqbltyXSplKHUscik7cmV0dXJuIGl9LENhdG11bGxSb206ZnVuY3Rpb24obix0KXt2YXIgcj1uLmxlbmd0aC0xLGk9cip0LHU9TWF0aC5mbG9vcihpKSxvPVRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQ2F0bXVsbFJvbTtyZXR1cm4gblswXT09PW5bcl0/KDA+dCYmKHU9TWF0aC5mbG9vcihpPXIqKDErdCkpKSxvKG5bKHUtMStyKSVyXSxuW3VdLG5bKHUrMSklcl0sblsodSsyKSVyXSxpLXUpKTowPnQ/blswXS0obyhuWzBdLG5bMF0sblsxXSxuWzFdLC1pKS1uWzBdKTp0PjE/bltyXS0obyhuW3JdLG5bcl0sbltyLTFdLG5bci0xXSxpLXIpLW5bcl0pOm8oblt1P3UtMTowXSxuW3VdLG5bdSsxPnI/cjp1KzFdLG5bdSsyPnI/cjp1KzJdLGktdSl9LFV0aWxzOntMaW5lYXI6ZnVuY3Rpb24obix0LHIpe3JldHVybih0LW4pKnIrbn0sQmVybnN0ZWluOmZ1bmN0aW9uKG4sdCl7dmFyIHI9VFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7cmV0dXJuIHIobikvcih0KS9yKG4tdCl9LEZhY3RvcmlhbDpmdW5jdGlvbigpe3ZhciBuPVsxXTtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIHIsaT0xO2lmKG5bdF0pcmV0dXJuIG5bdF07Zm9yKHI9dDtyPjE7ci0tKWkqPXI7cmV0dXJuIG5bdF09aX19KCksQ2F0bXVsbFJvbTpmdW5jdGlvbihuLHQscixpLHUpe3ZhciBvPS41KihyLW4pLGU9LjUqKGktdCksYT11KnUsZj11KmE7cmV0dXJuKDIqdC0yKnIrbytlKSpmKygtMyp0KzMqci0yKm8tZSkqYStvKnUrdH19fSxcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPVRXRUVOKTtcbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIFRXRUVOICE9IFwidW5kZWZpbmVkXCIgPyBUV0VFTiA6IHdpbmRvdy5UV0VFTik7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0Lmd1aScpXG5tb2R1bGUuZXhwb3J0cy5jb2xvciA9IHJlcXVpcmUoJy4vdmVuZG9yL2RhdC5jb2xvcicpIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qKiBAbmFtZXNwYWNlICovXG52YXIgZGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBkYXQgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29sb3IgPSBkYXQuY29sb3IgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQudXRpbHMgPSBkYXQudXRpbHMgfHwge307XG5cbmRhdC51dGlscy5jb21tb24gPSAoZnVuY3Rpb24gKCkge1xuICBcbiAgdmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEJhbmQtYWlkIG1ldGhvZHMgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBhIGxvdCBlYXNpZXIgaW4gSmF2YVNjcmlwdC5cbiAgICogSW1wbGVtZW50YXRpb24gYW5kIHN0cnVjdHVyZSBpbnNwaXJlZCBieSB1bmRlcnNjb3JlLmpzXG4gICAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAgICovXG5cbiAgcmV0dXJuIHsgXG4gICAgXG4gICAgQlJFQUs6IHt9LFxuICBcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIFxuICAgIH0sXG4gICAgXG4gICAgY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ciwgc2NvcGUpIHtcblxuICAgICAgXG4gICAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7IFxuICAgICAgICBcbiAgICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkgeyAvLyBJcyBudW1iZXIgYnV0IG5vdCBOYU5cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKylcbiAgICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIFxuICAgICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmZXI6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgc2V0VGltZW91dChmbmMsIDApO1xuICAgIH0sXG4gICAgXG4gICAgdG9BcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gICAgfSxcblxuICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorMDtcbiAgICB9LFxuICAgIFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaisnJztcbiAgICB9LFxuICAgIFxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gIFxuICB9O1xuICAgIFxufSkoKTtcblxuXG5kYXQuY29sb3IudG9TdHJpbmcgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgaWYgKGNvbG9yLmEgPT0gMSB8fCBjb21tb24uaXNVbmRlZmluZWQoY29sb3IuYSkpIHtcblxuICAgICAgdmFyIHMgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgNikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIHM7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IucikgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmcpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5iKSArICcsJyArIGNvbG9yLmEgKyAnKSc7XG5cbiAgICB9XG5cbiAgfVxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuQ29sb3IgPSBkYXQuY29sb3IuQ29sb3IgPSAoZnVuY3Rpb24gKGludGVycHJldCwgbWF0aCwgdG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cblxuICB9O1xuXG4gIENvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCdnJywnYicsJ2gnLCdzJywndicsJ2hleCcsJ2EnXTtcblxuICBjb21tb24uZXh0ZW5kKENvbG9yLnByb3RvdHlwZSwge1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b09yaWdpbmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcblxuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gICAgfVxuXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IG1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVJHQihjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG5cbiAgICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IG1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG5cbiAgICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgbWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRocm93ICdDb3JydXB0ZWQgY29sb3Igc3RhdGUnO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUhTVihjb2xvcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IG1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIHM6IHJlc3VsdC5zLFxuICAgICAgICAgIHY6IHJlc3VsdC52XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFjb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbG9yO1xuXG59KShkYXQuY29sb3IuaW50ZXJwcmV0ID0gKGZ1bmN0aW9uICh0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIHJlc3VsdCwgdG9SZXR1cm47XG5cbiAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdG9SZXR1cm4gPSBmYWxzZTtcblxuICAgIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgIGNvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24oZmFtaWx5KSB7XG5cbiAgICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuXG4gICAgICAgIGNvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24oY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH07XG5cbiAgdmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcblxuICAgIC8vIFN0cmluZ3NcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzU3RyaW5nLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFRIUkVFX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIFNJWF9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0I6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQkE6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCxcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBOdW1iZXJzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc051bWJlcixcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBIRVg6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gQXJyYXlzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc0FycmF5LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQl9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE9iamVjdHNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzT2JqZWN0LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gIF07XG5cbiAgcmV0dXJuIGludGVycHJldDtcblxuXG59KShkYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb2xvci5tYXRoID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdG1wQ29tcG9uZW50O1xuXG4gIHJldHVybiB7XG5cbiAgICBoc3ZfdG9fcmdiOiBmdW5jdGlvbihoLCBzLCB2KSB7XG5cbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cbiAgICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgICAgdmFyIHEgPSB2ICogKDEuMCAtIChmICogcykpO1xuICAgICAgdmFyIHQgPSB2ICogKDEuMCAtICgoMS4wIC0gZikgKiBzKSk7XG4gICAgICB2YXIgYyA9IFtcbiAgICAgICAgW3YsIHQsIHBdLFxuICAgICAgICBbcSwgdiwgcF0sXG4gICAgICAgIFtwLCB2LCB0XSxcbiAgICAgICAgW3AsIHEsIHZdLFxuICAgICAgICBbdCwgcCwgdl0sXG4gICAgICAgIFt2LCBwLCBxXVxuICAgICAgXVtoaV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgcmdiX3RvX2hzdjogZnVuY3Rpb24ociwgZywgYikge1xuXG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaCwgcztcblxuICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogTmFOLFxuICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgdjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZyA9PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggKiAzNjAsXG4gICAgICAgIHM6IHMsXG4gICAgICAgIHY6IG1heCAvIDI1NVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmdiX3RvX2hleDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICAgIHJldHVybiAoaGV4ID4+IChjb21wb25lbnRJbmRleCAqIDgpKSAmIDB4RkY7XG4gICAgfSxcblxuICAgIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IChoZXggJiB+ICgweEZGIDw8IHRtcENvbXBvbmVudCkpO1xuICAgIH1cblxuICB9XG5cbn0pKCksXG5kYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKTsiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5ndWkgPSBkYXQuZ3VpIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbnRyb2xsZXJzID0gZGF0LmNvbnRyb2xsZXJzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmRvbSA9IGRhdC5kb20gfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29sb3IgPSBkYXQuY29sb3IgfHwge307XG5cbmRhdC51dGlscy5jc3MgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGxvYWQ6IGZ1bmN0aW9uICh1cmwsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICBpbmplY3Q6IGZ1bmN0aW9uKGNzcywgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgaW5qZWN0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBpbmplY3RlZC5pbm5lckhUTUwgPSBjc3M7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChpbmplY3RlZCk7XG4gICAgfVxuICB9XG59KSgpO1xuXG5cbmRhdC51dGlscy5jb21tb24gPSAoZnVuY3Rpb24gKCkge1xuICBcbiAgdmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEJhbmQtYWlkIG1ldGhvZHMgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBhIGxvdCBlYXNpZXIgaW4gSmF2YVNjcmlwdC5cbiAgICogSW1wbGVtZW50YXRpb24gYW5kIHN0cnVjdHVyZSBpbnNwaXJlZCBieSB1bmRlcnNjb3JlLmpzXG4gICAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAgICovXG5cbiAgcmV0dXJuIHsgXG4gICAgXG4gICAgQlJFQUs6IHt9LFxuICBcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIFxuICAgIH0sXG4gICAgXG4gICAgY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ciwgc2NvcGUpIHtcblxuICAgICAgXG4gICAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7IFxuICAgICAgICBcbiAgICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkgeyAvLyBJcyBudW1iZXIgYnV0IG5vdCBOYU5cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKylcbiAgICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIFxuICAgICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmZXI6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgc2V0VGltZW91dChmbmMsIDApO1xuICAgIH0sXG4gICAgXG4gICAgdG9BcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gICAgfSxcblxuICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorMDtcbiAgICB9LFxuICAgIFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaisnJztcbiAgICB9LFxuICAgIFxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gIFxuICB9O1xuICAgIFxufSkoKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBBbiBcImFic3RyYWN0XCIgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSB3aG8gZXh0ZW5kIHRoaXMgY2xhc3Mgd2lsbCBwdXQgdGhlaXIgRE9NIGVsZW1lbnRzIGluIGhlcmUuXG4gICAgICogQHR5cGUge0RPTUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBmaW5pc2hpbmcgY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlIHdpdGhcbiAgICAgICAgICogdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWVcbiAgICAgICAgICogaXMgbW9kaWZpZWQgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmdcbiAgICAgICAgICogdGhlIHZhbHVlIHdpaCB0aGlzIENvbnRyb2xsZXIuIFVzZWZ1bCBmb3IgdmFsdWVzIHRoYXQgY2hhbmdlXG4gICAgICAgICAqIGluY3JlbWVudGFsbHkgbGlrZSBudW1iZXJzIG9yIHN0cmluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyXG4gICAgICAgICAqIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nIHRoZSB2YWx1ZSB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uRmluaXNoQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGN1cnJlbnQgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2hlcyB0aGUgdmlzdWFsIGRpc3BsYXkgb2YgYSBDb250cm9sbGVyIGluIG9yZGVyIHRvIGtlZXAgc3luY1xuICAgICAgICAgKiB3aXRoIHRoZSBvYmplY3QncyBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdmFsdWUgaGFzIGRldmlhdGVkIGZyb20gaW5pdGlhbFZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBpc01vZGlmaWVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBDb250cm9sbGVyO1xuXG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5kb20uZG9tID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICB2YXIgRVZFTlRfTUFQID0ge1xuICAgICdIVE1MRXZlbnRzJzogWydjaGFuZ2UnXSxcbiAgICAnTW91c2VFdmVudHMnOiBbJ2NsaWNrJywnbW91c2Vtb3ZlJywnbW91c2Vkb3duJywnbW91c2V1cCcsICdtb3VzZW92ZXInXSxcbiAgICAnS2V5Ym9hcmRFdmVudHMnOiBbJ2tleWRvd24nXVxuICB9O1xuXG4gIHZhciBFVkVOVF9NQVBfSU5WID0ge307XG4gIGNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24odiwgaykge1xuICAgIGNvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuXG4gIGZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG5cbiAgICBpZiAodmFsID09PSAnMCcgfHwgY29tbW9uLmlzVW5kZWZpbmVkKHZhbCkpIHJldHVybiAwO1xuXG4gICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuXG4gICAgaWYgKCFjb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLi4uZW1zPyAlP1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXIgZGF0LmRvbVxuICAgKi9cbiAgdmFyIGRvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIHNlbGVjdGFibGVcbiAgICAgKi9cbiAgICBtYWtlU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgc2VsZWN0YWJsZSkge1xuXG4gICAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIH07XG5cbiAgICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBob3Jpem9udGFsXG4gICAgICogQHBhcmFtIHZlcnRpY2FsXG4gICAgICovXG4gICAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uKGVsZW0sIGhvcml6b250YWwsIHZlcnRpY2FsKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIGhvcml6b250YWwgPSB0cnVlO1xuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh2ZXJ0aWNhbCkpIHZlcnRpY2FsID0gdHJ1ZTtcblxuICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGZha2VFdmVudDogZnVuY3Rpb24oZWxlbSwgZXZlbnRUeXBlLCBwYXJhbXMsIGF1eCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdHlwZSAnICsgZXZlbnRUeXBlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgICAgdmFyIGNsaWVudFggPSBwYXJhbXMueCB8fCBwYXJhbXMuY2xpZW50WCB8fCAwO1xuICAgICAgICAgIHZhciBjbGllbnRZID0gcGFyYW1zLnkgfHwgcGFyYW1zLmNsaWVudFkgfHwgMDtcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBYXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFlcbiAgICAgICAgICAgICAgY2xpZW50WCwgLy9jbGllbnQgWFxuICAgICAgICAgICAgICBjbGllbnRZLCAvL2NsaWVudCBZXG4gICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS2V5Ym9hcmRFdmVudHMnOlxuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7IC8vIHdlYmtpdCB8fCBtb3pcbiAgICAgICAgICBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBrZXlDb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFyQ29kZTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LFxuICAgICAgICAgICAgICBwYXJhbXMuY3RybEtleSwgcGFyYW1zLmFsdEtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLnNoaWZ0S2V5LCBwYXJhbXMubWV0YUtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLmtleUNvZGUsIHBhcmFtcy5jaGFyQ29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5kZWZhdWx0cyhldnQsIGF1eCk7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudClcbiAgICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMrKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHMrfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWyd3aWR0aCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydoZWlnaHQnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHZhciBvZmZzZXQgPSB7bGVmdDogMCwgdG9wOjB9O1xuICAgICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yNjg0NTYxL3JldmlzaW9uc1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiApO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBkb207XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBzZWxlY3QgaW5wdXQgdG8gYWx0ZXIgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCwgdXNpbmcgYVxuICAgKiBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nW119IG9wdGlvbnMgQSBtYXAgb2YgbGFiZWxzIHRvIGFjY2VwdGFibGUgdmFsdWVzLCBvclxuICAgKiBhIGxpc3Qgb2YgYWNjZXB0YWJsZSBzdHJpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBvcHRpb25zKSB7XG5cbiAgICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJvcCBkb3duIG1lbnVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBtYXA7XG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXG4gICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICBfdGhpcy5fX3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuXG4gICAgfSk7XG5cbiAgICAvLyBBY2tub3dsZWRnZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlc2lyZWRWYWx1ZSA9IHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0KTtcblxuICB9O1xuXG4gIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgdGhpcy5fX21pbiA9IHBhcmFtcy5taW47XG4gICAgdGhpcy5fX21heCA9IHBhcmFtcy5tYXg7XG4gICAgdGhpcy5fX3N0ZXAgPSBwYXJhbXMuc3RlcDtcblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX3N0ZXApKSB7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PSAwKSB7XG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IDE7IC8vIFdoYXQgYXJlIHdlLCBwc3ljaGljcz9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhleSBEb3VnLCBjaGVjayB0aGlzIG91dC5cbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2codGhpcy5pbml0aWFsVmFsdWUpL01hdGguTE4xMCkpLzEwO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gdGhpcy5fX3N0ZXA7XG5cbiAgICB9XG5cbiAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHModGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX21pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21pbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gdGhpcy5fX21heCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19tYXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgdiAlIHRoaXMuX19zdGVwICE9IDApIHtcbiAgICAgICAgICAgIHYgPSBNYXRoLnJvdW5kKHYgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtaW5pbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIFRoZSBtaW5pbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19taW4gPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWF4aW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBUaGUgbWF4aW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWF4ID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIHN0ZXAgdmFsdWUgdGhhdCBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBpbmNyZW1lbnRzIGJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIFRoZSBzdGVwIHZhbHVlIGZvclxuICAgICAgICAgKiBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBAZGVmYXVsdCBpZiBtaW5pbXVtIGFuZCBtYXhpbXVtIHNwZWNpZmllZCBpbmNyZW1lbnQgaXMgMSUgb2YgdGhlXG4gICAgICAgICAqIGRpZmZlcmVuY2Ugb3RoZXJ3aXNlIHN0ZXBWYWx1ZSBpcyAxXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RlcDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19zdGVwID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gICAgeCA9IHgudG9TdHJpbmcoKTtcbiAgICBpZiAoeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcmV0dXJuIHgubGVuZ3RoIC0geC5pbmRleE9mKCcuJykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciBhbmRcbiAgICogcHJvdmlkZXMgYW4gaW5wdXQgZWxlbWVudCB3aXRoIHdoaWNoIHRvIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiB7TnVtYmVyfSBQcmV2aW91cyBtb3VzZSB5IHBvc2l0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhciBwcmV2X3k7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgLy8gTWFrZXMgaXQgc28gbWFudWFsbHkgc3BlY2lmaWVkIHZhbHVlcyBhcmUgbm90IHRydW5jYXRlZC5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgLy8gV2hlbiBwcmVzc2luZyBlbnRpcmUsIHlvdSBjYW4gYmUgYXMgcHJlY2lzZSBhcyB5b3Ugd2FudC5cbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghY29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIF90aGlzLnNldFZhbHVlKGF0dGVtcHRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICB2YXIgZGlmZiA9IHByZXZfeSAtIGUuY2xpZW50WTtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XG5cbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICAgIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5UbztcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xuXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY3NzLCBjb21tb24sIHN0eWxlU2hlZXQpIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciwgY29udGFpbnNcbiAgICogYSBtaW5pbXVtIGFuZCBtYXhpbXVtLCBhbmQgcHJvdmlkZXMgYSBzbGlkZXIgZWxlbWVudCB3aXRoIHdoaWNoIHRvXG4gICAqIG1hbmlwdWxhdGUgaXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHRoZSBzbGlkZXIgZWxlbWVudCBpcyBtYWRlIHVwIG9mXG4gICAqIDxjb2RlPiZsdDtkaXYmZ3Q7PC9jb2RlPiB0YWdzLCA8c3Ryb25nPm5vdDwvc3Ryb25nPiB0aGUgaHRtbDVcbiAgICogPGNvZGU+Jmx0O3NsaWRlciZndDs8L2NvZGU+IGVsZW1lbnQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgXG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIFxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuXG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgICAgb25Nb3VzZURyYWcoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICB2YXIgd2lkdGggPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIFxuICAgICAgX3RoaXMuc2V0VmFsdWUoXG4gICAgICAgIG1hcChlLmNsaWVudFgsIG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIHdpZHRoLCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5fX2ZvcmVncm91bmQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYmFja2dyb3VuZCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIC8qKlxuICAgKiBJbmplY3RzIGRlZmF1bHQgc3R5bGVzaGVldCBmb3Igc2xpZGVyIGVsZW1lbnRzLlxuICAgKi9cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci51c2VEZWZhdWx0U3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKS8odGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgICAgIHRoaXMuX19mb3JlZ3JvdW5kLnN0eWxlLndpZHRoID0gcGN0KjEwMCsnJSc7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuXG5cbiAgKTtcblxuICBmdW5jdGlvbiBtYXAodiwgaTEsIGkyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG4gIFxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jc3MsXG5kYXQudXRpbHMuY29tbW9uLFxuXCIuc2xpZGVyIHtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMTUpO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgcGFkZGluZzogMCAwLjVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5zbGlkZXItZmcge1xcbiAgcGFkZGluZzogMXB4IDAgMnB4IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tbGVmdDogLTAuNWVtO1xcbiAgcGFkZGluZy1yaWdodDogMC41ZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW0gMCAwIDFlbTtcXG59XFxuXFxuLnNsaWRlci1mZzphZnRlciB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiAgMXB4IHNvbGlkICNhYWE7XFxuICBjb250ZW50OiAnJztcXG4gIGZsb2F0OiByaWdodDtcXG4gIG1hcmdpbi1yaWdodDogLTFlbTtcXG4gIG1hcmdpbi10b3A6IC0xcHg7XFxuICBoZWlnaHQ6IDAuOWVtO1xcbiAgd2lkdGg6IDAuOWVtO1xcbn1cIik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgR1VJIGludGVyZmFjZSB0byBmaXJlIGEgc3BlY2lmaWVkIG1ldGhvZCwgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuXG4gICAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuICAgIGRvbS5iaW5kKHRoaXMuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYnV0dG9uLCAnYnV0dG9uJyk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2J1dHRvbik7XG5cblxuICB9O1xuXG4gIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBGdW5jdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIFxuICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBjaGVja2JveCBpbnB1dCB0byBhbHRlciB0aGUgYm9vbGVhbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gICAgdGhpcy5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2NoZWNrYm94KTtcblxuICAgIC8vIE1hdGNoIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cblxuICB9O1xuXG4gIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTsgICAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IudG9TdHJpbmcgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgaWYgKGNvbG9yLmEgPT0gMSB8fCBjb21tb24uaXNVbmRlZmluZWQoY29sb3IuYSkpIHtcblxuICAgICAgdmFyIHMgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgNikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIHM7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IucikgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmcpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5iKSArICcsJyArIGNvbG9yLmEgKyAnKSc7XG5cbiAgICB9XG5cbiAgfVxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IuaW50ZXJwcmV0ID0gKGZ1bmN0aW9uICh0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIHJlc3VsdCwgdG9SZXR1cm47XG5cbiAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdG9SZXR1cm4gPSBmYWxzZTtcblxuICAgIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgIGNvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24oZmFtaWx5KSB7XG5cbiAgICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuXG4gICAgICAgIGNvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24oY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH07XG5cbiAgdmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcblxuICAgIC8vIFN0cmluZ3NcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzU3RyaW5nLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFRIUkVFX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIFNJWF9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0I6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQkE6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCxcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBOdW1iZXJzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc051bWJlcixcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBIRVg6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gQXJyYXlzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc0FycmF5LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQl9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE9iamVjdHNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzT2JqZWN0LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gIF07XG5cbiAgcmV0dXJuIGludGVycHJldDtcblxuXG59KShkYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuR1VJID0gZGF0Lmd1aS5HVUkgPSAoZnVuY3Rpb24gKGNzcywgc2F2ZURpYWxvZ3VlQ29udGVudHMsIHN0eWxlU2hlZXQsIGNvbnRyb2xsZXJGYWN0b3J5LCBDb250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBPcHRpb25Db250cm9sbGVyLCBDb2xvckNvbnRyb2xsZXIsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgQ2VudGVyZWREaXYsIGRvbSwgY29tbW9uKSB7XG5cbiAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcblxuICAvKiogT3V0ZXItbW9zdCBjbGFzc05hbWUgZm9yIEdVSSdzICovXG4gIHZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcblxuICB2YXIgSElERV9LRVlfQ09ERSA9IDcyO1xuXG4gIC8qKiBUaGUgb25seSB2YWx1ZSBzaGFyZWQgYmV0d2VlbiB0aGUgSlMgYW5kIFNDU1MuIFVzZSBjYXV0aW9uLiAqL1xuICB2YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xuXG4gIHZhciBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgPSAnRGVmYXVsdCc7XG5cbiAgdmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cgJiYgd2luZG93Wydsb2NhbFN0b3JhZ2UnXSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIHZhciBTQVZFX0RJQUxPR1VFO1xuXG4gIC8qKiBIYXZlIHdlIHlldCB0byBjcmVhdGUgYW4gYXV0b1BsYWNlIEdVST8gKi9cbiAgdmFyIGF1dG9fcGxhY2VfdmlyZ2luID0gdHJ1ZTtcblxuICAvKiogRml4ZWQgcG9zaXRpb24gZGl2IHRoYXQgYXV0byBwbGFjZSBHVUkncyBnbyBpbnNpZGUgKi9cbiAgdmFyIGF1dG9fcGxhY2VfY29udGFpbmVyO1xuXG4gIC8qKiBBcmUgd2UgaGlkaW5nIHRoZSBHVUkncyA/ICovXG4gIHZhciBoaWRlID0gZmFsc2U7XG5cbiAgLyoqIEdVSSdzIHdoaWNoIHNob3VsZCBiZSBoaWRkZW4gKi9cbiAgdmFyIGhpZGVhYmxlX2d1aXMgPSBbXTtcblxuICAvKipcbiAgICogQSBsaWdodHdlaWdodCBjb250cm9sbGVyIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuIEl0IGFsbG93cyB5b3UgdG8gZWFzaWx5XG4gICAqIG1hbmlwdWxhdGUgdmFyaWFibGVzIGFuZCBmaXJlIGZ1bmN0aW9ucyBvbiB0aGUgZmx5LlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogQG1lbWJlciBkYXQuZ3VpXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMubG9hZF0gSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYXZlZCBzdGF0ZSBvZlxuICAgKiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmF1dG89dHJ1ZV1cbiAgICogQHBhcmFtIHtkYXQuZ3VpLkdVSX0gW3BhcmFtcy5wYXJlbnRdIFRoZSBHVUkgSSdtIG5lc3RlZCBpbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNsb3NlZF0gSWYgdHJ1ZSwgc3RhcnRzIGNsb3NlZFxuICAgKi9cbiAgdmFyIEdVSSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIE91dGVybW9zdCBET00gRWxlbWVudFxuICAgICAqIEB0eXBlIERPTUVsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgR1VJJ3MgYnkgbmFtZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuXG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG9iamVjdHMgSSdtIHJlbWVtYmVyaW5nIGZvciBzYXZlLCBvbmx5IHVzZWQgaW4gdG9wIGxldmVsIEdVSVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGluZGV4IG9mIHJlbWVtYmVyZWQgb2JqZWN0cyB0byBhIG1hcCBvZiBjb250cm9sbGVycywgb25seSB1c2VkXG4gICAgICogaW4gdG9wIGxldmVsIEdVSS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXIsXG4gICAgICogICAgYW5vdGhlclByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9LFxuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH1cbiAgICAgKiBdXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gRGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXG4gICAgfSk7XG5cbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICAgIH0pO1xuXG5cbiAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcblxuICAgICAgLy8gRXhwbGljaXQgcHJlc2V0XG4gICAgICBpZiAocGFyYW1zLnByZXNldCkgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuXG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcbiAgICAgIGhpZGVhYmxlX2d1aXMucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHJvb3QgbGV2ZWwgR1VJJ3MgYXJlIHJlc2l6YWJsZS5cbiAgICBwYXJhbXMucmVzaXphYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5yZXNpemFibGU7XG5cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlICYmIGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcbiAgICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4vLyAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuc2Nyb2xsYWJsZSA9PT0gdHJ1ZTtcblxuICAgIC8vIE5vdCBwYXJ0IG9mIHBhcmFtcyBiZWNhdXNlIEkgZG9uJ3Qgd2FudCBwZW9wbGUgcGFzc2luZyB0aGlzIGluIHZpYVxuICAgIC8vIGNvbnN0cnVjdG9yLiBTaG91bGQgYmUgYSAncmVtZW1iZXJlZCcgdmFsdWUuXG4gICAgdmFyIHVzZV9sb2NhbF9zdG9yYWdlID1cbiAgICAgICAgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJlxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcblxuICAgICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJLnByb3RvdHlwZSAqL1xuICAgICAgICB7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcGFyZW50IDxjb2RlPkdVSTwvY29kZT5cbiAgICAgICAgICAgKiBAdHlwZSBkYXQuZ3VpLkdVSVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNjcm9sbGFibGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSGFuZGxlcyA8Y29kZT5HVUk8L2NvZGU+J3MgZWxlbWVudCBwbGFjZW1lbnQgZm9yIHlvdVxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBhdXRvUGxhY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgaWRlbnRpZmllciBmb3IgYSBzZXQgb2Ygc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgcHJlc2V0OiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiA8Y29kZT5HVUk8L2NvZGU+IGVsZW1lbnRcbiAgICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy53aWR0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbmFtZSBvZiA8Y29kZT5HVUk8L2NvZGU+LiBVc2VkIGZvciBmb2xkZXJzLiBpLmVcbiAgICAgICAgICAgKiBhIGZvbGRlcidzIG5hbWVcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgYW1vbmcgc2libGluZyBmb2xkZXJzXG4gICAgICAgICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgICAgICAgaWYgKHRpdGxlX3Jvd19uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVfcm93X25hbWUuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciB0aGUgPGNvZGU+R1VJPC9jb2RlPiBpcyBjb2xsYXBzZWQgb3Igbm90XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNsb3NlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgYXJlbid0IGdvaW5nIHRvIHJlc3BlY3QgdGhlIENTUyB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAvLyBMZXRzIGp1c3QgY2hlY2sgb3VyIGhlaWdodCBhZ2FpbnN0IHRoZSB3aW5kb3cgaGVpZ2h0IHJpZ2h0IG9mZlxuICAgICAgICAgICAgICAvLyB0aGUgYmF0LlxuICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENvbnRhaW5zIGFsbCBwcmVzZXRzXG4gICAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAgICovXG4gICAgICAgICAgbG9hZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIHVzZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1N0b3JhZ2UjbG9jYWxTdG9yYWdlXCI+bG9jYWxTdG9yYWdlPC9hPiBhcyB0aGUgbWVhbnMgZm9yXG4gICAgICAgICAgICogPGNvZGU+cmVtZW1iZXI8L2NvZGU+aW5nXG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZToge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXNlX2xvY2FsX3N0b3JhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgICAgICAgdXNlX2xvY2FsX3N0b3JhZ2UgPSBib29sO1xuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICAgICBkb20uYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAvLyBBcmUgd2UgYSByb290IGxldmVsIEdVST9cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgIHBhcmFtcy5jbG9zZWQgPSBmYWxzZTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgICAvLyBBcmUgd2Ugc3VwcG9zZWQgdG8gYmUgbG9hZGluZyBsb2NhbGx5P1xuICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgICBpZiAodXNlX2xvY2FsX3N0b3JhZ2UpIHtcblxuICAgICAgICAgIF90aGlzLnVzZUxvY2FsU3RvcmFnZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc2F2ZWRfZ3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuXG4gICAgICAgICAgaWYgKHNhdmVkX2d1aSkge1xuICAgICAgICAgICAgcGFyYW1zLmxvYWQgPSBKU09OLnBhcnNlKHNhdmVkX2d1aSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pO1xuXG4gICAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG5cblxuICAgICAgfSk7XG5cblxuICAgICAgLy8gT2gsIHlvdSdyZSBhIG5lc3RlZCBHVUkhXG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlX3Jvd19uYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3Jvd19uYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG5cbiAgICAgIHZhciB0aXRsZV9yb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlX3Jvd19uYW1lKTtcblxuICAgICAgdmFyIG9uX2NsaWNrX3RpdGxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93LCAndGl0bGUnKTtcbiAgICAgIGRvbS5iaW5kKHRpdGxlX3JvdywgJ2NsaWNrJywgb25fY2xpY2tfdGl0bGUpO1xuXG4gICAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgICBpZiAoYXV0b19wbGFjZV92aXJnaW4pIHtcbiAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b19wbGFjZV9jb250YWluZXIpO1xuICAgICAgICAgIGF1dG9fcGxhY2VfdmlyZ2luID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaXQgaW4gdGhlIGRvbSBmb3IgeW91LlxuICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBhdXRvIHN0eWxlc1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG5cbiAgICAgIH1cblxuXG4gICAgICAvLyBNYWtlIGl0IG5vdCBlbGFzdGljLlxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG5cbiAgICB9XG5cbiAgICBkb20uYmluZCh3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCk7IH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIHRoaXMub25SZXNpemUoKTtcblxuXG4gICAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuICAgIH1cblxuICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgICAgICByb290LndpZHRoICs9IDE7XG4gICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByb290LndpZHRoIC09IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICAgICAgcmVzZXRXaWR0aCgpO1xuICAgICAgfVxuXG4gIH07XG5cbiAgR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIGhpZGUgPSAhaGlkZTtcbiAgICBjb21tb24uZWFjaChoaWRlYWJsZV9ndWlzLCBmdW5jdGlvbihndWkpIHtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLnpJbmRleCA9IGhpZGUgPyAtOTk5IDogOTk5O1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGhpZGUgPyAwIDogMTtcbiAgICB9KTtcbiAgfTtcblxuICBHVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcbiAgR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG4gIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG4gIEdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuICBHVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG4gIEdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbiAgR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5cbiAgR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG4gIEdVSS5URVhUX0NMT1NFRCA9ICdDbG9zZSBDb250cm9scyc7XG4gIEdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5cbiAgZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gICAgfVxuXG4gIH0sIGZhbHNlKTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBHVUkucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gY29udHJvbGxlclxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgLy8gVE9ETyBsaXN0ZW5pbmc/XG4gICAgICAgICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSBUaGUgbmV3IGZvbGRlci5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoaXMgR1VJIGFscmVhZHkgaGFzIGEgZm9sZGVyIGJ5IHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZEZvbGRlcjogZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMgb24gbmFtZXMgaW4gb3JkZXIgdG8gaGF2ZSBhIGtleVxuICAgICAgICAgIC8vIGJ5IHdoaWNoIHRvIHJlbWVtYmVyIHNhdmVkIHZhbHVlc1xuICAgICAgICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhbHJlYWR5IGhhdmUgYSBmb2xkZXIgaW4gdGhpcyBHVUkgYnkgdGhlJyArXG4gICAgICAgICAgICAgICAgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3X2d1aV9wYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIGF1dG9QbGFjZSB0cmFpdCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gb3Blbi9jbG9zZSBmb2xkZXIgYWN0aW9ucyB0b1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGEgc2Nyb2xsYmFyIGFwcGVhcnMgaWYgdGhlIHdpbmRvdyBpcyB0b28gc2hvcnQuXG4gICAgICAgICAgbmV3X2d1aV9wYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG5cbiAgICAgICAgICAvLyBEbyB3ZSBoYXZlIHNhdmVkIGFwcGVhcmFuY2UgZGF0YSBmb3IgdGhpcyBmb2xkZXI/XG5cbiAgICAgICAgICBpZiAodGhpcy5sb2FkICYmIC8vIEFueXRoaW5nIGxvYWRlZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnMgJiYgLy8gV2FzIG15IHBhcmVudCBhIGRlYWQtZW5kP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkgeyAvLyBEaWQgZGFkZHkgcmVtZW1iZXIgbWU/XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG1lIGNsb3NlZCBpZiBJIHdhcyBjbG9zZWRcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcblxuICAgICAgICAgICAgLy8gUGFzcyBkb3duIHRoZSBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3X2d1aV9wYXJhbXMpO1xuICAgICAgICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuXG4gICAgICAgICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MobGksICdmb2xkZXInKTtcbiAgICAgICAgICByZXR1cm4gZ3VpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG5cbiAgICAgICAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgICAgICAgdmFyIGggPSAwO1xuXG4gICAgICAgICAgICBjb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICBpZiAoISAocm9vdC5hdXRvUGxhY2UgJiYgbm9kZSA9PT0gcm9vdC5fX3NhdmVfcm93KSlcbiAgICAgICAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFyayBvYmplY3RzIGZvciBzYXZpbmcuIFRoZSBvcmRlciBvZiB0aGVzZSBvYmplY3RzIGNhbm5vdCBjaGFuZ2UgYXNcbiAgICAgICAgICogdGhlIEdVSSBncm93cy4gV2hlbiByZW1lbWJlcmluZyBuZXcgb2JqZWN0cywgYXBwZW5kIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICAgKiBvZiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuLi59IG9iamVjdHNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vdCBjYWxsZWQgb24gYSB0b3AgbGV2ZWwgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbWVtYmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9ndWVDb250ZW50cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gb25seSBjYWxsIHJlbWVtYmVyIG9uIGEgdG9wIGxldmVsIEdVSS5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09IC0xKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2F2ZSByb3cgd2lkdGhcbiAgICAgICAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IHRoZSB0b3Btb3N0IHBhcmVudCBHVUkgb2YgYSBuZXN0ZWQgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBndWkgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICAgICAgICBndWkgPSBndWkucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ3VpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZlxuICAgICAgICAgKiB0aGlzIEdVSSBhcyB3ZWxsIGFzIGl0cyByZW1lbWJlcmVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XG5cbiAgICAgICAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblxuICAgICAgICAgIC8vIEFtIEkgcmVtZW1iZXJpbmcgYW55IHZhbHVlcz9cbiAgICAgICAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG5cbiAgICAgICAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZWxlbWVudCwga2V5KSB7XG4gICAgICAgICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlQXM6IGZ1bmN0aW9uKHByZXNldE5hbWUpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICAgICAgLy8gUmV0YWluIGRlZmF1bHQgdmFsdWVzIHVwb24gZmlyc3Qgc2F2ZVxuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbcHJlc2V0TmFtZV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcbiAgICAgICAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uKGd1aSkge1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHJldmVydCB3b3JrIG9uIERlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihmb2xkZXIpIHtcbiAgICAgICAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZ3VpKSB7XG4gICAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PSAwO1xuICAgICAgICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgICBpZiAoaW5pdCkgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBhZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBcIiArIG9iamVjdCArIFwiIGhhcyBubyBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29udHJvbGxlcjtcblxuICAgIGlmIChwYXJhbXMuY29sb3IpIHtcblxuICAgICAgY29udHJvbGxlciA9IG5ldyBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFjdG9yeUFyZ3MgPSBbb2JqZWN0LHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyRmFjdG9yeS5hcHBseShndWksIGZhY3RvcnlBcmdzKTtcblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYmVmb3JlIGluc3RhbmNlb2YgQ29udHJvbGxlcikge1xuICAgICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgICB9XG5cbiAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG5cbiAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xuXG4gICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZG9tLmFkZENsYXNzKG5hbWUsICdwcm9wZXJ0eS1uYW1lJyk7XG4gICAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcblxuICAgIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG5cbiAgICBkb20uYWRkQ2xhc3MobGksIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCB0eXBlb2YgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcblxuICAgIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xuXG4gICAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcblxuICAgIHJldHVybiBjb250cm9sbGVyO1xuXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcm93IHRvIHRoZSBlbmQgb2YgdGhlIEdVSSBvciBiZWZvcmUgYW5vdGhlciByb3cuXG4gICAqXG4gICAqIEBwYXJhbSBndWlcbiAgICogQHBhcmFtIFtkb21dIElmIHNwZWNpZmllZCwgaW5zZXJ0cyB0aGUgZG9tIGNvbnRlbnQgaW4gdGhlIG5ldyByb3dcbiAgICogQHBhcmFtIFtsaUJlZm9yZV0gSWYgc3BlY2lmaWVkLCBwbGFjZXMgdGhlIG5ldyByb3cgYmVmb3JlIGFub3RoZXIgcm93XG4gICAqL1xuICBmdW5jdGlvbiBhZGRSb3coZ3VpLCBkb20sIGxpQmVmb3JlKSB7XG4gICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBpZiAoZG9tKSBsaS5hcHBlbmRDaGlsZChkb20pO1xuICAgIGlmIChsaUJlZm9yZSkge1xuICAgICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBwYXJhbXMuYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICBndWkub25SZXNpemUoKTtcbiAgICByZXR1cm4gbGk7XG4gIH1cblxuICBmdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG5cbiAgICBjb250cm9sbGVyLl9fbGkgPSBsaTtcbiAgICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb250cm9sbGVyLCB7XG5cbiAgICAgIG9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykgfHwgY29tbW9uLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtvcHRpb25zXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG5hbWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9IHY7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBBbGwgc2xpZGVycyBzaG91bGQgYmUgYWNjb21wYW5pZWQgYnkgYSBib3guXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKSB7XG5cbiAgICAgIHZhciBib3ggPSBuZXcgTnVtYmVyQ29udHJvbGxlckJveChjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcblxuICAgICAgY29tbW9uLmVhY2goWyd1cGRhdGVEaXNwbGF5JywgJ29uQ2hhbmdlJywgJ29uRmluaXNoQ2hhbmdlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XG4gICAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuICAgICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gcGIuYXBwbHkoYm94LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJCb3gpIHtcblxuICAgICAgdmFyIHIgPSBmdW5jdGlvbihyZXR1cm5lZCkge1xuXG4gICAgICAgIC8vIEhhdmUgd2UgZGVmaW5lZCBib3RoIGJvdW5kYXJpZXM/XG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XG5cbiAgICAgICAgICAvLyBXZWxsLCB0aGVuIGxldHMganVzdCByZXBsYWNlIHRoaXMgd2l0aCBhIHNsaWRlci5cbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5lZDtcblxuICAgICAgfTtcblxuICAgICAgY29udHJvbGxlci5taW4gPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1pbik7XG4gICAgICBjb250cm9sbGVyLm1heCA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnRzIGRvdWJsZS10b2dnbGVcbiAgICAgIH0pXG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuXG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG5cbiAgICAvLyBGaW5kIHRoZSB0b3Btb3N0IEdVSSwgdGhhdCdzIHdoZXJlIHJlbWVtYmVyZWQgb2JqZWN0cyBsaXZlLlxuICAgIHZhciByb290ID0gZ3VpLmdldFJvb3QoKTtcblxuICAgIC8vIERvZXMgdGhlIG9iamVjdCB3ZSdyZSBjb250cm9sbGluZyBtYXRjaCBhbnl0aGluZyB3ZSd2ZSBiZWVuIHRvbGQgdG9cbiAgICAvLyByZW1lbWJlcj9cbiAgICB2YXIgbWF0Y2hlZF9pbmRleCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKGNvbnRyb2xsZXIub2JqZWN0KTtcblxuICAgIC8vIFdoeSB5ZXMsIGl0IGRvZXMhXG4gICAgaWYgKG1hdGNoZWRfaW5kZXggIT0gLTEpIHtcblxuICAgICAgLy8gTGV0IG1lIGZldGNoIGEgbWFwIG9mIGNvbnRyb2xsZXJzIGZvciB0aGNvbW1vbi5pc09iamVjdC5cbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XTtcblxuICAgICAgLy8gT2hwLCBJIGJlbGlldmUgdGhpcyBpcyB0aGUgZmlyc3QgY29udHJvbGxlciB3ZSd2ZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAvLyBvYmplY3QuIExldHMgbWFrZSB0aGUgbWFwIGZyZXNoLlxuICAgICAgaWYgKGNvbnRyb2xsZXJfbWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlcl9tYXAgPSB7fTtcbiAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XSA9XG4gICAgICAgICAgICBjb250cm9sbGVyX21hcDtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgIGNvbnRyb2xsZXJfbWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcblxuICAgICAgLy8gT2theSwgbm93IGhhdmUgd2Ugc2F2ZWQgYW55IHZhbHVlcyBmb3IgdGhpcyBjb250cm9sbGVyP1xuICAgICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgIHZhciBwcmVzZXRfbWFwID0gcm9vdC5sb2FkLnJlbWVtYmVyZWQ7XG5cbiAgICAgICAgLy8gV2hpY2ggcHJlc2V0IGFyZSB3ZSB0cnlpbmcgdG8gbG9hZD9cbiAgICAgICAgdmFyIHByZXNldDtcblxuICAgICAgICBpZiAocHJlc2V0X21hcFtndWkucHJlc2V0XSkge1xuXG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtndWkucHJlc2V0XTtcblxuICAgICAgICB9IGVsc2UgaWYgKHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuXG4gICAgICAgICAgLy8gVWhoLCB5b3UgY2FuIGhhdmUgdGhlIGRlZmF1bHQgaW5zdGVhZD9cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIE5hZGEuXG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRGlkIHRoZSBsb2FkZWQgb2JqZWN0IHJlbWVtYmVyIHRoY29tbW9uLmlzT2JqZWN0P1xuICAgICAgICBpZiAocHJlc2V0W21hdGNoZWRfaW5kZXhdICYmXG5cbiAgICAgICAgICAvLyBEaWQgd2UgcmVtZW1iZXIgdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5P1xuICAgICAgICAgICAgcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIC8vIFdlIGRpZCByZW1lbWJlciBzb21ldGhpbmcgZm9yIHRoaXMgZ3V5IC4uLlxuICAgICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XTtcblxuICAgICAgICAgIC8vIEFuZCB0aGF0J3Mgd2hhdCBpdCBpcy5cbiAgICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gICAgLy8gVE9ETyBob3cgZG9lcyB0aGlzIGRlYWwgd2l0aCBtdWx0aXBsZSBHVUkncz9cbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XG5cbiAgICB2YXIgZGl2ID0gZ3VpLl9fc2F2ZV9yb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcblxuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xuXG4gICAgZG9tLmFkZENsYXNzKGRpdiwgJ3NhdmUtcm93Jyk7XG5cbiAgICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgZG9tLmFkZENsYXNzKGdlYXJzLCAnYnV0dG9uIGdlYXJzJyk7XG5cbiAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBGdW5jdGlvbkNvbnRyb2xsZXJcbiAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XG5cbiAgICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24yLmlubmVySFRNTCA9ICdOZXcnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG5cbiAgICB2YXIgYnV0dG9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdyZXZlcnQnKTtcblxuICAgIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICBjb21tb24uZWFjaChndWkubG9hZC5yZW1lbWJlcmVkLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09IGd1aS5wcmVzZXQpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcblxuICAgIH0pO1xuXG4gICAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuXG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xuICAgICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuXG4gICAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcblxuICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbigpIHtcbiAgICAgICAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuXG4gICAgICAvLyBUT0RPOiBVc2UgYSBib29sZWFuIGNvbnRyb2xsZXIsIGZvb2whXG4gICAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBndWkudXNlTG9jYWxTdG9yYWdlID0gIWd1aS51c2VMb2NhbFN0b3JhZ2U7XG4gICAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcblxuICAgIGRvbS5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09IDY3KSkge1xuICAgICAgICBTQVZFX0RJQUxPR1VFLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkuc2F2ZSgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgICBpZiAocHJlc2V0TmFtZSkgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnJldmVydCgpO1xuICAgIH0pO1xuXG4vLyAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZShndWkpIHtcblxuICAgIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuXG4gICAgICB3aWR0aDogJzZweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgICBoZWlnaHQ6ICcyMDBweCcsXG4gICAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbi8vICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGJsdWUnXG5cbiAgICB9KTtcblxuICAgIHZhciBwbW91c2VYO1xuXG4gICAgZG9tLmJpbmQoZ3VpLl9fcmVzaXplX2hhbmRsZSwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gICAgZG9tLmJpbmQoZ3VpLl9fY2xvc2VCdXR0b24sICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuXG4gICAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIGZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgZG9tLmFkZENsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGd1aS53aWR0aCArPSBwbW91c2VYIC0gZS5jbGllbnRYO1xuICAgICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcblxuICAgICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIC8vIEF1dG8gcGxhY2VkIHNhdmUtcm93cyBhcmUgcG9zaXRpb24gZml4ZWQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyBzZXQgdGhlIHdpZHRoIG1hbnVhbGx5IGlmIHdlIHdhbnQgaXQgdG8gYmxlZWQgdG8gdGhlIGVkZ2VcbiAgICBpZiAoZ3VpLl9fc2F2ZV9yb3cgJiYgZ3VpLmF1dG9QbGFjZSkge1xuICAgICAgZ3VpLl9fc2F2ZV9yb3cuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9aWYgKGd1aS5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICBndWkuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG5cbiAgICB2YXIgdG9SZXR1cm4gPSB7fTtcblxuICAgIC8vIEZvciBlYWNoIG9iamVjdCBJJ20gcmVtZW1iZXJpbmdcbiAgICBjb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24odmFsLCBpbmRleCkge1xuXG4gICAgICB2YXIgc2F2ZWRfdmFsdWVzID0ge307XG5cbiAgICAgIC8vIFRoZSBjb250cm9sbGVycyBJJ3ZlIG1hZGUgZm9yIHRoY29tbW9uLmlzT2JqZWN0IGJ5IHByb3BlcnR5XG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIC8vIFJlbWVtYmVyIGVhY2ggdmFsdWUgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJfbWFwLCBmdW5jdGlvbihjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzYXZlZF92YWx1ZXNbcHJvcGVydHldID0gdXNlSW5pdGlhbFZhbHVlcyA/IGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlIDogY29udHJvbGxlci5nZXRWYWx1ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIHZhbHVlcyBmb3IgdGhjb21tb24uaXNPYmplY3RcbiAgICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkX3ZhbHVlcztcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRQcmVzZXRPcHRpb24oZ3VpLCBuYW1lLCBzZXRTZWxlY3RlZCkge1xuICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgICBvcHQudmFsdWUgPSBuYW1lO1xuICAgIGd1aS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PSBndWkucHJlc2V0KSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtQcmVzZXRNb2RpZmllZChndWksIG1vZGlmaWVkKSB7XG4gICAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbi8vICAgIGNvbnNvbGUubG9nKCdtYXJrJywgbW9kaWZpZWQsIG9wdCk7XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgXCIqXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG5cblxuICAgIGlmIChjb250cm9sbGVyQXJyYXkubGVuZ3RoICE9IDApIHtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChjb250cm9sbGVyQXJyYXksIGZ1bmN0aW9uKGMpIHtcbiAgICAgIGMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gIH1cblxuICByZXR1cm4gR1VJO1xuXG59KShkYXQudXRpbHMuY3NzLFxuXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuICAgICAgXFxuICAgIDwvZGl2PlxcbiAgICBcXG4gIDwvZGl2PlxcblxcbjwvZGl2PlwiLFxuXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXJ9LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93e292ZXJmbG93LXk6YXV0b30uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjE7bWFyZ2luLXRvcDotMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICMyYzJjMmN9LmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b257b3BhY2l0eToxICFpbXBvcnRhbnR9LmRnLm1haW46aG92ZXIgLmNsb3NlLWJ1dHRvbiwuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWd7b3BhY2l0eToxfS5kZy5tYWluIC5jbG9zZS1idXR0b257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjtib3JkZXI6MDtwb3NpdGlvbjphYnNvbHV0ZTtsaW5lLWhlaWdodDoxOXB4O2hlaWdodDoyMHB4O2N1cnNvcjpwb2ludGVyO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMH0uZGcubWFpbiAuY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uZGcuYXtmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MTVweDtvdmVyZmxvdy14OmhpZGRlbn0uZGcuYS5oYXMtc2F2ZSB1bHttYXJnaW4tdG9wOjI3cHh9LmRnLmEuaGFzLXNhdmUgdWwuY2xvc2Vke21hcmdpbi10b3A6MH0uZGcuYSAuc2F2ZS1yb3d7cG9zaXRpb246Zml4ZWQ7dG9wOjA7ei1pbmRleDoxMDAyfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW8tdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstbW96LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dH0uZGcgbGk6bm90KC5mb2xkZXIpe2N1cnNvcjphdXRvO2hlaWdodDoyN3B4O2xpbmUtaGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGkgPiAqe2hlaWdodDowO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MH0uZGcgLmNye2NsZWFyOmJvdGg7cGFkZGluZy1sZWZ0OjNweDtoZWlnaHQ6MjdweH0uZGcgLnByb3BlcnR5LW5hbWV7Y3Vyc29yOmRlZmF1bHQ7ZmxvYXQ6bGVmdDtjbGVhcjpsZWZ0O3dpZHRoOjQwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjlweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuc2VsZWN0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi1sZWZ0Oi05cHg7bWFyZ2luLXRvcDoyM3B4O3otaW5kZXg6MTB9LmRnIC5jOmhvdmVyIC5zZWxlY3RvciwuZGcgLnNlbGVjdG9yLmRyYWd7ZGlzcGxheTpibG9ja30uZGcgbGkuc2F2ZS1yb3d7cGFkZGluZzowfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MHB4IDZweH0uZGcuZGlhbG9ndWV7YmFja2dyb3VuZC1jb2xvcjojMjIyO3dpZHRoOjQ2MHB4O3BhZGRpbmc6MTVweDtmb250LXNpemU6MTNweDtsaW5lLWhlaWdodDoxNXB4fSNkZy1uZXctY29uc3RydWN0b3J7cGFkZGluZzoxMHB4O2NvbG9yOiMyMjI7Zm9udC1mYW1pbHk6TW9uYWNvLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHg7Ym9yZGVyOjA7cmVzaXplOm5vbmU7Ym94LXNoYWRvdzppbnNldCAxcHggMXB4IDFweCAjODg4O3dvcmQtd3JhcDpicmVhay13b3JkO21hcmdpbjoxMnB4IDA7ZGlzcGxheTpibG9jazt3aWR0aDo0NDBweDtvdmVyZmxvdy15OnNjcm9sbDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmV9I2RnLWxvY2FsLWV4cGxhaW57ZGlzcGxheTpub25lO2ZvbnQtc2l6ZToxMXB4O2xpbmUtaGVpZ2h0OjE3cHg7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6OHB4O21hcmdpbi10b3A6MTBweH0jZGctbG9jYWwtZXhwbGFpbiBjb2Rle2ZvbnQtc2l6ZToxMHB4fSNkYXQtZ3VpLXNhdmUtbG9jYWxseXtkaXNwbGF5Om5vbmV9LmRne2NvbG9yOiNlZWU7Zm9udDoxMXB4ICdMdWNpZGEgR3JhbmRlJywgc2Fucy1zZXJpZjt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMTExfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHg7YmFja2dyb3VuZDojMWExYTFhfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7aGVpZ2h0OjA7ZGlzcGxheTpub25lfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiM2NzY3Njd9LmRnIGxpOm5vdCguZm9sZGVyKXtiYWNrZ3JvdW5kOiMxYTFhMWE7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzJjMmMyY30uZGcgbGkuc2F2ZS1yb3d7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kOiNkYWQ1Y2I7Ym9yZGVyOjB9LmRnIGxpLnNhdmUtcm93IHNlbGVjdHttYXJnaW4tbGVmdDo1cHg7d2lkdGg6MTA4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b257bWFyZ2luLWxlZnQ6NXB4O21hcmdpbi10b3A6MXB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtc2l6ZTo5cHg7bGluZS1oZWlnaHQ6N3B4O3BhZGRpbmc6NHB4IDRweCA1cHggNHB4O2JhY2tncm91bmQ6I2M1YmRhZDtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgMXB4IDAgI2IwYTU4Zjtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGY7Y3Vyc29yOnBvaW50ZXJ9LmRnIGxpLnNhdmUtcm93IC5idXR0b24uZ2VhcnN7YmFja2dyb3VuZDojYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7aGVpZ2h0OjdweDt3aWR0aDo4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojYmFiMTllO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4Zn0uZGcgbGkuZm9sZGVye2JvcmRlci1ib3R0b206MH0uZGcgbGkudGl0bGV7cGFkZGluZy1sZWZ0OjE2cHg7YmFja2dyb3VuZDojMDAwIHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEkraEtnRnhvQ2dBT3c9PSkgNnB4IDEwcHggbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKX0uZGcgLmNsb3NlZCBsaS50aXRsZXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSl9LmRnIC5jci5ib29sZWFue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjODA2Nzg3fS5kZyAuY3IuZnVuY3Rpb257Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICNlNjFkNWZ9LmRnIC5jci5udW1iZXJ7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMyZmExZDZ9LmRnIC5jci5udW1iZXIgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMmZhMWQ2fS5kZyAuY3Iuc3RyaW5ne2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMWVkMzZmfS5kZyAuY3Iuc3RyaW5nIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzFlZDM2Zn0uZGcgLmNyLmZ1bmN0aW9uOmhvdmVyLC5kZyAuY3IuYm9vbGVhbjpob3ZlcntiYWNrZ3JvdW5kOiMxMTF9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17YmFja2dyb3VuZDojMzAzMDMwO291dGxpbmU6bm9uZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06Zm9jdXN7YmFja2dyb3VuZDojNDk0OTQ5O2NvbG9yOiNmZmZ9LmRnIC5jIC5zbGlkZXJ7YmFja2dyb3VuZDojMzAzMDMwO2N1cnNvcjpldy1yZXNpemV9LmRnIC5jIC5zbGlkZXItZmd7YmFja2dyb3VuZDojMmZhMWQ2fS5kZyAuYyAuc2xpZGVyOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgLnNsaWRlcjpob3ZlciAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzQ0YWJkYX1cXG5cIixcbmRhdC5jb250cm9sbGVycy5mYWN0b3J5ID0gKGZ1bmN0aW9uIChPcHRpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBTdHJpbmdDb250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBjb21tb24pIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAvLyBQcm92aWRpbmcgb3B0aW9ucz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgY29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb3ZpZGluZyBhIG1hcD9cblxuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuXG4gICAgICAgICAgICAvLyBIYXMgbWluIGFuZCBtYXguXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0pKGRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5TdHJpbmdDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSB0ZXh0IGlucHV0IHRvIGFsdGVyIHRoZSBzdHJpbmcgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gU3RvcHMgdGhlIGNhcmV0IGZyb20gbW92aW5nIG9uIGFjY291bnQgb2Y6XG4gICAgICAgICAgLy8ga2V5dXAgLT4gc2V0VmFsdWUgLT4gdXBkYXRlRGlzcGxheVxuICAgICAgICAgIGlmICghZG9tLmlzQWN0aXZlKHRoaXMuX19pbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIENvbG9yLCBpbnRlcnByZXQsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdGhpcy5fX2NvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgdGhpcy5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICB0aGlzLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuXG4gICAgdGhpcy5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuXG4gICAgdGhpcy5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG5cbiAgICB0aGlzLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHsgLy8gb24gZW50ZXJcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgZG9tXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLCAnZHJhZycpXG4gICAgICAgIC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICB2YXIgdmFsdWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NlbGVjdG9yLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEyMnB4JyxcbiAgICAgIGhlaWdodDogJzEwMnB4JyxcbiAgICAgIHBhZGRpbmc6ICczcHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTJweCcsXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgKHRoaXMuX19jb2xvci52IDwgLjUgPyAnI2ZmZicgOiAnIzAwMCcpLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHZhbHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZV9maWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJ1xuICAgIH0pO1xuXG4gICAgaHVlR3JhZGllbnQodGhpcy5fX2h1ZV9maWVsZCk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuLy8gICAgICB3aWR0aDogJzEyMHB4JyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4vLyAgICAgIHBhZGRpbmc6ICc0cHgnLFxuLy8gICAgICBtYXJnaW5Cb3R0b206ICc2cHgnLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2V0SChlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcbiAgICAgIHNldFNWKGUpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnbm9uZSc7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fX2NvbG9yLl9fc3RhdGUgPSBpO1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gX3RoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZEgoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVfZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fZmllbGRfa25vYik7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2tub2IpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3Rvcik7XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgdyA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgcyA9IChlLmNsaWVudFggLSBvLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpIC8gdztcbiAgICAgIHZhciB2ID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHc7XG5cbiAgICAgIGlmICh2ID4gMSkgdiA9IDE7XG4gICAgICBlbHNlIGlmICh2IDwgMCkgdiA9IDA7XG5cbiAgICAgIGlmIChzID4gMSkgcyA9IDE7XG4gICAgICBlbHNlIGlmIChzIDwgMCkgcyA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHMgPSBkb20uZ2V0SGVpZ2h0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgaCA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyBzO1xuXG4gICAgICBpZiAoaCA+IDEpIGggPSAxO1xuICAgICAgZWxzZSBpZiAoaCA8IDApIGggPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLmggPSBoICogMzYwO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICB9O1xuXG4gIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb2xvckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaXNtYXRjaCBvbiB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUuXG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKENvbG9yLkNPTVBPTkVOVFMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICAhY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICBpW2NvbXBvbmVudF0gIT09IHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSWYgbm90aGluZyBkaXZlcmdlcywgd2Uga2VlcCBvdXIgcHJldmlvdXMgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3Igc3RhdGVmdWxuZXNzLCBvdGhlcndpc2Ugd2UgcmVjYWxjdWxhdGUgZnJlc2hcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19jb2xvci5fX3N0YXRlLCBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAuYSA9IDE7XG5cbiAgICAgICAgICB2YXIgZmxpcCA9ICh0aGlzLl9fY29sb3IudiA8IC41IHx8IHRoaXMuX19jb2xvci5zID4gLjUpID8gMjU1IDogMDtcbiAgICAgICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogMTAwICogdGhpcy5fX2NvbG9yLnMgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCdcblxuICAgICAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgICAgIHRoaXMuX190ZW1wLnYgPSAxO1xuXG4gICAgICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b1N0cmluZygpKTtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpLFxuICAgICAgICAgICAgY29sb3I6ICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknLFxuICAgICAgICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsnLC43KSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuICBcbiAgdmFyIHZlbmRvcnMgPSBbJy1tb3otJywnLW8tJywnLXdlYmtpdC0nLCctbXMtJywnJ107XG4gIFxuICBmdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgY29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24odmVuZG9yKSB7XG4gICAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcreCsnLCAnK2ErJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBodWVHcmFkaWVudChlbGVtKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gIH1cblxuXG4gIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQuY29sb3IuQ29sb3IgPSAoZnVuY3Rpb24gKGludGVycHJldCwgbWF0aCwgdG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cblxuICB9O1xuXG4gIENvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCdnJywnYicsJ2gnLCdzJywndicsJ2hleCcsJ2EnXTtcblxuICBjb21tb24uZXh0ZW5kKENvbG9yLnByb3RvdHlwZSwge1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b09yaWdpbmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcblxuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gICAgfVxuXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IG1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVJHQihjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG5cbiAgICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IG1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG5cbiAgICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgbWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRocm93ICdDb3JydXB0ZWQgY29sb3Igc3RhdGUnO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUhTVihjb2xvcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IG1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIHM6IHJlc3VsdC5zLFxuICAgICAgICAgIHY6IHJlc3VsdC52XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFjb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbG9yO1xuXG59KShkYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIHJlcXVpcmVqcyB2ZXJzaW9uIG9mIFBhdWwgSXJpc2gncyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICovXG5cbiAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cbiAgICAgIH07XG59KSgpLFxuZGF0LmRvbS5DZW50ZXJlZERpdiA9IChmdW5jdGlvbiAoZG9tLCBjb21tb24pIHtcblxuXG4gIHZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuICAgIGRvbS5tYWtlRnVsbHNjcmVlbih0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDEnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfSk7XG5cblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIFxuXG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNTIlJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gICAgdGhpcy5sYXlvdXQoKTtcblxuICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB9KTtcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIH07XG5cbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc0OCUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGgvMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodC8yIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBsb2NrU2Nyb2xsKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxuXG4gIHJldHVybiBDZW50ZXJlZERpdjtcblxufSkoZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7IiwiLy8gdmVuZG9yIGRlcGVuZGVuY2llc1xudmFyIE1hcmlvbmV0dGUgPSByZXF1aXJlKCdtYXJpb25ldHRlJyk7XG5cbi8vIGNvbnN0cnVjdG9yXG52YXIgQXBwID0gbmV3IE1hcmlvbmV0dGUuQXBwbGljYXRpb24oKTtcblxuQXBwLmFkZEluaXRpYWxpemVyKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gYXBwIGRlcGVuZGVuY2llcyBpbiBjb3JyZWN0IG9yZGVyXG5cbiAgICAvLyBjb21tb25zXG4gICAgcmVxdWlyZSgnZmFzdGNsaWNrJyk7XG5cbiAgICByZXF1aXJlKCcuL3JlZ2lvbnMvYXBwX3JlZ2lvbnMnKTtcblxuICAgIHJlcXVpcmUoJy4vZW50aXRpZXMvbWFuaWZlc3RfZW50aXR5Jyk7XG5cbiAgICByZXF1aXJlKCcuL3ZpZXdzL2FwcF92aWV3Jyk7XG4gICAgcmVxdWlyZSgnLi92aWV3cy9zaGFkZXJzX3ZpZXcnKTtcbiAgICByZXF1aXJlKCcuL3ZpZXdzL2NvbXBvc2VyX3ZpZXcnKTtcbiAgICByZXF1aXJlKCcuL3ZpZXdzL2VmZmVjdF92aWV3Jyk7XG4gICAgcmVxdWlyZSgnLi9jb250cm9sbGVycy9hcHBfY29udHJvbGxlcicpO1xufSk7XG5cbi8vIGV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBBcHA7IiwidmFyIEF1ZGlvQW5hbHlzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gICAgdmFyIG9mZmxpbmVDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gbnVsbDtcbiAgICB2YXIgaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdmFyIHNvdXJjZU5vZGUgPSBudWxsO1xuICAgIHZhciBhbmFseXNlciA9IG51bGw7XG4gICAgdmFyIHRoZUJ1ZmZlciA9IG51bGw7XG4gICAgdmFyIERFQlVHQ0FOVkFTID0gbnVsbDtcbiAgICB2YXIgbWVkaWFTdHJlYW1Tb3VyY2UgPSBudWxsO1xuICAgIHZhciBkZXRlY3RvckVsZW0sXG4gICAgICAgIGNhbnZhc0VsZW0sXG4gICAgICAgIHdhdmVDYW52YXMsXG4gICAgICAgIHBpdGNoRWxlbSxcbiAgICAgICAgbm90ZUVsZW0sXG4gICAgICAgIGRldHVuZUVsZW0sXG4gICAgICAgIGRldHVuZUFtb3VudDtcblxuICAgIGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICBvZmZsaW5lQ29udGV4dCA9IG5ldyB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAyLCA0NDEwMCk7XG5cbiAgICBmdW5jdGlvbiBfb25UcmFja0xvYWRlZCgpIHtcbiAgICAgICAgaWYgKGlzUGxheWluZykge1xuICAgICAgICAgICAgLy9zdG9wIHBsYXlpbmcgYW5kIHJldHVyblxuICAgICAgICAgICAgc291cmNlTm9kZS5zdG9wKDApO1xuICAgICAgICAgICAgc291cmNlTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBhbmFseXNlciA9IG51bGw7XG4gICAgICAgICAgICBpc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWZJRCk7XG4gICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlTm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgc291cmNlTm9kZS5idWZmZXIgPSB0aGVCdWZmZXI7XG4gICAgICAgIHNvdXJjZU5vZGUubG9vcCA9IHRydWU7XG5cbiAgICAgICAgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG4gICAgICAgIHNvdXJjZU5vZGUuY29ubmVjdChhbmFseXNlcik7XG4gICAgICAgIGFuYWx5c2VyLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgc291cmNlTm9kZS5zdGFydCgwKTtcbiAgICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgaXNMaXZlSW5wdXQgPSBmYWxzZTtcblxuICAgICAgICBfdXBkYXRlUGl0Y2goKTtcblxuICAgIH1cblxuXG4gICAgdmFyIHJhZklEID0gbnVsbDtcbiAgICB2YXIgdHJhY2tzID0gbnVsbDtcbiAgICB2YXIgYnVmbGVuID0gMTAyNDtcbiAgICB2YXIgYnVmID0gbmV3IEZsb2F0MzJBcnJheShidWZsZW4pO1xuXG4gICAgdmFyIG5vdGVTdHJpbmdzID0gW1wiQ1wiLCBcIkMjXCIsIFwiRFwiLCBcIkQjXCIsIFwiRVwiLCBcIkZcIiwgXCJGI1wiLCBcIkdcIiwgXCJHI1wiLCBcIkFcIiwgXCJBI1wiLCBcIkJcIl07XG5cbiAgICB2YXIgTUlOX1NBTVBMRVMgPSAwOyAvLyB3aWxsIGJlIGluaXRpYWxpemVkIHdoZW4gQXVkaW9Db250ZXh0IGlzIGNyZWF0ZWQuXG5cbiAgICBmdW5jdGlvbiBfYXV0b0NvcnJlbGF0ZShidWYsIHNhbXBsZVJhdGUpIHtcbiAgICAgICAgdmFyIFNJWkUgPSBidWYubGVuZ3RoO1xuICAgICAgICB2YXIgTUFYX1NBTVBMRVMgPSBNYXRoLmZsb29yKFNJWkUgLyAyKTtcbiAgICAgICAgdmFyIGJlc3Rfb2Zmc2V0ID0gLTE7XG4gICAgICAgIHZhciBiZXN0X2NvcnJlbGF0aW9uID0gMDtcbiAgICAgICAgdmFyIHJtcyA9IDA7XG4gICAgICAgIHZhciBmb3VuZEdvb2RDb3JyZWxhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgY29ycmVsYXRpb25zID0gbmV3IEFycmF5KE1BWF9TQU1QTEVTKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNJWkU7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGJ1ZltpXTtcbiAgICAgICAgICAgIHJtcyArPSB2YWwgKiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcm1zID0gTWF0aC5zcXJ0KHJtcyAvIFNJWkUpO1xuICAgICAgICBpZiAocm1zIDwgMC4wMSkgLy8gbm90IGVub3VnaCBzaWduYWxcbiAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICB2YXIgbGFzdENvcnJlbGF0aW9uID0gMTtcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gTUlOX1NBTVBMRVM7IG9mZnNldCA8IE1BWF9TQU1QTEVTOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgdmFyIGNvcnJlbGF0aW9uID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhfU0FNUExFUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb24gKz0gTWF0aC5hYnMoKGJ1ZltpXSkgLSAoYnVmW2kgKyBvZmZzZXRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3JyZWxhdGlvbiA9IDEgLSAoY29ycmVsYXRpb24gLyBNQVhfU0FNUExFUyk7XG4gICAgICAgICAgICBjb3JyZWxhdGlvbnNbb2Zmc2V0XSA9IGNvcnJlbGF0aW9uOyAvLyBzdG9yZSBpdCwgZm9yIHRoZSB0d2Vha2luZyB3ZSBuZWVkIHRvIGRvIGJlbG93LlxuICAgICAgICAgICAgaWYgKChjb3JyZWxhdGlvbiA+IDAuOSkgJiYgKGNvcnJlbGF0aW9uID4gbGFzdENvcnJlbGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kR29vZENvcnJlbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29ycmVsYXRpb24gPiBiZXN0X2NvcnJlbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RfY29ycmVsYXRpb24gPSBjb3JyZWxhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZEdvb2RDb3JyZWxhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNob3J0LWNpcmN1aXQgLSB3ZSBmb3VuZCBhIGdvb2QgY29ycmVsYXRpb24sIHRoZW4gYSBiYWQgb25lLCBzbyB3ZSdkIGp1c3QgYmUgc2VlaW5nIGNvcGllcyBmcm9tIGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gdHdlYWsgdGhlIG9mZnNldCAtIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGUgdmFsdWVzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBiZXN0IG9mZnNldCwgYW5kIHNoaWZ0aW5nIGl0IGEgYml0LiAgVGhpcyBpcyBjb21wbGV4LCBhbmQgSEFDS1kgaW4gdGhpcyBjb2RlIChoYXBweSB0byB0YWtlIFBScyEpIC1cbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRvIGEgY3VydmUgZml0IG9uIGNvcnJlbGF0aW9uc1tdIGFyb3VuZCBiZXN0X29mZnNldCBpbiBvcmRlciB0byBiZXR0ZXIgZGV0ZXJtaW5lIHByZWNpc2VcbiAgICAgICAgICAgICAgICAvLyAoYW50aS1hbGlhc2VkKSBvZmZzZXQuXG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IGJlc3Rfb2Zmc2V0ID49MSwgXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZm91bmRHb29kQ29ycmVsYXRpb24gY2Fubm90IGdvIHRvIHRydWUgdW50aWwgdGhlIHNlY29uZCBwYXNzIChvZmZzZXQ9MSksIGFuZCBcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBkcm9wIGludG8gdGhpcyBjbGF1c2UgdW50aWwgdGhlIGZvbGxvd2luZyBwYXNzIChlbHNlIGlmKS5cbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSAoY29ycmVsYXRpb25zW2Jlc3Rfb2Zmc2V0ICsgMV0gLSBjb3JyZWxhdGlvbnNbYmVzdF9vZmZzZXQgLSAxXSkgLyBjb3JyZWxhdGlvbnNbYmVzdF9vZmZzZXRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBzYW1wbGVSYXRlIC8gKGJlc3Rfb2Zmc2V0ICsgKDggKiBzaGlmdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENvcnJlbGF0aW9uID0gY29ycmVsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RfY29ycmVsYXRpb24gPiAwLjAxKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImYgPSBcIiArIHNhbXBsZVJhdGUvYmVzdF9vZmZzZXQgKyBcIkh6IChybXM6IFwiICsgcm1zICsgXCIgY29uZmlkZW5jZTogXCIgKyBiZXN0X2NvcnJlbGF0aW9uICsgXCIpXCIpXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlUmF0ZSAvIGJlc3Rfb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLy8gIHZhciBiZXN0X2ZyZXF1ZW5jeSA9IHNhbXBsZVJhdGUvYmVzdF9vZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25vdGVGcm9tUGl0Y2goZnJlcXVlbmN5KSB7XG4gICAgICAgIHZhciBub3RlTnVtID0gMTIgKiAoTWF0aC5sb2coZnJlcXVlbmN5IC8gNDQwKSAvIE1hdGgubG9nKDIpKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobm90ZU51bSkgKyA2OTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIF91cGRhdGVQaXRjaCh0aW1lKSB7XG4gICAgICAgIHZhciBjeWNsZXMgPSBuZXcgQXJyYXk7XG4gICAgICAgIGFuYWx5c2VyLmdldEZsb2F0VGltZURvbWFpbkRhdGEoYnVmKTtcbiAgICAgICAgdmFyIGFjID0gX2F1dG9Db3JyZWxhdGUoYnVmLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgICAgIGlmIChhYyA9PSAtMSkge30gZWxzZSB7XG4gICAgICAgICAgICBwaXRjaCA9IGFjO1xuICAgICAgICAgICAgdmFyIG5vdGUgPSBfbm90ZUZyb21QaXRjaChwaXRjaCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhub3RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhZklEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfdXBkYXRlUGl0Y2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHVybCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoZUJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBfb25UcmFja0xvYWRlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkVHJhY2s6IGFkZFRyYWNrXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1ZGlvQW5hbHlzZXI7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIFNIQURFUlMgPSByZXF1aXJlKCcuLi9jb21tb24vc2hhZGVycycpO1xudmFyIE9QVElPTlMgPSByZXF1aXJlKCcuLi9jb21tb24vc2hhZGVyX29wdGlvbnMnKTtcbnZhciBTRVRUSU5HUyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaGFkZXJfc2V0dGluZ3MnKTtcblxudmFyIEVmZmVjdHMgPSBmdW5jdGlvbihzY2VuZSwgY2FtZXJhLCByZW5kZXJlciwgZmJvKSB7XG5cblx0Ly92YXIgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHQvLyBjcmVhdGUgYSBjYW1lcmEsIHdoaWNoIGRlZmluZXMgd2hlcmUgd2UncmUgbG9va2luZyBhdC5cblx0Ly92YXIgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCAxMDAwKTtcblxuXHQvKnZhciB3ZWJHTFJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcblx0d2ViR0xSZW5kZXJlci5zZXRDbGVhckNvbG9yKG5ldyBUSFJFRS5Db2xvcigweGFhYWFmZiwgMS4wKSk7XG5cdHdlYkdMUmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblx0d2ViR0xSZW5kZXJlci5zaGFkb3dNYXBFbmFibGVkID0gdHJ1ZTtcblx0d2ViR0xSZW5kZXJlci5hbnRpYWxpYXMgPSBmYWxzZTsqL1xuXG5cdC8vZWwuYXBwZW5kQ2hpbGQod2ViR0xSZW5kZXJlci5kb21FbGVtZW50KTtcblx0dmFyIF9vdGhlckZibztcblxuXHR2YXIgZWZmZWN0cyA9IHtcblx0XHRiaXQ6IG5ldyBUSFJFRS5TaGFkZXJQYXNzKFNIQURFUlMuYml0KSxcblx0XHRwaXhlbGF0ZTogbmV3IFRIUkVFLlNoYWRlclBhc3MoU0hBREVSUy5waXhlbGF0ZSksXG5cdFx0YmxlYWNoOiBuZXcgVEhSRUUuU2hhZGVyUGFzcyhTSEFERVJTLmJsZWFjaCksXG5cdFx0YmxlbmQ6IG5ldyBUSFJFRS5TaGFkZXJQYXNzKFNIQURFUlMuYmxlbmQpLFxuXHRcdGNvbG9yOiBuZXcgVEhSRUUuU2hhZGVyUGFzcyhTSEFERVJTLmNvbG9yKSxcblx0XHRjb3B5OiBuZXcgVEhSRUUuU2hhZGVyUGFzcyhTSEFERVJTLmNvcHkpLFxuXHRcdGRvdDogbmV3IFRIUkVFLlNoYWRlclBhc3MoU0hBREVSUy5kb3QpLFxuXHRcdGVkZ2U6IG5ldyBUSFJFRS5TaGFkZXJQYXNzKFNIQURFUlMuZWRnZSksXG5cdFx0Z2xpdGNoOiBuZXcgVEhSRUUuU2hhZGVyUGFzcyhTSEFERVJTLmdsaXRjaCksXG5cdFx0a2FsZWlkbzogbmV3IFRIUkVFLlNoYWRlclBhc3MoU0hBREVSUy5rYWxlaWRvKSxcblx0XHR0d2lzdDogbmV3IFRIUkVFLlNoYWRlclBhc3MoU0hBREVSUy50d2lzdCksXG5cdFx0cmdiU2hpZnQ6IG5ldyBUSFJFRS5TaGFkZXJQYXNzKFNIQURFUlMucmdiU2hpZnQpXG5cdH07XG5cblxuXHRfLmZvckluKGVmZmVjdHMsIGZ1bmN0aW9uKGVmZmVjdCwga2V5KSB7XG5cdFx0aWYgKE9QVElPTlNba2V5XSkge1xuXHRcdFx0ZWZmZWN0WydlbmFibGVkJ10gPSBPUFRJT05TW2tleV1bJ2VuYWJsZWQnXTtcblx0XHR9XG5cdH0pO1xuXG5cdHZhciByZW5kZXJQYXNzID0gbmV3IFRIUkVFLlJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSk7XG5cdHZhciBlZmZlY3RDb3B5ID0gbmV3IFRIUkVFLlNoYWRlclBhc3MoU0hBREVSUy5jb3B5KTtcblx0ZWZmZWN0Q29weS5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG5cblx0Ly9lZmZlY3RzLmdsaXRjaFsndW5pZm9ybXMnXVsndERpc3AnXS52YWx1ZSA9IG5ldyBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCdhc3NldHMvaW1nL2hlcm8uanBnJyk7XG5cblx0dmFyIGNvbXBvc2VyID0gbmV3IFRIUkVFLkVmZmVjdENvbXBvc2VyKHJlbmRlcmVyLCBmYm8pO1xuXHRjb21wb3Nlci5hZGRQYXNzKHJlbmRlclBhc3MpO1xuXHQvL2NvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy5ibGVuZCk7XG5cdGNvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy5waXhlbGF0ZSk7XG5cdGNvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy5ibGVhY2gpO1xuXHRjb21wb3Nlci5hZGRQYXNzKGVmZmVjdHMuYml0KTtcblx0Y29tcG9zZXIuYWRkUGFzcyhlZmZlY3RzLmNvbG9yKTtcblx0Lypjb21wb3Nlci5hZGRQYXNzKGVmZmVjdHMuZG90KTtcblx0Y29tcG9zZXIuYWRkUGFzcyhlZmZlY3RzLmVkZ2UpO1xuXHQqL1xuXHRjb21wb3Nlci5hZGRQYXNzKGVmZmVjdHMua2FsZWlkbyk7XG5cdGNvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy50d2lzdCk7XG5cdGNvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy5yZ2JTaGlmdCk7XG5cdGNvbXBvc2VyLmFkZFBhc3MoZWZmZWN0cy5jb3B5KTtcblxuXHQvKmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG5cdFx0cmVuZGVyKCk7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcblx0fSovXG5cblx0ZnVuY3Rpb24gX3VwZGF0ZUVmZmVjdHMoKSB7XG5cdFx0Ly9lZmZlY3RzLmJsZW5kWyd1bmlmb3JtcyddWyd0RGlmZnVzZTEnXS52YWx1ZSA9IGZibztcblx0XHRpZiAoX290aGVyRmJvKSB7XG5cdFx0XHQvL2VmZmVjdHMuYmxlbmRbJ3VuaWZvcm1zJ11bJ3REaWZmdXNlMiddLnZhbHVlID0gX290aGVyRmJvO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRjb21wb3Nlci5yZW5kZXIoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE90aGVyRmJvKGYpIHtcblx0XHRfb3RoZXJGYm8gPSBmO1xuXG5cdFx0X3VwZGF0ZUVmZmVjdHMoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVVuaWZvcm1zKHVuaWZvcm1zKSB7XG5cdFx0dmFyIG9iaiA9IHVuaWZvcm1zWyd1bmlmb3JtcyddO1xuXHRcdHZhciBlZmZlY3QgPSBlZmZlY3RzW3VuaWZvcm1zWydzaGFkZXInXV07XG5cdFx0ZWZmZWN0LmVuYWJsZWQgPSBvYmpbJ2VuYWJsZWQnXTtcblx0XHRfLmZvckluKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRcdGlmIChfLmlzT2JqZWN0KHZhbCkpIHtcblx0XHRcdFx0aWYgKGVmZmVjdFsndW5pZm9ybXMnXVtrZXldKSB7XG5cdFx0XHRcdFx0ZWZmZWN0Wyd1bmlmb3JtcyddW2tleV0udmFsdWUgPSB2YWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR1cGRhdGVVbmlmb3JtczogdXBkYXRlVW5pZm9ybXMsXG5cdFx0c2V0T3RoZXJGYm86IHNldE90aGVyRmJvLFxuXHRcdHJlbmRlcjogcmVuZGVyXG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RzOyIsInZhciBTaW1wbGUxRE5vaXNlID0gKGZ1bmN0aW9uKG51bVBvaW50cykge1xyXG4gICAgdmFyIFBFUkxJTl9BTVAgPSAxO1xyXG4gICAgdmFyIFBFUkxJTl9TQ0FMRSA9IDE7XHJcbiAgICB2YXIgTUFYX1ZFUlRJQ0VTID0gbnVtUG9pbnRzIHx8IE5VTV9QT0lOVFM7XHJcbiAgICB2YXIgTUFYX1ZFUlRJQ0VTX01BU0sgPSBNQVhfVkVSVElDRVMgLSAxO1xyXG4gICAgdmFyIG1pcnJvciA9IDA7XHJcblxyXG4gICAgdmFyIGxlcnAgPSBmdW5jdGlvbihhLCBiLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjb3NMZXJwID0gZnVuY3Rpb24oYSwgYiwgeCkge1xyXG4gICAgICAgIHZhciBmdCA9IHggKiAzLjE0MTU5MjdcclxuICAgICAgICB2YXIgZiA9ICgxIC0gTWF0aC5jb3MoZnQpKSAqIC41XHJcbiAgICAgICAgcmV0dXJuIGEgKiAoMSAtIGYpICsgYiAqIGZcclxuICAgIH07XHJcbiAgICB2YXIgciA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNQVhfVkVSVElDRVM7ICsraSkge1xyXG4gICAgICAgIHIucHVzaChNYXRoLnJhbmRvbSgpKTtcclxuICAgIH1cclxuICAgIHZhciBsID0gci5sZW5ndGg7XHJcbiAgICAvKmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xyXG5cdFx0cltsLWldID0gcltpXTtcclxuXHR9Ki9cclxuICAgIHJbMF0gPSBjb3NMZXJwKHJbbCAtIDFdLCByWzFdLCAwLjUpO1xyXG5cclxuICAgIHZhciBnZXRWYWwgPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgdmFyIHNjYWxlZFggPSB4ICogUEVSTElOX1NDQUxFO1xyXG4gICAgICAgIHZhciB4Rmxvb3IgPSBNYXRoLmZsb29yKHNjYWxlZFgpO1xyXG4gICAgICAgIHZhciB0ID0gc2NhbGVkWCAtIHhGbG9vcjtcclxuICAgICAgICB2YXIgdFJlbWFwU21vb3Roc3RlcCA9IHQgKiB0ICogKDMgLSAyICogdCk7XHJcblxyXG4gICAgICAgIC8vLyBNb2R1bG8gdXNpbmcgJlxyXG4gICAgICAgIHZhciB4TWluID0geEZsb29yICUgTUFYX1ZFUlRJQ0VTX01BU0s7XHJcbiAgICAgICAgdmFyIHhNYXggPSAoeE1pbiArIDEpICUgTUFYX1ZFUlRJQ0VTX01BU0s7XHJcblxyXG4gICAgICAgIHZhciB5ID0gY29zTGVycChyW3hNaW5dLCByW3hNYXhdLCB0UmVtYXBTbW9vdGhzdGVwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHkgKiBQRVJMSU5fQU1QO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZXR1cm4gdGhlIEFQSVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRWYWw6IGdldFZhbCxcclxuICAgICAgICBzZXRBbXBsaXR1ZGU6IGZ1bmN0aW9uKG5ld0FtcGxpdHVkZSkge1xyXG4gICAgICAgICAgICBhbXBsaXR1ZGUgPSBuZXdBbXBsaXR1ZGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRTY2FsZTogZnVuY3Rpb24obmV3U2NhbGUpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBuZXdTY2FsZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgxMDApO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGUxRE5vaXNlOyIsIi8qdmFyIFBsYXllckNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJy4vcGxheWVyX21hbmFnZXInKSk7XG5QbGF5ZXJDb250cm9sbGVyLmluaXQgPSBmdW5jdGlvbigpe1xuXG59O1xuKi9cbnZhciBQbGF5ZXJDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0aWYgKCFNZWRpYVNvdXJjZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTk8gTUVESUFTT1VSQ0UhJyk7XG5cdH1cblxuXHR2YXIgcmVxdWVzdElkO1xuXG5cdC8vYm9vbGVhbnNcblx0dmFyIHVwZGF0ZWRTdGFydGVkLCBsb2NrZWQsIHN0YXJ0aW5nID0gdHJ1ZTtcblxuXHQvL3BsYXliYWNrIGluZm9cblx0dmFyIHNlZ0R1cmF0aW9uID0gMCxcblx0XHRwbGF5T2Zmc2V0ID0gMCxcblx0XHRlbnRlckZyYW1lQ291bnRlciA9IDAsXG5cdFx0cHJldmlvdXNDdXJyZW50VGltZSA9IDAsXG5cdFx0c2VnbWVudEluZGV4ID0gMCxcblx0XHR0b3RhbFNlZ21lbnRzID0gMCxcblx0XHRza2lwQ291bnQgPSAwLFxuXG5cdFx0Y2hhcHRlckluZGV4ID0gMCxcblx0XHRjdXJyZW50Q2hhcHRlciA9IDA7XG5cblx0Ly9jYWxsYmFja1xuXHR2YXIgb25OZXdWbywgbmVlZE1vcmVTZWdtZW50cztcblx0Ly8vLy0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vU0VUVVBcblx0Ly8vLy0tLS0tLS0tLS0tLS0tLS0tXG5cblx0dmFyIHZpZGVvRWxlbWVudDtcblx0dmFyIG1lZGlhU291cmNlO1xuXHR2YXIgc291cmNlQnVmZmVyO1xuXG5cdC8vcmVmIHRvIHByb3RvXG5cdHZhciBfbWFuaWZlc3Q7XG5cdHZhciBwbGF5bGlzdDtcblx0dmFyIGJvdW5kVXBkYXRlO1xuXG5cdGZ1bmN0aW9uIGluaXQodkVsKSB7XG5cblx0XHR2aWRlb0VsZW1lbnQgPSB2RWw7XG5cblx0XHRtZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuXHRcdHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG1lZGlhU291cmNlKTtcblx0XHR2aWRlb0VsZW1lbnQuc3JjID0gdXJsO1xuXG5cdFx0bWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF9vblNvdXJjZU9wZW4sIGZhbHNlKTtcblx0XHRib3VuZFVwZGF0ZSA9IG9uVXBkYXRlLmJpbmQodGhpcyk7XG5cdFx0cmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShib3VuZFVwZGF0ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBfb25Tb3VyY2VPcGVuKGUpIHtcblx0XHRtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgX29uU291cmNlT3Blbik7XG5cdFx0c291cmNlQnVmZmVyID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJjMDFlXCInKTtcblx0XHRzb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlc3RhcnQnLCBvbkJ1ZmZlclVwZGF0ZVN0YXJ0KTtcblx0XHRzb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgb25CdWZmZXJVcGRhdGVFbmQpO1xuXHRcdHN0YXJ0aW5nID0gZmFsc2U7XG5cdFx0Y29uc29sZS5sb2coXCJzb3VyY2Ugb3BlblwiKTtcblx0fVxuXG5cdC8vLy8tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL0JVRkZFUiBIQU5ETEVSU1xuXHQvLy8vLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGZ1bmN0aW9uIG9uQnVmZmVyVXBkYXRlU3RhcnQoKSB7XG5cdFx0dXBkYXRlZFN0YXJ0ZWQgPSB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gb25CdWZmZXJVcGRhdGVFbmQoKSB7XG5cdFx0Lypzb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgb25CdWZmZXJVcGRhdGVFbmQpO1xuXHRcdHZhciBjdXJyZW50Vm8gPSBwbGF5bGlzdFtzZWdtZW50SW5kZXggLSAxXTtcblx0XHRpZiAoY3VycmVudFZvKSB7XG5cdFx0XHRzZWdEdXJhdGlvbiA9IGN1cnJlbnRWb1snZHVyYXRpb25TZWMnXTtcblx0XHRcdHZhciBkdXIgPSBwbGF5T2Zmc2V0O1xuXHRcdFx0aWYgKGR1ciA9PT0gMCkge1xuXHRcdFx0XHRkdXIgPSBjdXJyZW50Vm9bJ2R1cmF0aW9uU2VjJ107XG5cdFx0XHR9XG5cdFx0XHRtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGR1cjtcblx0XHR9XG5cdFx0c291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIG9uQnVmZmVyVXBkYXRlRW5kKTsqL1xuXHRcdHVwZGF0ZWRTdGFydGVkID0gZmFsc2U7XG5cdFx0bG9ja2VkID0gZmFsc2U7XG5cdH1cdFxuXG5cdC8vLy8tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1VQREFURVxuXHQvLy8vLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRmdW5jdGlvbiBvblVwZGF0ZSgpIHtcblx0XHRpZiAodG90YWxTZWdtZW50cyA+IDApIHtcblx0XHRcdGlmIChzZWdtZW50SW5kZXggPCB0b3RhbFNlZ21lbnRzKSB7XG5cdFx0XHRcdGlmICghdXBkYXRlZFN0YXJ0ZWQgfHwgIWxvY2tlZCkge1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2codmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lICwocGxheU9mZnNldCAtIHNlZ0R1cmF0aW9uICogLjgpLCBzZWdEdXJhdGlvbik7XG5cdFx0XHRcdFx0aWYgKHZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA+PSAocGxheU9mZnNldCAtIHNlZ0R1cmF0aW9uICogLjgpKSB7XG5cdFx0XHRcdFx0XHRsb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBjdXJyZW50Q2hhcHRlcltzZWdtZW50SW5kZXhdO1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNsaXAgPSBkYXRhWydjbGlwJ107XG5cdFx0XHRcdFx0XHRcdHBsYXlPZmZzZXQgKz0gY2xpcFsnZHVyYXRpb24nXTtcblx0XHRcdFx0XHRcdFx0c2VnRHVyYXRpb24gPSBjbGlwWydkdXJhdGlvbiddO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oc2VnRHVyYXRpb24pXG5cdFx0XHRcdFx0XHRcdHBsYXlTZWdtZW50KGNsaXApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ05vIG1vcmUgYXQnLCBzZWdtZW50SW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIk5vIE1vcmUgdmlkZW9zXCIpO1xuXHRcdFx0XHRfb25DaGFwdGVyQ29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwcmV2aW91c0N1cnJlbnRUaW1lID0gdmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lO1xuXHRcdHJlcXVlc3RJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYm91bmRVcGRhdGUpO1xuXHR9XG5cblx0Ly8tLS0tLS0tLS0tXG5cdC8vUExBWSBBIFZPXG5cdC8vLS0tLS0tLS0tLVxuXG5cdGZ1bmN0aW9uIHBsYXlTZWdtZW50KGRhdGEpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHVybCA9ICdhc3NldHMvdmlkZW9zLycrZGF0YVsncmVsUGF0aCddO1xuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3BlbignR0VUJywgdXJsKTtcblx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBkYXRhWydtZWRpYVJhbmdlJ10pO1xuXHRcdHhoci5zZW5kKCk7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdFx0eGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09IHhoci5ET05FKSB7IC8vd2FpdCBmb3IgdmlkZW8gdG8gbG9hZFxuXHRcdFx0XHRpZiAoIXNvdXJjZUJ1ZmZlciB8fCAhbWVkaWFTb3VyY2UgfHwgc3RhcnRpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHNlZ1Jlc3AgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuXHRcdFx0XHR2YXIgb2ZmO1xuXHRcdFx0XHRpZiAoc291cmNlQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRvZmYgPSBzb3VyY2VCdWZmZXIuYnVmZmVyZWQuZW5kKHNvdXJjZUJ1ZmZlci5idWZmZXJlZC5sZW5ndGggLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZyhtZWRpYVNvdXJjZS5yZWFkeVN0YXRlKTtcblx0XHRcdFx0c291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IG9mZiB8fCAwO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIF9fYWRkSW5pdChpbml0UmVzKSB7XG5cdFx0XHRcdFx0c291cmNlQnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIG9uQnVmZmVyVXBkYXRlRW5kKTtcblx0XHRcdFx0XHRzb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgX19vbkluaXRBZGRlZCk7XG5cdFx0XHRcdFx0c291cmNlQnVmZmVyLmFwcGVuZEJ1ZmZlcihpbml0UmVzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIF9fb25Jbml0QWRkZWQoKSB7XG5cdFx0XHRcdFx0aWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuXHRcdFx0XHRcdFx0c291cmNlQnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIF9fb25Jbml0QWRkZWQpO1xuXHRcdFx0XHRcdFx0c291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIG9uQnVmZmVyVXBkYXRlRW5kKTtcblx0XHRcdFx0XHRcdC8vdmFyIHRzID0gc291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldCAtIGRhdGFbJ3N0YXJ0VGltZVNlYyddO1xuXHRcdFx0XHRcdFx0Ly9zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdHM7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhzZWdtZW50SW5kZXgsICcvJywgdG90YWxTZWdtZW50cyk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhtZWRpYVNvdXJjZS5yZWFkeVN0YXRlKTtcblx0XHRcdFx0XHRcdHNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIoc2VnUmVzcCk7XG5cdFx0XHRcdFx0XHRzZWdtZW50SW5kZXgrKztcblxuXHRcdFx0XHRcdFx0LyppZiAob25OZXdWbykge1xuXHRcdFx0XHRcdFx0XHRvbk5ld1ZvKGRhdGEpO1xuXHRcdFx0XHRcdFx0fSovXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGluaXRpYWxSZXF1ZXN0KGRhdGEsIF9fYWRkSW5pdCk7XG5cdFx0XHR9XG5cdFx0fSwgZmFsc2UpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpbml0aWFsUmVxdWVzdChkYXRhLCBjYWxsYmFjaykge1xuXHRcdHZhciB1cmwgPSAnYXNzZXRzL3ZpZGVvcy8nK2RhdGFbJ3JlbFBhdGgnXTtcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0dmFyIHJhbmdlID0gXCJieXRlcz0wLVwiICsgKGRhdGFbJ2ZpcnN0T2Zmc2V0J10gLSAxKTtcblx0XHR4aHIub3BlbignR0VUJywgdXJsKTtcblx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIHJhbmdlKTtcblx0XHR4aHIuc2VuZCgpO1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRcdHRyeSB7XG5cdFx0XHR4aHIuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PSB4aHIuRE9ORSkgeyAvLyB3YWl0IGZvciB2aWRlbyB0byBsb2FkXG5cdFx0XHRcdFx0d2hpbGUodXBkYXRlZFN0YXJ0ZWQpe31cblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGxvZyhlKTtcblx0XHR9XG5cdH1cblxuXHQvL2NyYXNoXG5cdGZ1bmN0aW9uIHJlc2V0TWVkaWFzb3VyY2UoKSB7XG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZCk7XG5cdFx0c291cmNlQnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIG9uQnVmZmVyVXBkYXRlRW5kKTtcblx0XHRzb3VyY2VCdWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlc3RhcnQnLCBvbkJ1ZmZlclVwZGF0ZVN0YXJ0KTtcblx0XHRtZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc291cmNlQnVmZmVyKTtcblx0XHRzb3VyY2VCdWZmZXIgPSBudWxsO1xuXHRcdG1lZGlhU291cmNlLmR1cmF0aW9uID0gMDtcblx0XHRlbnRlckZyYW1lQ291bnRlciA9IDA7XG5cdFx0bWVkaWFTb3VyY2UgPSBudWxsO1xuXHRcdGxvY2tlZCA9IHVwZGF0ZWRTdGFydGVkID0gZmFsc2U7XG5cdFx0dmlkZW9FbGVtZW50LnBsYXkoKTtcblx0XHR2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSAwO1xuXHRcdHNlZ0R1cmF0aW9uID0gcGxheU9mZnNldCA9IDA7XG5cdFx0Ly9pbml0KCk7XG5cdFx0Lypzb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgX19vbkR1cmF0aW9uU2V0KTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbWVkaWFTb3VyY2UuZHVyYXRpb247XG5cbiAgICAgICAgZnVuY3Rpb24gX19vbkR1cmF0aW9uU2V0KGUpIHtcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBfX29uRHVyYXRpb25TZXQpO1xuICAgICAgICAgICAgc291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIG9uQnVmZmVyVXBkYXRlRW5kKTtcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQgPSAwO1xuICAgICAgICAgICAgc291cmNlQnVmZmVyLnJlbW92ZSgwLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgc2VnRHVyYXRpb24gPSBwbGF5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiWkVST0VEXCIpO1xuICAgICAgICB9Ki9cblxuXHR9XG5cblx0ZnVuY3Rpb24gX29uQ2hhcHRlckNvbXBsZXRlKCl7XG5cdFx0Y2hhcHRlckluZGV4Kys7XG5cdFx0aWYoY2hhcHRlckluZGV4ID4gX21hbmlmZXN0Lmxlbmd0aCAtMSl7XG5cdFx0XHRjaGFwdGVySW5kZXggPSAwO1xuXHRcdH1cblx0XHRzZWdtZW50SW5kZXggPSAwO1xuXHRcdGN1cnJlbnRDaGFwdGVyID0gX21hbmlmZXN0W2NoYXB0ZXJJbmRleF07XG5cdFx0dG90YWxTZWdtZW50cyA9IGN1cnJlbnRDaGFwdGVyLmxlbmd0aDtcblx0fVxuXHQvLy8tLS0tLS0tLS0tLS0tLS1cblx0Ly9BUElcblx0Ly8vLS0tLS0tLS0tLS0tLS0tXG5cblx0ZnVuY3Rpb24gc2V0T25OZXdWbyhjYWxsYmFjaykge1xuXHRcdG9uTmV3Vm8gPSBjYWxsYmFjaztcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEVudGlyZU1hbmlmZXN0KG1hbmlmZXN0KXtcblx0XHRfbWFuaWZlc3QgPSBtYW5pZmVzdDtcblx0XHRjdXJyZW50Q2hhcHRlciA9IF9tYW5pZmVzdFtjaGFwdGVySW5kZXhdO1xuXHRcdHRvdGFsU2VnbWVudHMgPSBjdXJyZW50Q2hhcHRlci5sZW5ndGg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGluaXQ6IGluaXQsXG5cdFx0c2V0T25OZXdWbzogc2V0T25OZXdWbyxcblx0XHRzZXRFbnRpcmVNYW5pZmVzdDogc2V0RW50aXJlTWFuaWZlc3Rcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXJDb250cm9sbGVyOyIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5FZmZlY3RDb21wb3NlciA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHJlbmRlclRhcmdldCApIHtcblxuXHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cblx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHZhciBwaXhlbFJhdGlvID0gMTtcblxuXHRcdHZhciB3aWR0aCAgPSBNYXRoLmZsb29yKCByZW5kZXJlci5jb250ZXh0LmNhbnZhcy53aWR0aCAgLyBwaXhlbFJhdGlvICkgfHwgMTtcblx0XHR2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vciggcmVuZGVyZXIuY29udGV4dC5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpbyApIHx8IDE7XG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB7IG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIHN0ZW5jaWxCdWZmZXI6IGZhbHNlIH07XG5cblx0XHRyZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuXHR0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuXHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cblx0dGhpcy5wYXNzZXMgPSBbXTtcblxuXHRpZiAoIFRIUkVFLkNvcHlTaGFkZXIgPT09IHVuZGVmaW5lZCApXG5cdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5FZmZlY3RDb21wb3NlciByZWxpZXMgb24gVEhSRUUuQ29weVNoYWRlclwiICk7XG5cblx0dGhpcy5jb3B5UGFzcyA9IG5ldyBUSFJFRS5TaGFkZXJQYXNzKCBUSFJFRS5Db3B5U2hhZGVyICk7XG5cbn07XG5cblRIUkVFLkVmZmVjdENvbXBvc2VyLnByb3RvdHlwZSA9IHtcblxuXHRzd2FwQnVmZmVyczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG1wID0gdGhpcy5yZWFkQnVmZmVyO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXI7XG5cdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRtcDtcblxuXHR9LFxuXG5cdGFkZFBhc3M6IGZ1bmN0aW9uICggcGFzcyApIHtcblxuXHRcdHRoaXMucGFzc2VzLnB1c2goIHBhc3MgKTtcblxuXHR9LFxuXG5cdGluc2VydFBhc3M6IGZ1bmN0aW9uICggcGFzcywgaW5kZXggKSB7XG5cblx0XHR0aGlzLnBhc3Nlcy5zcGxpY2UoIGluZGV4LCAwLCBwYXNzICk7XG5cblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0XHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuXHRcdHZhciBtYXNrQWN0aXZlID0gZmFsc2U7XG5cblx0XHR2YXIgcGFzcywgaSwgaWwgPSB0aGlzLnBhc3Nlcy5sZW5ndGg7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwYXNzID0gdGhpcy5wYXNzZXNbIGkgXTtcblxuXHRcdFx0aWYgKCAhcGFzcy5lbmFibGVkICkgY29udGludWU7XG5cblx0XHRcdHBhc3MucmVuZGVyKCB0aGlzLnJlbmRlcmVyLCB0aGlzLndyaXRlQnVmZmVyLCB0aGlzLnJlYWRCdWZmZXIsIGRlbHRhLCBtYXNrQWN0aXZlICk7XG5cblx0XHRcdGlmICggcGFzcy5uZWVkc1N3YXAgKSB7XG5cblx0XHRcdFx0aWYgKCBtYXNrQWN0aXZlICkge1xuXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG5cblx0XHRcdFx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0Lk5PVEVRVUFMLCAxLCAweGZmZmZmZmZmICk7XG5cblx0XHRcdFx0XHR0aGlzLmNvcHlQYXNzLnJlbmRlciggdGhpcy5yZW5kZXJlciwgdGhpcy53cml0ZUJ1ZmZlciwgdGhpcy5yZWFkQnVmZmVyLCBkZWx0YSApO1xuXG5cdFx0XHRcdFx0Y29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnN3YXBCdWZmZXJzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXNzIGluc3RhbmNlb2YgVEhSRUUuTWFza1Bhc3MgKSB7XG5cblx0XHRcdFx0bWFza0FjdGl2ZSA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgaW5zdGFuY2VvZiBUSFJFRS5DbGVhck1hc2tQYXNzICkge1xuXG5cdFx0XHRcdG1hc2tBY3RpdmUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQxLmNsb25lKCk7XG5cblx0XHRcdHZhciBwaXhlbFJhdGlvID0gdGhpcy5yZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG5cblx0XHRcdHJlbmRlclRhcmdldC53aWR0aCAgPSBNYXRoLmZsb29yKCB0aGlzLnJlbmRlcmVyLmNvbnRleHQuY2FudmFzLndpZHRoICAvIHBpeGVsUmF0aW8gKTtcblx0XHRcdHJlbmRlclRhcmdldC5oZWlnaHQgPSBNYXRoLmZsb29yKCB0aGlzLnJlbmRlcmVyLmNvbnRleHQuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW8gKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0MSA9IHJlbmRlclRhcmdldDtcblx0XHR0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuXHRcdHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDE7XG5cdFx0dGhpcy5yZWFkQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQyO1xuXG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0MS5jbG9uZSgpO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LndpZHRoID0gd2lkdGg7XG5cdFx0cmVuZGVyVGFyZ2V0LmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMucmVzZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdH1cblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5NYXNrUGFzcyA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuXHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG5cdHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5NYXNrUGFzcy5wcm90b3R5cGUgPSB7XG5cblx0cmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cblx0XHR2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cblx0XHQvLyBkb24ndCB1cGRhdGUgY29sb3Igb3IgZGVwdGhcblxuXHRcdGNvbnRleHQuY29sb3JNYXNrKCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSApO1xuXHRcdGNvbnRleHQuZGVwdGhNYXNrKCBmYWxzZSApO1xuXG5cdFx0Ly8gc2V0IHVwIHN0ZW5jaWxcblxuXHRcdHZhciB3cml0ZVZhbHVlLCBjbGVhclZhbHVlO1xuXG5cdFx0aWYgKCB0aGlzLmludmVyc2UgKSB7XG5cblx0XHRcdHdyaXRlVmFsdWUgPSAwO1xuXHRcdFx0Y2xlYXJWYWx1ZSA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR3cml0ZVZhbHVlID0gMTtcblx0XHRcdGNsZWFyVmFsdWUgPSAwO1xuXG5cdFx0fVxuXG5cdFx0Y29udGV4dC5lbmFibGUoIGNvbnRleHQuU1RFTkNJTF9URVNUICk7XG5cdFx0Y29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UgKTtcblx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0LkFMV0FZUywgd3JpdGVWYWx1ZSwgMHhmZmZmZmZmZiApO1xuXHRcdGNvbnRleHQuY2xlYXJTdGVuY2lsKCBjbGVhclZhbHVlICk7XG5cblx0XHQvLyBkcmF3IGludG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgd3JpdGVCdWZmZXIsIHRoaXMuY2xlYXIgKTtcblxuXHRcdC8vIHJlLWVuYWJsZSB1cGRhdGUgb2YgY29sb3IgYW5kIGRlcHRoXG5cblx0XHRjb250ZXh0LmNvbG9yTWFzayggdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSApO1xuXHRcdGNvbnRleHQuZGVwdGhNYXNrKCB0cnVlICk7XG5cblx0XHQvLyBvbmx5IHJlbmRlciB3aGVyZSBzdGVuY2lsIGlzIHNldCB0byAxXG5cblx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0LkVRVUFMLCAxLCAweGZmZmZmZmZmICk7ICAvLyBkcmF3IGlmID09IDFcblx0XHRjb250ZXh0LnN0ZW5jaWxPcCggY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCApO1xuXG5cdH1cblxufTtcblxuXG5USFJFRS5DbGVhck1hc2tQYXNzID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbn07XG5cblRIUkVFLkNsZWFyTWFza1Bhc3MucHJvdG90eXBlID0ge1xuXG5cdHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuXG5cdFx0dmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdFx0Y29udGV4dC5kaXNhYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuXG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUSFJFRS5NYXNrUGFzczsiLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUmVuZGVyUGFzcyA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCwgY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApIHtcblxuXHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0dGhpcy5jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcblx0dGhpcy5jbGVhckFscGhhID0gKCBjbGVhckFscGhhICE9PSB1bmRlZmluZWQgKSA/IGNsZWFyQWxwaGEgOiAxO1xuXG5cdHRoaXMub2xkQ2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXHR0aGlzLm9sZENsZWFyQWxwaGEgPSAxO1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5SZW5kZXJQYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdGlmICggdGhpcy5jbGVhckNvbG9yICkge1xuXG5cdFx0XHR0aGlzLm9sZENsZWFyQ29sb3IuY29weSggcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpICk7XG5cdFx0XHR0aGlzLm9sZENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHRoaXMuY2xlYXJDb2xvciwgdGhpcy5jbGVhckFscGhhICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJDb2xvciApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5vbGRDbGVhckNvbG9yLCB0aGlzLm9sZENsZWFyQWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRIUkVFLlJlbmRlclBhc3M7IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNoYWRlclBhc3MgPSBmdW5jdGlvbiAoIHNoYWRlciwgdGV4dHVyZUlEICkge1xuXG5cdHRoaXMudGV4dHVyZUlEID0gKCB0ZXh0dXJlSUQgIT09IHVuZGVmaW5lZCApID8gdGV4dHVyZUlEIDogXCJ0RGlmZnVzZVwiO1xuXG5cdHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKTtcblxuXHR0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cbiAgICAgICAgXHRkZWZpbmVzOiBzaGFkZXIuZGVmaW5lcyB8fCB7fSxcblx0XHR1bmlmb3JtczogdGhpcy51bmlmb3Jtcyxcblx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXG5cdH0gKTtcblxuXHR0aGlzLnJlbmRlclRvU2NyZWVuID0gZmFsc2U7XG5cblx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuXHR0aGlzLmNsZWFyID0gZmFsc2U7XG5cblxuXHR0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIC0xLCAxLCAxLCAtMSwgMCwgMSApO1xuXHR0aGlzLnNjZW5lICA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG5cdHRoaXMucXVhZCA9IG5ldyBUSFJFRS5NZXNoKCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggMiwgMiApLCBudWxsICk7XG5cdHRoaXMuc2NlbmUuYWRkKCB0aGlzLnF1YWQgKTtcblxufTtcblxuVEhSRUUuU2hhZGVyUGFzcy5wcm90b3R5cGUgPSB7XG5cblx0cmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cblx0XHRpZiAoIHRoaXMudW5pZm9ybXNbIHRoaXMudGV4dHVyZUlEIF0gKSB7XG5cblx0XHRcdHRoaXMudW5pZm9ybXNbIHRoaXMudGV4dHVyZUlEIF0udmFsdWUgPSByZWFkQnVmZmVyO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdGlmICggdGhpcy5yZW5kZXJUb1NjcmVlbiApIHtcblxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgd3JpdGVCdWZmZXIsIHRoaXMuY2xlYXIgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVEhSRUUuU2hhZGVyUGFzczsiLCIndXNlIHN0cmljdCc7XG52YXIgVVRJTFMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgRUZGRUNUUyA9IHJlcXVpcmUoJy4vZWZmZWN0c19zY2VuZScpXG5cbnZhciBTY2VuZSA9IGZ1bmN0aW9uKHJlbmRlcmVyLCBjbGVhckNvbG9yLCBjYW1lcmFaKSB7XG5cdHZhciBmYm87XG5cblx0dmFyIF9zY2VuZSwgX2NhbWVyYSwgX2NsZWFyQ29sb3IsIF9tZXNoO1xuXG5cdF9jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcblxuXHRfY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMTAwMDApO1xuXHQvL19jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKHdpbmRvdy5pbm5lcldpZHRoIC8gLTIsIHdpbmRvdy5pbm5lcldpZHRoIC8gMiwgd2luZG93LmlubmVySGVpZ2h0IC8gMiwgd2luZG93LmlubmVySGVpZ2h0IC8gLTIsIDEsIDEwMDApO1xuXHRfY2FtZXJhLnBvc2l0aW9uLnogPSBjYW1lcmFaO1xuXHQvLyBTZXR1cCBzY2VuZVxuXHRfc2NlbmUgPSB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cdF9zY2VuZS5hZGQobmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDU1NTU1NSkpO1xuXG5cdHZhciByZW5kZXJUYXJnZXRQYXJhbWV0ZXJzID0ge1xuXHRcdG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuXHRcdG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuXHRcdGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LFxuXHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlXG5cdH07XG5cblx0ZmJvID0gdGhpcy5mYm8gPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCwgcmVuZGVyVGFyZ2V0UGFyYW1ldGVycyk7XG5cdGZiby5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdGZiby5tYWdGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0dmFyIGZ4ID0gbmV3IEVGRkVDVFMoX3NjZW5lLCBfY2FtZXJhLCByZW5kZXJlciwgZmJvKTtcblxuXHRmdW5jdGlvbiByZW5kZXIocnR0KSB7XG5cdFx0Ly9yZW5kZXJlci5zZXRDbGVhckNvbG9yKF9jbGVhckNvbG9yKTtcblx0XHRmeC5yZW5kZXIoKTtcblx0XHQvKmlmIChydHQpIHtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihfc2NlbmUsIF9jYW1lcmEsIGZibywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihfc2NlbmUsIF9jYW1lcmEpO1xuXHRcdH0qL1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlUGxhbmUodywgaCwgbWF0ZXJpYWwpIHtcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgxMjgwLCA3MjAsIDQsIDQpO1xuXHRcdGdlb21ldHJ5LmNlbnRlcigpO1xuXHRcdF9tZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHQvL19tZXNoLnBvc2l0aW9uLnogPSAtMjAwO1xuXHRcdC8vX21lc2gucG9zaXRpb24ueiA9IC00MDA7XG5cdFx0Ly9fbWVzaC5wb3NpdGlvbi54ID0gO1xuXHRcdF9zY2VuZS5hZGQoX21lc2gpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzaXplKHcsIGgsIHNjYWxlKSB7XG5cdFx0X2NhbWVyYS5hc3BlY3QgPSB3IC8gaDtcblx0XHRfbWVzaC5zY2FsZS54ID0gX21lc2guc2NhbGUueSA9IHNjYWxlO1xuXHRcdF9jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXHRcdC8vZmJvLnNldFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVVbmlmb3Jtcyh1bmlmb3Jtcyl7XG5cdFx0ZngudXBkYXRlVW5pZm9ybXModW5pZm9ybXMpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRyZXNpemU6IHJlc2l6ZSxcblx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRmeDogZngsXG5cdFx0ZmJvOiBmYm8sXG5cdFx0dXBkYXRlVW5pZm9ybXM6IHVwZGF0ZVVuaWZvcm1zLFxuXHRcdGNyZWF0ZVBsYW5lOiBjcmVhdGVQbGFuZVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lOyIsInZhciBTSEFERVJTID0gcmVxdWlyZSgnLi9zaGFkZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gU0hBREVSU1tcIm1peFwiXTtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZShzaGFkZXIudW5pZm9ybXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhZGVyOiBzaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybXNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2hyb21hOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IFNIQURFUlNbXCJjaHJvbWFcIl07XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoc2hhZGVyLnVuaWZvcm1zKTtcblxuICAgICAgICB1bmlmb3Jtc1tcImVuYWJsZUNocm9tYVwiXS52YWx1ZSA9IHRydWU7XG4gICAgICAgIHVuaWZvcm1zW1wiZW5hYmxlQ29sb3JcIl0udmFsdWUgPSB0cnVlO1xuICAgICAgICB1bmlmb3Jtc1tcImVuYWJsZVJlZmxlY3Rpb25cIl0udmFsdWUgPSB0cnVlO1xuICAgICAgICB1bmlmb3Jtc1tcImVuYWJsZURpc3BsYWNlbWVudFwiXS52YWx1ZSA9IHRydWU7XG4gICAgICAgIHVuaWZvcm1zW1wiZW5hYmxlUmlwcGxlc1wiXS52YWx1ZSA9IHRydWU7XG5cbiAgICAgICAgdW5pZm9ybXNbXCJ1RGlzcGxhY2VtZW50Qmlhc1wiXS52YWx1ZSA9IDEuMDtcbiAgICAgICAgdW5pZm9ybXNbXCJ1RGlzcGxhY2VtZW50U2NhbGVcIl0udmFsdWUgPSAyMDtcblxuICAgICAgICB1bmlmb3Jtc1tcInVBbWJpZW50Q29sb3JcIl0udmFsdWUuY29udmVydEdhbW1hVG9MaW5lYXIoKTtcbiAgICAgICAgdW5pZm9ybXNbXCJ1RGlmZnVzZUNvbG9yXCJdLnZhbHVlLmNvbnZlcnRHYW1tYVRvTGluZWFyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFkZXI6IHNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmcmFjdGFsMTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSBTSEFERVJTW1wiZnJhY3RhbDFcIl07XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoc2hhZGVyLnVuaWZvcm1zKTtcblxuICAgICAgICB1bmlmb3Jtc1tcInVBbWJpZW50Q29sb3JcIl0udmFsdWUuY29udmVydEdhbW1hVG9MaW5lYXIoKTtcbiAgICAgICAgdW5pZm9ybXNbXCJ1RGlmZnVzZUNvbG9yXCJdLnZhbHVlLmNvbnZlcnRHYW1tYVRvTGluZWFyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaGFkZXI6IHNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IFNIQURFUlNbXCJjYXZlXCJdO1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKHNoYWRlci51bmlmb3Jtcyk7XG5cbiAgICAgICAgdW5pZm9ybXNbXCJ1QW1iaWVudENvbG9yXCJdLnZhbHVlLmNvbnZlcnRHYW1tYVRvTGluZWFyKCk7XG4gICAgICAgIHVuaWZvcm1zW1widURpZmZ1c2VDb2xvclwiXS52YWx1ZS5jb252ZXJ0R2FtbWFUb0xpbmVhcigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhZGVyOiBzaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybXNcbiAgICAgICAgfVxuICAgIH1cbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdGJsZWFjaDoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdG9wYWNpdHk6IHtcblx0XHRcdG9wYWNpdHk6IDAuMDUsXG5cdFx0XHRtaW46IC00LFxuXHRcdFx0bWF4OiA0XG5cdFx0fVxuXHR9LFxuXHRibGVuZDoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdG1peFJhdGlvOiAwLjAxLFxuXHRcdG9wYWNpdHk6IDAuMDFcblx0fSxcblx0YnJpZ2h0bmVzczoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdGJyaWdodG5lc3M6IDAuMDEsXG5cdFx0Y29udHJhc3Q6IDAuMDFcblx0fSxcblx0Y29weToge1xuXHRcdGVuYWJsZWQ6IHRydWUsXG5cdH0sXG5cdHBpeGVsYXRlOiB7XG5cdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0eEFtb3VudDoge1xuXHRcdFx0eEFtb3VudDogMC4wMSxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMVxuXHRcdH0sXG5cdFx0eUFtb3VudDoge1xuXHRcdFx0eUFtb3VudDogMC4wMSxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMVxuXHRcdH1cblx0fSxcblx0Y29sb3I6IHtcblx0XHRlbmFibGVkOiBmYWxzZSxcblx0XHR1U2F0dXJhdGlvbjoge1xuXHRcdFx0dVNhdHVyYXRpb246IDEuMDEsXG5cdFx0XHRtaW46IDEsXG5cdFx0XHRtYXg6IDEwXG5cdFx0fSxcblx0XHR1Q29udHJhc3Q6IHtcblx0XHRcdHVDb250cmFzdDogMS4wMSxcblx0XHRcdG1pbjogLTYsXG5cdFx0XHRtYXg6IDZcblx0XHR9LFxuXHRcdHVEZXNhdHVyYXRlOiB7XG5cdFx0XHR1RGVzYXR1cmF0ZTogMCxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogNFxuXHRcdH0sXG5cdFx0dUJyaWdodG5lc3M6IHtcblx0XHRcdHVCcmlnaHRuZXNzOiAwLjA1LFxuXHRcdFx0bWluOiAtMSxcblx0XHRcdG1heDogMS4zXG5cdFx0fSxcblx0XHR1SHVlOiB7XG5cdFx0XHR1SHVlOiAwLjA1LFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiA0XG5cdFx0fVxuXHR9LFxuXHRnbGl0Y2g6IHtcblx0XHRlbmFibGVkOiBmYWxzZSxcblx0XHRcImFtb3VudFwiOiB7XG5cdFx0XHRhbW91bnQ6IDAuMDUsXG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IDRcblx0XHR9LFxuXHRcdFwiYW5nbGVcIjoge1xuXHRcdFx0YW5nbGU6IDAuMDUsXG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IE1hdGguUEkgKiAyXG5cdFx0fSxcblx0XHRcInNlZWRcIjoge1xuXHRcdFx0c2VlZDogMC4wNSxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogNFxuXHRcdH0sXG5cdFx0XCJzZWVkX3hcIjoge1xuXHRcdFx0c2VlZF94OiAwLjA1LFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiA0XG5cdFx0fSxcblx0XHRcInNlZWRfeVwiOiB7XG5cdFx0XHRzZWVkX3k6IDAuMDUsXG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IDRcblx0XHR9LFxuXHRcdFwiZGlzdG9ydGlvbl94XCI6IHtcblx0XHRcdGRpc3RvcnRpb25feDogMC4wNSxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogNFxuXHRcdH0sXG5cdFx0XCJkaXN0b3J0aW9uX3lcIjoge1xuXHRcdFx0ZGlzdG9ydGlvbl95OiAwLjA1LFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiA0XG5cdFx0fSxcblx0XHRcImNvbF9zXCI6IHtcblx0XHRcdGNvbF9zOiAwLjA1LFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiA0XG5cdFx0fVxuXHR9LFxuXHRkb3Q6IHtcblx0XHRlbmFibGVkOiBmYWxzZSxcblx0XHRcImFuZ2xlXCI6IHtcblx0XHRcdGFuZ2xlOiAwLjAxLFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiBNYXRoLlBJICogMlxuXHRcdH0sXG5cdFx0XCJzY2FsZVwiOiB7XG5cdFx0XHRzY2FsZTogMC4wMSxcblx0XHRcdG1pbjogMCxcblx0XHRcdG1heDogMTBcblx0XHR9XG5cdH0sXG5cdGJpdDoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFwiYml0U2l6ZVwiOiB7XG5cdFx0XHRiaXRTaXplOiAyLjAsXG5cdFx0XHRtaW46IDEuMyxcblx0XHRcdG1heDogOFxuXHRcdH1cblx0fSxcblx0a2FsZWlkbzoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFwic2lkZXNcIjoge1xuXHRcdFx0c2lkZXM6IDAuMDEsXG5cdFx0XHRtaW46IDAuMDEsXG5cdFx0XHRtYXg6IDMyXG5cdFx0fSxcblx0XHRcImFuZ2xlXCI6IHtcblx0XHRcdGFuZ2xlOiAwLjAxLFxuXHRcdFx0bWluOiAwLFxuXHRcdFx0bWF4OiBNYXRoLlBJICogMlxuXHRcdH1cblx0fSxcblx0dHdpc3Q6IHtcblx0XHRlbmFibGVkOiBmYWxzZSxcblx0XHRcInJhZGl1c1wiOiB7XG5cdFx0XHRyYWRpdXM6IDAuMTQxLFxuXHRcdFx0bWluOiAwLjA2NSxcblx0XHRcdG1heDogMC40MlxuXHRcdH0sXG5cdFx0XCJhbmdsZVwiOiB7XG5cdFx0XHRhbmdsZTogMC4wMSxcblx0XHRcdG1pbjogLU1hdGguUEkgKiAuNSxcblx0XHRcdG1heDogTWF0aC5QSSAqIC41XG5cdFx0fVxuXHR9LFxuXHRyZ2JTaGlmdDoge1xuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXHRcdFwidVJlZFwiOiB7XG5cdFx0XHR1UmVkOiAxLFxuXHRcdFx0bWluOiAxLFxuXHRcdFx0bWF4OiAzMlxuXHRcdH0sXG5cdFx0XCJ1R3JlZW5cIjoge1xuXHRcdFx0dUdyZWVuOiAxLFxuXHRcdFx0bWluOiAxLFxuXHRcdFx0bWF4OiAzMlxuXHRcdH0sXG5cdFx0XCJ1QnVlXCI6IHtcblx0XHRcdHVCdWU6IDEsXG5cdFx0XHRtaW46IDEsXG5cdFx0XHRtYXg6IDMyXG5cdFx0fVxuXHR9XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRibGVhY2g6IHtcblx0XHRtaW46IDAsXG5cdFx0bWF4OiAxXG5cdH0sXG5cdGJva2FoOiB7XG5cdFx0XCJ0aHJlc2hvbGRcIjogMC41MSxcblx0XHRcImdhaW5cIjogMi4wMSxcblx0XHRcImJpYXNcIjogMC41MSxcblx0XHRcImZyaW5nZVwiOiAwLjcxLFxuXHR9LFxuXHRnbGl0Y2g6IHtcblx0XHRcImFtb3VudFwiOiAwLjA4LFxuXHRcdFwiYW5nbGVcIjogMC4wMixcblx0XHRcInNlZWRcIjogMC4wMixcblx0XHRcInNlZWRfeFwiOiAwLjAyLFxuXHRcdFwic2VlZF95XCI6IDAuMDIsXG5cdFx0XCJkaXN0b3J0aW9uX3hcIjogMC41MSxcblx0XHRcImRpc3RvcnRpb25feVwiOiAwLjYxLFxuXHRcdFwiY29sX3NcIjogMC4wNVxuXHR9LFxuXHRkb3Q6IHtcblx0XHRcImFuZ2xlXCI6IDEuNTcsXG5cdFx0XCJzY2FsZVwiOiAxLjAxXG5cdH0sXG5cdGthbGVpZG86IHtcblx0XHRcInNpZGVzXCI6IDAuMDEsXG5cdFx0XCJhbmdsZVwiOiAwLjAxLFxuXHR9XG59OyIsIlxuVEhSRUUuQ29weVNoYWRlciA9IHJlcXVpcmUoJy4vc2hhZGVycy9Db3B5U2hhZGVyJyk7XG5USFJFRS5NYXNrUGFzcyA9IHJlcXVpcmUoJy4vcG9zdC9NYXNrUGFzcycpO1xuVEhSRUUuUmVuZGVyUGFzcyA9IHJlcXVpcmUoJy4vcG9zdC9SZW5kZXJQYXNzJyk7XG5USFJFRS5TaGFkZXJQYXNzID0gcmVxdWlyZSgnLi9wb3N0L1NoYWRlclBhc3MnKTtcbnJlcXVpcmUoJy4vcG9zdC9FZmZlY3RDb21wb3NlcicpO1xuLyp2YXIgc291cmNlID0gZ2xzbGlmeSh7XG4gICAgdmVydGV4OiAnLi4vLi4vLi4vZ2xzbC9kaXNwbGFjZW1lbnQudmVydCcsXG4gICAgZnJhZ21lbnQ6ICcuLi8uLi8uLi9nbHNsL21lZ2EuZnJhZycsXG4gICAgc291cmNlT25seTogdHJ1ZVxufSk7Ki9cblxuLyp2YXIgY3JlYXRlU2hhZGVyID0gcmVxdWlyZSgndGhyZWUtZ2xzbGlmeScpKFRIUkVFKVxudmFyIG15U2hhZGVyID0gY3JlYXRlU2hhZGVyKHNvdXJjZSk7XG5jb25zb2xlLmxvZyhteVNoYWRlcik7Ki9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ21peCcgOiB7XG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgXCJ1TWl4UmF0aW9cIiAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxuICAgICAgICAgICAgXCJ1VGhyZXNob2xkXCIgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjUgfSxcbiAgICAgICAgICAgIFwidVNhdHVyYXRpb25cIiAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuIH0sXG5cbiAgICAgICAgICAgIFwidE9uZVwiICAgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICBcInRUd29cIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgXCJ0TWl4XCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBdICksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOlwiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVRocmVzaG9sZDtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVNaXhSYXRpbztcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVTYXR1cmF0aW9uO1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRPbmU7XFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdFR3bztcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0TWl4O1xcblxcbiAgICAgICAgICAgIHZlYzMgY2hhbmdlU2F0dXJhdGlvbih2ZWMzIGNvbG9yLCBmbG9hdCBzYXR1cmF0aW9uKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGx1bWEgPSBkb3QodmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKSAqIGNvbG9yLCB2ZWMzKDEuKSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBtaXgodmVjMyhsdW1hKSwgY29sb3IsIHNhdHVyYXRpb24pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgdGV4T25lID0gdGV4dHVyZTJEKHRPbmUsIHZVdik7XFxuICAgICAgICAgICAgICAgIHZlYzQgdGV4VHdvID0gdGV4dHVyZTJEKHRUd28sIHZVdik7XFxuICAgICAgICAgICAgICAgIHZlYzQgdGV4TWl4ID0gdGV4dHVyZTJEKHRNaXgsIHZVdik7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzMgdGV4dFR3b0NvbCA9IHRleFR3by5yZ2I7XFxuICAgICAgICAgICAgICAgIHRleHRUd29Db2wgPSBjaGFuZ2VTYXR1cmF0aW9uKHRleHRUd29Db2wsIHVTYXR1cmF0aW9uKTtcXG5cXG4gICAgICAgICAgICAgICAgdmVjNCB0cmFuc2l0aW9uVGV4ZWwgPSB0ZXh0dXJlMkQodE1peCwgdlV2KTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgciA9IHVNaXhSYXRpbyAqICgxLjAgKyB1VGhyZXNob2xkICogMi4wKSAtIHVUaHJlc2hvbGQ7XFxuICAgICAgICAgICAgICAgIGZsb2F0IG1peGYgPSBjbGFtcCgodHJhbnNpdGlvblRleGVsLmcgLSByKSAqICgxLjAgLyB1VGhyZXNob2xkKSwgMC4wLCAxLjApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGNvbCA9IG1peCh0ZXhPbmUsIHZlYzQodGV4dFR3b0NvbCwgMS4wKSwgbWl4Zik7XFxuICAgICAgICAgICAgICAgIGNvbCAqPSAwLjAxICsgMi41ICogcG93KHZVdi54ICogdlV2LnkgKiAoMS4wIC0gdlV2LngpICogKDEuMCAtIHZVdi55KSwgMC4zKTtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sO1xcbiAgICAgICAgICAgICAgICAvLyBnbF9GcmFnQ29sb3IgPSB0ZXhPbmU7XFxuICAgICAgICAgICAgfVwiLFxuICAgICAgICAgICAgdmVydGV4U2hhZGVyOlwiI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdlV2ID0gdmVjMih1di54LCB1di55KTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXG59XCJcbiAgICB9LFxuICAgICdjb2xvcicgOiB7XG4gICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICBcInREaWZmdXNlXCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgXCJ1U2F0dXJhdGlvblwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgXCJ1Q29udHJhc3RcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidURlc2F0dXJhdGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidUJyaWdodG5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidUh1ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF0gKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6XCIjZGVmaW5lIEdMU0xJRlkgMVxcblxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0ICoqIEh1ZSwgc2F0dXJhdGlvbiwgbHVtaW5hbmNlXFxuXFx0XFx0XFx0ICovXFxuXFxuXFx0XFx0XFx0dmVjMyB0b0h1ZSh2ZWMzIHJnYiwgZmxvYXQgYWRqdXN0bWVudCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBtYXQzIHRvWUlRID0gbWF0MygwLjI5OSwgMC41ODcsIDAuMTE0LFxcbiAgICAgICAgICAgICAgICAgICAgMC41OTU3MTYsIC0wLjI3NDQ1MywgLTAuMzIxMjYzLFxcbiAgICAgICAgICAgICAgICAgICAgMC4yMTE0NTYsIC0wLjUyMjU5MSwgMC4zMTExMzUpO1xcbiAgICAgICAgICAgICAgICBjb25zdCBtYXQzIHRvUkdCID0gbWF0MygxLjAsIDAuOTU2MywgMC42MjEwLFxcbiAgICAgICAgICAgICAgICAgICAgMS4wLCAtMC4yNzIxLCAtMC42NDc0LFxcbiAgICAgICAgICAgICAgICAgICAgMS4wLCAtMS4xMDcsIDEuNzA0Nik7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzMgeWlxID0gdG9ZSVEgKiByZ2I7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGh1ZSA9IGF0YW4oeWlxLnosIHlpcS55KSArIGFkanVzdG1lbnQ7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNocm9tYSA9IHNxcnQoeWlxLnogKiB5aXEueiArIHlpcS55ICogeWlxLnkpO1xcblxcbiAgICAgICAgICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMyh5aXEueCwgY2hyb21hICogY29zKGh1ZSksIGNocm9tYSAqIHNpbihodWUpKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUkdCICogY29sb3I7XFxuICAgICAgICAgICAgfVxcblxcblxcdFxcdFxcdHZlYzMgUkdCVG9IU0wodmVjMyBjb2xvcikge1xcblxcdFxcdFxcdFxcdHZlYzMgaHNsOyAvLyBpbml0IHRvIDAgdG8gYXZvaWQgd2FybmluZ3MgPyAoYW5kIHJldmVyc2UgaWYgKyByZW1vdmUgZmlyc3QgcGFydClcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBmbWluID0gbWluKG1pbihjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7IC8vTWluLiB2YWx1ZSBvZiBSR0JcXG5cXHRcXHRcXHRcXHRmbG9hdCBmbWF4ID0gbWF4KG1heChjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7IC8vTWF4LiB2YWx1ZSBvZiBSR0JcXG5cXHRcXHRcXHRcXHRmbG9hdCBkZWx0YSA9IGZtYXggLSBmbWluOyAvL0RlbHRhIFJHQiB2YWx1ZVxcblxcblxcdFxcdFxcdFxcdGhzbC56ID0gKGZtYXggKyBmbWluKSAvIDIuMDsgLy8gTHVtaW5hbmNlXFxuXFxuXFx0XFx0XFx0XFx0aWYgKGRlbHRhID09IDAuMCkgLy9UaGlzIGlzIGEgZ3JheSwgbm8gY2hyb21hLi4uXFxuXFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdGhzbC54ID0gMC4wOyAvLyBIdWVcXG5cXHRcXHRcXHRcXHRcXHRoc2wueSA9IDAuMDsgLy8gU2F0dXJhdGlvblxcblxcdFxcdFxcdFxcdH0gZWxzZSAvL0Nocm9tYXRpYyBkYXRhLi4uXFxuXFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdGlmIChoc2wueiA8IDAuNSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRoc2wueSA9IGRlbHRhIC8gKGZtYXggKyBmbWluKTsgLy8gU2F0dXJhdGlvblxcblxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRoc2wueSA9IGRlbHRhIC8gKDIuMCAtIGZtYXggLSBmbWluKTsgLy8gU2F0dXJhdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IGRlbHRhUiA9ICgoKGZtYXggLSBjb2xvci5yKSAvIDYuMCkgKyAoZGVsdGEgLyAyLjApKSAvIGRlbHRhO1xcblxcdFxcdFxcdFxcdFxcdGZsb2F0IGRlbHRhRyA9ICgoKGZtYXggLSBjb2xvci5nKSAvIDYuMCkgKyAoZGVsdGEgLyAyLjApKSAvIGRlbHRhO1xcblxcdFxcdFxcdFxcdFxcdGZsb2F0IGRlbHRhQiA9ICgoKGZtYXggLSBjb2xvci5iKSAvIDYuMCkgKyAoZGVsdGEgLyAyLjApKSAvIGRlbHRhO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChjb2xvci5yID09IGZtYXgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aHNsLnggPSBkZWx0YUIgLSBkZWx0YUc7IC8vIEh1ZVxcblxcdFxcdFxcdFxcdFxcdGVsc2UgaWYgKGNvbG9yLmcgPT0gZm1heClcXG5cXHRcXHRcXHRcXHRcXHRcXHRoc2wueCA9ICgxLjAgLyAzLjApICsgZGVsdGFSIC0gZGVsdGFCOyAvLyBIdWVcXG5cXHRcXHRcXHRcXHRcXHRlbHNlIGlmIChjb2xvci5iID09IGZtYXgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aHNsLnggPSAoMi4wIC8gMy4wKSArIGRlbHRhRyAtIGRlbHRhUjsgLy8gSHVlXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGhzbC54IDwgMC4wKVxcblxcdFxcdFxcdFxcdFxcdFxcdGhzbC54ICs9IDEuMDsgLy8gSHVlXFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAoaHNsLnggPiAxLjApXFxuXFx0XFx0XFx0XFx0XFx0XFx0aHNsLnggLT0gMS4wOyAvLyBIdWVcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGhzbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmVjMyByZ2IyaHN2KHZlYzMgcmdiKSB7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgQ21heCA9IG1heChyZ2IuciwgbWF4KHJnYi5nLCByZ2IuYikpO1xcblxcdFxcdFxcdFxcdGZsb2F0IENtaW4gPSBtaW4ocmdiLnIsIG1pbihyZ2IuZywgcmdiLmIpKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkZWx0YSA9IENtYXggLSBDbWluO1xcblxcblxcdFxcdFxcdFxcdHZlYzMgaHN2ID0gdmVjMygwLiwgMC4sIENtYXgpO1xcblxcblxcdFxcdFxcdFxcdGlmIChDbWF4ID4gQ21pbikge1xcblxcdFxcdFxcdFxcdFxcdGhzdi55ID0gZGVsdGEgLyBDbWF4O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChyZ2IuciA9PSBDbWF4KVxcblxcdFxcdFxcdFxcdFxcdFxcdGhzdi54ID0gKHJnYi5nIC0gcmdiLmIpIC8gZGVsdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHJnYi5nID09IENtYXgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aHN2LnggPSAyLiArIChyZ2IuYiAtIHJnYi5yKSAvIGRlbHRhO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoc3YueCA9IDQuICsgKHJnYi5yIC0gcmdiLmcpIC8gZGVsdGE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGhzdi54ID0gZnJhY3QoaHN2LnggLyA2Lik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBoc3Y7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZsb2F0IGNocm9tYVZhbCh2ZWMzIGNvbG9yLCB2ZWMzIGtleUNvbG9yLCBmbG9hdCB0b2xlcmFuY2UsIGZsb2F0IHNsb3BlKSB7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZCA9IGFicyhsZW5ndGgoYWJzKGtleUNvbG9yIC0gY29sb3IpKSk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZWRnZTAgPSB0b2xlcmFuY2UgKiAoMS4wIC0gc2xvcGUpO1xcblxcdFxcdFxcdFxcdGZsb2F0IGFscGhhID0gc21vb3Roc3RlcChlZGdlMCwgdG9sZXJhbmNlLCBkKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMS4gLSBhbHBoYTtcXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFxuXFx0XFx0XFx0dmVjMyBjaGFuZ2VTYXR1cmF0aW9uKHZlYzMgY29sb3IsIGZsb2F0IHNhdHVyYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRmbG9hdCBsdW1hID0gZG90KHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSkgKiBjb2xvciwgdmVjMygxLikpO1xcblxcdFxcdFxcdFxcdHJldHVybiBtaXgodmVjMyhsdW1hKSwgY29sb3IsIHNhdHVyYXRpb24pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2ZWMzIERlc2F0dXJhdGUodmVjMyBjb2xvciwgZmxvYXQgRGVzYXR1cmF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0dmVjMyBncmF5WGZlciA9IHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIGdyYXkgPSB2ZWMzKGRvdChncmF5WGZlciwgY29sb3IpKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmVjMyhtaXgoY29sb3IsIGdyYXksIERlc2F0dXJhdGlvbikpO1xcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHQgLy8gZGVmaW5lIG91ciB2YXJ5aW5nIHRleHR1cmUgY29vcmRpbmF0ZXNcXG5cXHRcXHRcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcblxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcblxcblxcdFxcdFxcdCAvL2NvbG9yXFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IHVEZXNhdHVyYXRlO1xcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgdUJyaWdodG5lc3M7XFxuXFx0XFx0XFx0dW5pZm9ybSBmbG9hdCB1SHVlO1xcblxcblxcdFxcdFxcdHZvaWQgbWFpbih2b2lkKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KS5yZ2I7XFxuXFx0XFx0XFx0XFx0Y29sb3IgPSBjaGFuZ2VTYXR1cmF0aW9uKGNvbG9yLCB1U2F0dXJhdGlvbik7XFxuXFx0XFx0XFx0XFx0Y29sb3IgPSBEZXNhdHVyYXRlKGNvbG9yLCB1RGVzYXR1cmF0ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Y29sb3IgPSAoY29sb3IgLSAwLjUpICogKHVDb250cmFzdCArIDEuMCkgKyAwLjU7XFxuXFx0XFx0XFx0XFx0Y29sb3IgPSBjb2xvciArIHVCcmlnaHRuZXNzO1xcblxcblxcdFxcdFxcdFxcdGNvbG9yID0gdG9IdWUoY29sb3IsIHVIdWUpO1xcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuKTtcXG5cXG5cXHRcXHRcXHR9XCIsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6XCIjZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICB2VXYgPSB2ZWMyKHV2LngsIHV2LnkpO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcbn1cIlxuICAgICAgICB9LFxuICAgICdjaHJvbWEnIDoge1xuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgXCJlbmFibGVDaHJvbWFcIiAgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwiZW5hYmxlRGlzcGxhY2VtZW50XCIgICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgICBcImVuYWJsZVJlZmxlY3Rpb25cIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwiZW5hYmxlUmlwcGxlc1wiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgXCJlbmFibGVDb2xvclwiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXG4gICAgICAgICAgICBcInRPbmVcIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgXCJ0VHdvXCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgIFwidERpc3BsYWNlbWVudFwiICAgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cbiAgICAgICAgICAgIFwidU5vcm1hbFNjYWxlXCI6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxuXG4gICAgICAgICAgICBcInVEaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgICAgIFwidURpc3BsYWNlbWVudFNjYWxlXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblxuICAgICAgICAgICAgXCJ1RGlmZnVzZUNvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcbiAgICAgICAgICAgIFwidVNwZWN1bGFyQ29sb3JcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuICAgICAgICAgICAgXCJ1QW1iaWVudENvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcbiAgICAgICAgICAgIFwidVNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcbiAgICAgICAgICAgIFwidU9wYWNpdHlcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuICAgICAgICAgICAgLy9jb2xvclxuICAgICAgICAgICAgXCJ1U2F0dXJhdGlvblwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgXCJ1Q29udHJhc3RcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidURlc2F0dXJhdGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidUJyaWdodG5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIFwidUh1ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9LFxuXG4gICAgICAgICAgICBcInVUaW1lXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBcInVXaWR0aFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgXCJ1SGVpZ2h0XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICBcInVSZXNcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuICAgICAgICAgICAgXCJ1c2VSZWZyYWN0XCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgICBcInVSZWZyYWN0aW9uUmF0aW9cIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfSxcbiAgICAgICAgICAgIFwidVJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cbiAgICAgICAgICAgIFwidU9mZnNldFwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApIH0sXG4gICAgICAgICAgICBcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxuXG4gICAgICAgICAgICBcIndyYXBSR0JcIiAgOiB7IHR5cGU6IFwidjNcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICkgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF0gKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6XCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgICAgICAgIHZlYzMgdG9IdWUodmVjMyByZ2IsIGZsb2F0IGFkanVzdG1lbnQpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0MyB0b1lJUSA9IG1hdDMoMC4yOTksIDAuNTg3LCAwLjExNCxcXG4gICAgICAgICAgICAgICAgICAgIDAuNTk1NzE2LCAtMC4yNzQ0NTMsIC0wLjMyMTI2MyxcXG4gICAgICAgICAgICAgICAgICAgIDAuMjExNDU2LCAtMC41MjI1OTEsIDAuMzExMTM1KTtcXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0MyB0b1JHQiA9IG1hdDMoMS4wLCAwLjk1NjMsIDAuNjIxMCxcXG4gICAgICAgICAgICAgICAgICAgIDEuMCwgLTAuMjcyMSwgLTAuNjQ3NCxcXG4gICAgICAgICAgICAgICAgICAgIDEuMCwgLTEuMTA3LCAxLjcwNDYpO1xcblxcbiAgICAgICAgICAgICAgICB2ZWMzIHlpcSA9IHRvWUlRICogcmdiO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBodWUgPSBhdGFuKHlpcS56LCB5aXEueSkgKyBhZGp1c3RtZW50O1xcbiAgICAgICAgICAgICAgICBmbG9hdCBjaHJvbWEgPSBzcXJ0KHlpcS56ICogeWlxLnogKyB5aXEueSAqIHlpcS55KTtcXG5cXG4gICAgICAgICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoeWlxLngsIGNocm9tYSAqIGNvcyhodWUpLCBjaHJvbWEgKiBzaW4oaHVlKSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0b1JHQiAqIGNvbG9yO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2ZWMzIFJHQlRvSFNMKHZlYzMgY29sb3IpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyBoc2w7IC8vIGluaXQgdG8gMCB0byBhdm9pZCB3YXJuaW5ncyA/IChhbmQgcmV2ZXJzZSBpZiArIHJlbW92ZSBmaXJzdCBwYXJ0KVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCBmbWluID0gbWluKG1pbihjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7IC8vTWluLiB2YWx1ZSBvZiBSR0JcXG4gICAgICAgICAgICAgICAgZmxvYXQgZm1heCA9IG1heChtYXgoY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpOyAvL01heC4gdmFsdWUgb2YgUkdCXFxuICAgICAgICAgICAgICAgIGZsb2F0IGRlbHRhID0gZm1heCAtIGZtaW47IC8vRGVsdGEgUkdCIHZhbHVlXFxuXFxuICAgICAgICAgICAgICAgIGhzbC56ID0gKGZtYXggKyBmbWluKSAvIDIuMDsgLy8gTHVtaW5hbmNlXFxuXFxuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA9PSAwLjApIC8vVGhpcyBpcyBhIGdyYXksIG5vIGNocm9tYS4uLlxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBoc2wueCA9IDAuMDsgLy8gSHVlXFxuICAgICAgICAgICAgICAgICAgICBoc2wueSA9IDAuMDsgLy8gU2F0dXJhdGlvblxcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy9DaHJvbWF0aWMgZGF0YS4uLlxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaHNsLnogPCAwLjUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHNsLnkgPSBkZWx0YSAvIChmbWF4ICsgZm1pbik7IC8vIFNhdHVyYXRpb25cXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICBoc2wueSA9IGRlbHRhIC8gKDIuMCAtIGZtYXggLSBmbWluKTsgLy8gU2F0dXJhdGlvblxcblxcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGVsdGFSID0gKCgoZm1heCAtIGNvbG9yLnIpIC8gNi4wKSArIChkZWx0YSAvIDIuMCkpIC8gZGVsdGE7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkZWx0YUcgPSAoKChmbWF4IC0gY29sb3IuZykgLyA2LjApICsgKGRlbHRhIC8gMi4wKSkgLyBkZWx0YTtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGRlbHRhQiA9ICgoKGZtYXggLSBjb2xvci5iKSAvIDYuMCkgKyAoZGVsdGEgLyAyLjApKSAvIGRlbHRhO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yLnIgPT0gZm1heClcXG4gICAgICAgICAgICAgICAgICAgICAgICBoc2wueCA9IGRlbHRhQiAtIGRlbHRhRzsgLy8gSHVlXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2xvci5nID09IGZtYXgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHNsLnggPSAoMS4wIC8gMy4wKSArIGRlbHRhUiAtIGRlbHRhQjsgLy8gSHVlXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2xvci5iID09IGZtYXgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHNsLnggPSAoMi4wIC8gMy4wKSArIGRlbHRhRyAtIGRlbHRhUjsgLy8gSHVlXFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaHNsLnggPCAwLjApXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHNsLnggKz0gMS4wOyAvLyBIdWVcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhzbC54ID4gMS4wKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhzbC54IC09IDEuMDsgLy8gSHVlXFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhzbDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmVjMyByZ2IyaHN2KHZlYzMgcmdiKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IENtYXggPSBtYXgocmdiLnIsIG1heChyZ2IuZywgcmdiLmIpKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgQ21pbiA9IG1pbihyZ2IuciwgbWluKHJnYi5nLCByZ2IuYikpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkZWx0YSA9IENtYXggLSBDbWluO1xcblxcbiAgICAgICAgICAgICAgICB2ZWMzIGhzdiA9IHZlYzMoMC4sIDAuLCBDbWF4KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKENtYXggPiBDbWluKSB7XFxuICAgICAgICAgICAgICAgICAgICBoc3YueSA9IGRlbHRhIC8gQ21heDtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZ2IuciA9PSBDbWF4KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhzdi54ID0gKHJnYi5nIC0gcmdiLmIpIC8gZGVsdGE7XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmdiLmcgPT0gQ21heClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHN2LnggPSAyLiArIChyZ2IuYiAtIHJnYi5yKSAvIGRlbHRhO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHN2LnggPSA0LiArIChyZ2IuciAtIHJnYi5nKSAvIGRlbHRhO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgaHN2LnggPSBmcmFjdChoc3YueCAvIDYuKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gaHN2O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBjaHJvbWFWYWwodmVjMyBjb2xvciwgdmVjMyBrZXlDb2xvciwgZmxvYXQgdG9sZXJhbmNlLCBmbG9hdCBzbG9wZSkge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkID0gYWJzKGxlbmd0aChhYnMoa2V5Q29sb3IgLSBjb2xvcikpKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZWRnZTAgPSB0b2xlcmFuY2UgKiAoMS4wIC0gc2xvcGUpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoZWRnZTAsIHRvbGVyYW5jZSwgZCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiAxLiAtIGFscGhhO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBhdmVyYWdlKHZlYzQgY29sKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoY29sLnIgKyBjb2wuZyArIGNvbC5iKSAvIDMuMDtcXG4gICAgICAgICAgICB9XFxuXFxuXFxuXFxuICAgICAgICAgICAgdmVjMyBjaGFuZ2VTYXR1cmF0aW9uKHZlYzMgY29sb3IsIGZsb2F0IHNhdHVyYXRpb24pIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgbHVtYSA9IGRvdCh2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpICogY29sb3IsIHZlYzMoMS4pKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peCh2ZWMzKGx1bWEpLCBjb2xvciwgc2F0dXJhdGlvbik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZlYzMgRGVzYXR1cmF0ZSh2ZWMzIGNvbG9yLCBmbG9hdCBEZXNhdHVyYXRpb24pIHtcXG4gICAgICAgICAgICAgICAgdmVjMyBncmF5WGZlciA9IHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG4gICAgICAgICAgICAgICAgdmVjMyBncmF5ID0gdmVjMyhkb3QoZ3JheVhmZXIsIGNvbG9yKSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2ZWMzKG1peChjb2xvciwgZ3JheSwgRGVzYXR1cmF0aW9uKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1QW1iaWVudENvbG9yO1xcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1RGlmZnVzZUNvbG9yO1xcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1U3BlY3VsYXJDb2xvcjtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVTaGluaW5lc3M7XFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIGJvb2wgZW5hYmxlQ2hyb21hO1xcbiAgICAgICAgICAgIHVuaWZvcm0gYm9vbCBlbmFibGVSZWZsZWN0aW9uO1xcbiAgICAgICAgICAgIHVuaWZvcm0gYm9vbCBlbmFibGVEaXNwbGFjZW1lbnQ7XFxuICAgICAgICAgICAgdW5pZm9ybSBib29sIGVuYWJsZUNvbG9yO1xcbiAgICAgICAgICAgIHVuaWZvcm0gYm9vbCBlbmFibGVSaXBwbGVzO1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRPbmU7XFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdFR3bztcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0Tm9ybWFsO1xcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRTcGVjdWxhcjtcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0QU87XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVJlZnJhY3Rpb25SYXRpbztcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVSZWZsZWN0aXZpdHk7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVXaWR0aDtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVIZWlnaHQ7XFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmVzO1xcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuICAgICAgICAgICAgIC8vY29sb3JcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVTYXR1cmF0aW9uO1xcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdUNvbnRyYXN0O1xcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURlc2F0dXJhdGU7XFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVIdWU7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXG5cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuXFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMygxLjApLCB1T3BhY2l0eSk7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzIgdXYyID0gdlV2O1xcblxcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlUmlwcGxlcykge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSwgMC41KTtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHggPSAoY2VudGVyLnggLSB1djIueCk7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB5ID0gKGNlbnRlci55IC0gdXYyLnkpO1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgciA9IC0oeCAqIHggKyB5ICogeSk7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB6ID0gMS4wICsgMC4wMSAqIHNpbigociArIHVUaW1lICogMC4wMikgLyAwLjEzKTtcXG4gICAgICAgICAgICAgICAgICAgIHV2Mi54ICo9IHo7XFxuICAgICAgICAgICAgICAgICAgICB1djIueSAqPSB6O1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCh0T25lLCB1djIpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGJnQ29sb3IgPSB0ZXh0dXJlMkQodFR3bywgdXYyKTtcXG4gICAgICAgICAgICAgICAgdGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVSZWZsZWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgICAgICB1djIueCArPSBzdGVwKHV2Mi54LCAwLjUpICogKDAuNSAtIHV2Mi54KSAqIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIHV2Mi55ICs9IHN0ZXAoMC41LCB1djIueSkgKiAoMC41IC0gdXYyLnkpICogMi4wO1xcbiAgICAgICAgICAgICAgICAgICAgLy91djIueCAtPSBzdGVwKDAuNSwgdXYyLngpICogKHV2Mi54LTAuNSkgKiAyLjA7XFxuICAgICAgICAgICAgICAgICAgICAvL3V2Mi55IC09IHN0ZXAoMC41LCB1djIueSkgKiAodXYyLnktMC41KSAqIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQodE9uZSwgdXYyKTtcXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSB0ZXh0dXJlMkQodFR3bywgdXYyKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXgodGV4ZWxDb2xvci5yZ2IsIGJnQ29sb3IucmdiLCBhdmVyYWdlKGJnQ29sb3IpKSwgMS4wKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXhlbENvbG9yO1xcblxcbiAgICAgICAgICAgICAgICB2ZWMzIGNvbG9yID0gZ2xfRnJhZ0NvbG9yLnJnYjtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZUNvbG9yKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNoYW5nZVNhdHVyYXRpb24oY29sb3IsIHVTYXR1cmF0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gRGVzYXR1cmF0ZShjb2xvciwgdURlc2F0dXJhdGUpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSAoY29sb3IgLSAwLjUpICogKHVDb250cmFzdCArIDEuMCkgKyAwLjU7XFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yICsgdUJyaWdodG5lc3M7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRvSHVlKGNvbG9yLCB1SHVlKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlQ2hyb21hKSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBmZiA9IGNocm9tYVZhbChjb2xvciwgdmVjMygxLjAsIDAuMCwgMC4wKSwgMC44LCAwLjIpO1xcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBtaXgoY29sb3IsIGJnQ29sb3IucmdiLCBmZik7XFxuICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG5cXG4gICAgICAgICAgICB9XCIsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6XCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVPZmZzZXQ7XFxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVSZXBlYXQ7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcXG5cXG4gICAgICAgICAgICAjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXFxuXFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaXNwbGFjZW1lbnQ7XFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudFNjYWxlO1xcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRCaWFzO1xcblxcbiAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiAgICAgICAgICAgICNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gICAgICAgICAgICAgICAgI2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFxuICAgICAgICAgICAgICAgICAgICBtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgaiA9IGkgKiA0LjA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgeCA9IG1vZCggaiwgTl9CT05FX1BJWEVMX1ggKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB5ID0gZmxvb3IoIGogLyBOX0JPTkVfUElYRUxfWCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IGR4ID0gMS4wIC8gTl9CT05FX1BJWEVMX1g7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvYXQgZHkgPSAxLjAgLyBOX0JPTkVfUElYRUxfWTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgI2Vsc2VcXG5cXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgbWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvbmU7XFxuXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgICNlbmRpZlxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgICNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XFxuXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcblxcblxcbiAgICAgICAgICAgICAgICB2Qmlub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCB2Tm9ybWFsLCB2VGFuZ2VudCApICogdGFuZ2VudC53ICk7XFxuXFxuICAgICAgICAgICAgICAgIHZVdiA9IHV2ICogdVJlcGVhdCArIHVPZmZzZXQ7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGRpc3BsYWNlbWVudCBtYXBwaW5nXFxuXFxuICAgICAgICAgICAgICAgIHZlYzMgZGlzcGxhY2VkUG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgICNpZmRlZiBWRVJURVhfVEVYVFVSRVNcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmICggZW5hYmxlRGlzcGxhY2VtZW50ICkge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMgZHYgPSB0ZXh0dXJlMkQoIHREaXNwbGFjZW1lbnQsIHV2ICkueHl6O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGRmID0gdURpc3BsYWNlbWVudFNjYWxlICogZHYueCArIHVEaXNwbGFjZW1lbnRCaWFzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb24gKyBub3JtYWxpemUoIG5vcm1hbCApICogZGY7XFxuXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBza2luVmVydGV4ID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lubmVkICAgICAgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAjZWxzZVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAjZWxzZVxcblxcbiAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraW5uZWQgICAgICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkUG9zaXRpb24gID0gc2tpbm5lZC54eXo7XFxuXFxuICAgICAgICAgICAgICAgICAgICAjZWxzZVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXG4gICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgICAgIC8vXFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcXG4gICAgICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XFxuXFxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgIC8vXFxuXFxuICAgICAgICAgICAgICAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuICAgICAgICAgICAgICAgIHZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHNoYWRvd3NcXG5cXG4gICAgICAgICAgICAgICAgI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gICAgICAgICAgICAgICAgICAgIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgIH1cIlxuICAgICAgICB9LFxuICAgICAgICAnZnJhY3RhbDEnIDoge1xuICAgICAgICAgICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcbiAgICAgICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInRPbmVcIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgIFwidFR3b1wiICAgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgXCJ0RGlzcGxhY2VtZW50XCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuICAgICAgICAgICAgICAgIFwidURpZmZ1c2VDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG4gICAgICAgICAgICAgICAgXCJ1U3BlY3VsYXJDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXG4gICAgICAgICAgICAgICAgXCJ1QW1iaWVudENvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcblxuICAgICAgICAgICAgICAgIFwidVRpbWVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgICAgICBcInVXaWR0aFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgICAgIFwidUhlaWdodFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgICAgIFwidVJlc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgICAgIFwidU9mZnNldFwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApIH0sXG4gICAgICAgICAgICAgICAgXCJ1UmVwZWF0XCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgXSApLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOlwiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdUFtYmllbnRDb2xvcjtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdURpZmZ1c2VDb2xvcjtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdVNwZWN1bGFyQ29sb3I7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVXaWR0aDtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVIZWlnaHQ7XFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmVzO1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRPbmU7XFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdFR3bztcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1xcblxcbiAgICAgICAgICAgICAvL0Jhc2ljIGZyYWN0YWwgYnkgQHBhdWxvZmFsY2FvXFxuXFxuICAgICAgICAgICAgY29uc3QgaW50IG1heEl0ZXJhdGlvbnMgPSA0OyAvL2EgbmljZSB2YWx1ZSBmb3IgZnVsbHNjcmVlbiBpcyA4XFxuXFxuICAgICAgICAgICAgZmxvYXQgY2lyY2xlU2l6ZSA9IDEuMCAvICgwLjQgKiBwb3coMi4wLCBmbG9hdChtYXhJdGVyYXRpb25zKSkpO1xcblxcbiAgICAgICAgICAgICAvL2dlbmVyaWMgcm90YXRpb24gZm9ybXVsYVxcbiAgICAgICAgICAgIHZlYzIgcm90KHZlYzIgdXYsIGZsb2F0IGEpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlYzIodXYueCAqIGNvcyhhKSAtIHV2LnkgKiBzaW4oYSksIHV2LnkgKiBjb3MoYSkgKyB1di54ICogc2luKGEpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICB2ZWMyIGlSZXNvbHV0aW9uID0gdmVjMih1V2lkdGgsIHVIZWlnaHQpO1xcbiAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZSBzdHVmZlxcbiAgICAgICAgICAgICAgICB2ZWMyIHV2ID0gaVJlc29sdXRpb24ueHk7XFxuICAgICAgICAgICAgICAgIHV2LnggPSB1di54IC8gdVdpZHRoO1xcbiAgICAgICAgICAgICAgICB1di55ID0gdXYueSAvIHVIZWlnaHQ7XFxuICAgICAgICAgICAgICAgIHV2ID0gLS41ICogKHV2IC0gMi4wICogdlV2Lnh5KSAvIHV2Lng7XFxuICAgICAgICAgICAgICAgIC8vZ2xvYmFsIHJvdGF0aW9uIGFuZCB6b29tXFxuICAgICAgICAgICAgICAgIHV2ID0gcm90KHV2LCB1VGltZSk7XFxuICAgICAgICAgICAgICAgIHV2ICo9IHNpbih1VGltZSkgKiAwLjA1ICsgNC47XFxuXFxuICAgICAgICAgICAgICAgIC8vbWlycm9yLCByb3RhdGUgYW5kIHNjYWxlIDYgdGltZXMuLi5cXG4gICAgICAgICAgICAgICAgZmxvYXQgcyA9IDEuO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG1heEl0ZXJhdGlvbnM7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgdXYgPSBhYnModXYpIC0gcztcXG4gICAgICAgICAgICAgICAgICAgIHV2ID0gcm90KHV2LCB1VGltZSk7XFxuICAgICAgICAgICAgICAgICAgICBzID0gcyAvIDIuMTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvL2RyYXcgYSBjaXJjbGVcXG4gICAgICAgICAgICAgICAgLy9mbG9hdCBjID0gbGVuZ3RoKHV2KSA+IGNpcmNsZVNpemUgPyAwLjAgOiAxLjA7Ki9cXG5cXG4gICAgICAgICAgICAgICAgdmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKHRPbmUsICB1diApO1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHRleGVsQ29sb3IucmdiLCAxLjApO1xcbiAgICAgICAgICAgICAgICAvL2dsX0ZyYWdDb2xvciA9IHZlYzQoYyxjLGMsIDEuMCk7XFxuICAgICAgICAgICAgfVwiLFxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjpcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdU9mZnNldDtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdVJlcGVhdDtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIGJvb2wgZW5hYmxlRGlzcGxhY2VtZW50O1xcblxcbiAgICAgICAgICAgICNpZmRlZiBWRVJURVhfVEVYVFVSRVNcXG5cXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpc3BsYWNlbWVudDtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50U2NhbGU7XFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XFxuXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG5cXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuICAgICAgICAgICAgI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgICAgICAgICAgICAgICAjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBqID0gaSAqIDQuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB4ID0gbW9kKCBqLCBOX0JPTkVfUElYRUxfWCApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHkgPSBmbG9vciggaiAvIE5fQk9ORV9QSVhFTF9YICk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvYXQgZHggPSAxLjAgLyBOX0JPTkVfUElYRUxfWDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBkeSA9IDEuMCAvIE5fQk9ORV9QSVhFTF9ZO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib25lO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAjZWxzZVxcblxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuICAgICAgICAgICAgICAgICAgICBtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgI2VuZGlmXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4gICAgICAgICAgICAjZW5kaWZcXG5cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuXFxuXFxuICAgICAgICAgICAgICAgIHZCaW5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXG4gICAgICAgICAgICAgICAgdlV2ID0gdXYgKiB1UmVwZWF0ICsgdU9mZnNldDtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZGlzcGxhY2VtZW50IG1hcHBpbmdcXG5cXG4gICAgICAgICAgICAgICAgdmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgI2lmZGVmIFZFUlRFWF9URVhUVVJFU1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmFibGVEaXNwbGFjZW1lbnQgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGYgPSB1RGlzcGxhY2VtZW50U2NhbGUgKiBkdi54ICsgdURpc3BsYWNlbWVudEJpYXM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbiArIG5vcm1hbGl6ZSggbm9ybWFsICkgKiBkZjtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW5uZWQgICAgICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uICA9IHNraW5uZWQueHl6O1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBza2luVmVydGV4ID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbm5lZCAgICAgICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcXG5cXG4gICAgICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXG4gICAgICAgICAgICAgICAgLy9cXG5cXG4gICAgICAgICAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggZGlzcGxhY2VkUG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcXG5cXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgLy9cXG5cXG4gICAgICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4gICAgICAgICAgICAgICAgdlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcXG5cXG4gICAgICAgICAgICAgICAgLy8gc2hhZG93c1xcblxcbiAgICAgICAgICAgICAgICAjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiAgICAgICAgICAgICAgICAgICAgZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2NhdmUnIDoge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG4gICAgICAgICAgICAgICAgICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcInRPbmVcIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBcInRUd29cIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBcInREaXNwbGFjZW1lbnRcIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwidURpZmZ1c2VDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG4gICAgICAgICAgICAgICAgICAgIFwidVNwZWN1bGFyQ29sb3JcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuICAgICAgICAgICAgICAgICAgICBcInVBbWJpZW50Q29sb3JcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwidVRpbWVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1V2lkdGhcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1SGVpZ2h0XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICAgICAgICAgIFwidVJlc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgICAgICAgICAgICBcInVPZmZzZXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKSB9LFxuICAgICAgICAgICAgICAgICAgICBcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOlwiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdUFtYmllbnRDb2xvcjtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdURpZmZ1c2VDb2xvcjtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdVNwZWN1bGFyQ29sb3I7XFxuXFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVXaWR0aDtcXG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVIZWlnaHQ7XFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1UmVzO1xcblxcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRPbmU7XFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdFR3bztcXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1xcblxcblxcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyBpUmVzb2x1dGlvbiA9IHZlYzMoMS4sIDEuLDEuICk7XFxuICAgICAgICAgICAgICAgIC8vbm9ybWFsaXplIHN0dWZmXFxuICAgICAgICAgICAgICAgLyogdmVjMiB1diA9IGlSZXNvbHV0aW9uLnh5O1xcbiAgICAgICAgICAgICAgICB1di54ID0gdXYueCAvIHVXaWR0aDtcXG4gICAgICAgICAgICAgICAgdXYueSA9IHV2LnkgLyB1SGVpZ2h0O1xcbiovXFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgcCA9IHZlYzQodlV2LCAxLCAxKSAvIGlSZXNvbHV0aW9uLnh5enogLSAuNSwgZCA9IHAgKiAuMSwgdDtcXG4gICAgICAgICAgICAgICAgcC53ICs9IHVUaW1lICogMS47XFxuICAgICAgICAgICAgICAgIGQueSArPSBzaW4ocC53KSAqIC4wMDE7XFxuICAgICAgICAgICAgICAgIGQueSA9IC1hYnMoZC55KTtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChmbG9hdCBpID0gMTAuOyBpID4gMC47IGkgLT0gLjAwNSkge1xcbiAgICAgICAgICAgICAgICAgICAgcCArPSBkO1xcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRleHR1cmUyRCh0T25lLCAuMiArIHAueHcgLyAyZTIsIC05OS4pO1xcbiAgICAgICAgICAgICAgICAgICAgdCAqPSB0ZXh0dXJlMkQodFR3bywgLjIgKyBwLnh3IC8gM2UyLCAtOTkuKTtcXG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHQgKiBpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQueSAqIDEzLiA+IHAueSArIDYuKSBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvL2dsX0ZyYWdDb2xvciA9IHZlYzQodGV4ZWxDb2xvci5yZ2IsIDEuMCk7XFxuICAgICAgICAgICAgICAgIC8vZ2xfRnJhZ0NvbG9yID0gdmVjNChjLGMsYywgMS4wKTtcXG4gICAgICAgICAgICB9XFxuXCIsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjpcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdU9mZnNldDtcXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdVJlcGVhdDtcXG5cXG4gICAgICAgICAgICB1bmlmb3JtIGJvb2wgZW5hYmxlRGlzcGxhY2VtZW50O1xcblxcbiAgICAgICAgICAgICNpZmRlZiBWRVJURVhfVEVYVFVSRVNcXG5cXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpc3BsYWNlbWVudDtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50U2NhbGU7XFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XFxuXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG5cXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuXFxuICAgICAgICAgICAgI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgICAgICAgICAgICAgICAjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBqID0gaSAqIDQuMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB4ID0gbW9kKCBqLCBOX0JPTkVfUElYRUxfWCApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHkgPSBmbG9vciggaiAvIE5fQk9ORV9QSVhFTF9YICk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvYXQgZHggPSAxLjAgLyBOX0JPTkVfUElYRUxfWDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBkeSA9IDEuMCAvIE5fQk9ORV9QSVhFTF9ZO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkeSAqICggeSArIDAuNSApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib25lO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAjZWxzZVxcblxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuICAgICAgICAgICAgICAgICAgICBtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9uZTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgI2VuZGlmXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4gICAgICAgICAgICAjZW5kaWZcXG5cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuXFxuXFxuICAgICAgICAgICAgICAgIHZCaW5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG5cXG4gICAgICAgICAgICAgICAgdlV2ID0gdXYgKiB1UmVwZWF0ICsgdU9mZnNldDtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZGlzcGxhY2VtZW50IG1hcHBpbmdcXG5cXG4gICAgICAgICAgICAgICAgdmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgI2lmZGVmIFZFUlRFWF9URVhUVVJFU1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbmFibGVEaXNwbGFjZW1lbnQgKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGYgPSB1RGlzcGxhY2VtZW50U2NhbGUgKiBkdi54ICsgdURpc3BsYWNlbWVudEJpYXM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbiArIG5vcm1hbGl6ZSggbm9ybWFsICkgKiBkZjtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraW5uZWQgICAgICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uICA9IHNraW5uZWQueHl6O1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBza2luVmVydGV4ID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpbm5lZCAgICAgICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcXG5cXG4gICAgICAgICAgICAgICAgICAgICNlbHNlXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgICAgICNlbmRpZlxcblxcbiAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXG4gICAgICAgICAgICAgICAgLy9cXG5cXG4gICAgICAgICAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggZGlzcGxhY2VkUG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcXG5cXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgLy9cXG5cXG4gICAgICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4gICAgICAgICAgICAgICAgdlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcXG5cXG4gICAgICAgICAgICAgICAgLy8gc2hhZG93c1xcblxcbiAgICAgICAgICAgICAgICAjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiAgICAgICAgICAgICAgICAgICAgZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHdpc3QnIDoge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidERpZmZ1c2VcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmFkaXVzXCI6ICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiBNYXRoLlBJIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFuZ2xlXCI6ICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF0gKSxcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOlwiI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgY29vcmQgPSB2VXYgLSAwLjU7XFxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGNvb3JkKTtcXG5cXG4gICAgICAgZmxvYXQgcmF0aW8gPSAocmFkaXVzIC0gZGlzdCkgLyByYWRpdXM7XFxuICAgICAgIGZsb2F0IGFuZ2xlTW9kID0gcmF0aW8gKiByYXRpbyAqIGFuZ2xlO1xcbiAgICAgICBmbG9hdCBzID0gc2luKGFuZ2xlTW9kKTtcXG4gICAgICAgZmxvYXQgYyA9IGNvcyhhbmdsZU1vZCk7XFxuICAgICAgIGNvb3JkID0gdmVjMihjb29yZC54ICogYyAtIGNvb3JkLnkgKiBzLCBjb29yZC54ICogcyArIGNvb3JkLnkgKiBjKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmQrMC41KTtcXG59XCIsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjpcIiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIHZVdiA9IHZlYzIodXYueCwgdXYueSk7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxufVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgJ3JnYlNoaWZ0JyA6IHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRTaXplXCIgICAgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxMjgsIDEyOCApIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInVSZWRcIjogICAgeyB0eXBlOiBcImlcIiwgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidUdyZWVuXCI6ICAgIHsgdHlwZTogXCJpXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInVCbHVlXCI6ICAgIHsgdHlwZTogXCJpXCIsIHZhbHVlOiAxIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBdICksXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcjpcIiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxudW5pZm9ybSB2ZWMyIHRTaXplO1xcbnVuaWZvcm0gaW50IHVSZWQ7XFxudW5pZm9ybSBpbnQgdUdyZWVuO1xcbnVuaWZvcm0gaW50IHVCbHVlO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXHRnbF9GcmFnQ29sb3IuciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgdmVjMih1UmVkLCB1UmVkKSAvIHRTaXplLnh5KS5yO1xcblxcdGdsX0ZyYWdDb2xvci5nID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyB2ZWMyKHVHcmVlbiwgdUdyZWVuKSAvIHRTaXplLnh5KS5nO1xcblxcdGdsX0ZyYWdDb2xvci5iID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyB2ZWMyKHVCbHVlLCB1Qmx1ZSkgLyB0U2l6ZS54eSkuYjtcXG5cXHRnbF9GcmFnQ29sb3IuYSA9IDEuMDtcXG59XCIsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcjpcIiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIHZVdiA9IHZlYzIodXYueCwgdXYueSk7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxufVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibGVhY2g6cmVxdWlyZSgnLi9zaGFkZXJzL0JsZWFjaEJ5cGFzc1NoYWRlcicpLFxuICAgICAgICAgICAgICAgIGJpdDpyZXF1aXJlKCcuL3NoYWRlcnMvQml0U2hhZGVyJyksXG4gICAgICAgICAgICAgICAgcGl4ZWxhdGU6cmVxdWlyZSgnLi9zaGFkZXJzL1BpeGVsYXRlU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgYmxlbmQ6cmVxdWlyZSgnLi9zaGFkZXJzL0JsZW5kU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzczpyZXF1aXJlKCcuL3NoYWRlcnMvQnJpZ2h0bmVzc0NvbnRyYXN0U2hhZGVyJyksXG4gICAgICAgICAgICAgICAgY29sb3JpZnk6cmVxdWlyZSgnLi9zaGFkZXJzL0NvbG9yaWZ5U2hhZGVyJyksXG4gICAgICAgICAgICAgICAgaHVlOnJlcXVpcmUoJy4vc2hhZGVycy9IdWVTYXR1cmF0aW9uU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50OnJlcXVpcmUoJy4vc2hhZGVycy9Ob3JtYWxEaXNwbGFjZW1lbnRTaGFkZXInKSxcbiAgICAgICAgICAgICAgICB0ZWNobmljb2xvcjpyZXF1aXJlKCcuL3NoYWRlcnMvVGVjaG5pY29sb3JTaGFkZXInKSxcbiAgICAgICAgICAgICAgICB0b25lOnJlcXVpcmUoJy4vc2hhZGVycy9Ub25lTWFwU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgYm9rYWg6cmVxdWlyZSgnLi9zaGFkZXJzL0Jva2VoU2hhZGVyMicpLCAvL2JhZFxuICAgICAgICAgICAgICAgIGNvbnZvbHV0aW9uOnJlcXVpcmUoJy4vc2hhZGVycy9Db252b2x1dGlvblNoYWRlcicpLFxuICAgICAgICAgICAgICAgIGVkZ2U6cmVxdWlyZSgnLi9zaGFkZXJzL0VkZ2VTaGFkZXIyJyksXG4gICAgICAgICAgICAgICAgZmlsbTpyZXF1aXJlKCcuL3NoYWRlcnMvRmlsbVNoYWRlcicpLFxuICAgICAgICAgICAgICAgIGZvY3VzOnJlcXVpcmUoJy4vc2hhZGVycy9Gb2N1c1NoYWRlcicpLFxuICAgICAgICAgICAgICAgIGZ4eGE6cmVxdWlyZSgnLi9zaGFkZXJzL0ZYQUFTaGFkZXInKSxcbiAgICAgICAgICAgICAgICBoQmx1cjpyZXF1aXJlKCcuL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXInKSxcbiAgICAgICAgICAgICAgICB2Qmx1cjpyZXF1aXJlKCcuL3NoYWRlcnMvVmVydGljYWxCbHVyU2hhZGVyJyksXG4gICAgICAgICAgICAgICAga2FsZWlkbzpyZXF1aXJlKCcuL3NoYWRlcnMvS2FsZWlkb1NoYWRlcicpLFxuICAgICAgICAgICAgICAgIG1pcnJvcjpyZXF1aXJlKCcuL3NoYWRlcnMvTWlycm9yU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgcmdiOnJlcXVpcmUoJy4vc2hhZGVycy9SR0JTaGlmdFNoYWRlcicpLFxuICAgICAgICAgICAgICAgIHNlcGlhOnJlcXVpcmUoJy4vc2hhZGVycy9TZXBpYVNoYWRlcicpLFxuICAgICAgICAgICAgICAgIGdsaXRjaDpyZXF1aXJlKCcuL3NoYWRlcnMvRGlnaXRhbEdsaXRjaCcpLFxuICAgICAgICAgICAgICAgIGRvdDpyZXF1aXJlKCcuL3NoYWRlcnMvRG90U2NyZWVuU2hhZGVyJyksXG4gICAgICAgICAgICAgICAgY29weTpUSFJFRS5Db3B5U2hhZGVyXG4gICAgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHVuaWZvcm1zOiB7XG5cbiAgICAgICAgXCJ0RGlmZnVzZVwiOiB7dHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsfSxcbiAgICAgICAgXCJiaXRTaXplXCI6IHt0eXBlOiBcImZcIiwgdmFsdWU6IDQuMH1cblxuICAgIH0sXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgXCJ2VXYgPSB1djtcIixcbiAgICAgICAgXCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IGJpdFNpemU7XCIsXG5cbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblxuICAgICAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgXCJ2ZWM0IHRleGVsID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG4gICAgICAgIFwiZmxvYXQgbiA9IHBvdyhiaXRTaXplLDIuMCk7XCIsXG4gICAgICAgIFwiZmxvYXQgbmV3UiA9IGZsb29yKHRleGVsLnIqbikvbjtcIixcbiAgICAgICAgXCJmbG9hdCBuZXdHID0gZmxvb3IodGV4ZWwuZypuKS9uO1wiLFxuICAgICAgICBcImZsb2F0IG5ld0IgPSBmbG9vcih0ZXhlbC5iKm4pL247XCIsXG5cbiAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKG5ld1IsbmV3RyxuZXdCKSwgMS4wKTtcIixcblxuICAgICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbn07IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEJsZWFjaCBieXBhc3Mgc2hhZGVyIFtodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JsZWFjaF9ieXBhc3NdXG4gKiAtIGJhc2VkIG9uIE52aWRpYSBleGFtcGxlXG4gKiBodHRwOi8vZGV2ZWxvcGVyLmRvd25sb2FkLm52aWRpYS5jb20vc2hhZGVybGlicmFyeS93ZWJwYWdlcy9zaGFkZXJfbGlicmFyeS5odG1sI3Bvc3RfYmxlYWNoX2J5cGFzc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJvcGFjaXR5XCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IGJhc2UgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblxuXHRcdFx0XCJ2ZWMzIGx1bUNvZWZmID0gdmVjMyggMC4yNSwgMC42NSwgMC4xICk7XCIsXG5cdFx0XHRcImZsb2F0IGx1bSA9IGRvdCggbHVtQ29lZmYsIGJhc2UucmdiICk7XCIsXG5cdFx0XHRcInZlYzMgYmxlbmQgPSB2ZWMzKCBsdW0gKTtcIixcblxuXHRcdFx0XCJmbG9hdCBMID0gbWluKCAxLjAsIG1heCggMC4wLCAxMC4wICogKCBsdW0gLSAwLjQ1ICkgKSApO1wiLFxuXG5cdFx0XHRcInZlYzMgcmVzdWx0MSA9IDIuMCAqIGJhc2UucmdiICogYmxlbmQ7XCIsXG5cdFx0XHRcInZlYzMgcmVzdWx0MiA9IDEuMCAtIDIuMCAqICggMS4wIC0gYmxlbmQgKSAqICggMS4wIC0gYmFzZS5yZ2IgKTtcIixcblxuXHRcdFx0XCJ2ZWMzIG5ld0NvbG9yID0gbWl4KCByZXN1bHQxLCByZXN1bHQyLCBMICk7XCIsXG5cblx0XHRcdFwiZmxvYXQgQTIgPSBvcGFjaXR5ICogYmFzZS5hO1wiLFxuXHRcdFx0XCJ2ZWMzIG1peFJHQiA9IEEyICogbmV3Q29sb3IucmdiO1wiLFxuXHRcdFx0XCJtaXhSR0IgKz0gKCAoIDEuMCAtIEEyICkgKiBiYXNlLnJnYiApO1wiLFxuXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIG1peFJHQiwgYmFzZS5hICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEJsZW5kIHR3byB0ZXh0dXJlc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlMVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidERpZmZ1c2UyXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJtaXhSYXRpb1wiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxuXHRcdFwib3BhY2l0eVwiOiAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBtaXhSYXRpbztcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2UxO1wiLFxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2UyO1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidmVjNCB0ZXhlbDEgPSB0ZXh0dXJlMkQoIHREaWZmdXNlMSwgdlV2ICk7XCIsXG5cdFx0XHRcInZlYzQgdGV4ZWwyID0gdGV4dHVyZTJEKCB0RGlmZnVzZTIsIHZVdiApO1wiLFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBvcGFjaXR5ICogbWl4KCB0ZXhlbDEsIHRleGVsMiwgbWl4UmF0aW8gKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1IHwgdHdpdHRlci5jb20vYmx1cnNwbGluZVxuICpcbiAqIERlcHRoLW9mLWZpZWxkIHNoYWRlciB3aXRoIGJva2VoXG4gKiBwb3J0ZWQgZnJvbSBHTFNMIHNoYWRlciBieSBNYXJ0aW5zIFVwaXRpc1xuICogaHR0cDovL2JsZW5kZXJhcnRpc3RzLm9yZy9mb3J1bS9zaG93dGhyZWFkLnBocD8yMzc0ODgtR0xTTC1kZXB0aC1vZi1maWVsZC13aXRoLWJva2VoLXYyLTQtKHVwZGF0ZSlcbiAqXG4gKiBSZXF1aXJlcyAjZGVmaW5lIFJJTkdTIGFuZCBTQU1QTEVTIGludGVnZXJzXG4gKi9cblxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInRleHR1cmVXaWR0aFwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwidGV4dHVyZUhlaWdodFwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXG5cdFx0XCJmb2NhbERlcHRoXCI6ICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwiZm9jYWxMZW5ndGhcIjogICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjQuMCB9LFxuXHRcdFwiZnN0b3BcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOSB9LFxuXG5cdFx0XCJ0Q29sb3JcIjogICB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidERlcHRoXCI6ICAgeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuXHRcdFwibWF4Ymx1clwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXG5cdFx0XCJzaG93Rm9jdXNcIjogICB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFwibWFudWFsZG9mXCI6ICAgeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcInZpZ25ldHRpbmdcIjogICB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFwiZGVwdGhibHVyXCI6ICAgeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblxuXHRcdFwidGhyZXNob2xkXCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cdFx0XCJnYWluXCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMi4wIH0sXG5cdFx0XCJiaWFzXCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cdFx0XCJmcmluZ2VcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjcgfSxcblxuXHRcdFwiem5lYXJcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjEgfSxcblx0XHRcInpmYXJcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxMDAgfSxcblxuXHRcdFwibm9pc2VcIjogIHsgdHlwZTogXCJpXCIsIHZhbHVlOiAxIH0sXG5cdFx0XCJkaXRoZXJpbmdcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDEgfSxcblx0XHRcInBlbnRhZ29uXCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cblx0XHRcInNoYWRlckZvY3VzXCI6ICB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMSB9LFxuXHRcdFwiZm9jdXNDb29yZHNcIjogIHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoKSB9LFxuXG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0Q29sb3I7XCIsXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGVwdGg7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHRleHR1cmVXaWR0aDtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgdGV4dHVyZUhlaWdodDtcIixcblxuXHRcdFwiY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1O1wiLFxuXG5cdFx0XCJmbG9hdCB3aWR0aCA9IHRleHR1cmVXaWR0aDsgLy90ZXh0dXJlIHdpZHRoXCIsXG5cdFx0XCJmbG9hdCBoZWlnaHQgPSB0ZXh0dXJlSGVpZ2h0OyAvL3RleHR1cmUgaGVpZ2h0XCIsXG5cblx0XHRcInZlYzIgdGV4ZWwgPSB2ZWMyKDEuMC93aWR0aCwxLjAvaGVpZ2h0KTtcIixcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBmb2NhbERlcHRoOyAgLy9mb2NhbCBkaXN0YW5jZSB2YWx1ZSBpbiBtZXRlcnMsIGJ1dCB5b3UgbWF5IHVzZSBhdXRvZm9jdXMgb3B0aW9uIGJlbG93XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGZvY2FsTGVuZ3RoOyAvL2ZvY2FsIGxlbmd0aCBpbiBtbVwiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBmc3RvcDsgLy9mLXN0b3AgdmFsdWVcIixcblx0XHRcInVuaWZvcm0gYm9vbCBzaG93Rm9jdXM7IC8vc2hvdyBkZWJ1ZyBmb2N1cyBwb2ludCBhbmQgZm9jYWwgcmFuZ2UgKHJlZCA9IGZvY2FsIHBvaW50LCBncmVlbiA9IGZvY2FsIHJhbmdlKVwiLFxuXG5cdFx0XCIvKlwiLFxuXHRcdFwibWFrZSBzdXJlIHRoYXQgdGhlc2UgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgZm9yIHlvdXIgY2FtZXJhLCBvdGhlcndpc2UgZGlzdGFuY2VzIHdpbGwgYmUgd3JvbmcuXCIsXG5cdFx0XCIqL1wiLFxuXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHpuZWFyOyAvLyBjYW1lcmEgY2xpcHBpbmcgc3RhcnRcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgemZhcjsgLy8gY2FtZXJhIGNsaXBwaW5nIGVuZFwiLFxuXG5cdFx0XCIvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiLFxuXHRcdFwiLy91c2VyIHZhcmlhYmxlc1wiLFxuXG5cdFx0XCJjb25zdCBpbnQgc2FtcGxlcyA9IFNBTVBMRVM7IC8vc2FtcGxlcyBvbiB0aGUgZmlyc3QgcmluZ1wiLFxuXHRcdFwiY29uc3QgaW50IHJpbmdzID0gUklOR1M7IC8vcmluZyBjb3VudFwiLFxuXG5cdFx0XCJjb25zdCBpbnQgbWF4cmluZ3NhbXBsZXMgPSByaW5ncyAqIHNhbXBsZXM7XCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBtYW51YWxkb2Y7IC8vIG1hbnVhbCBkb2YgY2FsY3VsYXRpb25cIixcblx0XHRcImZsb2F0IG5kb2ZzdGFydCA9IDEuMDsgLy8gbmVhciBkb2YgYmx1ciBzdGFydFwiLFxuXHRcdFwiZmxvYXQgbmRvZmRpc3QgPSAyLjA7IC8vIG5lYXIgZG9mIGJsdXIgZmFsbG9mZiBkaXN0YW5jZVwiLFxuXHRcdFwiZmxvYXQgZmRvZnN0YXJ0ID0gMS4wOyAvLyBmYXIgZG9mIGJsdXIgc3RhcnRcIixcblx0XHRcImZsb2F0IGZkb2ZkaXN0ID0gMy4wOyAvLyBmYXIgZG9mIGJsdXIgZmFsbG9mZiBkaXN0YW5jZVwiLFxuXG5cdFx0XCJmbG9hdCBDb0MgPSAwLjAzOyAvL2NpcmNsZSBvZiBjb25mdXNpb24gc2l6ZSBpbiBtbSAoMzVtbSBmaWxtID0gMC4wM21tKVwiLFxuXG5cdFx0XCJ1bmlmb3JtIGJvb2wgdmlnbmV0dGluZzsgLy8gdXNlIG9wdGljYWwgbGVucyB2aWduZXR0aW5nXCIsXG5cblx0XHRcImZsb2F0IHZpZ25vdXQgPSAxLjM7IC8vIHZpZ25ldHRpbmcgb3V0ZXIgYm9yZGVyXCIsXG5cdFx0XCJmbG9hdCB2aWduaW4gPSAwLjA7IC8vIHZpZ25ldHRpbmcgaW5uZXIgYm9yZGVyXCIsXG5cdFx0XCJmbG9hdCB2aWduZmFkZSA9IDIyLjA7IC8vIGYtc3RvcHMgdGlsbCB2aWduZXRlIGZhZGVzXCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBzaGFkZXJGb2N1cztcIixcblxuXHRcdFwiYm9vbCBhdXRvZm9jdXMgPSBzaGFkZXJGb2N1cztcIixcblx0XHRcIi8vdXNlIGF1dG9mb2N1cyBpbiBzaGFkZXIgLSB1c2Ugd2l0aCBmb2N1c0Nvb3Jkc1wiLFxuXHRcdFwiLy8gZGlzYWJsZSBpZiB5b3UgdXNlIGV4dGVybmFsIGZvY2FsRGVwdGggdmFsdWVcIixcblxuXHRcdFwidW5pZm9ybSB2ZWMyIGZvY3VzQ29vcmRzO1wiLFxuXHRcdFwiLy8gYXV0b2ZvY3VzIHBvaW50IG9uIHNjcmVlbiAoMC4wLDAuMCAtIGxlZnQgbG93ZXIgY29ybmVyLCAxLjAsMS4wIC0gdXBwZXIgcmlnaHQpXCIsXG5cdFx0XCIvLyBpZiBjZW50ZXIgb2Ygc2NyZWVuIHVzZSB2ZWMyKDAuNSwgMC41KTtcIixcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBtYXhibHVyO1wiLFxuXHRcdFwiLy9jbGFtcCB2YWx1ZSBvZiBtYXggYmx1ciAoMC4wID0gbm8gYmx1ciwgMS4wIGRlZmF1bHQpXCIsXG5cblx0XHRcInVuaWZvcm0gZmxvYXQgdGhyZXNob2xkOyAvLyBoaWdobGlnaHQgdGhyZXNob2xkO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBnYWluOyAvLyBoaWdobGlnaHQgZ2FpbjtcIixcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBiaWFzOyAvLyBib2tlaCBlZGdlIGJpYXNcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgZnJpbmdlOyAvLyBib2tlaCBjaHJvbWF0aWMgYWJlcnJhdGlvbiAvIGZyaW5naW5nXCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBub2lzZTsgLy91c2Ugbm9pc2UgaW5zdGVhZCBvZiBwYXR0ZXJuIGZvciBzYW1wbGUgZGl0aGVyaW5nXCIsXG5cblx0XHRcInVuaWZvcm0gZmxvYXQgZGl0aGVyaW5nO1wiLFxuXHRcdFwiZmxvYXQgbmFtb3VudCA9IGRpdGhlcmluZzsgLy9kaXRoZXIgYW1vdW50XCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBkZXB0aGJsdXI7IC8vIGJsdXIgdGhlIGRlcHRoIGJ1ZmZlclwiLFxuXHRcdFwiZmxvYXQgZGJzaXplID0gMS4yNTsgLy8gZGVwdGggYmx1ciBzaXplXCIsXG5cblx0XHRcIi8qXCIsXG5cdFx0XCJuZXh0IHBhcnQgaXMgZXhwZXJpbWVudGFsXCIsXG5cdFx0XCJub3QgbG9va2luZyBnb29kIHdpdGggc21hbGwgc2FtcGxlIGFuZCByaW5nIGNvdW50XCIsXG5cdFx0XCJsb29rcyBva2F5IHN0YXJ0aW5nIGZyb20gc2FtcGxlcyA9IDQsIHJpbmdzID0gNFwiLFxuXHRcdFwiKi9cIixcblxuXHRcdFwidW5pZm9ybSBib29sIHBlbnRhZ29uOyAvL3VzZSBwZW50YWdvbiBhcyBib2tlaCBzaGFwZT9cIixcblx0XHRcImZsb2F0IGZlYXRoZXIgPSAwLjQ7IC8vcGVudGFnb24gc2hhcGUgZmVhdGhlclwiLFxuXG5cdFx0XCIvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiLFxuXG5cdFx0XCJmbG9hdCBwZW50YSh2ZWMyIGNvb3Jkcykge1wiLFxuXHRcdFx0XCIvL3BlbnRhZ29uYWwgc2hhcGVcIixcblx0XHRcdFwiZmxvYXQgc2NhbGUgPSBmbG9hdChyaW5ncykgLSAxLjM7XCIsXG5cdFx0XHRcInZlYzQgIEhTMCA9IHZlYzQoIDEuMCwgICAgICAgICAwLjAsICAgICAgICAgMC4wLCAgMS4wKTtcIixcblx0XHRcdFwidmVjNCAgSFMxID0gdmVjNCggMC4zMDkwMTY5OTQsIDAuOTUxMDU2NTE2LCAwLjAsICAxLjApO1wiLFxuXHRcdFx0XCJ2ZWM0ICBIUzIgPSB2ZWM0KC0wLjgwOTAxNjk5NCwgMC41ODc3ODUyNTIsIDAuMCwgIDEuMCk7XCIsXG5cdFx0XHRcInZlYzQgIEhTMyA9IHZlYzQoLTAuODA5MDE2OTk0LC0wLjU4Nzc4NTI1MiwgMC4wLCAgMS4wKTtcIixcblx0XHRcdFwidmVjNCAgSFM0ID0gdmVjNCggMC4zMDkwMTY5OTQsLTAuOTUxMDU2NTE2LCAwLjAsICAxLjApO1wiLFxuXHRcdFx0XCJ2ZWM0ICBIUzUgPSB2ZWM0KCAwLjAgICAgICAgICwwLjAgICAgICAgICAsIDEuMCwgIDEuMCk7XCIsXG5cblx0XHRcdFwidmVjNCAgb25lID0gdmVjNCggMS4wICk7XCIsXG5cblx0XHRcdFwidmVjNCBQID0gdmVjNCgoY29vcmRzKSx2ZWMyKHNjYWxlLCBzY2FsZSkpO1wiLFxuXG5cdFx0XHRcInZlYzQgZGlzdCA9IHZlYzQoMC4wKTtcIixcblx0XHRcdFwiZmxvYXQgaW5vcm91dCA9IC00LjA7XCIsXG5cblx0XHRcdFwiZGlzdC54ID0gZG90KCBQLCBIUzAgKTtcIixcblx0XHRcdFwiZGlzdC55ID0gZG90KCBQLCBIUzEgKTtcIixcblx0XHRcdFwiZGlzdC56ID0gZG90KCBQLCBIUzIgKTtcIixcblx0XHRcdFwiZGlzdC53ID0gZG90KCBQLCBIUzMgKTtcIixcblxuXHRcdFx0XCJkaXN0ID0gc21vb3Roc3RlcCggLWZlYXRoZXIsIGZlYXRoZXIsIGRpc3QgKTtcIixcblxuXHRcdFx0XCJpbm9yb3V0ICs9IGRvdCggZGlzdCwgb25lICk7XCIsXG5cblx0XHRcdFwiZGlzdC54ID0gZG90KCBQLCBIUzQgKTtcIixcblx0XHRcdFwiZGlzdC55ID0gSFM1LncgLSBhYnMoIFAueiApO1wiLFxuXG5cdFx0XHRcImRpc3QgPSBzbW9vdGhzdGVwKCAtZmVhdGhlciwgZmVhdGhlciwgZGlzdCApO1wiLFxuXHRcdFx0XCJpbm9yb3V0ICs9IGRpc3QueDtcIixcblxuXHRcdFx0XCJyZXR1cm4gY2xhbXAoIGlub3JvdXQsIDAuMCwgMS4wICk7XCIsXG5cdFx0XCJ9XCIsXG5cblx0XHRcImZsb2F0IGJkZXB0aCh2ZWMyIGNvb3Jkcykge1wiLFxuXHRcdFx0XCIvLyBEZXB0aCBidWZmZXIgYmx1clwiLFxuXHRcdFx0XCJmbG9hdCBkID0gMC4wO1wiLFxuXHRcdFx0XCJmbG9hdCBrZXJuZWxbOV07XCIsXG5cdFx0XHRcInZlYzIgb2Zmc2V0WzldO1wiLFxuXG5cdFx0XHRcInZlYzIgd2ggPSB2ZWMyKHRleGVsLngsIHRleGVsLnkpICogZGJzaXplO1wiLFxuXG5cdFx0XHRcIm9mZnNldFswXSA9IHZlYzIoLXdoLngsLXdoLnkpO1wiLFxuXHRcdFx0XCJvZmZzZXRbMV0gPSB2ZWMyKCAwLjAsIC13aC55KTtcIixcblx0XHRcdFwib2Zmc2V0WzJdID0gdmVjMiggd2gueCAtd2gueSk7XCIsXG5cblx0XHRcdFwib2Zmc2V0WzNdID0gdmVjMigtd2gueCwgIDAuMCk7XCIsXG5cdFx0XHRcIm9mZnNldFs0XSA9IHZlYzIoIDAuMCwgICAwLjApO1wiLFxuXHRcdFx0XCJvZmZzZXRbNV0gPSB2ZWMyKCB3aC54LCAgMC4wKTtcIixcblxuXHRcdFx0XCJvZmZzZXRbNl0gPSB2ZWMyKC13aC54LCB3aC55KTtcIixcblx0XHRcdFwib2Zmc2V0WzddID0gdmVjMiggMC4wLCAgd2gueSk7XCIsXG5cdFx0XHRcIm9mZnNldFs4XSA9IHZlYzIoIHdoLngsIHdoLnkpO1wiLFxuXG5cdFx0XHRcImtlcm5lbFswXSA9IDEuMC8xNi4wOyAgIGtlcm5lbFsxXSA9IDIuMC8xNi4wOyAgIGtlcm5lbFsyXSA9IDEuMC8xNi4wO1wiLFxuXHRcdFx0XCJrZXJuZWxbM10gPSAyLjAvMTYuMDsgICBrZXJuZWxbNF0gPSA0LjAvMTYuMDsgICBrZXJuZWxbNV0gPSAyLjAvMTYuMDtcIixcblx0XHRcdFwia2VybmVsWzZdID0gMS4wLzE2LjA7ICAga2VybmVsWzddID0gMi4wLzE2LjA7ICAga2VybmVsWzhdID0gMS4wLzE2LjA7XCIsXG5cblxuXHRcdFx0XCJmb3IoIGludCBpPTA7IGk8OTsgaSsrICkge1wiLFxuXHRcdFx0XHRcImZsb2F0IHRtcCA9IHRleHR1cmUyRCh0RGVwdGgsIGNvb3JkcyArIG9mZnNldFtpXSkucjtcIixcblx0XHRcdFx0XCJkICs9IHRtcCAqIGtlcm5lbFtpXTtcIixcblx0XHRcdFwifVwiLFxuXG5cdFx0XHRcInJldHVybiBkO1wiLFxuXHRcdFwifVwiLFxuXG5cblx0XHRcInZlYzMgY29sb3IodmVjMiBjb29yZHMsZmxvYXQgYmx1cikge1wiLFxuXHRcdFx0XCIvL3Byb2Nlc3NpbmcgdGhlIHNhbXBsZVwiLFxuXG5cdFx0XHRcInZlYzMgY29sID0gdmVjMygwLjApO1wiLFxuXG5cdFx0XHRcImNvbC5yID0gdGV4dHVyZTJEKHRDb2xvcixjb29yZHMgKyB2ZWMyKDAuMCwxLjApKnRleGVsKmZyaW5nZSpibHVyKS5yO1wiLFxuXHRcdFx0XCJjb2wuZyA9IHRleHR1cmUyRCh0Q29sb3IsY29vcmRzICsgdmVjMigtMC44NjYsLTAuNSkqdGV4ZWwqZnJpbmdlKmJsdXIpLmc7XCIsXG5cdFx0XHRcImNvbC5iID0gdGV4dHVyZTJEKHRDb2xvcixjb29yZHMgKyB2ZWMyKDAuODY2LC0wLjUpKnRleGVsKmZyaW5nZSpibHVyKS5iO1wiLFxuXG5cdFx0XHRcInZlYzMgbHVtY29lZmYgPSB2ZWMzKDAuMjk5LDAuNTg3LDAuMTE0KTtcIixcblx0XHRcdFwiZmxvYXQgbHVtID0gZG90KGNvbC5yZ2IsIGx1bWNvZWZmKTtcIixcblx0XHRcdFwiZmxvYXQgdGhyZXNoID0gbWF4KChsdW0tdGhyZXNob2xkKSpnYWluLCAwLjApO1wiLFxuXHRcdFx0XCJyZXR1cm4gY29sK21peCh2ZWMzKDAuMCksY29sLHRocmVzaCpibHVyKTtcIixcblx0XHRcIn1cIixcblxuXHRcdFwidmVjMiByYW5kKHZlYzIgY29vcmQpIHtcIixcblx0XHRcdFwiLy8gZ2VuZXJhdGluZyBub2lzZSAvIHBhdHRlcm4gdGV4dHVyZSBmb3IgZGl0aGVyaW5nXCIsXG5cblx0XHRcdFwiZmxvYXQgbm9pc2VYID0gKChmcmFjdCgxLjAtY29vcmQucyood2lkdGgvMi4wKSkqMC4yNSkrKGZyYWN0KGNvb3JkLnQqKGhlaWdodC8yLjApKSowLjc1KSkqMi4wLTEuMDtcIixcblx0XHRcdFwiZmxvYXQgbm9pc2VZID0gKChmcmFjdCgxLjAtY29vcmQucyood2lkdGgvMi4wKSkqMC43NSkrKGZyYWN0KGNvb3JkLnQqKGhlaWdodC8yLjApKSowLjI1KSkqMi4wLTEuMDtcIixcblxuXHRcdFx0XCJpZiAobm9pc2UpIHtcIixcblx0XHRcdFx0XCJub2lzZVggPSBjbGFtcChmcmFjdChzaW4oZG90KGNvb3JkICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1MyksMC4wLDEuMCkqMi4wLTEuMDtcIixcblx0XHRcdFx0XCJub2lzZVkgPSBjbGFtcChmcmFjdChzaW4oZG90KGNvb3JkICx2ZWMyKDEyLjk4OTgsNzguMjMzKSoyLjApKSAqIDQzNzU4LjU0NTMpLDAuMCwxLjApKjIuMC0xLjA7XCIsXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJyZXR1cm4gdmVjMihub2lzZVgsbm9pc2VZKTtcIixcblx0XHRcIn1cIixcblxuXHRcdFwidmVjMyBkZWJ1Z0ZvY3VzKHZlYzMgY29sLCBmbG9hdCBibHVyLCBmbG9hdCBkZXB0aCkge1wiLFxuXHRcdFx0XCJmbG9hdCBlZGdlID0gMC4wMDIqZGVwdGg7IC8vZGlzdGFuY2UgYmFzZWQgZWRnZSBzbW9vdGhpbmdcIixcblx0XHRcdFwiZmxvYXQgbSA9IGNsYW1wKHNtb290aHN0ZXAoMC4wLGVkZ2UsYmx1ciksMC4wLDEuMCk7XCIsXG5cdFx0XHRcImZsb2F0IGUgPSBjbGFtcChzbW9vdGhzdGVwKDEuMC1lZGdlLDEuMCxibHVyKSwwLjAsMS4wKTtcIixcblxuXHRcdFx0XCJjb2wgPSBtaXgoY29sLHZlYzMoMS4wLDAuNSwwLjApLCgxLjAtbSkqMC42KTtcIixcblx0XHRcdFwiY29sID0gbWl4KGNvbCx2ZWMzKDAuMCwwLjUsMS4wKSwoKDEuMC1lKS0oMS4wLW0pKSowLjIpO1wiLFxuXG5cdFx0XHRcInJldHVybiBjb2w7XCIsXG5cdFx0XCJ9XCIsXG5cblx0XHRcImZsb2F0IGxpbmVhcml6ZShmbG9hdCBkZXB0aCkge1wiLFxuXHRcdFx0XCJyZXR1cm4gLXpmYXIgKiB6bmVhciAvIChkZXB0aCAqICh6ZmFyIC0gem5lYXIpIC0gemZhcik7XCIsXG5cdFx0XCJ9XCIsXG5cblxuXHRcdFwiZmxvYXQgdmlnbmV0dGUoKSB7XCIsXG5cdFx0XHRcImZsb2F0IGRpc3QgPSBkaXN0YW5jZSh2VXYueHksIHZlYzIoMC41LDAuNSkpO1wiLFxuXHRcdFx0XCJkaXN0ID0gc21vb3Roc3RlcCh2aWdub3V0Kyhmc3RvcC92aWduZmFkZSksIHZpZ25pbisoZnN0b3AvdmlnbmZhZGUpLCBkaXN0KTtcIixcblx0XHRcdFwicmV0dXJuIGNsYW1wKGRpc3QsMC4wLDEuMCk7XCIsXG5cdFx0XCJ9XCIsXG5cblx0XHRcImZsb2F0IGdhdGhlcihmbG9hdCBpLCBmbG9hdCBqLCBpbnQgcmluZ3NhbXBsZXMsIGlub3V0IHZlYzMgY29sLCBmbG9hdCB3LCBmbG9hdCBoLCBmbG9hdCBibHVyKSB7XCIsXG5cdFx0XHRcImZsb2F0IHJpbmdzMiA9IGZsb2F0KHJpbmdzKTtcIixcblx0XHRcdFwiZmxvYXQgc3RlcCA9IFBJKjIuMCAvIGZsb2F0KHJpbmdzYW1wbGVzKTtcIixcblx0XHRcdFwiZmxvYXQgcHcgPSBjb3MoaipzdGVwKSppO1wiLFxuXHRcdFx0XCJmbG9hdCBwaCA9IHNpbihqKnN0ZXApKmk7XCIsXG5cdFx0XHRcImZsb2F0IHAgPSAxLjA7XCIsXG5cdFx0XHRcImlmIChwZW50YWdvbikge1wiLFxuXHRcdFx0XHRcInAgPSBwZW50YSh2ZWMyKHB3LHBoKSk7XCIsXG5cdFx0XHRcIn1cIixcblx0XHRcdFwiY29sICs9IGNvbG9yKHZVdi54eSArIHZlYzIocHcqdyxwaCpoKSwgYmx1cikgKiBtaXgoMS4wLCBpL3JpbmdzMiwgYmlhcykgKiBwO1wiLFxuXHRcdFx0XCJyZXR1cm4gMS4wICogbWl4KDEuMCwgaSAvcmluZ3MyLCBiaWFzKSAqIHA7XCIsXG5cdFx0XCJ9XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblx0XHRcdFwiLy9zY2VuZSBkZXB0aCBjYWxjdWxhdGlvblwiLFxuXG5cdFx0XHRcImZsb2F0IGRlcHRoID0gbGluZWFyaXplKHRleHR1cmUyRCh0RGVwdGgsdlV2Lnh5KS54KTtcIixcblxuXHRcdFx0XCIvLyBCbHVyIGRlcHRoP1wiLFxuXHRcdFx0XCJpZiAoZGVwdGhibHVyKSB7XCIsXG5cdFx0XHRcdFwiZGVwdGggPSBsaW5lYXJpemUoYmRlcHRoKHZVdi54eSkpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiLy9mb2NhbCBwbGFuZSBjYWxjdWxhdGlvblwiLFxuXG5cdFx0XHRcImZsb2F0IGZEZXB0aCA9IGZvY2FsRGVwdGg7XCIsXG5cblx0XHRcdFwiaWYgKGF1dG9mb2N1cykge1wiLFxuXG5cdFx0XHRcdFwiZkRlcHRoID0gbGluZWFyaXplKHRleHR1cmUyRCh0RGVwdGgsZm9jdXNDb29yZHMpLngpO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCIvLyBkb2YgYmx1ciBmYWN0b3IgY2FsY3VsYXRpb25cIixcblxuXHRcdFx0XCJmbG9hdCBibHVyID0gMC4wO1wiLFxuXG5cdFx0XHRcImlmIChtYW51YWxkb2YpIHtcIixcblx0XHRcdFx0XCJmbG9hdCBhID0gZGVwdGgtZkRlcHRoOyAvLyBGb2NhbCBwbGFuZVwiLFxuXHRcdFx0XHRcImZsb2F0IGIgPSAoYS1mZG9mc3RhcnQpL2Zkb2ZkaXN0OyAvLyBGYXIgRG9GXCIsXG5cdFx0XHRcdFwiZmxvYXQgYyA9ICgtYS1uZG9mc3RhcnQpL25kb2ZkaXN0OyAvLyBOZWFyIERvZlwiLFxuXHRcdFx0XHRcImJsdXIgPSAoYT4wLjApID8gYiA6IGM7XCIsXG5cdFx0XHRcIn0gZWxzZSB7XCIsXG5cdFx0XHRcdFwiZmxvYXQgZiA9IGZvY2FsTGVuZ3RoOyAvLyBmb2NhbCBsZW5ndGggaW4gbW1cIixcblx0XHRcdFx0XCJmbG9hdCBkID0gZkRlcHRoKjEwMDAuMDsgLy8gZm9jYWwgcGxhbmUgaW4gbW1cIixcblx0XHRcdFx0XCJmbG9hdCBvID0gZGVwdGgqMTAwMC4wOyAvLyBkZXB0aCBpbiBtbVwiLFxuXG5cdFx0XHRcdFwiZmxvYXQgYSA9IChvKmYpLyhvLWYpO1wiLFxuXHRcdFx0XHRcImZsb2F0IGIgPSAoZCpmKS8oZC1mKTtcIixcblx0XHRcdFx0XCJmbG9hdCBjID0gKGQtZikvKGQqZnN0b3AqQ29DKTtcIixcblxuXHRcdFx0XHRcImJsdXIgPSBhYnMoYS1iKSpjO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiYmx1ciA9IGNsYW1wKGJsdXIsMC4wLDEuMCk7XCIsXG5cblx0XHRcdFwiLy8gY2FsY3VsYXRpb24gb2YgcGF0dGVybiBmb3IgZGl0aGVyaW5nXCIsXG5cblx0XHRcdFwidmVjMiBub2lzZSA9IHJhbmQodlV2Lnh5KSpuYW1vdW50KmJsdXI7XCIsXG5cblx0XHRcdFwiLy8gZ2V0dGluZyBibHVyIHggYW5kIHkgc3RlcCBmYWN0b3JcIixcblxuXHRcdFx0XCJmbG9hdCB3ID0gKDEuMC93aWR0aCkqYmx1ciptYXhibHVyK25vaXNlLng7XCIsXG5cdFx0XHRcImZsb2F0IGggPSAoMS4wL2hlaWdodCkqYmx1ciptYXhibHVyK25vaXNlLnk7XCIsXG5cblx0XHRcdFwiLy8gY2FsY3VsYXRpb24gb2YgZmluYWwgY29sb3JcIixcblxuXHRcdFx0XCJ2ZWMzIGNvbCA9IHZlYzMoMC4wKTtcIixcblxuXHRcdFx0XCJpZihibHVyIDwgMC4wNSkge1wiLFxuXHRcdFx0XHRcIi8vc29tZSBvcHRpbWl6YXRpb24gdGhpbmd5XCIsXG5cdFx0XHRcdFwiY29sID0gdGV4dHVyZTJEKHRDb2xvciwgdlV2Lnh5KS5yZ2I7XCIsXG5cdFx0XHRcIn0gZWxzZSB7XCIsXG5cdFx0XHRcdFwiY29sID0gdGV4dHVyZTJEKHRDb2xvciwgdlV2Lnh5KS5yZ2I7XCIsXG5cdFx0XHRcdFwiZmxvYXQgcyA9IDEuMDtcIixcblx0XHRcdFx0XCJpbnQgcmluZ3NhbXBsZXM7XCIsXG5cblx0XHRcdFx0XCJmb3IgKGludCBpID0gMTsgaSA8PSByaW5nczsgaSsrKSB7XCIsXG5cdFx0XHRcdFx0XCIvKnVuYm94c3RhcnQqL1wiLFxuXHRcdFx0XHRcdFwicmluZ3NhbXBsZXMgPSBpICogc2FtcGxlcztcIixcblxuXHRcdFx0XHRcdFwiZm9yIChpbnQgaiA9IDAgOyBqIDwgbWF4cmluZ3NhbXBsZXMgOyBqKyspIHtcIixcblx0XHRcdFx0XHRcdFwiaWYgKGogPj0gcmluZ3NhbXBsZXMpIGJyZWFrO1wiLFxuXHRcdFx0XHRcdFx0XCJzICs9IGdhdGhlcihmbG9hdChpKSwgZmxvYXQoaiksIHJpbmdzYW1wbGVzLCBjb2wsIHcsIGgsIGJsdXIpO1wiLFxuXHRcdFx0XHRcdFwifVwiLFxuXHRcdFx0XHRcdFwiLyp1bmJveGVuZCovXCIsXG5cdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFwiY29sIC89IHM7IC8vZGl2aWRlIGJ5IHNhbXBsZSBjb3VudFwiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiaWYgKHNob3dGb2N1cykge1wiLFxuXHRcdFx0XHRcImNvbCA9IGRlYnVnRm9jdXMoY29sLCBibHVyLCBkZXB0aCk7XCIsXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJpZiAodmlnbmV0dGluZykge1wiLFxuXHRcdFx0XHRcImNvbCAqPSB2aWduZXR0ZSgpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiA9IGNvbDtcIixcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7XCIsXG5cdFx0XCJ9IFwiXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgdGFwaW8gLyBodHRwOi8vdGFwaW8uZ2l0aHViLmNvbS9cbiAqXG4gKiBCcmlnaHRuZXNzIGFuZCBjb250cmFzdCBhZGp1c3RtZW50XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qc1xuICogYnJpZ2h0bmVzczogLTEgdG8gMSAoLTEgaXMgc29saWQgYmxhY2ssIDAgaXMgbm8gY2hhbmdlLCBhbmQgMSBpcyBzb2xpZCB3aGl0ZSlcbiAqIGNvbnRyYXN0OiAtMSB0byAxICgtMSBpcyBzb2xpZCBncmF5LCAwIGlzIG5vIGNoYW5nZSwgYW5kIDEgaXMgbWF4aW11bSBjb250cmFzdClcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiAgIHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJicmlnaHRuZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH0sXG5cdFx0XCJjb250cmFzdFwiOiAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGJyaWdodG5lc3M7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGNvbnRyYXN0O1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiArPSBicmlnaHRuZXNzO1wiLFxuXG5cdFx0XHRcImlmIChjb250cmFzdCA+IDAuMCkge1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgPSAoZ2xfRnJhZ0NvbG9yLnJnYiAtIDAuNSkgLyAoMS4wIC0gY29udHJhc3QpICsgMC41O1wiLFxuXHRcdFx0XCJ9IGVsc2Uge1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgPSAoZ2xfRnJhZ0NvbG9yLnJnYiAtIDAuNSkgKiAoMS4wICsgY29udHJhc3QpICsgMC41O1wiLFxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIENvbG9yaWZ5IHNoYWRlclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJjb2xvclwiOiAgICB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidmVjNCB0ZXhlbCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxuXG5cdFx0XHRcInZlYzMgbHVtYSA9IHZlYzMoIDAuMjk5LCAwLjU4NywgMC4xMTQgKTtcIixcblx0XHRcdFwiZmxvYXQgdiA9IGRvdCggdGV4ZWwueHl6LCBsdW1hICk7XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdiAqIGNvbG9yLCB0ZXhlbC53ICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIENvbnZvbHV0aW9uIHNoYWRlclxuICogcG9ydGVkIGZyb20gbzNkIHNhbXBsZSB0byBXZWJHTCAvIEdMU0xcbiAqIGh0dHA6Ly9vM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NhbXBsZXMvY29udm9sdXRpb24uaHRtbFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdGRlZmluZXM6IHtcblxuXHRcdFwiS0VSTkVMX1NJWkVfRkxPQVRcIjogXCIyNS4wXCIsXG5cdFx0XCJLRVJORUxfU0laRV9JTlRcIjogXCIyNVwiLFxuXG5cdH0sXG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogICAgICAgIHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJ1SW1hZ2VJbmNyZW1lbnRcIjogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMC4wMDE5NTMxMjUsIDAuMCApIH0sXG5cdFx0XCJjS2VybmVsXCI6ICAgICAgICAgeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDAuMDAxOTUzMTI1LCAwLjAgKSB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSB2ZWMyIHVJbWFnZUluY3JlbWVudDtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2IC0gKCAoIEtFUk5FTF9TSVpFX0ZMT0FUIC0gMS4wICkgLyAyLjAgKSAqIHVJbWFnZUluY3JlbWVudDtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBjS2VybmVsWyBLRVJORUxfU0laRV9JTlQgXTtcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIHZlYzIgdUltYWdlSW5jcmVtZW50O1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidmVjMiBpbWFnZUNvb3JkID0gdlV2O1wiLFxuXHRcdFx0XCJ2ZWM0IHN1bSA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgS0VSTkVMX1NJWkVfSU5UOyBpICsrICkge1wiLFxuXG5cdFx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIGltYWdlQ29vcmQgKSAqIGNLZXJuZWxbIGkgXTtcIixcblx0XHRcdFx0XCJpbWFnZUNvb3JkICs9IHVJbWFnZUluY3JlbWVudDtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gc3VtO1wiLFxuXG5cdFx0XCJ9XCJcblxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRidWlsZEtlcm5lbDogZnVuY3Rpb24gKCBzaWdtYSApIHtcblxuXHRcdC8vIFdlIGxvcCBvZmYgdGhlIHNxcnQoMiAqIHBpKSAqIHNpZ21hIHRlcm0sIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIG5vcm1hbGl6ZSBhbnl3YXkuXG5cblx0XHRmdW5jdGlvbiBnYXVzcyggeCwgc2lnbWEgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmV4cCggLSAoIHggKiB4ICkgLyAoIDIuMCAqIHNpZ21hICogc2lnbWEgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGksIHZhbHVlcywgc3VtLCBoYWxmV2lkdGgsIGtNYXhLZXJuZWxTaXplID0gMjUsIGtlcm5lbFNpemUgPSAyICogTWF0aC5jZWlsKCBzaWdtYSAqIDMuMCApICsgMTtcblxuXHRcdGlmICgga2VybmVsU2l6ZSA+IGtNYXhLZXJuZWxTaXplICkga2VybmVsU2l6ZSA9IGtNYXhLZXJuZWxTaXplO1xuXHRcdGhhbGZXaWR0aCA9ICgga2VybmVsU2l6ZSAtIDEgKSAqIDAuNTtcblxuXHRcdHZhbHVlcyA9IG5ldyBBcnJheSgga2VybmVsU2l6ZSApO1xuXHRcdHN1bSA9IDAuMDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGtlcm5lbFNpemU7ICsrIGkgKSB7XG5cblx0XHRcdHZhbHVlc1sgaSBdID0gZ2F1c3MoIGkgLSBoYWxmV2lkdGgsIHNpZ21hICk7XG5cdFx0XHRzdW0gKz0gdmFsdWVzWyBpIF07XG5cblx0XHR9XG5cblx0XHQvLyBub3JtYWxpemUgdGhlIGtlcm5lbFxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBrZXJuZWxTaXplOyArKyBpICkgdmFsdWVzWyBpIF0gLz0gc3VtO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblxuXHR9XG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRnVsbC1zY3JlZW4gdGV4dHVyZWQgcXVhZCBzaGFkZXJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwib3BhY2l0eVwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidmVjNCB0ZXhlbCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBvcGFjaXR5ICogdGV4ZWw7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGZlbGl4dHVybmVyIC8gaHR0cDovL2FpcnRpZ2h0LmNjL1xuICpcbiAqIFJHQiBTaGlmdCBTaGFkZXJcbiAqIFNoaWZ0cyByZWQgYW5kIGJsdWUgY2hhbm5lbHMgZnJvbSBjZW50ZXIgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuICogUG9ydGVkIGZyb20gaHR0cDovL2tyaXNzLmN4L3RvbS8yMDA5LzA1L3JnYi1zaGlmdC9cbiAqIGJ5IFRvbSBCdXR0ZXJ3b3J0aCAvIGh0dHA6Ly9rcmlzcy5jeC90b20vXG4gKlxuICogYW1vdW50OiBzaGlmdCBkaXN0YW5jZSAoMSBpcyB3aWR0aCBvZiBpbnB1dClcbiAqIGFuZ2xlOiBzaGlmdCBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjpcdFx0eyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwvL2RpZmZ1c2UgdGV4dHVyZVxuXHRcdFwidERpc3BcIjpcdFx0eyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwvL2Rpc3BsYWNlbWVudCB0ZXh0dXJlIGZvciBkaWdpdGFsIGdsaXRjaCBzcXVhcmVzXG5cdFx0XCJieXBcIjpcdFx0XHR7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMSB9LC8vYXBwbHkgdGhlIGdsaXRjaCA/XG5cdFx0XCJhbW91bnRcIjpcdFx0eyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDggfSxcblx0XHRcImFuZ2xlXCI6XHRcdHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAyIH0sXG5cdFx0XCJzZWVkXCI6XHRcdFx0eyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDIgfSxcblx0XHRcInNlZWRfeFwiOlx0XHR7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMiB9LC8vLTEsMVxuXHRcdFwic2VlZF95XCI6XHRcdHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAyIH0sLy8tMSwxXG5cdFx0XCJkaXN0b3J0aW9uX3hcIjpcdHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjUgfSxcblx0XHRcImRpc3RvcnRpb25feVwiOlx0eyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNiB9LFxuXHRcdFwiY29sX3NcIjpcdFx0eyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDUgfVxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFwifVwiXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXHRcdFwidW5pZm9ybSBpbnQgYnlwO1wiLC8vc2hvdWxkIHdlIGFwcGx5IHRoZSBnbGl0Y2ggP1xuXHRcdFxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcDtcIixcblx0XHRcblx0XHRcInVuaWZvcm0gZmxvYXQgYW1vdW50O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBhbmdsZTtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgc2VlZDtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgc2VlZF94O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBzZWVkX3k7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGRpc3RvcnRpb25feDtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvbl95O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBjb2xfcztcIixcblx0XHRcdFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblx0XHRcblx0XHRcblx0XHRcImZsb2F0IHJhbmQodmVjMiBjbyl7XCIsXG5cdFx0XHRcInJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XCIsXG5cdFx0XCJ9XCIsXG5cdFx0XHRcdFxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXHRcdFx0XCJpZihieXA8MSkge1wiLFxuXHRcdFx0XHRcInZlYzIgcCA9IHZVdjtcIixcblx0XHRcdFx0XCJmbG9hdCB4cyA9IGZsb29yKGdsX0ZyYWdDb29yZC54IC8gMC41KTtcIixcblx0XHRcdFx0XCJmbG9hdCB5cyA9IGZsb29yKGdsX0ZyYWdDb29yZC55IC8gMC41KTtcIixcblx0XHRcdFx0Ly9iYXNlZCBvbiBzdGFmZmFudGFucyBnbGl0Y2ggc2hhZGVyIGZvciB1bml0eSBodHRwczovL2dpdGh1Yi5jb20vc3RhZmZhbnRhbi91bml0eWdsaXRjaFxuXHRcdFx0XHRcInZlYzQgbm9ybWFsID0gdGV4dHVyZTJEICh0RGlzcCwgcCpzZWVkKnNlZWQpO1wiLFxuXHRcdFx0XHRcImlmKHAueTxkaXN0b3J0aW9uX3grY29sX3MgJiYgcC55PmRpc3RvcnRpb25feC1jb2xfcypzZWVkKSB7XCIsXG5cdFx0XHRcdFx0XCJpZihzZWVkX3g+MC4pe1wiLFxuXHRcdFx0XHRcdFx0XCJwLnkgPSAxLiAtIChwLnkgKyBkaXN0b3J0aW9uX3kpO1wiLFxuXHRcdFx0XHRcdFwifVwiLFxuXHRcdFx0XHRcdFwiZWxzZSB7XCIsXG5cdFx0XHRcdFx0XHRcInAueSA9IGRpc3RvcnRpb25feTtcIixcblx0XHRcdFx0XHRcIn1cIixcblx0XHRcdFx0XCJ9XCIsXG5cdFx0XHRcdFwiaWYocC54PGRpc3RvcnRpb25feStjb2xfcyAmJiBwLng+ZGlzdG9ydGlvbl95LWNvbF9zKnNlZWQpIHtcIixcblx0XHRcdFx0XHRcImlmKHNlZWRfeT4wLil7XCIsXG5cdFx0XHRcdFx0XHRcInAueD1kaXN0b3J0aW9uX3g7XCIsXG5cdFx0XHRcdFx0XCJ9XCIsXG5cdFx0XHRcdFx0XCJlbHNlIHtcIixcblx0XHRcdFx0XHRcdFwicC54ID0gMS4gLSAocC54ICsgZGlzdG9ydGlvbl94KTtcIixcblx0XHRcdFx0XHRcIn1cIixcblx0XHRcdFx0XCJ9XCIsXG5cdFx0XHRcdFwicC54Kz1ub3JtYWwueCpzZWVkX3gqKHNlZWQvNS4pO1wiLFxuXHRcdFx0XHRcInAueSs9bm9ybWFsLnkqc2VlZF95KihzZWVkLzUuKTtcIixcblx0XHRcdFx0Ly9iYXNlIGZyb20gUkdCIHNoaWZ0IHNoYWRlclxuXHRcdFx0XHRcInZlYzIgb2Zmc2V0ID0gYW1vdW50ICogdmVjMiggY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSk7XCIsXG5cdFx0XHRcdFwidmVjNCBjciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgcCArIG9mZnNldCk7XCIsXG5cdFx0XHRcdFwidmVjNCBjZ2EgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHApO1wiLFxuXHRcdFx0XHRcInZlYzQgY2IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHAgLSBvZmZzZXQpO1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoY3IuciwgY2dhLmcsIGNiLmIsIGNnYS5hKTtcIixcblx0XHRcdFx0Ly9hZGQgbm9pc2Vcblx0XHRcdFx0XCJ2ZWM0IHNub3cgPSAyMDAuKmFtb3VudCp2ZWM0KHJhbmQodmVjMih4cyAqIHNlZWQseXMgKiBzZWVkKjUwLikpKjAuMik7XCIsXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yKyBzbm93O1wiLFxuXHRcdFx0XCJ9XCIsXG5cdFx0XHRcImVsc2Uge1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvcj10ZXh0dXJlMkQgKHREaWZmdXNlLCB2VXYpO1wiLFxuXHRcdFx0XCJ9XCIsXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBEb3Qgc2NyZWVuIHNoYWRlclxuICogYmFzZWQgb24gZ2xmeC5qcyBzZXBpYSBzaGFkZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzXG4gKi9cblxubW9kdWxlLmV4cG9ydHM9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidFNpemVcIjogICAgeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMjU2LCAyNTYgKSB9LFxuXHRcdFwiY2VudGVyXCI6ICAgeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMC41LCAwLjUgKSB9LFxuXHRcdFwiYW5nbGVcIjogICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuNTcgfSxcblx0XHRcInNjYWxlXCI6ICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSB2ZWMyIGNlbnRlcjtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgYW5nbGU7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXHRcdFwidW5pZm9ybSB2ZWMyIHRTaXplO1wiLFxuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwiZmxvYXQgcGF0dGVybigpIHtcIixcblxuXHRcdFx0XCJmbG9hdCBzID0gc2luKCBhbmdsZSApLCBjID0gY29zKCBhbmdsZSApO1wiLFxuXG5cdFx0XHRcInZlYzIgdGV4ID0gdlV2ICogdFNpemUgLSBjZW50ZXI7XCIsXG5cdFx0XHRcInZlYzIgcG9pbnQgPSB2ZWMyKCBjICogdGV4LnggLSBzICogdGV4LnksIHMgKiB0ZXgueCArIGMgKiB0ZXgueSApICogc2NhbGU7XCIsXG5cblx0XHRcdFwicmV0dXJuICggc2luKCBwb2ludC54ICkgKiBzaW4oIHBvaW50LnkgKSApICogNC4wO1wiLFxuXG5cdFx0XCJ9XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG5cblx0XHRcdFwiZmxvYXQgYXZlcmFnZSA9ICggY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iICkgLyAzLjA7XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkgKSwgY29sb3IuYSApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODUgfCBodHRwczovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIEVkZ2UgRGV0ZWN0aW9uIFNoYWRlciB1c2luZyBTb2JlbCBmaWx0ZXJcbiAqIEJhc2VkIG9uIGh0dHA6Ly9yYXN0ZXJncmlkLmNvbS9ibG9nLzIwMTEvMDEvZnJlaS1jaGVuLWVkZ2UtZGV0ZWN0b3JcbiAqXG4gKiBhc3BlY3Q6IHZlYzIgb2YgKDEvd2lkdGgsIDEvaGVpZ2h0KVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJhc3BlY3RcIjogICAgeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggNTEyLCA1MTIgKSB9LFxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblx0XHRcInVuaWZvcm0gdmVjMiBhc3BlY3Q7XCIsXG5cblxuXHRcdFwidmVjMiB0ZXhlbCA9IHZlYzIoMS4wIC8gYXNwZWN0LngsIDEuMCAvIGFzcGVjdC55KTtcIixcblxuXHRcdFwibWF0MyBHWzJdO1wiLFxuXG5cdFx0XCJjb25zdCBtYXQzIGcwID0gbWF0MyggMS4wLCAyLjAsIDEuMCwgMC4wLCAwLjAsIDAuMCwgLTEuMCwgLTIuMCwgLTEuMCApO1wiLFxuXHRcdFwiY29uc3QgbWF0MyBnMSA9IG1hdDMoIDEuMCwgMC4wLCAtMS4wLCAyLjAsIDAuMCwgLTIuMCwgMS4wLCAwLjAsIC0xLjAgKTtcIixcblxuXG5cdFx0XCJ2b2lkIG1haW4odm9pZClcIixcblx0XHRcIntcIixcblx0XHRcdFwibWF0MyBJO1wiLFxuXHRcdFx0XCJmbG9hdCBjbnZbMl07XCIsXG5cdFx0XHRcInZlYzMgc2FtcGxlO1wiLFxuXG5cdFx0XHRcIkdbMF0gPSBnMDtcIixcblx0XHRcdFwiR1sxXSA9IGcxO1wiLFxuXG5cdFx0XHQvKiBmZXRjaCB0aGUgM3gzIG5laWdoYm91cmhvb2QgYW5kIHVzZSB0aGUgUkdCIHZlY3RvcidzIGxlbmd0aCBhcyBpbnRlbnNpdHkgdmFsdWUgKi9cblx0XHRcdFwiZm9yIChmbG9hdCBpPTAuMDsgaTwzLjA7IGkrKylcIixcblx0XHRcdFwiZm9yIChmbG9hdCBqPTAuMDsgajwzLjA7IGorKykge1wiLFxuXHRcdFx0XHRcInNhbXBsZSA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiArIHRleGVsICogdmVjMihpLTEuMCxqLTEuMCkgKS5yZ2I7XCIsXG5cdFx0XHRcdFwiSVtpbnQoaSldW2ludChqKV0gPSBsZW5ndGgoc2FtcGxlKTtcIixcblx0XHRcdFwifVwiLFxuXG5cdFx0XHQvKiBjYWxjdWxhdGUgdGhlIGNvbnZvbHV0aW9uIHZhbHVlcyBmb3IgYWxsIHRoZSBtYXNrcyAqL1xuXHRcdFx0XCJmb3IgKGludCBpPTA7IGk8MjsgaSsrKSB7XCIsXG5cdFx0XHRcdFwiZmxvYXQgZHAzID0gZG90KEdbaV1bMF0sIElbMF0pICsgZG90KEdbaV1bMV0sIElbMV0pICsgZG90KEdbaV1bMl0sIElbMl0pO1wiLFxuXHRcdFx0XHRcImNudltpXSA9IGRwMyAqIGRwMzsgXCIsXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuNSAqIHNxcnQoY252WzBdKmNudlswXStjbnZbMV0qY252WzFdKSk7XCIsXG5cdFx0XCJ9IFwiLFxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBkYXZpZGVkYyAvIGh0dHA6Ly93d3cuc2tldGNocGF0Y2gubmV0L1xuICpcbiAqIE5WSURJQSBGWEFBIGJ5IFRpbW90aHkgTG90dGVzXG4gKiBodHRwOi8vdGltb3RoeWxvdHRlcy5ibG9nc3BvdC5jb20vMjAxMS8wNi9meGFhMy1zb3VyY2UtcmVsZWFzZWQuaHRtbFxuICogLSBXZWJHTCBwb3J0IGJ5IEBzdXBlcmVnZ2JlcnRcbiAqIGh0dHA6Ly93d3cuZ2xnZS5vcmcvZGVtb3MvZnhhYS9cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiAgIHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJyZXNvbHV0aW9uXCI6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEgLyAxMDI0LCAxIC8gNTEyICkgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblx0XHRcInVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1wiLFxuXG5cdFx0XCIjZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvMTI4LjApXCIsXG5cdFx0XCIjZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAvOC4wKVwiLFxuXHRcdFwiI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIC0xLjAsIC0xLjAgKSApICogcmVzb2x1dGlvbiApLnh5ejtcIixcblx0XHRcdFwidmVjMyByZ2JORSA9IHRleHR1cmUyRCggdERpZmZ1c2UsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMS4wLCAtMS4wICkgKSAqIHJlc29sdXRpb24gKS54eXo7XCIsXG5cdFx0XHRcInZlYzMgcmdiU1cgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIC0xLjAsIDEuMCApICkgKiByZXNvbHV0aW9uICkueHl6O1wiLFxuXHRcdFx0XCJ2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgKCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKCAxLjAsIDEuMCApICkgKiByZXNvbHV0aW9uICkueHl6O1wiLFxuXHRcdFx0XCJ2ZWM0IHJnYmFNICA9IHRleHR1cmUyRCggdERpZmZ1c2UsICBnbF9GcmFnQ29vcmQueHkgICogcmVzb2x1dGlvbiApO1wiLFxuXHRcdFx0XCJ2ZWMzIHJnYk0gID0gcmdiYU0ueHl6O1wiLFxuXHRcdFx0XCJ2ZWMzIGx1bWEgPSB2ZWMzKCAwLjI5OSwgMC41ODcsIDAuMTE0ICk7XCIsXG5cblx0XHRcdFwiZmxvYXQgbHVtYU5XID0gZG90KCByZ2JOVywgbHVtYSApO1wiLFxuXHRcdFx0XCJmbG9hdCBsdW1hTkUgPSBkb3QoIHJnYk5FLCBsdW1hICk7XCIsXG5cdFx0XHRcImZsb2F0IGx1bWFTVyA9IGRvdCggcmdiU1csIGx1bWEgKTtcIixcblx0XHRcdFwiZmxvYXQgbHVtYVNFID0gZG90KCByZ2JTRSwgbHVtYSApO1wiLFxuXHRcdFx0XCJmbG9hdCBsdW1hTSAgPSBkb3QoIHJnYk0sICBsdW1hICk7XCIsXG5cdFx0XHRcImZsb2F0IGx1bWFNaW4gPSBtaW4oIGx1bWFNLCBtaW4oIG1pbiggbHVtYU5XLCBsdW1hTkUgKSwgbWluKCBsdW1hU1csIGx1bWFTRSApICkgKTtcIixcblx0XHRcdFwiZmxvYXQgbHVtYU1heCA9IG1heCggbHVtYU0sIG1heCggbWF4KCBsdW1hTlcsIGx1bWFORSkgLCBtYXgoIGx1bWFTVywgbHVtYVNFICkgKSApO1wiLFxuXG5cdFx0XHRcInZlYzIgZGlyO1wiLFxuXHRcdFx0XCJkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XCIsXG5cdFx0XHRcImRpci55ID0gICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcIixcblxuXHRcdFx0XCJmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoICggbHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFICkgKiAoIDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwgKSwgRlhBQV9SRURVQ0VfTUlOICk7XCIsXG5cblx0XHRcdFwiZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKCBtaW4oIGFicyggZGlyLnggKSwgYWJzKCBkaXIueSApICkgKyBkaXJSZWR1Y2UgKTtcIixcblx0XHRcdFwiZGlyID0gbWluKCB2ZWMyKCBGWEFBX1NQQU5fTUFYLCAgRlhBQV9TUEFOX01BWCksXCIsXG5cdFx0XHRcdCAgXCJtYXgoIHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcIixcblx0XHRcdFx0XHRcdFwiZGlyICogcmNwRGlyTWluKSkgKiByZXNvbHV0aW9uO1wiLFxuXHRcdFx0XCJ2ZWM0IHJnYkEgPSAoMS4wLzIuMCkgKiAoXCIsXG4gICAgICAgIFx0XCJ0ZXh0dXJlMkQodERpZmZ1c2UsICBnbF9GcmFnQ29vcmQueHkgICogcmVzb2x1dGlvbiArIGRpciAqICgxLjAvMy4wIC0gMC41KSkgK1wiLFxuXHRcdFx0XCJ0ZXh0dXJlMkQodERpZmZ1c2UsICBnbF9GcmFnQ29vcmQueHkgICogcmVzb2x1dGlvbiArIGRpciAqICgyLjAvMy4wIC0gMC41KSkpO1wiLFxuICAgIFx0XHRcInZlYzQgcmdiQiA9IHJnYkEgKiAoMS4wLzIuMCkgKyAoMS4wLzQuMCkgKiAoXCIsXG5cdFx0XHRcInRleHR1cmUyRCh0RGlmZnVzZSwgIGdsX0ZyYWdDb29yZC54eSAgKiByZXNvbHV0aW9uICsgZGlyICogKDAuMC8zLjAgLSAwLjUpKSArXCIsXG4gICAgICBcdFx0XCJ0ZXh0dXJlMkQodERpZmZ1c2UsICBnbF9GcmFnQ29vcmQueHkgICogcmVzb2x1dGlvbiArIGRpciAqICgzLjAvMy4wIC0gMC41KSkpO1wiLFxuICAgIFx0XHRcImZsb2F0IGx1bWFCID0gZG90KHJnYkIsIHZlYzQobHVtYSwgMC4wKSk7XCIsXG5cblx0XHRcdFwiaWYgKCAoIGx1bWFCIDwgbHVtYU1pbiApIHx8ICggbHVtYUIgPiBsdW1hTWF4ICkgKSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSByZ2JBO1wiLFxuXG5cdFx0XHRcIn0gZWxzZSB7XCIsXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gcmdiQjtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZpbG0gZ3JhaW4gJiBzY2FubGluZXMgc2hhZGVyXG4gKlxuICogLSBwb3J0ZWQgZnJvbSBITFNMIHRvIFdlYkdMIC8gR0xTTFxuICogaHR0cDovL3d3dy50cnVldmlzaW9uM2QuY29tL2ZvcnVtcy9zaG93Y2FzZS9zdGF0aWNub2lzZV9jb2xvcmJsYWNrd2hpdGVfc2NhbmxpbmVfc2hhZGVycy10MTg2OTguMC5odG1sXG4gKlxuICogU2NyZWVuIFNwYWNlIFN0YXRpYyBQb3N0cHJvY2Vzc29yXG4gKlxuICogUHJvZHVjZXMgYW4gYW5hbG9ndWUgbm9pc2Ugb3ZlcmxheSBzaW1pbGFyIHRvIGEgZmlsbSBncmFpbiAvIFRWIHN0YXRpY1xuICpcbiAqIE9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGFuZCBub2lzZSBhbGdvcml0aG1cbiAqIFBhdCAnSGF3dGhvcm5lJyBTaGVhcm9uXG4gKlxuICogT3B0aW1pemVkIHNjYW5saW5lcyArIG5vaXNlIHZlcnNpb24gd2l0aCBpbnRlbnNpdHkgc2NhbGluZ1xuICogR2VvcmcgJ0xldmlhdGhhbicgU3RlaW5yb2hkZXJcbiAqXG4gKiBUaGlzIHZlcnNpb24gaXMgcHJvdmlkZWQgdW5kZXIgYSBDcmVhdGl2ZSBDb21tb25zIEF0dHJpYnV0aW9uIDMuMCBMaWNlbnNlXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS8zLjAvXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogICB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidGltZVwiOiAgICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wIH0sXG5cdFx0XCJuSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjUgfSxcblx0XHRcInNJbnRlbnNpdHlcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDUgfSxcblx0XHRcInNDb3VudFwiOiAgICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDQwOTYgfSxcblx0XHRcImdyYXlzY2FsZVwiOiAgeyB0eXBlOiBcImlcIiwgdmFsdWU6IDEgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdC8vIGNvbnRyb2wgcGFyYW1ldGVyXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHRpbWU7XCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBncmF5c2NhbGU7XCIsXG5cblx0XHQvLyBub2lzZSBlZmZlY3QgaW50ZW5zaXR5IHZhbHVlICgwID0gbm8gZWZmZWN0LCAxID0gZnVsbCBlZmZlY3QpXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IG5JbnRlbnNpdHk7XCIsXG5cblx0XHQvLyBzY2FubGluZXMgZWZmZWN0IGludGVuc2l0eSB2YWx1ZSAoMCA9IG5vIGVmZmVjdCwgMSA9IGZ1bGwgZWZmZWN0KVxuXHRcdFwidW5pZm9ybSBmbG9hdCBzSW50ZW5zaXR5O1wiLFxuXG5cdFx0Ly8gc2NhbmxpbmVzIGVmZmVjdCBjb3VudCB2YWx1ZSAoMCA9IG5vIGVmZmVjdCwgNDA5NiA9IGZ1bGwgZWZmZWN0KVxuXHRcdFwidW5pZm9ybSBmbG9hdCBzQ291bnQ7XCIsXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdC8vIHNhbXBsZSB0aGUgc291cmNlXG5cdFx0XHRcInZlYzQgY1RleHR1cmVTY3JlZW4gPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblxuXHRcdFx0Ly8gbWFrZSBzb21lIG5vaXNlXG5cdFx0XHRcImZsb2F0IHggPSB2VXYueCAqIHZVdi55ICogdGltZSAqICAxMDAwLjA7XCIsXG5cdFx0XHRcInggPSBtb2QoIHgsIDEzLjAgKSAqIG1vZCggeCwgMTIzLjAgKTtcIixcblx0XHRcdFwiZmxvYXQgZHggPSBtb2QoIHgsIDAuMDEgKTtcIixcblxuXHRcdFx0Ly8gYWRkIG5vaXNlXG5cdFx0XHRcInZlYzMgY1Jlc3VsdCA9IGNUZXh0dXJlU2NyZWVuLnJnYiArIGNUZXh0dXJlU2NyZWVuLnJnYiAqIGNsYW1wKCAwLjEgKyBkeCAqIDEwMC4wLCAwLjAsIDEuMCApO1wiLFxuXG5cdFx0XHQvLyBnZXQgdXMgYSBzaW5lIGFuZCBjb3NpbmVcblx0XHRcdFwidmVjMiBzYyA9IHZlYzIoIHNpbiggdlV2LnkgKiBzQ291bnQgKSwgY29zKCB2VXYueSAqIHNDb3VudCApICk7XCIsXG5cblx0XHRcdC8vIGFkZCBzY2FubGluZXNcblx0XHRcdFwiY1Jlc3VsdCArPSBjVGV4dHVyZVNjcmVlbi5yZ2IgKiB2ZWMzKCBzYy54LCBzYy55LCBzYy54ICkgKiBzSW50ZW5zaXR5O1wiLFxuXG5cdFx0XHQvLyBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHNvdXJjZSBhbmQgcmVzdWx0IGJ5IGludGVuc2l0eVxuXHRcdFx0XCJjUmVzdWx0ID0gY1RleHR1cmVTY3JlZW4ucmdiICsgY2xhbXAoIG5JbnRlbnNpdHksIDAuMCwxLjAgKSAqICggY1Jlc3VsdCAtIGNUZXh0dXJlU2NyZWVuLnJnYiApO1wiLFxuXG5cdFx0XHQvLyBjb252ZXJ0IHRvIGdyYXlzY2FsZSBpZiBkZXNpcmVkXG5cdFx0XHRcImlmKCBncmF5c2NhbGUgKSB7XCIsXG5cblx0XHRcdFx0XCJjUmVzdWx0ID0gdmVjMyggY1Jlc3VsdC5yICogMC4zICsgY1Jlc3VsdC5nICogMC41OSArIGNSZXN1bHQuYiAqIDAuMTEgKTtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gIHZlYzQoIGNSZXN1bHQsIGNUZXh0dXJlU2NyZWVuLmEgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRm9jdXMgc2hhZGVyXG4gKiBiYXNlZCBvbiBQYWludEVmZmVjdCBwb3N0cHJvY2VzcyBmcm9tIHJvLm1lXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvMy1kcmVhbXMtb2YtYmxhY2svc291cmNlL2Jyb3dzZS9kZXBsb3kvanMvZWZmZWN0cy9QYWludEVmZmVjdC5qc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zIDoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiAgICAgICB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwic2NyZWVuV2lkdGhcIjogICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEwMjQgfSxcblx0XHRcInNjcmVlbkhlaWdodFwiOiAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxMDI0IH0sXG5cdFx0XCJzYW1wbGVEaXN0YW5jZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45NCB9LFxuXHRcdFwid2F2ZUZhY3RvclwiOiAgICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAxMjUgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgc2NyZWVuSGVpZ2h0O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBzYW1wbGVEaXN0YW5jZTtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgd2F2ZUZhY3RvcjtcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IGNvbG9yLCBvcmcsIHRtcCwgYWRkO1wiLFxuXHRcdFx0XCJmbG9hdCBzYW1wbGVfZGlzdCwgZjtcIixcblx0XHRcdFwidmVjMiB2aW47XCIsXG5cdFx0XHRcInZlYzIgdXYgPSB2VXY7XCIsXG5cblx0XHRcdFwiYWRkID0gY29sb3IgPSBvcmcgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB1diApO1wiLFxuXG5cdFx0XHRcInZpbiA9ICggdXYgLSB2ZWMyKCAwLjUgKSApICogdmVjMiggMS40ICk7XCIsXG5cdFx0XHRcInNhbXBsZV9kaXN0ID0gZG90KCB2aW4sIHZpbiApICogMi4wO1wiLFxuXG5cdFx0XHRcImYgPSAoIHdhdmVGYWN0b3IgKiAxMDAuMCArIHNhbXBsZV9kaXN0ICkgKiBzYW1wbGVEaXN0YW5jZSAqIDQuMDtcIixcblxuXHRcdFx0XCJ2ZWMyIHNhbXBsZVNpemUgPSB2ZWMyKCAgMS4wIC8gc2NyZWVuV2lkdGgsIDEuMCAvIHNjcmVlbkhlaWdodCApICogdmVjMiggZiApO1wiLFxuXG5cdFx0XHRcImFkZCArPSB0bXAgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB1diArIHZlYzIoIDAuMTExOTY0LCAwLjk5MzcxMiApICogc2FtcGxlU2l6ZSApO1wiLFxuXHRcdFx0XCJpZiggdG1wLmIgPCBjb2xvci5iICkgY29sb3IgPSB0bXA7XCIsXG5cblx0XHRcdFwiYWRkICs9IHRtcCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHV2ICsgdmVjMiggMC44NDY3MjQsIDAuNTMyMDMyICkgKiBzYW1wbGVTaXplICk7XCIsXG5cdFx0XHRcImlmKCB0bXAuYiA8IGNvbG9yLmIgKSBjb2xvciA9IHRtcDtcIixcblxuXHRcdFx0XCJhZGQgKz0gdG1wID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdXYgKyB2ZWMyKCAwLjk0Mzg4MywgLTAuMzMwMjc5ICkgKiBzYW1wbGVTaXplICk7XCIsXG5cdFx0XHRcImlmKCB0bXAuYiA8IGNvbG9yLmIgKSBjb2xvciA9IHRtcDtcIixcblxuXHRcdFx0XCJhZGQgKz0gdG1wID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdXYgKyB2ZWMyKCAwLjMzMDI3OSwgLTAuOTQzODgzICkgKiBzYW1wbGVTaXplICk7XCIsXG5cdFx0XHRcImlmKCB0bXAuYiA8IGNvbG9yLmIgKSBjb2xvciA9IHRtcDtcIixcblxuXHRcdFx0XCJhZGQgKz0gdG1wID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdXYgKyB2ZWMyKCAtMC41MzIwMzIsIC0wLjg0NjcyNCApICogc2FtcGxlU2l6ZSApO1wiLFxuXHRcdFx0XCJpZiggdG1wLmIgPCBjb2xvci5iICkgY29sb3IgPSB0bXA7XCIsXG5cblx0XHRcdFwiYWRkICs9IHRtcCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHV2ICsgdmVjMiggLTAuOTkzNzEyLCAtMC4xMTE5NjQgKSAqIHNhbXBsZVNpemUgKTtcIixcblx0XHRcdFwiaWYoIHRtcC5iIDwgY29sb3IuYiApIGNvbG9yID0gdG1wO1wiLFxuXG5cdFx0XHRcImFkZCArPSB0bXAgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB1diArIHZlYzIoIC0wLjcwNzEwNywgMC43MDcxMDcgKSAqIHNhbXBsZVNpemUgKTtcIixcblx0XHRcdFwiaWYoIHRtcC5iIDwgY29sb3IuYiApIGNvbG9yID0gdG1wO1wiLFxuXG5cdFx0XHRcImNvbG9yID0gY29sb3IgKiB2ZWM0KCAyLjAgKSAtICggYWRkIC8gdmVjNCggOC4wICkgKTtcIixcblx0XHRcdFwiY29sb3IgPSBjb2xvciArICggYWRkIC8gdmVjNCggOC4wICkgLSBjb2xvciApICogKCB2ZWM0KCAxLjAgKSAtIHZlYzQoIHNhbXBsZV9kaXN0ICogMC41ICkgKTtcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvci5yZ2IgKiBjb2xvci5yZ2IgKiB2ZWMzKCAwLjk1ICkgKyBjb2xvci5yZ2IsIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXG5cdF0uam9pbihcIlxcblwiKVxufTtcbiIsIi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIFR3byBwYXNzIEdhdXNzaWFuIGJsdXIgZmlsdGVyIChob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBibHVyIHNoYWRlcnMpXG4gKiAtIGRlc2NyaWJlZCBpbiBodHRwOi8vd3d3LmdhbWVyZW5kZXJpbmcuY29tLzIwMDgvMTAvMTEvZ2F1c3NpYW4tYmx1ci1maWx0ZXItc2hhZGVyL1xuICogICBhbmQgdXNlZCBpbiBodHRwOi8vd3d3LmNha2UyMy5kZS90cmF2ZWxpbmctd2F2ZWZyb250cy1saXQtdXAuaHRtbFxuICpcbiAqIC0gOSBzYW1wbGVzIHBlciBwYXNzXG4gKiAtIHN0YW5kYXJkIGRldmlhdGlvbiAyLjdcbiAqIC0gXCJoXCIgYW5kIFwidlwiIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNldCB0byBcIjEgLyB3aWR0aFwiIGFuZCBcIjEgLyBoZWlnaHRcIlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJoXCI6ICAgICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIC8gNTEyLjAgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGg7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IHN1bSA9IHZlYzQoIDAuMCApO1wiLFxuXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDQuMCAqIGgsIHZVdi55ICkgKSAqIDAuMDUxO1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSAzLjAgKiBoLCB2VXYueSApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDIuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTIyNDU7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDEuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSApICkgKiAwLjE2MzM7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDEuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMi4wICogaCwgdlV2LnkgKSApICogMC4xMjI0NTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMy4wICogaCwgdlV2LnkgKSApICogMC4wOTE4O1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggKyA0LjAgKiBoLCB2VXYueSApICkgKiAwLjA1MTtcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBzdW07XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIHRhcGlvIC8gaHR0cDovL3RhcGlvLmdpdGh1Yi5jb20vXG4gKlxuICogSHVlIGFuZCBzYXR1cmF0aW9uIGFkanVzdG1lbnRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzXG4gKiBodWU6IC0xIHRvIDEgKC0xIGlzIDE4MCBkZWdyZWVzIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24sIDAgaXMgbm8gY2hhbmdlLCBldGMuXG4gKiBzYXR1cmF0aW9uOiAtMSB0byAxICgtMSBpcyBzb2xpZCBncmF5LCAwIGlzIG5vIGNoYW5nZSwgYW5kIDEgaXMgbWF4aW11bSBjb250cmFzdClcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiAgIHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJodWVcIjogICAgICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH0sXG5cdFx0XCJzYXR1cmF0aW9uXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGh1ZTtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgc2F0dXJhdGlvbjtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxuXG5cdFx0XHQvLyBodWVcblx0XHRcdFwiZmxvYXQgYW5nbGUgPSBodWUgKiAzLjE0MTU5MjY1O1wiLFxuXHRcdFx0XCJmbG9hdCBzID0gc2luKGFuZ2xlKSwgYyA9IGNvcyhhbmdsZSk7XCIsXG5cdFx0XHRcInZlYzMgd2VpZ2h0cyA9ICh2ZWMzKDIuMCAqIGMsIC1zcXJ0KDMuMCkgKiBzIC0gYywgc3FydCgzLjApICogcyAtIGMpICsgMS4wKSAvIDMuMDtcIixcblx0XHRcdFwiZmxvYXQgbGVuID0gbGVuZ3RoKGdsX0ZyYWdDb2xvci5yZ2IpO1wiLFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiID0gdmVjMyhcIixcblx0XHRcdFx0XCJkb3QoZ2xfRnJhZ0NvbG9yLnJnYiwgd2VpZ2h0cy54eXopLFwiLFxuXHRcdFx0XHRcImRvdChnbF9GcmFnQ29sb3IucmdiLCB3ZWlnaHRzLnp4eSksXCIsXG5cdFx0XHRcdFwiZG90KGdsX0ZyYWdDb2xvci5yZ2IsIHdlaWdodHMueXp4KVwiLFxuXHRcdFx0XCIpO1wiLFxuXG5cdFx0XHQvLyBzYXR1cmF0aW9uXG5cdFx0XHRcImZsb2F0IGF2ZXJhZ2UgPSAoZ2xfRnJhZ0NvbG9yLnIgKyBnbF9GcmFnQ29sb3IuZyArIGdsX0ZyYWdDb2xvci5iKSAvIDMuMDtcIixcblx0XHRcdFwiaWYgKHNhdHVyYXRpb24gPiAwLjApIHtcIixcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICs9IChhdmVyYWdlIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gMS4wIC8gKDEuMDAxIC0gc2F0dXJhdGlvbikpO1wiLFxuXHRcdFx0XCJ9IGVsc2Uge1wiLFxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKz0gKGF2ZXJhZ2UgLSBnbF9GcmFnQ29sb3IucmdiKSAqICgtc2F0dXJhdGlvbik7XCIsXG5cdFx0XHRcIn1cIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgZmVsaXh0dXJuZXIgLyBodHRwOi8vYWlydGlnaHQuY2MvXG4gKlxuICogS2FsZWlkb3Njb3BlIFNoYWRlclxuICogUmFkaWFsIHJlZmxlY3Rpb24gYXJvdW5kIGNlbnRlciBwb2ludFxuICogUG9ydGVkIGZyb206IGh0dHA6Ly9waXhlbHNoYWRlcnMuY29tL2VkaXRvci9cbiAqIGJ5IFRvYnkgU2NoYWNobWFuIC8gaHR0cDovL3RvYnlzY2hhY2htYW4uY29tL1xuICpcbiAqIHNpZGVzOiBudW1iZXIgb2YgcmVmbGVjdGlvbnNcbiAqIGFuZ2xlOiBpbml0aWFsIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwic2lkZXNcIjogICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDYuMCB9LFxuXHRcdFwiYW5nbGVcIjogICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgc2lkZXM7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGFuZ2xlO1wiLFxuXHRcdFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzIgcCA9IHZVdiAtIDAuNTtcIixcblx0XHRcdFwiZmxvYXQgciA9IGxlbmd0aChwKTtcIixcblx0XHRcdFwiZmxvYXQgYSA9IGF0YW4ocC55LCBwLngpICsgYW5nbGU7XCIsXG5cdFx0XHRcImZsb2F0IHRhdSA9IDIuICogMy4xNDE2IDtcIixcblx0XHRcdFwiYSA9IG1vZChhLCB0YXUvc2lkZXMpO1wiLFxuXHRcdFx0XCJhID0gYWJzKGEgLSB0YXUvc2lkZXMvMi4pIDtcIixcblx0XHRcdFwicCA9IHIgKiB2ZWMyKGNvcyhhKSwgc2luKGEpKTtcIixcblx0XHRcdFwidmVjNCBjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgcCArIDAuNSk7XCIsXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IGNvbG9yO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBmZWxpeHR1cm5lciAvIGh0dHA6Ly9haXJ0aWdodC5jYy9cbiAqXG4gKiBNaXJyb3IgU2hhZGVyXG4gKiBDb3BpZXMgaGFsZiB0aGUgaW5wdXQgdG8gdGhlIG90aGVyIGhhbGZcbiAqXG4gKiBzaWRlOiBzaWRlIG9mIGlucHV0IHRvIG1pcnJvciAoMCA9IGxlZnQsIDEgPSByaWdodCwgMiA9IHRvcCwgMyA9IGJvdHRvbSlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwic2lkZVwiOiAgICAgeyB0eXBlOiBcImlcIiwgdmFsdWU6IDEgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIGludCBzaWRlO1wiLFxuXHRcdFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzIgcCA9IHZVdjtcIixcblx0XHRcdFwiaWYgKHNpZGUgPT0gMCl7XCIsXG5cdFx0XHRcdFwiaWYgKHAueCA+IDAuNSkgcC54ID0gMS4wIC0gcC54O1wiLFxuXHRcdFx0XCJ9ZWxzZSBpZiAoc2lkZSA9PSAxKXtcIixcblx0XHRcdFx0XCJpZiAocC54IDwgMC41KSBwLnggPSAxLjAgLSBwLng7XCIsXG5cdFx0XHRcIn1lbHNlIGlmIChzaWRlID09IDIpe1wiLFxuXHRcdFx0XHRcImlmIChwLnkgPCAwLjUpIHAueSA9IDEuMCAtIHAueTtcIixcblx0XHRcdFwifWVsc2UgaWYgKHNpZGUgPT0gMyl7XCIsXG5cdFx0XHRcdFwiaWYgKHAueSA+IDAuNSkgcC55ID0gMS4wIC0gcC55O1wiLFxuXHRcdFx0XCJ9IFwiLFxuXHRcdFx0XCJ2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCBwKTtcIixcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gY29sb3I7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLypcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogTm9ybWFsIG1hcCBzaGFkZXJcbiAqICAtIEJsaW5uLVBob25nXG4gKiAgLSBub3JtYWwgKyBkaWZmdXNlICsgc3BlY3VsYXIgKyBBTyArIGRpc3BsYWNlbWVudCArIHJlZmxlY3Rpb24gKyBzaGFkb3cgbWFwc1xuICogIC0gcG9pbnQgYW5kIGRpcmVjdGlvbmFsIGxpZ2h0cyAodXNlIHdpdGggXCJsaWdodHM6IHRydWVcIiBtYXRlcmlhbCBvcHRpb24pXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcblx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG5cdFx0e1xuXG5cdFx0XCJlbmFibGVBT1wiICAgICAgICAgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcImVuYWJsZURpZmZ1c2VcIiAgICAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFwiZW5hYmxlU3BlY3VsYXJcIiAgICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XCJlbmFibGVSZWZsZWN0aW9uXCIgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcImVuYWJsZURpc3BsYWNlbWVudFwiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXG5cdFx0XCJ0RGlzcGxhY2VtZW50XCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sIC8vIG11c3QgZ28gZmlyc3QgYXMgdGhpcyBpcyB2ZXJ0ZXggdGV4dHVyZVxuXHRcdFwidERpZmZ1c2VcIiAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidEN1YmVcIiAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidE5vcm1hbFwiICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidFNwZWN1bGFyXCIgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwidEFPXCIgICAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0XCJ1Tm9ybWFsU2NhbGVcIjogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH0sXG5cblx0XHRcInVEaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcblx0XHRcInVEaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcImRpZmZ1c2VcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxuXHRcdFwic3BlY3VsYXJcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuXHRcdFwic2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9LFxuXHRcdFwib3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG5cdFx0XCJyZWZyYWN0aW9uUmF0aW9cIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfSxcblx0XHRcInJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cblx0XHRcInVPZmZzZXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKSB9LFxuXHRcdFwidVJlcGVhdFwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH0sXG5cblx0XHRcIndyYXBSR0JcIiA6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSB9XG5cblx0XHR9XG5cblx0XSApLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVEaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSBib29sIGVuYWJsZVNwZWN1bGFyO1wiLFxuXHRcdFwidW5pZm9ybSBib29sIGVuYWJsZUFPO1wiLFxuXHRcdFwidW5pZm9ybSBib29sIGVuYWJsZVJlZmxlY3Rpb247XCIsXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdE5vcm1hbDtcIixcblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRTcGVjdWxhcjtcIixcblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRBTztcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcblxuXHRcdFwidW5pZm9ybSB2ZWMyIHVOb3JtYWxTY2FsZTtcIixcblxuXHRcdFwidW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxuXHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcblx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxuXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcIlx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblx0XHRcIlx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxuXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcIlx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXHRcdFwiXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxuXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxuXHRcdFwiXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcblx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XCJcdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XCIjZW5kaWZcIixcblxuXHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcIlx0dW5pZm9ybSB2ZWMzIHdyYXBSR0I7XCIsXG5cblx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblxuXHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFx0Ly8gb3V0Z29pbmcgbGlnaHQgZG9lcyBub3QgaGF2ZSBhbiBhbHBoYSwgdGhlIHN1cmZhY2UgZG9lc1xuXHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFwiXHR2ZWMzIHNwZWN1bGFyVGV4ID0gdmVjMyggMS4wICk7XCIsXG5cblx0XHRcIlx0dmVjMyBub3JtYWxUZXggPSB0ZXh0dXJlMkQoIHROb3JtYWwsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcIixcblx0XHRcIlx0bm9ybWFsVGV4Lnh5ICo9IHVOb3JtYWxTY2FsZTtcIixcblx0XHRcIlx0bm9ybWFsVGV4ID0gbm9ybWFsaXplKCBub3JtYWxUZXggKTtcIixcblxuXHRcdFwiXHRpZiggZW5hYmxlRGlmZnVzZSApIHtcIixcblxuXHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XCJcdFx0XHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblx0XHRcIlx0XHRcdHRleGVsQ29sb3IueHl6ICo9IHRleGVsQ29sb3IueHl6O1wiLFxuXG5cdFx0XCJcdFx0XHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcIixcblxuXHRcdFwiXHRcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHRcdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblxuXHRcdFwiXHRcdCNlbmRpZlwiLFxuXG5cdFx0XCJcdH1cIixcblxuXHRcdFwiXHRpZiggZW5hYmxlQU8gKSB7XCIsXG5cblx0XHRcIlx0XHQjaWZkZWYgR0FNTUFfSU5QVVRcIixcblxuXHRcdFwiXHRcdFx0dmVjNCBhb0NvbG9yID0gdGV4dHVyZTJEKCB0QU8sIHZVdiApO1wiLFxuXHRcdFwiXHRcdFx0YW9Db2xvci54eXogKj0gYW9Db2xvci54eXo7XCIsXG5cblx0XHRcIlx0XHRcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gYW9Db2xvci54eXo7XCIsXG5cblx0XHRcIlx0XHQjZWxzZVwiLFxuXG5cdFx0XCJcdFx0XHRkaWZmdXNlQ29sb3IucmdiICo9IHRleHR1cmUyRCggdEFPLCB2VXYgKS54eXo7XCIsXG5cblx0XHRcIlx0XHQjZW5kaWZcIixcblxuXHRcdFwiXHR9XCIsXG5cblx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XCJcdGlmKCBlbmFibGVTcGVjdWxhciApXCIsXG5cdFx0XCJcdFx0c3BlY3VsYXJUZXggPSB0ZXh0dXJlMkQoIHRTcGVjdWxhciwgdlV2ICkueHl6O1wiLFxuXG5cdFx0XCJcdG1hdDMgdHNiID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaW5vcm1hbCApLCBub3JtYWxpemUoIHZOb3JtYWwgKSApO1wiLFxuXHRcdFwiXHR2ZWMzIGZpbmFsTm9ybWFsID0gdHNiICogbm9ybWFsVGV4O1wiLFxuXG5cdFx0XCJcdCNpZmRlZiBGTElQX1NJREVEXCIsXG5cblx0XHRcIlx0XHRmaW5hbE5vcm1hbCA9IC1maW5hbE5vcm1hbDtcIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFwiXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggZmluYWxOb3JtYWwgKTtcIixcblx0XHRcIlx0dmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcblxuXHRcdFwiXHR2ZWMzIHRvdGFsRGlmZnVzZUxpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XCJcdHZlYzMgdG90YWxTcGVjdWxhckxpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdC8vIHBvaW50IGxpZ2h0c1xuXG5cdFx0XCJcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XCJcdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFwiXHRcdFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXHRcdFwiXHRcdFx0dmVjMyBwb2ludFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcblxuXHRcdFwiXHRcdFx0ZmxvYXQgcG9pbnREaXN0YW5jZSA9IDEuMDtcIixcblx0XHRcIlx0XHRcdGlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxuXHRcdFwiXHRcdFx0XHRwb2ludERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggcG9pbnRWZWN0b3IgKSAvIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxuXG5cdFx0XCJcdFx0XHRwb2ludFZlY3RvciA9IG5vcm1hbGl6ZSggcG9pbnRWZWN0b3IgKTtcIixcblxuXHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFwiXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcIlx0XHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICksIDAuMCApO1wiLFxuXHRcdFwiXHRcdFx0XHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSArIDAuNSwgMC4wICk7XCIsXG5cblx0XHRcIlx0XHRcdFx0dmVjMyBwb2ludERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXG5cblx0XHRcIlx0XHRcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XCIsXG5cblx0XHRcIlx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XCJcdFx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBwb2ludERpc3RhbmNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludERpZmZ1c2VXZWlnaHQ7XCIsXG5cblx0XHRcdFx0XHQvLyBzcGVjdWxhclxuXG5cdFx0XCJcdFx0XHR2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggcG9pbnRWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcIlx0XHRcdGZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxuXG5cdFx0XCJcdFx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1wiLFxuXG5cdFx0XCJcdFx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBwb2ludFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcIlx0XHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcblxuXHRcdFwiXHRcdH1cIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0Ly8gc3BvdCBsaWdodHNcblxuXHRcdFwiXHQjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxuXG5cdFx0XCJcdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxuXG5cdFx0XCJcdFx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcblx0XHRcIlx0XHRcdHZlYzMgc3BvdFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcblxuXHRcdFwiXHRcdFx0ZmxvYXQgc3BvdERpc3RhbmNlID0gMS4wO1wiLFxuXHRcdFwiXHRcdFx0aWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcblx0XHRcIlx0XHRcdFx0c3BvdERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggc3BvdFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcblxuXHRcdFwiXHRcdFx0c3BvdFZlY3RvciA9IG5vcm1hbGl6ZSggc3BvdFZlY3RvciApO1wiLFxuXG5cdFx0XCJcdFx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1wiLFxuXG5cdFx0XCJcdFx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1wiLFxuXG5cdFx0XCJcdFx0XHRcdHNwb3RFZmZlY3QgPSBtYXgoIHBvdyggbWF4KCBzcG90RWZmZWN0LCAwLjAgKSwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxuXG5cdFx0XCJcdFx0XHRcdCNpZmRlZiBXUkFQX0FST1VORFwiLFxuXG5cdFx0XCJcdFx0XHRcdFx0ZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICkgKyAwLjUsIDAuMCApO1wiLFxuXG5cdFx0XCJcdFx0XHRcdFx0dmVjMyBzcG90RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRGdWxsICksIHZlYzMoIHNwb3REaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXG5cblx0XHRcIlx0XHRcdFx0I2Vsc2VcIixcblxuXHRcdFwiXHRcdFx0XHRcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcblxuXHRcdFwiXHRcdFx0XHQjZW5kaWZcIixcblxuXHRcdFwiXHRcdFx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBzcG90RGlzdGFuY2UgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RWZmZWN0O1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBzcGVjdWxhclxuXG5cdFx0XCJcdFx0XHRcdHZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcIlx0XHRcdFx0ZmxvYXQgc3BvdERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdFx0ZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxuXG5cdFx0XCJcdFx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XCIsXG5cblx0XHRcIlx0XHRcdFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggc3BvdFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1wiLFxuXHRcdFwiXHRcdFx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gc2NobGljayAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90U3BlY3VsYXJXZWlnaHQgKiBzcG90RGlmZnVzZVdlaWdodCAqIHNwb3REaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIHNwb3RFZmZlY3Q7XCIsXG5cblx0XHRcIlx0XHRcdH1cIixcblxuXHRcdFwiXHRcdH1cIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0Ly8gZGlyZWN0aW9uYWwgbGlnaHRzXG5cblx0XHRcIlx0I2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXG5cdFx0XCJcdFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSsrICkge1wiLFxuXG5cdFx0XCJcdFx0XHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdHZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxuXG5cdFx0XHRcdFx0Ly8gZGlmZnVzZVxuXG5cdFx0XCJcdFx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcIixcblxuXHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nRnVsbCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdFx0ZmxvYXQgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKSArIDAuNSwgMC4wICk7XCIsXG5cblx0XHRcIlx0XHRcdFx0dmVjMyBkaXJEaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzKCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nRnVsbCApLCB2ZWMzKCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiApLCB3cmFwUkdCICk7XCIsXG5cblx0XHRcIlx0XHRcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHRcdFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcblxuXHRcdFwiXHRcdFx0I2VuZGlmXCIsXG5cblx0XHRcIlx0XHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyRGlmZnVzZVdlaWdodDtcIixcblxuXHRcdFx0XHRcdC8vIHNwZWN1bGFyXG5cblx0XHRcIlx0XHRcdHZlYzMgZGlySGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggZGlyVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XCJcdFx0XHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdGZsb2F0IGRpclNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBkaXJEb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXG5cblx0XHRcIlx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XCIsXG5cblx0XHRcIlx0XHRcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXG5cdFx0XCJcdFx0XHR0b3RhbFNwZWN1bGFyTGlnaHQgKz0gc2NobGljayAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0ICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1wiLFxuXG5cdFx0XCJcdFx0fVwiLFxuXG5cdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHQvLyBoZW1pc3BoZXJlIGxpZ2h0c1xuXG5cdFx0XCJcdCNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXG5cblx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFwiXHRcdFx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcblx0XHRcIlx0XHRcdHZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcblxuXHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFwiXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXG5cdFx0XCJcdFx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XCIsXG5cblx0XHRcIlx0XHRcdHZlYzMgaGVtaUNvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxuXG5cdFx0XCJcdFx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBoZW1pQ29sb3I7XCIsXG5cblx0XHRcdFx0XHQvLyBzcGVjdWxhciAoc2t5IGxpZ2h0KVxuXG5cblx0XHRcIlx0XHRcdHZlYzMgaGVtaUhhbGZWZWN0b3JTa3kgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcIlx0XHRcdGZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXG5cdFx0XCJcdFx0XHRmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIG1heCggaGVtaURvdE5vcm1hbEhhbGZTa3ksIDAuMCApLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXG5cblx0XHRcdFx0XHQvLyBzcGVjdWxhciAoZ3JvdW5kIGxpZ2h0KVxuXG5cdFx0XCJcdFx0XHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcIixcblxuXHRcdFwiXHRcdFx0dmVjMyBoZW1pSGFsZlZlY3Rvckdyb3VuZCA9IG5vcm1hbGl6ZSggbFZlY3Rvckdyb3VuZCArIHZpZXdQb3NpdGlvbiApO1wiLFxuXHRcdFwiXHRcdFx0ZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZHcm91bmQgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSArIDAuNTtcIixcblx0XHRcIlx0XHRcdGZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggbWF4KCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCwgMC4wICksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFwiXHRcdFx0ZmxvYXQgZG90UHJvZHVjdEdyb3VuZCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yR3JvdW5kICk7XCIsXG5cblx0XHRcIlx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XCIsXG5cblx0XHRcIlx0XHRcdHZlYzMgc2NobGlja1NreSA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3IsIGhlbWlIYWxmVmVjdG9yU2t5ICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcIlx0XHRcdHZlYzMgc2NobGlja0dyb3VuZCA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3JHcm91bmQsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcIlx0XHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBoZW1pQ29sb3IgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiAoIHNjaGxpY2tTa3kgKiBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgKiBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICsgc2NobGlja0dyb3VuZCAqIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCAqIG1heCggZG90UHJvZHVjdEdyb3VuZCwgMC4wICkgKTtcIixcblxuXHRcdFwiXHRcdH1cIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFwiXHQjaWZkZWYgTUVUQUxcIixcblxuXHRcdFwiXHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyBhbWJpZW50TGlnaHRDb2xvciArIHRvdGFsU3BlY3VsYXJMaWdodCApO1wiLFxuXG5cdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgYW1iaWVudExpZ2h0Q29sb3IgKSArIHRvdGFsU3BlY3VsYXJMaWdodDtcIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFwiXHRpZiAoIGVuYWJsZVJlZmxlY3Rpb24gKSB7XCIsXG5cblx0XHRcIlx0XHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XCIsXG5cblx0XHRcIlx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlwiLFxuXG5cdFx0XCJcdFx0XHR2ZWMzIHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCApO1wiLFxuXG5cdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFwiXHRcdFx0dmVjMyB2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCBub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1wiLFxuXG5cdFx0XCJcdFx0I2VuZGlmXCIsXG5cblx0XHRcIlx0XHR2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggLXZSZWZsZWN0LngsIHZSZWZsZWN0Lnl6ICkgKTtcIixcblxuXHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XCJcdFx0XHRjdWJlQ29sb3IueHl6ICo9IGN1YmVDb2xvci54eXo7XCIsXG5cblx0XHRcIlx0XHQjZW5kaWZcIixcblxuXHRcdFwiXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGN1YmVDb2xvci54eXosIHNwZWN1bGFyVGV4LnIgKiByZWZsZWN0aXZpdHkgKTtcIixcblxuXHRcdFwiXHR9XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFx0Ly8gVE9ETywgdGhpcyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgdG8gYWxsb3cgZm9yIGJyaWdodCBoaWdobGlnaHRzIG9uIHZlcnkgdHJhbnNwYXJlbnQgb2JqZWN0c1xuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcImF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XCIsXG5cblx0XHRcInVuaWZvcm0gdmVjMiB1T2Zmc2V0O1wiLFxuXHRcdFwidW5pZm9ybSB2ZWMyIHVSZXBlYXQ7XCIsXG5cblx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVEaXNwbGFjZW1lbnQ7XCIsXG5cblx0XHRcIiNpZmRlZiBWRVJURVhfVEVYVFVSRVNcIixcblxuXHRcdFwiXHR1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1wiLFxuXHRcdFwiXHR1bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRTY2FsZTtcIixcblx0XHRcIlx0dW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50QmlhcztcIixcblxuXHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcIixcblx0XHRcInZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XCIsXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdC8vIG5vcm1hbCwgdGFuZ2VudCBhbmQgYmlub3JtYWwgdmVjdG9yc1xuXG5cdFx0XCJcdCNpZmRlZiBVU0VfU0tJTk5JTkdcIixcblxuXHRcdFwiXHRcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXG5cblx0XHRcIlx0XHR2ZWM0IHNraW5uZWRUYW5nZW50ID0gc2tpbk1hdHJpeCAqIHZlYzQoIHRhbmdlbnQueHl6LCAwLjAgKTtcIixcblx0XHRcIlx0XHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogc2tpbm5lZFRhbmdlbnQueHl6ICk7XCIsXG5cblx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFwiXHRcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXHRcdFwiXHRcdHZUYW5nZW50ID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiB0YW5nZW50Lnh5eiApO1wiLFxuXG5cdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XCJcdHZCaW5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcIixcblxuXHRcdFwiXHR2VXYgPSB1diAqIHVSZXBlYXQgKyB1T2Zmc2V0O1wiLFxuXG5cdFx0XHQvLyBkaXNwbGFjZW1lbnQgbWFwcGluZ1xuXG5cdFx0XCJcdHZlYzMgZGlzcGxhY2VkUG9zaXRpb247XCIsXG5cblx0XHRcIlx0I2lmZGVmIFZFUlRFWF9URVhUVVJFU1wiLFxuXG5cdFx0XCJcdFx0aWYgKCBlbmFibGVEaXNwbGFjZW1lbnQgKSB7XCIsXG5cblx0XHRcIlx0XHRcdHZlYzMgZHYgPSB0ZXh0dXJlMkQoIHREaXNwbGFjZW1lbnQsIHV2ICkueHl6O1wiLFxuXHRcdFwiXHRcdFx0ZmxvYXQgZGYgPSB1RGlzcGxhY2VtZW50U2NhbGUgKiBkdi54ICsgdURpc3BsYWNlbWVudEJpYXM7XCIsXG5cdFx0XCJcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbm9ybWFsaXplKCBub3JtYWwgKSAqIGRmO1wiLFxuXG5cdFx0XCJcdFx0fSBlbHNlIHtcIixcblxuXHRcdFwiXHRcdFx0I2lmZGVmIFVTRV9TS0lOTklOR1wiLFxuXG5cdFx0XCJcdFx0XHRcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIlx0XHRcdFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XCIsXG5cdFx0XCJcdFx0XHRcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1wiLFxuXHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcblx0XHRcIlx0XHRcdFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XCIsXG5cdFx0XCJcdFx0XHRcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1wiLFxuXHRcdFwiXHRcdFx0XHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcIixcblxuXHRcdFwiXHRcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHNraW5uZWQueHl6O1wiLFxuXG5cdFx0XCJcdFx0XHQjZWxzZVwiLFxuXG5cdFx0XCJcdFx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXG5cblx0XHRcIlx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XCJcdFx0fVwiLFxuXG5cdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHQjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG5cblx0XHRcIlx0XHRcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIlx0XHRcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1wiLFxuXHRcdFwiXHRcdFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XCIsXG5cdFx0XCJcdFx0XHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcblx0XHRcIlx0XHRcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1wiLFxuXHRcdFwiXHRcdFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XCIsXG5cdFx0XCJcdFx0XHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcIixcblxuXHRcdFwiXHRcdFx0ZGlzcGxhY2VkUG9zaXRpb24gPSBza2lubmVkLnh5ejtcIixcblxuXHRcdFwiXHRcdCNlbHNlXCIsXG5cblx0XHRcIlx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXG5cblx0XHRcIlx0XHQjZW5kaWZcIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0Ly9cblxuXHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XCJcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggZGlzcGxhY2VkUG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdC8vXG5cblx0XHRcIlx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcIixcblx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixcblxuXHRcdFx0Ly8gc2hhZG93c1xuXG5cdFx0XCJcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXG5cblx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1wiLFxuXG5cdFx0XCJcdFx0XHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFwiXHRcdH1cIixcblxuXHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1IHwgaHR0cHM6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBFZGdlIERldGVjdGlvbiBTaGFkZXIgdXNpbmcgU29iZWwgZmlsdGVyXG4gKiBCYXNlZCBvbiBodHRwOi8vcmFzdGVyZ3JpZC5jb20vYmxvZy8yMDExLzAxL2ZyZWktY2hlbi1lZGdlLWRldGVjdG9yXG4gKlxuICogYXNwZWN0OiB2ZWMyIG9mICgxL3dpZHRoLCAxL2hlaWdodClcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7XG5cdFx0XHR0eXBlOiBcInRcIixcblx0XHRcdHZhbHVlOiBudWxsXG5cdFx0fSxcblx0XHRcInhBbW91bnRcIjoge1xuXHRcdFx0dHlwZTogXCJmXCIsXG5cdFx0XHR2YWx1ZTogMC4wMVxuXHRcdH0sXG5cdFx0XCJ5QW1vdW50XCI6IHtcblx0XHRcdHR5cGU6IFwiZlwiLFxuXHRcdFx0dmFsdWU6IDAuMDFcblx0XHR9LFxuXHRcdFwidFNpemVcIjogICAgeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggNjQsIDY0ICkgfVxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCB4QW1vdW50O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCB5QW1vdW50O1wiLFxuXHRcdFwidW5pZm9ybSB2ZWMyIHRTaXplO1wiLFxuXG5cblx0XHRcInZvaWQgbWFpbih2b2lkKVwiLFxuXHRcdFwie1wiLFxuXHRcdFx0XCJ2ZWMyIHMgPSB2ZWMyKHhBbW91bnQseUFtb3VudCk7XCIsXG5cdFx0XHRcInZlYzIgc2l6ZSA9IHRTaXplIC8gcztcIixcblx0XHRcdCBcInZlYzIgY29sb3IgPSBmbG9vciggKCB2VXYgKiBzaXplICkgKSAvIHNpemUgKyBzL3RTaXplICogMC41O1wiLFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvbG9yKTtcIixcblx0XHRcIn0gXCIsXG5cblx0XS5qb2luKFwiXFxuXCIpXG5cbn07IiwiLyoqXG4gKiBAYXV0aG9yIGZlbGl4dHVybmVyIC8gaHR0cDovL2FpcnRpZ2h0LmNjL1xuICpcbiAqIFJHQiBTaGlmdCBTaGFkZXJcbiAqIFNoaWZ0cyByZWQgYW5kIGJsdWUgY2hhbm5lbHMgZnJvbSBjZW50ZXIgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuICogUG9ydGVkIGZyb20gaHR0cDovL2tyaXNzLmN4L3RvbS8yMDA5LzA1L3JnYi1zaGlmdC9cbiAqIGJ5IFRvbSBCdXR0ZXJ3b3J0aCAvIGh0dHA6Ly9rcmlzcy5jeC90b20vXG4gKlxuICogYW1vdW50OiBzaGlmdCBkaXN0YW5jZSAoMSBpcyB3aWR0aCBvZiBpbnB1dClcbiAqIGFuZ2xlOiBzaGlmdCBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcImFtb3VudFwiOiAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwNSB9LFxuXHRcdFwiYW5nbGVcIjogICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblx0XHRcInVuaWZvcm0gZmxvYXQgYW1vdW50O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBhbmdsZTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzIgb2Zmc2V0ID0gYW1vdW50ICogdmVjMiggY29zKGFuZ2xlKSwgc2luKGFuZ2xlKSk7XCIsXG5cdFx0XHRcInZlYzQgY3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArIG9mZnNldCk7XCIsXG5cdFx0XHRcInZlYzQgY2dhID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1wiLFxuXHRcdFx0XCJ2ZWM0IGNiID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgLSBvZmZzZXQpO1wiLFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KGNyLnIsIGNnYS5nLCBjYi5iLCBjZ2EuYSk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIFNlcGlhIHRvbmUgc2hhZGVyXG4gKiBiYXNlZCBvbiBnbGZ4LmpzIHNlcGlhIHNoYWRlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0XCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiYW1vdW50XCI6ICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IGFtb3VudDtcIixcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG5cdFx0XHRcInZlYzMgYyA9IGNvbG9yLnJnYjtcIixcblxuXHRcdFx0XCJjb2xvci5yID0gZG90KCBjLCB2ZWMzKCAxLjAgLSAwLjYwNyAqIGFtb3VudCwgMC43NjkgKiBhbW91bnQsIDAuMTg5ICogYW1vdW50ICkgKTtcIixcblx0XHRcdFwiY29sb3IuZyA9IGRvdCggYywgdmVjMyggMC4zNDkgKiBhbW91bnQsIDEuMCAtIDAuMzE0ICogYW1vdW50LCAwLjE2OCAqIGFtb3VudCApICk7XCIsXG5cdFx0XHRcImNvbG9yLmIgPSBkb3QoIGMsIHZlYzMoIDAuMjcyICogYW1vdW50LCAwLjUzNCAqIGFtb3VudCwgMS4wIC0gMC44NjkgKiBhbW91bnQgKSApO1wiLFxuXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIG1pbiggdmVjMyggMS4wICksIGNvbG9yLnJnYiApLCBjb2xvci5hICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGZsaW1zaGF3IC8gaHR0cDovL2NoYXJsaWVob2V5LmNvbVxuICpcbiAqIFRlY2huaWNvbG9yIFNoYWRlclxuICogU2ltdWxhdGVzIHRoZSBsb29rIG9mIHRoZSB0d28tc3RyaXAgdGVjaG5pY29sb3IgcHJvY2VzcyBwb3B1bGFyIGluIGVhcmx5IDIwdGggY2VudHVyeSBmaWxtcy5cbiAqIE1vcmUgaGlzdG9yaWNhbCBpbmZvIGhlcmU6IGh0dHA6Ly93d3cud2lkZXNjcmVlbm11c2V1bS5jb20vb2xkY29sb3IvdGVjaG5pY29sb3IxLmh0bVxuICogRGVtbyBoZXJlOiBodHRwOi8vY2hhcmxpZWhvZXkuY29tL3RlY2huaWNvbG9yX3NoYWRlci9zaGFkZXJfdGVzdC5odG1sXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzQgdGV4ID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKTtcIixcblx0XHRcdFwidmVjNCBuZXdUZXggPSB2ZWM0KHRleC5yLCAodGV4LmcgKyB0ZXguYikgKiAuNSwgKHRleC5nICsgdGV4LmIpICogLjUsIDEuMCk7XCIsXG5cblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gbmV3VGV4O1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBtaWlib25kXG4gKlxuICogRnVsbC1zY3JlZW4gdG9uZS1tYXBwaW5nIHNoYWRlciBiYXNlZCBvbiBodHRwOi8vd3d3LmdyYXBoaWNzLmNvcm5lbGwuZWR1L35qYWYvcHVibGljYXRpb25zL3NpZzAyX3BhcGVyLnBkZlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJhdmVyYWdlTHVtaW5hbmNlXCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJsdW1pbmFuY2VNYXBcIjogIHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJtYXhMdW1pbmFuY2VcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxNi4wIH0sXG5cdFx0XCJtaWRkbGVHcmV5XCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC42IH1cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZVdiA9IHV2O1wiLFxuXHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKSxcblxuXHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBtaWRkbGVHcmV5O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBtYXhMdW1pbmFuY2U7XCIsXG5cdFx0XCIjaWZkZWYgQURBUFRFRF9MVU1JTkFOQ0VcIixcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbHVtaW5hbmNlTWFwO1wiLFxuXHRcdFwiI2Vsc2VcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBhdmVyYWdlTHVtaW5hbmNlO1wiLFxuXHRcdFwiI2VuZGlmXCIsXG5cdFx0XG5cdFx0XCJjb25zdCB2ZWMzIExVTV9DT05WRVJUID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcIixcblxuXHRcdFwidmVjMyBUb25lTWFwKCB2ZWMzIHZDb2xvciApIHtcIixcblx0XHRcdFwiI2lmZGVmIEFEQVBURURfTFVNSU5BTkNFXCIsXG5cdFx0XHRcdC8vIEdldCB0aGUgY2FsY3VsYXRlZCBhdmVyYWdlIGx1bWluYW5jZSBcblx0XHRcdFx0XCJmbG9hdCBmTHVtQXZnID0gdGV4dHVyZTJEKGx1bWluYW5jZU1hcCwgdmVjMigwLjUsIDAuNSkpLnI7XCIsXG5cdFx0XHRcIiNlbHNlXCIsXG5cdFx0XHRcdFwiZmxvYXQgZkx1bUF2ZyA9IGF2ZXJhZ2VMdW1pbmFuY2U7XCIsXG5cdFx0XHRcIiNlbmRpZlwiLFxuXHRcdFx0XG5cdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGx1bWluYW5jZSBvZiB0aGUgY3VycmVudCBwaXhlbFxuXHRcdFx0XCJmbG9hdCBmTHVtUGl4ZWwgPSBkb3QodkNvbG9yLCBMVU1fQ09OVkVSVCk7XCIsXG5cblx0XHRcdC8vIEFwcGx5IHRoZSBtb2RpZmllZCBvcGVyYXRvciAoRXEuIDQpXG5cdFx0XHRcImZsb2F0IGZMdW1TY2FsZWQgPSAoZkx1bVBpeGVsICogbWlkZGxlR3JleSkgLyBmTHVtQXZnO1wiLFxuXG5cdFx0XHRcImZsb2F0IGZMdW1Db21wcmVzc2VkID0gKGZMdW1TY2FsZWQgKiAoMS4wICsgKGZMdW1TY2FsZWQgLyAobWF4THVtaW5hbmNlICogbWF4THVtaW5hbmNlKSkpKSAvICgxLjAgKyBmTHVtU2NhbGVkKTtcIixcblx0XHRcdFwicmV0dXJuIGZMdW1Db21wcmVzc2VkICogdkNvbG9yO1wiLFxuXHRcdFwifVwiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidmVjNCB0ZXhlbCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxuXHRcdFx0XG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIFRvbmVNYXAoIHRleGVsLnh5eiApLCB0ZXhlbC53ICk7XCIsXG5cdFx0XHQvL0dhbW1hIDIuMFxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcbiIsIi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqIFR3byBwYXNzIEdhdXNzaWFuIGJsdXIgZmlsdGVyIChob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBibHVyIHNoYWRlcnMpXG4gKiAtIGRlc2NyaWJlZCBpbiBodHRwOi8vd3d3LmdhbWVyZW5kZXJpbmcuY29tLzIwMDgvMTAvMTEvZ2F1c3NpYW4tYmx1ci1maWx0ZXItc2hhZGVyL1xuICogICBhbmQgdXNlZCBpbiBodHRwOi8vd3d3LmNha2UyMy5kZS90cmF2ZWxpbmctd2F2ZWZyb250cy1saXQtdXAuaHRtbFxuICpcbiAqIC0gOSBzYW1wbGVzIHBlciBwYXNzXG4gKiAtIHN0YW5kYXJkIGRldmlhdGlvbiAyLjdcbiAqIC0gXCJoXCIgYW5kIFwidlwiIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNldCB0byBcIjEgLyB3aWR0aFwiIGFuZCBcIjEgLyBoZWlnaHRcIlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJ2XCI6ICAgICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIC8gNTEyLjAgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cdFx0XCJ1bmlmb3JtIGZsb2F0IHY7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IHN1bSA9IHZlYzQoIDAuMCApO1wiLFxuXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSA0LjAgKiB2ICkgKSAqIDAuMDUxO1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMy4wICogdiApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAyLjAgKiB2ICkgKSAqIDAuMTIyNDU7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAxLjAgKiB2ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSApICkgKiAwLjE2MzM7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKyAxLjAgKiB2ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDIuMCAqIHYgKSApICogMC4xMjI0NTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDMuMCAqIHYgKSApICogMC4wOTE4O1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICsgNC4wICogdiApICkgKiAwLjA1MTtcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBzdW07XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuIiwidmFyIFBfV0lEVEggPSAyNTY7XG52YXIgUF9IRUlHSFQgPSAyNTY7XG52YXIgUF9ERVBUSCA9IDI1NjtcbnZhciBUSU1FX0JJQVMgPSAtMTAwMDtcbnZhciBUV0VFTiA9IHJlcXVpcmUoJ3R3ZWVuanMnKTtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGhyZWUgPSBmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBfY29udGFpbmVyLCBfYW5pbWF0ZUNhbGxiYWNrO1xuXG5cdHZhciBfY2FtZXJhLCBfc2NlbmUsIF9yZW5kZXJlciwgX2xpZ2h0R3JvdXAsIF9hbWJpZW50TGlnaHQsIF9jb250cm9scztcblxuXHR2YXIgd2luZG93SGFsZlgsIHdpbmRvd0hhbGZZO1xuXG5cdGZ1bmN0aW9uIGluaXQoY29udGFpbmVyLCBhbmltYXRlQ2FsbGJhY2spIHtcblxuXHRcdF9jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0X2FuaW1hdGVDYWxsYmFjayA9IGFuaW1hdGVDYWxsYmFjaztcblxuXHRcdF9jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAxLCAxMDAwMCk7XG5cdFx0X2NhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMTQwMCk7XG5cblx0XHRfc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHRcdF9yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG5cdFx0X3JlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdFx0X2NvbnRhaW5lci5hcHBlbmRDaGlsZChfcmVuZGVyZXIuZG9tRWxlbWVudCk7XG5cblx0XHQvLyBMSUdIVFNcblx0XHRfbGlnaHRHcm91cCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXHRcdF9zY2VuZS5hZGQoX2xpZ2h0R3JvdXApO1xuXHRcdF9saWdodEdyb3VwLnBvc2l0aW9uLnogPSA0MDAwO1xuXG5cdFx0dmFyIGdMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHhlZmVmZWYpO1xuXHRcdF9zY2VuZS5hZGQoZ0xpZ2h0KTtcblxuXHRcdF9hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KDB4ZmZmZmZmKTtcblxuXHRcdHZhciBsaWdodCA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSg0MCwgNCwgNCk7XG5cdFx0dmFyIGxNZXNoID0gbmV3IFRIUkVFLk1lc2gobGlnaHQsIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHR3aXJlZnJhbWU6IHRydWVcblx0XHR9KSk7XG5cblx0XHQvL19saWdodEdyb3VwLmFkZChsTWVzaCk7XG5cdFx0X2xpZ2h0R3JvdXAuYWRkKF9hbWJpZW50TGlnaHQpO1xuXG5cdFx0X2NvbnRyb2xzID0gbmV3IFRIUkVFLlRyYWNrYmFsbENvbnRyb2xzKF9jYW1lcmEsIF9yZW5kZXJlci5kb21FbGVtZW50KTtcblx0XHRfY29udHJvbHMubWluRGlzdGFuY2UgPSA0MDA7XG5cdFx0X2NvbnRyb2xzLm1heERpc3RhbmNlID0gMTAwMDtcblx0XHRfcmVuZGVyZXIuZ2FtbWFJbnB1dCA9IHRydWU7XG5cdFx0X3JlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcblxuXHRcdGFuaW1hdGUoKTtcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIF9zY2VuZTtcblx0fVxuXG5cdC8vLy0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL0FQSVxuXHQvLy8tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQvLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1BSSVZBVEVEXG5cdC8vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvL3Jlc2l6ZVxuXHRmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcblx0XHR3aW5kb3dIYWxmWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcblx0XHR3aW5kb3dIYWxmWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG5cdFx0X2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0X3JlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdH1cblx0Ly9yZW5kZXJcblx0ZnVuY3Rpb24gYW5pbWF0ZSgpIHtcblx0XHRUV0VFTi51cGRhdGUoKTtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuXHRcdHRocmVlUmVuZGVyKCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0aHJlZVJlbmRlcigpIHtcblx0XHRfY29udHJvbHMudXBkYXRlKCk7XG5cdFx0X2FuaW1hdGVDYWxsYmFjaygpO1xuXHRcdF9saWdodEdyb3VwLnBvc2l0aW9uLmNvcHkoX2NhbWVyYS5wb3NpdGlvbik7XG5cdFx0X2xpZ2h0R3JvdXAucm90YXRpb24uY29weShfY2FtZXJhLnJvdGF0aW9uKTtcblx0XHRfcmVuZGVyZXIucmVuZGVyKF9zY2VuZSwgX2NhbWVyYSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGluaXQ6aW5pdFxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVlOyIsInZhciBRID0gcmVxdWlyZSgncScpO1xudmFyIFBlcmxpbiA9IHJlcXVpcmUoJy4vbm9pc2UnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG4vL3NlY29uZHNcbnZhciBJTlRFUlZBTCA9IDAuNTtcbnZhciBTRVFVRU5DSUFMX1JFRlMgPSBmYWxzZTtcbnZhciBDSEFQVEVSX0RVUkFUSU9OID0gNDU7IC8vbWluc1xuXG52YXIgZmxhdHRlbmREYXRhID0gW107XG5cbi8qXG4gXG4gXG4gKi9cblxudmFyIFRpbWVsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBBTEw7XG5cbiAgICBmdW5jdGlvbiBzdGFydChjbGlwc01hbmlmZXN0KSB7XG4gICAgICAgIEFMTCA9IFtdO1xuICAgICAgICBfLmVhY2goY2xpcHNNYW5pZmVzdCwgZnVuY3Rpb24oY2hhcHRlciwgaSkge1xuICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgQUxMLnB1c2gobyk7XG4gICAgICAgICAgICBvWydyb3V0ZXMnXSA9IFtdO1xuICAgICAgICAgICAgX2J1aWxkUm91dGVzKG9bJ3JvdXRlcyddLCBjaGFwdGVyLCBpKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9yZXBsYWNlUm91dGUoY2xpcHNNYW5pZmVzdCwgQUxMKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYnVpbGRSb3V0ZXMocm91dGVzLCBjaGFwdGVyLCBjaGFwdGVySW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdGFsRHVyYXRpb24gPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9fY3JlYXRlUm91dGUoKSB7XG4gICAgICAgICAgICBpZiAodG90YWxEdXJhdGlvbiA+IChDSEFQVEVSX0RVUkFUSU9OICogNjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvdXRlID0gW107XG4gICAgICAgICAgICB2YXIgc2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXB0ZXJbMF1bJ3ZpZGVvcyddLmxlbmd0aCk7XG4gICAgICAgICAgICByb3V0ZS5wdXNoKFswLCBzZWVkXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNoYXB0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBjaGFwdGVyW2ldWyd2aWRlb3MnXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IFBlcmxpbi5nZXRWYWwoaSk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWF4KHNlZWQgLSAxLCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5taW4oc2VlZCArIDEsIHRvdGFsIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIGNob2ljZXMgPSBbbWluLCBzZWVkLCBtYXhdO1xuICAgICAgICAgICAgICAgIHZhciBjaG9pY2U7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm0gPSBpIC8gY2hhcHRlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy9mYXN0IHRvIHNsb3cgYXQgZW5kXG4gICAgICAgICAgICAgICAgaWYgKGNoYXB0ZXJJbmRleCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub3JtID0gMSAtIG5vcm07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaG9pY2VGYWN0b3I7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFwdGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9pY2VGYWN0b3IgPSAoZmFjdG9yICsgTWF0aC5hc2luKG5vcm0pKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9pY2UgPSBjaG9pY2VzW01hdGguZmxvb3IoX2NsYW1wKGNob2ljZXMubGVuZ3RoICogY2hvaWNlRmFjdG9yLCAwLHRvdGFsKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlID0gY2hvaWNlc1tNYXRoLmZsb29yKF9jbGFtcChjaG9pY2VzLmxlbmd0aCAqIGZhY3RvciwgMCx0b3RhbCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hvaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSBjaGFwdGVyW2ldWyd2aWRlb3MnXVtjaG9pY2VdWydkdXJhdGlvbiddO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZS5wdXNoKFtpLCBjaG9pY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgc2VlZCA9IGNob2ljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICAgICAgICBfX2NyZWF0ZVJvdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfX2NyZWF0ZVJvdXRlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlcGxhY2VSb3V0ZShtYW5pZmVzdCwgcm91dGVzKXtcbiAgICAgICAgdmFyIHJlcGxhY2VkTWFuaWZlc3QgPSBbXTtcbiAgICAgICAgXy5lYWNoKHJvdXRlcyxmdW5jdGlvbihyb3V0ZU9iaiwgY2hhcHRlckluZGV4KXtcbiAgICAgICAgICAgIHZhciB2aWRlb3MgPSBtYW5pZmVzdFtjaGFwdGVySW5kZXhdO1xuICAgICAgICAgICAgdmFyIGNoID0gW107XG4gICAgICAgICAgICBfLmVhY2gocm91dGVPYmpbJ3JvdXRlcyddLGZ1bmN0aW9uKHJvdXRlKXtcbiAgICAgICAgICAgICAgICBfLmVhY2gocm91dGUsZnVuY3Rpb24oZGF0YSwgaSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB2aWRlb3NbZGF0YVswXV07XG4gICAgICAgICAgICAgICAgICAgIG9bJ2NoYXB0ZXInXSA9IGNoYXB0ZXJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgb1snaW5kZXgnXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG9bJ2RpciddID0gaXRlbVsnZGlyJ107XG4gICAgICAgICAgICAgICAgICAgIG9bJ2NsaXAnXSA9IGl0ZW1bJ2Rhc2hlZCddW2RhdGFbMV1dO1xuICAgICAgICAgICAgICAgICAgICBjaC5wdXNoKG8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXBsYWNlZE1hbmlmZXN0LnB1c2goY2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VkTWFuaWZlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsYW1wKG51bWJlciwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obnVtYmVyLCBtYXgpKTtcbiAgICB9XG4gICAgLy9mdW5jdGlvbiBfY3JlYXRlUm91dGUoKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lOyIsInZhciBBUCA9IDAuNTYyNTtcbnZhciBXID0gMTI4MDtcbnZhciBIID0gNzIwO1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVRJTFMgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGZ1bmN0aW9uIG9uQXNwZWN0UmVzaXplKHcsIGgsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIF9kb09wKHcsIGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2RvT3AodywgaCkge1xuXHRcdHcgPSB3IHx8IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdGggPSBoIHx8IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHR2YXIgY29udGFpbmVyUmF0aW8gPSB3IC8gaDtcblx0XHR2YXIgZWxSYXRpbyA9IFcgLyBIO1xuXHRcdHZhciBzY2FsZSA9IDEsXG5cdFx0XHR4LCB5O1xuXG5cdFx0Ly8gZGVmaW5lIHNjYWxlXG5cdFx0aWYgKGNvbnRhaW5lclJhdGlvID4gZWxSYXRpbykge1xuXHRcdFx0aWYgKHcgPiBXKSB7XG5cdFx0XHRcdHNjYWxlID0gdyAvIFc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY2FsZSA9IFcgLyB3O1xuXHRcdFx0fVxuXHRcdFx0c2NhbGUgPSB3IC8gVztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGggPiBIKSB7XG5cdFx0XHRcdHNjYWxlID0gaCAvIEg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY2FsZSA9IEggLyBoO1xuXHRcdFx0fVxuXHRcdFx0c2NhbGUgPSBoIC8gSDtcblx0XHR9XG5cdFx0Ly8gZGVmaW5lIHBvc2l0aW9uXG5cdFx0aWYgKGNvbnRhaW5lclJhdGlvID09PSBlbFJhdGlvKSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAodyAtIFcgKiBzY2FsZSkgKiAwLjUgLyBzY2FsZTtcblx0XHRcdHkgPSAoaCAtIEggKiBzY2FsZSkgKiAwLjUgLyBzY2FsZTtcblx0XHR9XG5cdFx0c2NhbGUgPSBNYXRoLm1heChzY2FsZSwgMSk7XG5cdFx0Ly8gZml4ZWRcblx0XHQvL3ggPSBOdW1iZXIoeC50b0ZpeGVkKDEpKTtcblx0XHQvL3kgPSBOdW1iZXIoeS50b0ZpeGVkKDEpKTtcblx0XHRvYmpbJ3cnXSA9IFcgKiBzY2FsZTtcblx0XHRvYmpbJ2gnXSA9IEggKiBzY2FsZTtcblx0XHRvYmpbJ3NjYWxlJ10gPSBzY2FsZTtcblx0XHRvYmpbJ3gnXSA9IHg7XG5cdFx0b2JqWyd5J10gPSB5O1xuXG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0b25Bc3BlY3RSZXNpemU6IG9uQXNwZWN0UmVzaXplXG5cdH1cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVVRJTFM7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBXZWJjYW0odmlkZW9FbCkge1xuXHRuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1zR2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5vR2V0VXNlck1lZGlhO1xuXG5cdGlmIChuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKSB7XG5cdFx0bmF2aWdhdG9yLmdldFVzZXJNZWRpYSh7XG5cdFx0XHR2aWRlbzogdHJ1ZVxuXHRcdH0sIGhhbmRsZVZpZGVvLCB2aWRlb0Vycm9yKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZVZpZGVvKHN0cmVhbSkge1xuXHRcdC8vIGlmIGZvdW5kIGF0dGFjaCBmZWVkIHRvIHZpZGVvIGVsZW1lbnRcblx0XHR2aWRlb0VsLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiB2aWRlb0Vycm9yKGUpIHtcblx0XHQvLyBubyB3ZWJjYW0gZm91bmQgLSBkbyBzb21ldGhpbmdcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYmNhbTsiLCIvLyBhcHAgZGVwZW5kZW5jaWVzXG52YXIgQXBwID0gcmVxdWlyZSgnLi4vYXBwJyk7XG5cbi8vIGRlZmluZSBtb2R1bGVcbkFwcC5tb2R1bGUoJ0FwcENvbnRyb2xsZXInLCBmdW5jdGlvbihBcHBDb250cm9sbGVyLCBBcHAsIEJhY2tib25lLCBNYXJpb25ldHRlLCAkLCBfKSB7XG5cdC8vIGNvbnRyb2xsZXIgY2xhc3Ncblx0QXBwQ29udHJvbGxlci5Db250cm9sbGVyID0gTWFyaW9uZXR0ZS5Db250cm9sbGVyLmV4dGVuZCh7XG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIGxpc3RlbiB0byBldmVudHNcblx0XHRcdHRoaXMuY3JlYXRlVmlld3MoKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlVmlld3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5hcHBWaWV3ID0gbmV3IEFwcC5WaWV3cy5BcHAoKTtcblx0XHRcdEFwcC5SZWdpb25zLnNob3coJ25hdicsIHRoaXMuYXBwVmlldyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBpbnN0YW5jZVxuXHRBcHBDb250cm9sbGVyLmluc3RhbmNlID0gbmV3IEFwcENvbnRyb2xsZXIuQ29udHJvbGxlcigpO1xufSk7XG5cbi8vIGV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBBcHAuQXBwQ29udHJvbGxlcjsiLCIvLyBhcHAgZGVwZW5kZW5jaWVzXG52YXIgQXBwID0gcmVxdWlyZSgnLi4vYXBwJyk7XG52YXIgUSA9IHJlcXVpcmUoJ3EnKTtcbi8vIGRlZmluZSBtb2R1bGVcbkFwcC5tb2R1bGUoJ0VudGl0aWVzJywgZnVuY3Rpb24oRW50aXRpZXMsIEFwcCwgQmFja2JvbmUsIE1hcmlvbmV0dGUsICQsIF8pIHtcblxuICAgIGZ1bmN0aW9uIF9nZXRNYW5pZmVzdCgpIHtcbiAgICAgICAgdmFyIGRlZmVyID0gUS5kZWZlcigpO1xuICAgICAgICBRKCQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgIHVybDogJ2Fzc2V0cy9qc29uL3ZpZGVvc19tYW5pZmVzdC5qc29uJ1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldEVmZmVjdHMoKSB7XG4gICAgICAgIHZhciBkZWZlciA9IFEuZGVmZXIoKTtcbiAgICAgICAgUSgkLmFqYXgoe1xuICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICB1cmw6ICdhc3NldHMvanNvbi9lZmZlY3RfZHVyYXRpb25zLmpzb24nXG4gICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICB9XG5cbiAgICBBcHAucmVxcmVzLnNldEhhbmRsZXIoJ3JlcXJlczplZmZlY3RzJywgX2dldEVmZmVjdHMpO1xuICAgIEFwcC5yZXFyZXMuc2V0SGFuZGxlcigncmVxcmVzOm1hbmlmZXN0JywgX2dldE1hbmlmZXN0KTtcblxufSk7XG5cbi8vIGV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBBcHAuRW50aXRpZXM7IiwiLy8gYXBwIGRlcGVuZGVuY2llc1xudmFyIEFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpO1xuXG4vLyBkZWZpbmUgbW9kdWxlXG5BcHAubW9kdWxlKCdSZWdpb25zJywgZnVuY3Rpb24oUmVnaW9ucywgQXBwLCBCYWNrYm9uZSwgTWFyaW9uZXR0ZSwgJCwgXykge1xuXG5cdC8vIHJlZ2lvbiBtYW5hZ2VyIGNsYXNzXG5cdFJlZ2lvbnMuUmVnaW9uTWFuYWdlciA9IE1hcmlvbmV0dGUuUmVnaW9uTWFuYWdlci5leHRlbmQoe1xuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBkZWZpbmUgcmVnaW9uc1xuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblx0XHRcdGRhdGFbJ25hdiddID0gJyNuYXYtcmVnaW9uJztcblx0XHRcdGRhdGFbJ2NvbnRlbnQnXSA9ICcjY29udGVudC1yZWdpb24nO1xuXHRcdFx0dGhpcy5hZGRSZWdpb25zKGRhdGEpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHRSZWdpb25zLmdldCA9IGZ1bmN0aW9uKHJlZ2lvbklkKSB7XG5cdFx0cmV0dXJuIFJlZ2lvbnMuaW5zdGFuY2UuZ2V0KHJlZ2lvbklkKTtcblx0fTtcblxuXHQvLyBoZWxwZXJzXG5cdFJlZ2lvbnMuc2hvdyA9IGZ1bmN0aW9uKHJlZ2lvbklkLCB2aWV3KSB7XG5cdFx0aWYgKCF2aWV3KSByZXR1cm47XG5cdFx0dmFyIHJlZ2lvbiA9IFJlZ2lvbnMuaW5zdGFuY2UuZ2V0KHJlZ2lvbklkKTtcblx0XHRpZiAocmVnaW9uKSB7XG5cdFx0XHRyZWdpb24uc2hvdyh2aWV3KTtcblx0XHR9XG5cdH07XG5cblx0UmVnaW9ucy5hZGQgPSBmdW5jdGlvbihjb25zdGFudCwgc2VsZWN0b3IpIHtcblx0XHRpZiAoIVJlZ2lvbnMuaW5zdGFuY2UpIHJldHVybjtcblx0XHR2YXIgciA9IHt9O1xuXHRcdHJbY29uc3RhbnRdID0gc2VsZWN0b3I7XG5cdFx0UmVnaW9ucy5pbnN0YW5jZS5hZGRSZWdpb25zKHIpO1xuXHR9O1xuXG5cdC8vIGluc3RhbmNlXG5cdFJlZ2lvbnMuaW5zdGFuY2UgPSBuZXcgUmVnaW9ucy5SZWdpb25NYW5hZ2VyKCk7XG5cbn0pO1xuXG4vLyBleHBvcnRcbm1vZHVsZS5leHBvcnRzID0gQXBwLlJlZ2lvbnM7IiwiLy8gYXBwIGRlcGVuZGVuY2llc1xudmFyIEFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpO1xuLy8gZGVmaW5lIG1vZHVsZVxuQXBwLm1vZHVsZSgnVmlld3MnLCBmdW5jdGlvbihWaWV3cywgQXBwLCBCYWNrYm9uZSwgTWFyaW9uZXR0ZSwgJCwgXykge1xuICAgIFZpZXdzLkFwcCA9IE1hcmlvbmV0dGUuTGF5b3V0Vmlldy5leHRlbmQoe1xuICAgICAgICB0ZW1wbGF0ZTogSlNUWydhcHAnXSxcbiAgICAgICAgcmVnaW9uczp7XG4gICAgICAgICAgICBjb250ZW50ejonI2NvbnRlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgJ2NsaWNrIC5qcy1zaGFkZXInOiAnb25TaGFkZXInLFxuICAgICAgICAgICAgJ2NsaWNrIC5qcy1jb21wb3Nlcic6ICdvbkNvbXBvc2VyJyxcbiAgICAgICAgICAgICdjbGljayAuanMtZngnOiAnb25GeCdcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB9LFxuICAgICAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgb25TaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25TaGFkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJWaWV3ID0gbmV3IEFwcC5WaWV3cy5TaGFkZXJWaWV3KCk7XG4gICAgICAgICAgICBBcHAuUmVnaW9ucy5zaG93KCdjb250ZW50JywgdGhpcy5zaGFkZXJWaWV3KTtcbiAgICAgICAgICAgIC8vdGhpcy5jb250ZW50ei5zaG93KHRoaXMuc2hhZGVyVmlldyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcG9zZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NlclZpZXcgPSBuZXcgQXBwLlZpZXdzLkNvbXBvc2VyKCk7XG4gICAgICAgICAgICBBcHAuUmVnaW9ucy5zaG93KCdjb250ZW50JywgdGhpcy5jb21wb3NlclZpZXcpO1xuICAgICAgICAgICAgLy90aGlzLmNvbnRlbnR6LnNob3codGhpcy5zaGFkZXJWaWV3KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25GeDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZ4VmlldyA9IG5ldyBBcHAuVmlld3MuRlgoKTtcbiAgICAgICAgICAgIEFwcC5SZWdpb25zLnNob3coJ2NvbnRlbnQnLCB0aGlzLmZ4Vmlldyk7XG4gICAgICAgICAgICAvL3RoaXMuY29udGVudHouc2hvdyh0aGlzLnNoYWRlclZpZXcpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuLy8gZXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IEFwcC5WaWV3czsiLCJ2YXIgQXBwID0gcmVxdWlyZSgnLi4vYXBwJyk7XG52YXIgZGF0ID0gcmVxdWlyZSgnZGF0LWd1aScpO1xudmFyIFN0YXRzID0gcmVxdWlyZSgnc3RhdHMnKTtcbnZhciBUSU1FTElORSA9IHJlcXVpcmUoJy4uL2NvbW1vbi90aW1lbGluZScpO1xudmFyIFNIQURFUlNfTElCID0gcmVxdWlyZSgnLi4vY29tbW9uL3NoYWRlcl9saWInKTtcbnZhciBUSFJFRV9TQ0VORSA9IHJlcXVpcmUoJy4uL2NvbW1vbi90aHJlZV9zY2VuZScpO1xudmFyIFNDRU5FID0gcmVxdWlyZSgnLi4vY29tbW9uL3NjZW5lJyk7XG52YXIgVVRJTFMgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKTtcbnZhciBBVURJTyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hdWRpb19hbmFseXNlcicpO1xudmFyIFBMQVlFUiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wbGF5ZXJfY29udHJvbGxlcicpO1xuLy8gYXBwIGRlcGVuZGVuY2llc1xudmFyIE5VTV9DT0xVTU5TID0gMjtcbnZhciBWSURFT19XSURUSCA9IDQ4MDtcbnZhciBWSURFT19IRUlHSFQgPSAzNjA7XG52YXIgTUFYX0FTUEVDVCA9IDIuMzE7XG5cbnZhciBzdGF0c0VuYWJsZWQgPSB0cnVlO1xuXG52YXIgY29udGFpbmVyLCBzdGF0cywgbG9hZGVyO1xudmFyIGNhbWVyYSwgc2NlbmUsIHJlbmRlcmVyO1xuXG52YXIgZ2VvbWV0cnk7XG52YXIgcGxhbmVzO1xudmFyIHZpZGVvUGxhbmUsIHZpZGVvTWF0ZXJpYWwsIHRleHRNYXRlcmlhbCwgdGV4dE1hdGVyaWFsU2lkZSwgdGV4dE1hdGVyaWFsRnJvbnQsIHRleHRNYXRlcmlhbEFycmF5LCB0ZXh0Q29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMHhGRjAwMCk7XG52YXIgdGV4dHVyZTEsIHRleHR1cmUyLCB0ZXh0dXJlMywgdmlkZW8sIHNjZW5lQSwgc2NlbmVCO1xudmFyIHBsYW5lc0dyb3VwO1xuXG4vL05vcm1hbCBtYXAgc2hhZGVyXG52YXIgYW1iaWVudCA9IDB4ZmZmZmZmLFxuXHRkaWZmdXNlID0gMHhmZmZmZmYgLyA1LFxuXHRzcGVjdWxhciA9IDB4ZmZmZmZmLFxuXHRzY2FsZSA9IDE0MztcblxudmFyIHRleHRNZXNoLCB0ZXh0R2VvO1xuXG52YXIgc3BvdExpZ2h0LCBwb2ludExpZ2h0LCBhbWJpZW50TGlnaHQ7XG52YXIgaXNSZW5kZXIgPSB0cnVlO1xuXG52YXIgbW91c2VYID0gMDtcbnZhciBtb3VzZVkgPSAwO1xuXG52YXIgY29udHJvbHM7XG5cbnZhciB3aW5kb3dIYWxmWCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMjtcbnZhciB3aW5kb3dIYWxmWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDI7XG5cbi8vIGRlZmluZSBtb2R1bGVcbkFwcC5tb2R1bGUoJ1ZpZXdzJywgZnVuY3Rpb24oVmlld3MsIEFwcCwgQmFja2JvbmUsIE1hcmlvbmV0dGUsICQsIF8pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0Vmlld3MuQ29tcG9zZXIgPSBNYXJpb25ldHRlLkl0ZW1WaWV3LmV4dGVuZCh7XG5cdFx0dGVtcGxhdGU6IEpTVFsnY29tcG9zZXJfdmlldyddLFxuXHRcdGV2ZW50czoge1xuXHRcdFx0J2NsaWNrIC5qcy1nbyc6ICdzdGFydFByb2Nlc3MnXG5cdFx0fSxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHR0aGlzLnRpbWVsaW5lID0gbmV3IFRJTUVMSU5FKCk7XG5cdFx0XHRBcHAucmVxcmVzLnJlcXVlc3QoJ3JlcXJlczptYW5pZmVzdCcpLnRoZW4oZnVuY3Rpb24obWFuaWZlc3QpIHtcblx0XHRcdFx0Y29uc29sZS5sb2cobWFuaWZlc3QpO1xuXHRcdFx0XHQvKnZhciBmaW5hbE1hbmlmZXN0ID0gW107XG5cdFx0XHRcdHZhciBuZXdNYW5pZmVzdCA9IFtdO1xuXHRcdFx0XHRfLmVhY2gobWFuaWZlc3QsZnVuY3Rpb24oY2xpcCl7XG5cdFx0XHRcdFx0bmV3TWFuaWZlc3QgPSBuZXdNYW5pZmVzdC5jb25jYXQoY2xpcFsndmlkZW9zJ10pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2ggPSBbXTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDIwOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciBjbGlwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRcdGNsaXBbJ3ZpZGVvcyddID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDM7IGsrKykge1xuXHRcdFx0XHRcdFx0XHRpZihuZXdNYW5pZmVzdC5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpdGVtID0gbmV3TWFuaWZlc3Quc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgc2lkeCA9IGl0ZW1bJ3NpZHgnXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdF8uZWFjaChzaWR4WydyZWZlcmVuY2VzJ10sZnVuY3Rpb24obyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbiArPSBvWydkdXJhdGlvblNlYyddO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGl0ZW1bJ2R1cmF0aW9uJ10gPSBkdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRjbGlwWyd2aWRlb3MnXS5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaC5wdXNoKGNsaXApXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZpbmFsTWFuaWZlc3QucHVzaChjaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coZmluYWxNYW5pZmVzdCk7XG5cdFx0XHRcdCovXG5cdFx0XHRcdHRoaXMubWFuaWZlc3QgPSAgdGhpcy50aW1lbGluZS5zdGFydChtYW5pZmVzdCk7XG5cdFx0XHRcdHRoaXMuc2V0dXBQbGF5ZXIoKTtcblx0XHRcdH0uYmluZCh0aGlzKSkuZG9uZSgpO1xuXHRcdH0sXG5cdFx0b25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly9ndWlcblx0XHRcdHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0dGhpcy5ndWlPcHRpb25zWyd1TWl4UmF0aW8nXSA9IDAuMDE7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnNbJ3VUaHJlc2hvbGQnXSA9IDAuMDE7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnNbJ3VTYXR1cmF0aW9uJ10gPSAwLjAxO1xuXHRcdH0sXG5cdFx0b25TaG93OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBndWkgPSBuZXcgZGF0LkdVSSgpO1xuXHRcdFx0Z3VpLmFkZCh0aGlzLmd1aU9wdGlvbnMsICd1TWl4UmF0aW8nLCAwLCAxKS5vbkNoYW5nZShmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0dmlkZW9NYXRlcmlhbC51bmlmb3Jtc1tcInVNaXhSYXRpb1wiXS52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndU1peFJhdGlvJ107XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHRndWkuYWRkKHRoaXMuZ3VpT3B0aW9ucywgJ3VUaHJlc2hvbGQnLCAwLCAuNSkub25DaGFuZ2UoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZpZGVvTWF0ZXJpYWwudW5pZm9ybXNbXCJ1VGhyZXNob2xkXCJdLnZhbHVlID0gdGhpcy5ndWlPcHRpb25zWyd1VGhyZXNob2xkJ107XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHRndWkuYWRkKHRoaXMuZ3VpT3B0aW9ucywgJ3VTYXR1cmF0aW9uJywgMCwgMi4pLm9uQ2hhbmdlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2aWRlb01hdGVyaWFsLnVuaWZvcm1zW1widVNhdHVyYXRpb25cIl0udmFsdWUgPSB0aGlzLmd1aU9wdGlvbnNbJ3VTYXR1cmF0aW9uJ107XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHRndWkud2lkdGggPSAzMDA7XG5cdFx0XHR0aGlzLmFhID0gbmV3IEFVRElPKCk7XG5cdFx0XHR0aGlzLmFhLmFkZFRyYWNrKCdhc3NldHMvYXVkaW8vZ2lybC5tcDMnKTtcblxuXHRcdFx0Lypcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215VmlkZW8nKTtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50LnZvbHVtZSA9IDA7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudC53aWR0aCA9IFZJREVPX1dJRFRIO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQuaGVpZ2h0ID0gVklERU9fSEVJR0hUO1xuXG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlWaWRlbzInKTtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50Mi52b2x1bWUgPSAwO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQyLndpZHRoID0gVklERU9fV0lEVEg7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDIuaGVpZ2h0ID0gVklERU9fSEVJR0hUO1xuXG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWl4ZXInKTtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50My52b2x1bWUgPSAwO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQzLndpZHRoID0gVklERU9fV0lEVEg7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDMuaGVpZ2h0ID0gVklERU9fSEVJR0hUOyovXG5cblx0XHRcdHRoaXMuZ3VpID0gZ3VpO1xuXHRcdFx0Ly90aGlzLnNldHVwM0QoKTtcblx0XHR9LFxuXHRcdHNldHVwUGxheWVyOmZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVZpZGVvJyk7XG5cdFx0XHR0aGlzLnBsYXllckNvbnRyb2xsZXIgPSBuZXcgUExBWUVSKCk7XG5cdFx0XHR0aGlzLnBsYXllckNvbnRyb2xsZXIuaW5pdCh0aGlzLnZpZGVvRWxlbWVudCk7XG5cdFx0XHRjb25zb2xlLmxvZyh0aGlzLm1hbmlmZXN0KTtcblx0XHRcdHRoaXMucGxheWVyQ29udHJvbGxlci5zZXRFbnRpcmVNYW5pZmVzdCh0aGlzLm1hbmlmZXN0KTtcblx0XHR9LFxuXHRcdC8vLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLzNEXG5cdFx0Ly8vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0c2V0dXAzRDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgWl9ESVMgPSA0MDA7XG5cdFx0XHRyZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcblx0XHRcdFx0YW50aWFsaWFzOiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGhyZWUnKS5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcblxuXHRcdFx0c3RhdHMgPSBuZXcgU3RhdHMoKTtcblx0XHRcdHN0YXRzLmRvbUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0c3RhdHMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnMHB4Jztcblx0XHRcdHRoaXMuZWwuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tRWxlbWVudCk7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDEsIDEwMDAwKTtcblx0XHRcdGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgWl9ESVMpO1xuXG5cdFx0XHRjb250cm9scyA9IG5ldyBUSFJFRS5UcmFja2JhbGxDb250cm9scyhjYW1lcmEsIHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXHRcdFx0Y29udHJvbHMubWluRGlzdGFuY2UgPSBaX0RJUztcblx0XHRcdGNvbnRyb2xzLm1heERpc3RhbmNlID0gMTAwMDtcblxuXHRcdFx0dGV4dHVyZTEgPSBuZXcgVEhSRUUuVGV4dHVyZSh0aGlzLnZpZGVvRWxlbWVudCk7XG5cdFx0XHR0ZXh0dXJlMS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlMS5tYWdGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHRcdHRleHR1cmUyID0gbmV3IFRIUkVFLlRleHR1cmUodGhpcy52aWRlb0VsZW1lbnQyKTtcblx0XHRcdHRleHR1cmUyLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUyLm1hZ0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0dGV4dHVyZTMgPSBuZXcgVEhSRUUuVGV4dHVyZSh0aGlzLnZpZGVvRWxlbWVudDMpO1xuXHRcdFx0dGV4dHVyZTMubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZTMubWFnRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHQvL3RleHR1cmUzID0gbmV3IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJy4uL2ltZzEuanBnJyk7XG5cdFx0XHR2YXIgc2NhbGVPYmogPSBVVElMUy5vbkFzcGVjdFJlc2l6ZSgpO1xuXG5cdFx0XHRzY2VuZUEgPSBuZXcgU0NFTkUocmVuZGVyZXIsIDB4ZmZmZmZmLCBaX0RJUyk7XG5cdFx0XHRzY2VuZUEuY3JlYXRlUGxhbmUoc2NhbGVPYmoudywgc2NhbGVPYmouaCwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0bWFwOiB0ZXh0dXJlMVxuXHRcdFx0fSkpO1xuXG5cdFx0XHRzY2VuZUIgPSBuZXcgU0NFTkUocmVuZGVyZXIsIDB4MDAwMDAwLCBaX0RJUyk7XG5cdFx0XHRzY2VuZUIuY3JlYXRlUGxhbmUoc2NhbGVPYmoudywgc2NhbGVPYmouaCwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdFx0bWFwOiB0ZXh0dXJlMlxuXHRcdFx0fSkpO1xuXG5cdFx0XHR2YXIgZCA9IFNIQURFUlNfTElCWydtaXgnXSgpO1xuXHRcdFx0Y29uc29sZS5sb2coZCk7XG5cdFx0XHR2YXIgc2hhZGVyID0gZFsnc2hhZGVyJ107XG5cdFx0XHR2YXIgdW5pZm9ybXMgPSBkWyd1bmlmb3JtcyddO1xuXHRcdFx0dW5pZm9ybXNbXCJ0T25lXCJdLnZhbHVlID0gc2NlbmVBLmZibztcblx0XHRcdHVuaWZvcm1zW1widFR3b1wiXS52YWx1ZSA9IHNjZW5lQi5mYm87XG5cdFx0XHR1bmlmb3Jtc1tcInRNaXhcIl0udmFsdWUgPSB0ZXh0dXJlMztcblx0XHRcdHVuaWZvcm1zW1widU1peFJhdGlvXCJdLnZhbHVlID0gdGhpcy5ndWlPcHRpb25zWyd1TWl4UmF0aW8nXTtcblx0XHRcdHVuaWZvcm1zW1widVRocmVzaG9sZFwiXS52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndVRocmVzaG9sZCddO1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0XHR1bmlmb3JtczogdW5pZm9ybXNcblx0XHRcdH07XG5cdFx0XHR2YXIgcXVhZGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoc2NhbGVPYmoudywgc2NhbGVPYmouaCwgNCwgNCk7XG5cdFx0XHQvL1RIUkVFLkdlb21ldHJ5VXRpbHMuY2VudGVyKHF1YWRnZW9tZXRyeSk7XG5cblx0XHRcdHZpZGVvTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwocGFyYW1ldGVycyk7XG5cblx0XHRcdHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblx0XHRcdHRoaXMucXVhZCA9IG5ldyBUSFJFRS5NZXNoKHF1YWRnZW9tZXRyeSwgdmlkZW9NYXRlcmlhbCk7XG5cdFx0XHRzY2VuZS5hZGQodGhpcy5xdWFkKTtcblxuXHRcdFx0c2NlbmUuYWRkKHRoaXMucXVhZCk7XG5cblx0XHRcdHRoaXMuYm91bmRBbmltYXRlID0gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG5cdFx0XHR0aGlzLmJvdW5kQW5pbWF0ZSgpO1xuXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG5cblx0XHRcdHRoaXMub25XaW5kb3dSZXNpemUoKTtcblx0XHR9LFxuXHRcdG9uV2luZG93UmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB3ID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0XHR2YXIgaCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHRcdGNhbWVyYS5hc3BlY3QgPSB3IC8gaDtcblx0XHRcdGNvbnNvbGUubG9nKGNhbWVyYS5hc3BlY3QpO1xuXHRcdFx0dmFyIHNjYWxlID0gMDtcblx0XHRcdGlmICh3IC8gaCA+IE1BWF9BU1BFQ1QpIHtcblx0XHRcdFx0c2NhbGUgPSAxICsgdyAvIGggLyBNQVhfQVNQRUNUO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2NhbGUgPSAxXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnF1YWQuc2NhbGUueCA9IHRoaXMucXVhZC5zY2FsZS55ID0gc2NhbGU7XG5cdFx0XHRyZW5kZXJlci5zZXRTaXplKHcsIGgpXG5cdFx0XHRzY2VuZUEucmVzaXplKHcsIGgsIHNjYWxlKTtcblx0XHRcdHNjZW5lQi5yZXNpemUodywgaCwgc2NhbGUpO1xuXHRcdH0sXG5cdFx0aGFuZGxlUmVzaXplOiBmdW5jdGlvbih3LCBoKSB7XG5cdFx0XHRjb25zb2xlLmxvZyh3LCBoKTtcblx0XHR9LFxuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kQW5pbWF0ZSk7XG5cdFx0XHR0aGlzLnRocmVlUmVuZGVyKCk7XG5cdFx0XHRzdGF0cy51cGRhdGUoKTtcblx0XHR9LFxuXG5cdFx0dGhyZWVSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29udHJvbHMudXBkYXRlKCk7XG5cdFx0XHR0ZXh0dXJlMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0ZXh0dXJlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0ZXh0dXJlMy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR2aWRlb01hdGVyaWFsLnVuaWZvcm1zLnVNaXhSYXRpby52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndU1peFJhdGlvJ107XG5cdFx0XHR2aWRlb01hdGVyaWFsLnVuaWZvcm1zLnVUaHJlc2hvbGQudmFsdWUgPSB0aGlzLmd1aU9wdGlvbnNbJ3VUaHJlc2hvbGQnXTtcblx0XHRcdGlmICh0aGlzLmd1aU9wdGlvbnNbJ3VNaXhSYXRpbyddID09IDApIHtcblx0XHRcdFx0c2NlbmVCLnJlbmRlcihmYWxzZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZ3VpT3B0aW9uc1sndU1peFJhdGlvJ10gPT0gMSkge1xuXHRcdFx0XHRzY2VuZUEucmVuZGVyKGZhbHNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjZW5lQS5yZW5kZXIodHJ1ZSk7XG5cdFx0XHRcdHNjZW5lQi5yZW5kZXIodHJ1ZSk7XG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCBudWxsLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fSk7XG59KTtcblxuLy8gZXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IEFwcC5Db21wb3NlcjsiLCJ2YXIgQXBwID0gcmVxdWlyZSgnLi4vYXBwJyk7XG52YXIgZGF0ID0gcmVxdWlyZSgnZGF0LWd1aScpO1xudmFyIFN0YXRzID0gcmVxdWlyZSgnc3RhdHMnKTtcbnZhciBTSEFERVJTX0xJQiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaGFkZXJfbGliJyk7XG52YXIgVEhSRUVfU0NFTkUgPSByZXF1aXJlKCcuLi9jb21tb24vdGhyZWVfc2NlbmUnKTtcbnZhciBTQ0VORSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zY2VuZScpO1xudmFyIFVUSUxTID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJyk7XG52YXIgRlhfT1BUSU9OUyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaGFkZXJfb3B0aW9ucycpO1xudmFyIFRJTUVMSU5FID0gcmVxdWlyZSgnLi4vY29tbW9uL3RpbWVsaW5lJyk7XG52YXIgV0VCQ0FNID0gcmVxdWlyZSgnLi4vY29tbW9uL3dlYmNhbScpO1xudmFyIFBMQVlFUiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wbGF5ZXJfY29udHJvbGxlcicpO1xuLy8gYXBwIGRlcGVuZGVuY2llc1xudmFyIE5VTV9DT0xVTU5TID0gMjtcbnZhciBWSURFT19XSURUSCA9IDEyODA7XG52YXIgVklERU9fSEVJR0hUID0gODUzO1xudmFyIE1BWF9BU1BFQ1QgPSAyLjMxO1xuXG52YXIgc3RhdHNFbmFibGVkID0gdHJ1ZTtcblxudmFyIGNvbnRhaW5lciwgc3RhdHMsIGxvYWRlcjtcbnZhciBjYW1lcmEsIHNjZW5lLCByZW5kZXJlcjtcblxudmFyIGdlb21ldHJ5O1xudmFyIHBsYW5lcztcbnZhciB2aWRlb1BsYW5lLCB2aWRlb01hdGVyaWFsLCB0ZXh0TWF0ZXJpYWwsIHRleHRNYXRlcmlhbFNpZGUsIHRleHRNYXRlcmlhbEZyb250LCB0ZXh0TWF0ZXJpYWxBcnJheSwgdGV4dENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4RkYwMDApO1xudmFyIHRleHR1cmUxLCB0ZXh0dXJlMiwgdGV4dHVyZTMsIHZpZGVvLCBzY2VuZUEsIHNjZW5lQiwgbWl4ZXI7XG52YXIgcGxhbmVzR3JvdXA7XG5cbi8vTm9ybWFsIG1hcCBzaGFkZXJcbnZhciBhbWJpZW50ID0gMHhmZmZmZmYsXG5cdGRpZmZ1c2UgPSAweGZmZmZmZiAvIDUsXG5cdHNwZWN1bGFyID0gMHhmZmZmZmYsXG5cdHNjYWxlID0gMTQzO1xuXG52YXIgdGV4dE1lc2gsIHRleHRHZW87XG5cbnZhciBzcG90TGlnaHQsIHBvaW50TGlnaHQsIGFtYmllbnRMaWdodDtcbnZhciBpc1JlbmRlciA9IHRydWU7XG5cbnZhciBtb3VzZVggPSAwO1xudmFyIG1vdXNlWSA9IDA7XG5cbnZhciBjb250cm9scztcblxudmFyIHdpbmRvd0hhbGZYID0gd2luZG93LmlubmVyV2lkdGggLyAyO1xudmFyIHdpbmRvd0hhbGZZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMjtcblxuLy8gZGVmaW5lIG1vZHVsZVxuQXBwLm1vZHVsZSgnVmlld3MnLCBmdW5jdGlvbihWaWV3cywgQXBwLCBCYWNrYm9uZSwgTWFyaW9uZXR0ZSwgJCwgXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRWaWV3cy5GWCA9IE1hcmlvbmV0dGUuSXRlbVZpZXcuZXh0ZW5kKHtcblx0XHR0ZW1wbGF0ZTogSlNUWydlZmZlY3RfdmlldyddLFxuXHRcdGV2ZW50czoge1xuXHRcdFx0J2NsaWNrIC5qcy1nbyc6ICdzdGFydFByb2Nlc3MnXG5cdFx0fSxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHR0aGlzLnRpbWVsaW5lID0gbmV3IFRJTUVMSU5FKCk7XG5cdFx0XHRBcHAucmVxcmVzLnJlcXVlc3QoJ3JlcXJlczptYW5pZmVzdCcpLnRoZW4oZnVuY3Rpb24obWFuaWZlc3QpIHtcblx0XHRcdFx0dGhpcy5tYW5pZmVzdCA9IHRoaXMudGltZWxpbmUuc3RhcnQobWFuaWZlc3QpO1xuXHRcdFx0XHR0aGlzLnNldHVwUGxheWVyKCk7XG5cdFx0XHR9LmJpbmQodGhpcykpLmRvbmUoKTtcblx0XHR9LFxuXHRcdHNldHVwUGxheWVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215VmlkZW8nKTtcblx0XHRcdHRoaXMucGxheWVyQ29udHJvbGxlciA9IG5ldyBQTEFZRVIoKTtcblx0XHRcdHRoaXMucGxheWVyQ29udHJvbGxlci5pbml0KHRoaXMudmlkZW9FbGVtZW50KTtcblx0XHRcdHRoaXMucGxheWVyQ29udHJvbGxlci5zZXRFbnRpcmVNYW5pZmVzdCh0aGlzLm1hbmlmZXN0KTtcblx0XHR9LFxuXHRcdG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0dGhpcy5ndWlPcHRpb25zWyd1TWl4UmF0aW8nXSA9IDAuMDE7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnNbJ3VUaHJlc2hvbGQnXSA9IDAuMDE7XG5cdFx0XHR0aGlzLmd1aU9wdGlvbnNbJ3VTYXR1cmF0aW9uJ10gPSAwLjAxO1xuXHRcdFx0Ly9ndWlcblx0XHR9LFxuXHRcdG9uU2hvdzogZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBndWkgPSBuZXcgZGF0LkdVSSgpO1xuXHRcdFx0dmFyIG1haW4gPSBndWkuYWRkRm9sZGVyKCdtYWluJyk7XG5cdFx0XHRtYWluLmFkZCh0aGlzLmd1aU9wdGlvbnMsICd1TWl4UmF0aW8nLCAwLCAxKS5vbkNoYW5nZShmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0dmlkZW9NYXRlcmlhbC51bmlmb3Jtc1tcInVNaXhSYXRpb1wiXS52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndU1peFJhdGlvJ107XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHRtYWluLmFkZCh0aGlzLmd1aU9wdGlvbnMsICd1VGhyZXNob2xkJywgMCwgLjUpLm9uQ2hhbmdlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2aWRlb01hdGVyaWFsLnVuaWZvcm1zW1widVRocmVzaG9sZFwiXS52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndVRocmVzaG9sZCddO1xuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblxuXHRcdFx0bWFpbi5hZGQodGhpcy5ndWlPcHRpb25zLCAndVNhdHVyYXRpb24nLCAwLCAxMC4pLm9uQ2hhbmdlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2aWRlb01hdGVyaWFsLnVuaWZvcm1zW1widVNhdHVyYXRpb25cIl0udmFsdWUgPSB0aGlzLmd1aU9wdGlvbnNbJ3VTYXR1cmF0aW9uJ107XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXG5cdFx0XHR2YXIgb3B0aW9uc0EgPSBndWkuYWRkRm9sZGVyKCdzY2VuZUEnKTtcblx0XHRcdHZhciBvcHRuc0ZvbGRlciA9IFtdO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBfLmNsb25lRGVlcChGWF9PUFRJT05TKTtcblx0XHRcdF8uZm9ySW4ob3B0aW9ucywgZnVuY3Rpb24ob2JqLCBrZXkpIHtcblx0XHRcdFx0dmFyIGYgPSBvcHRpb25zQS5hZGRGb2xkZXIoJ3NjZW5lQS0nK2tleSk7XG5cdFx0XHRcdG9wdG5zRm9sZGVyLnB1c2goZik7XG5cdFx0XHRcdF8uZm9ySW4ob2JqLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0XHRcdFx0dmFyIGIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdGJbJ3VuaWZvcm1zJ10gPSBvYmo7XG5cdFx0XHRcdFx0Ylsnc2hhZGVyJ10gPSBrZXk7XG5cdFx0XHRcdFx0aWYgKF8uaXNPYmplY3QodikpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHYpO1xuXHRcdFx0XHRcdFx0Xy5mb3JJbih2LCBmdW5jdGlvbih2diwga2spIHtcblx0XHRcdFx0XHRcdFx0aWYgKGtrID09PSBrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zi5hZGQodiwgaywgdlsnbWluJ10sIHZbJ21heCddKS5vbkNoYW5nZShmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNjZW5lQS51cGRhdGVVbmlmb3Jtcyh0aGlzKTtcblx0XHRcdFx0XHRcdFx0XHR9LmJpbmQoYikpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYodHlwZW9mIHYgPT09ICdib29sZWFuJyl7XG5cdFx0XHRcdFx0XHRmLmFkZChvYmosIGspLm9uQ2hhbmdlKGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0XHRzY2VuZUEudXBkYXRlVW5pZm9ybXModGhpcyk7XG5cdFx0XHRcdFx0XHR9LmJpbmQoYikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIG9wdGlvbnNCID0gZ3VpLmFkZEZvbGRlcignc2NlbmVCJyk7XG5cdFx0XHR2YXIgb3B0bnNGb2xkZXIgPSBbXTtcblx0XHRcdHZhciBvcHRpb25zID0gXy5jbG9uZURlZXAoRlhfT1BUSU9OUyk7XG5cdFx0XHRfLmZvckluKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG5cdFx0XHRcdHZhciBmID0gb3B0aW9uc0IuYWRkRm9sZGVyKCdzY2VuZUItJytrZXkpO1xuXHRcdFx0XHRvcHRuc0ZvbGRlci5wdXNoKGYpO1xuXHRcdFx0XHRfLmZvckluKG9iaiwgZnVuY3Rpb24odiwgaykge1xuXHRcdFx0XHRcdHZhciBiID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRiWyd1bmlmb3JtcyddID0gb2JqO1xuXHRcdFx0XHRcdGJbJ3NoYWRlciddID0ga2V5O1xuXHRcdFx0XHRcdGlmIChfLmlzT2JqZWN0KHYpKSB7XG5cdFx0XHRcdFx0XHRfLmZvckluKHYsIGZ1bmN0aW9uKHZ2LCBraykge1xuXHRcdFx0XHRcdFx0XHRpZiAoa2sgPT09IGspIHtcblx0XHRcdFx0XHRcdFx0XHRmLmFkZCh2LCBrLCB2WydtaW4nXSwgdlsnbWF4J10pLm9uQ2hhbmdlKGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2NlbmVCLnVwZGF0ZVVuaWZvcm1zKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRcdH0uYmluZChiKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmLmFkZChvYmosIGspLm9uQ2hhbmdlKGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0XHRzY2VuZUIudXBkYXRlVW5pZm9ybXModGhpcyk7XG5cdFx0XHRcdFx0XHR9LmJpbmQoYikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdC8qXG5cdFx0XHR2YXIgb3B0bnNGb2xkZXIyID0gW107XG5cdFx0XHR2YXIgb3B0aW9uc0IgPSBndWkuYWRkRm9sZGVyKCdzY2VuZUInKTtcblx0XHRcdHZhciBvcHRpb25zID0gXy5jbG9uZURlZXAoRlhfT1BUSU9OUyk7XG5cdFx0XHRfLmZvckluKG9wdGlvbnMsIGZ1bmN0aW9uKG9iaiwga2V5KSB7XG5cdFx0XHRcdHZhciBmID0gb3B0aW9uc0IuYWRkRm9sZGVyKGtleSk7XG5cdFx0XHRcdG9wdG5zRm9sZGVyMi5wdXNoKGYpO1xuXHRcdFx0XHRfLmZvckluKG9iaiwgZnVuY3Rpb24odiwgaykge1xuXHRcdFx0XHRcdHZhciBiID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRiWyd1bmlmb3JtcyddID0gb2JqO1xuXHRcdFx0XHRcdGJbJ3NoYWRlciddID0ga2V5O1xuXHRcdFx0XHRcdGYuYWRkKG9iaiwgaywgMC4wMSwgMTAuMCkub25DaGFuZ2UoZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyh2YWwpO1xuXHRcdFx0XHRcdFx0c2NlbmVCLnVwZGF0ZVVuaWZvcm1zKHRoaXMpO1xuXHRcdFx0XHRcdH0uYmluZChiKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7Ki9cblx0XHRcdC8vb3B0aW9uc0EuXG5cblx0XHRcdGd1aS53aWR0aCA9IDMwMDtcblxuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlWaWRlbycpO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQudm9sdW1lID0gMDtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50LndpZHRoID0gVklERU9fV0lEVEg7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudC5oZWlnaHQgPSBWSURFT19IRUlHSFQ7XG5cblx0XHRcdHRoaXMudmlkZW9FbGVtZW50MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteVZpZGVvMicpO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQyLnZvbHVtZSA9IDA7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDIud2lkdGggPSBWSURFT19XSURUSDtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50Mi5oZWlnaHQgPSBWSURFT19IRUlHSFQ7XG5cblx0XHRcdHRoaXMudmlkZW9FbGVtZW50MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaXhlcicpO1xuXHRcdFx0dGhpcy53ZWJjYW0gPSBuZXcgV0VCQ0FNKHRoaXMudmlkZW9FbGVtZW50Myk7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDMudm9sdW1lID0gMDtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50My53aWR0aCA9IFZJREVPX1dJRFRIO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQzLmhlaWdodCA9IFZJREVPX0hFSUdIVDtcblxuXHRcdFx0dGhpcy5ndWkgPSBndWk7XG5cdFx0XHR0aGlzLnNldHVwM0QoKTtcblx0XHR9LFxuXG5cdFx0Ly8vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vM0Rcblx0XHQvLy8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRzZXR1cDNEOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBaX0RJUyA9IDQwMDtcblx0XHRcdHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuXHRcdFx0XHRhbnRpYWxpYXM6IHRydWVcblx0XHRcdH0pO1xuXHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblx0XHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aHJlZScpLmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuXG5cdFx0XHRzdGF0cyA9IG5ldyBTdGF0cygpO1xuXHRcdFx0c3RhdHMuZG9tRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRzdGF0cy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICcwcHgnO1xuXHRcdFx0dGhpcy5lbC5hcHBlbmRDaGlsZChzdGF0cy5kb21FbGVtZW50KTtcblxuXHRcdFx0Y2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMTAwMDApO1xuXHRcdFx0Y2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCBaX0RJUyk7XG5cblx0XHRcdHRleHR1cmUxID0gbmV3IFRIUkVFLlRleHR1cmUodGhpcy52aWRlb0VsZW1lbnQpO1xuXHRcdFx0dGV4dHVyZTEubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZTEubWFnRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHR0ZXh0dXJlMiA9IG5ldyBUSFJFRS5UZXh0dXJlKHRoaXMudmlkZW9FbGVtZW50Mik7XG5cdFx0XHR0ZXh0dXJlMi5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlMi5tYWdGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHRcdHRleHR1cmUzID0gbmV3IFRIUkVFLlRleHR1cmUodGhpcy52aWRlb0VsZW1lbnQzKTtcblx0XHRcdHRleHR1cmUzLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUzLm1hZ0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0dmFyIHNjYWxlT2JqID0gVVRJTFMub25Bc3BlY3RSZXNpemUoKTtcblxuXHRcdFx0c2NlbmVBID0gbmV3IFNDRU5FKHJlbmRlcmVyLCAweGZmZmZmZiwgWl9ESVMpO1xuXHRcdFx0c2NlbmVBLmNyZWF0ZVBsYW5lKHNjYWxlT2JqLncsIHNjYWxlT2JqLmgsIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdG1hcDogdGV4dHVyZTFcblx0XHRcdH0pKTtcblxuXHRcdFx0c2NlbmVCID0gbmV3IFNDRU5FKHJlbmRlcmVyLCAweDAwMDAwMCwgWl9ESVMpO1xuXHRcdFx0c2NlbmVCLmNyZWF0ZVBsYW5lKHNjYWxlT2JqLncsIHNjYWxlT2JqLmgsIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdG1hcDogdGV4dHVyZTJcblx0XHRcdH0pKTtcblxuXHRcdFx0c2NlbmVBLmZ4LnNldE90aGVyRmJvKHNjZW5lQi5mYm8pO1xuXHRcdFx0c2NlbmVCLmZ4LnNldE90aGVyRmJvKHNjZW5lQS5mYm8pO1xuXG5cdFx0XHR2YXIgZCA9IFNIQURFUlNfTElCWydtaXgnXSgpO1xuXHRcdFx0dmFyIHNoYWRlciA9IGRbJ3NoYWRlciddO1xuXHRcdFx0dmFyIHVuaWZvcm1zID0gZFsndW5pZm9ybXMnXTtcblx0XHRcdHVuaWZvcm1zW1widE9uZVwiXS52YWx1ZSA9IHNjZW5lQS5mYm87XG5cdFx0XHR1bmlmb3Jtc1tcInRUd29cIl0udmFsdWUgPSBzY2VuZUIuZmJvO1xuXHRcdFx0dW5pZm9ybXNbXCJ0TWl4XCJdLnZhbHVlID0gdGV4dHVyZTM7XG5cdFx0XHR1bmlmb3Jtc1tcInVNaXhSYXRpb1wiXS52YWx1ZSA9IHRoaXMuZ3VpT3B0aW9uc1sndU1peFJhdGlvJ107XG5cdFx0XHR1bmlmb3Jtc1tcInVUaHJlc2hvbGRcIl0udmFsdWUgPSB0aGlzLmd1aU9wdGlvbnNbJ3VUaHJlc2hvbGQnXTtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB7XG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0dW5pZm9ybXM6IHVuaWZvcm1zXG5cdFx0XHR9O1xuXHRcdFx0dmFyIHF1YWRnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHNjYWxlT2JqLncsIHNjYWxlT2JqLmgsIDQsIDQpO1xuXHRcdFx0Ly9USFJFRS5HZW9tZXRyeVV0aWxzLmNlbnRlcihxdWFkZ2VvbWV0cnkpO1xuXG5cdFx0XHR2aWRlb01hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHBhcmFtZXRlcnMpO1xuXG5cdFx0XHRzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG5cdFx0XHR0aGlzLnF1YWQgPSBuZXcgVEhSRUUuTWVzaChxdWFkZ2VvbWV0cnksIHZpZGVvTWF0ZXJpYWwpO1xuXHRcdFx0c2NlbmUuYWRkKHRoaXMucXVhZCk7XG5cblx0XHRcdHNjZW5lLmFkZCh0aGlzLnF1YWQpO1xuXG5cdFx0XHR0aGlzLmJvdW5kQW5pbWF0ZSA9IHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuXHRcdFx0dGhpcy5ib3VuZEFuaW1hdGUoKTtcblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25XaW5kb3dSZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG5cdFx0XHR0aGlzLm9uV2luZG93UmVzaXplKCk7XG5cdFx0fSxcblx0XHRvbldpbmRvd1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdFx0dmFyIGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0XHRjYW1lcmEuYXNwZWN0ID0gdyAvIGg7XG5cdFx0XHRjb25zb2xlLmxvZyhVVElMUy5vbkFzcGVjdFJlc2l6ZSh3LCBoKSk7XG5cdFx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdFx0c2NhbGUgPSBVVElMUy5vbkFzcGVjdFJlc2l6ZSh3LCBoKS5zY2FsZVxuXHRcdFx0LyppZiAodyAvIGggPiBNQVhfQVNQRUNUKSB7XG5cdFx0XHRcdHNjYWxlID0gMSArIHcgLyBoIC8gTUFYX0FTUEVDVDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjYWxlID0gMVxuXHRcdFx0fSovXG5cdFx0XHRzY2FsZSA9IDE7XG5cdFx0XHR0aGlzLnF1YWQuc2NhbGUueCA9IHRoaXMucXVhZC5zY2FsZS55ID0gc2NhbGU7XG5cdFx0XHRyZW5kZXJlci5zZXRTaXplKHcsIGgpXG5cdFx0XHRzY2VuZUEucmVzaXplKHcsIGgsIHNjYWxlKTtcblx0XHRcdHNjZW5lQi5yZXNpemUodywgaCwgc2NhbGUpO1xuXHRcdH0sXG5cdFx0aGFuZGxlUmVzaXplOiBmdW5jdGlvbih3LCBoKSB7XG5cdFx0XHRjb25zb2xlLmxvZyh3LCBoKTtcblx0XHR9LFxuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kQW5pbWF0ZSk7XG5cdFx0XHR0aGlzLnRocmVlUmVuZGVyKCk7XG5cdFx0XHRzdGF0cy51cGRhdGUoKTtcblx0XHR9LFxuXG5cdFx0dGhyZWVSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4dHVyZTEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGV4dHVyZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGV4dHVyZTMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dmlkZW9NYXRlcmlhbC51bmlmb3Jtcy51TWl4UmF0aW8udmFsdWUgPSB0aGlzLmd1aU9wdGlvbnNbJ3VNaXhSYXRpbyddO1xuXHRcdFx0dmlkZW9NYXRlcmlhbC51bmlmb3Jtcy51VGhyZXNob2xkLnZhbHVlID0gdGhpcy5ndWlPcHRpb25zWyd1VGhyZXNob2xkJ107XG5cdFx0XHRpZiAodGhpcy5ndWlPcHRpb25zWyd1TWl4UmF0aW8nXSA9PSAwKSB7XG5cdFx0XHRcdHNjZW5lQi5yZW5kZXIoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5ndWlPcHRpb25zWyd1TWl4UmF0aW8nXSA9PSAxKSB7XG5cdFx0XHRcdHNjZW5lQS5yZW5kZXIoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjZW5lQS5yZW5kZXIoKTtcblx0XHRcdFx0c2NlbmVCLnJlbmRlcigpO1xuXHRcdFx0fVxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIG51bGwsIHRydWUpO1xuXHRcdH1cblxuXHR9KTtcbn0pO1xuXG4vLyBleHBvcnRcbm1vZHVsZS5leHBvcnRzID0gQXBwLkZYOyIsInZhciBBcHAgPSByZXF1aXJlKCcuLi9hcHAnKTtcbnZhciBkYXQgPSByZXF1aXJlKCdkYXQtZ3VpJyk7XG52YXIgU3RhdHMgPSByZXF1aXJlKCdzdGF0cycpO1xudmFyIFNIQURFUlNfTElCID0gcmVxdWlyZSgnLi4vY29tbW9uL3NoYWRlcl9saWInKTtcbnZhciBUSFJFRV9TQ0VORSA9IHJlcXVpcmUoJy4uL2NvbW1vbi90aHJlZV9zY2VuZScpO1xuLy8gYXBwIGRlcGVuZGVuY2llc1xudmFyIE5VTV9DT0xVTU5TID0gMjtcbnZhciBWSURFT19XSURUSCA9IDEyODA7XG52YXIgVklERU9fSEVJR0hUID0gNzIwO1xuXG52YXIgc3RhdHNFbmFibGVkID0gdHJ1ZTtcblxudmFyIGNvbnRhaW5lciwgc3RhdHMsIGxvYWRlcjtcbnZhciBjYW1lcmEsIHNjZW5lLCByZW5kZXJlcjtcblxudmFyIGdlb21ldHJ5O1xudmFyIHBsYW5lcztcbnZhciB2aWRlb1BsYW5lLCB2aWRlb01hdGVyaWFsLCB0ZXh0TWF0ZXJpYWwsIHRleHRNYXRlcmlhbFNpZGUsIHRleHRNYXRlcmlhbEZyb250LCB0ZXh0TWF0ZXJpYWxBcnJheSwgdGV4dENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4RkYwMDApO1xudmFyIHRleHR1cmUsIHRleHR1cmUyLCB2aWRlbztcbnZhciBwbGFuZXNHcm91cDtcblxuLy9Ob3JtYWwgbWFwIHNoYWRlclxudmFyIGFtYmllbnQgPSAweGZmZmZmZixcblx0ZGlmZnVzZSA9IDB4ZmZmZmZmIC8gNSxcblx0c3BlY3VsYXIgPSAweGZmZmZmZixcblx0c2NhbGUgPSAxNDM7XG5cbnZhciB0ZXh0TWVzaCwgdGV4dEdlbztcblxudmFyIHNwb3RMaWdodCwgcG9pbnRMaWdodCwgYW1iaWVudExpZ2h0O1xudmFyIGlzUmVuZGVyID0gdHJ1ZTtcblxudmFyIG1vdXNlWCA9IDA7XG52YXIgbW91c2VZID0gMDtcblxudmFyIGNvbnRyb2xzO1xuXG52YXIgd2luZG93SGFsZlggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XG52YXIgd2luZG93SGFsZlkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyO1xuXG4vLyBkZWZpbmUgbW9kdWxlXG5BcHAubW9kdWxlKCdWaWV3cycsIGZ1bmN0aW9uKFZpZXdzLCBBcHAsIEJhY2tib25lLCBNYXJpb25ldHRlLCAkLCBfKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdFZpZXdzLlNoYWRlclZpZXcgPSBNYXJpb25ldHRlLkl0ZW1WaWV3LmV4dGVuZCh7XG5cdFx0dGVtcGxhdGU6IEpTVFsneW91dHViZV90aHJlZSddLFxuXHRcdGV2ZW50czoge1xuXHRcdFx0J2NsaWNrIC5qcy1nbyc6ICdzdGFydFByb2Nlc3MnXG5cdFx0fSxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUNvdW50ZXIgPSAwO1xuXHRcdFx0dGhpcy5ndWlPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdHRoaXMuZ3VpT3B0aW9uc1snbnVtUGxhbmVzJ10gPSAxO1xuXHRcdFx0dGhpcy5ndWlPcHRpb25zWydzZXRTaGFkZXInXSA9ICdmcmFjdGFsMSc7XG5cdFx0fSxcblx0XHRvblJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvL2d1aVxuXHRcdFx0dmFyIGd1aSA9IG5ldyBkYXQuR1VJKCk7XG5cdFx0XHRndWkuYWRkKHRoaXMuZ3VpT3B0aW9ucywgJ251bVBsYW5lcycsIDEsIDQpLnN0ZXAoMSkub25DaGFuZ2UoZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdHRoaXMuY3JlYXRlUGxhbmVzKHZhbCk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdFx0Z3VpLmFkZCh0aGlzLmd1aU9wdGlvbnMsICdzZXRTaGFkZXInLCBbJ2ZyYWN0YWwxJywgJ2Nocm9tYScsICdjYXZlJ10pLm9uQ2hhbmdlKF8uZGVib3VuY2UoZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdHRoaXMuc2V0U2hhZGVyKHZhbCk7XG5cdFx0XHR9LDEwMCkuYmluZCh0aGlzKSk7XG5cblx0XHRcdGd1aS53aWR0aCA9IDMwMDtcblx0XHRcdHRoaXMuZ3VpID0gZ3VpO1xuXHRcdH0sXG5cdFx0b25TaG93OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRoaXMuJHRleHRFbCA9IHRoaXMuJGVsLmZpbmQoJy5UaHJlZUZvbnRzJyk7XG5cblx0XHRcdHRoaXMudmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215VmlkZW8nKTtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50LnZvbHVtZSA9IDA7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudC53aWR0aCA9IFZJREVPX1dJRFRIO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQuaGVpZ2h0ID0gVklERU9fSEVJR0hUO1xuXG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlWaWRlbzInKTtcblx0XHRcdHRoaXMudmlkZW9FbGVtZW50Mi52b2x1bWUgPSAwO1xuXHRcdFx0dGhpcy52aWRlb0VsZW1lbnQyLndpZHRoID0gVklERU9fV0lEVEg7XG5cdFx0XHR0aGlzLnZpZGVvRWxlbWVudDIuaGVpZ2h0ID0gVklERU9fSEVJR0hUO1xuXG5cdFx0XHR0aGlzLnNldHVwM0QoKTtcblx0XHR9LFxuXG5cdFx0Ly8vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vM0Rcblx0XHQvLy8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRzZXR1cDNEOiBmdW5jdGlvbigpIHtcblx0XHRcdHBsYW5lcyA9IFtdO1xuXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KFZJREVPX1dJRFRILCBWSURFT19IRUlHSFQsIDQ4MCwgMjcwKTtcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xuXG5cdFx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUodGhpcy52aWRlb0VsZW1lbnQpO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0dGV4dHVyZTIgPSBuZXcgVEhSRUUuVGV4dHVyZSh0aGlzLnZpZGVvRWxlbWVudDIpO1xuXHRcdFx0dGV4dHVyZTIubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZTIubWFnRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHR2YXIgX3MgPSBuZXcgVEhSRUVfU0NFTkUoKTtcblx0XHRcdHNjZW5lID0gX3MuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGhyZWUnKSwgdGhpcy50aHJlZVJlbmRlci5iaW5kKHRoaXMpKTtcblxuXHRcdFx0dGhpcy5zZXRTaGFkZXIoJ2NhdmUnKTtcblx0XHR9LFxuXG5cdFx0c2V0U2hhZGVyOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgZCA9IFNIQURFUlNfTElCW25hbWVdKCk7XG5cdFx0XHR2YXIgc2hhZGVyID0gZFsnc2hhZGVyJ107XG5cdFx0XHR2YXIgdW5pZm9ybXMgPSBkWyd1bmlmb3JtcyddO1xuXHRcdFx0dW5pZm9ybXNbXCJ0T25lXCJdLnZhbHVlID0gdGV4dHVyZTI7XG5cdFx0XHR1bmlmb3Jtc1tcInRUd29cIl0udmFsdWUgPSB0ZXh0dXJlO1xuXHRcdFx0dW5pZm9ybXNbXCJ0RGlzcGxhY2VtZW50XCJdLnZhbHVlID0gdGV4dHVyZTtcblx0XHRcdHVuaWZvcm1zW1widUFtYmllbnRDb2xvclwiXS52YWx1ZS5zZXRIZXgoYW1iaWVudCk7XG5cdFx0XHR1bmlmb3Jtc1tcInVEaWZmdXNlQ29sb3JcIl0udmFsdWUuc2V0SGV4KGRpZmZ1c2UpO1xuXG5cdFx0XHR1bmlmb3Jtc1tcInVXaWR0aFwiXS52YWx1ZSA9IFZJREVPX1dJRFRIO1xuXHRcdFx0dW5pZm9ybXNbXCJ1SGVpZ2h0XCJdLnZhbHVlID0gVklERU9fSEVJR0hUO1xuXHRcdFx0dW5pZm9ybXNbXCJ1UmVzXCJdLnZhbHVlID0gVklERU9fSEVJR0hUIC8gVklERU9fV0lEVEg7XG5cblx0XHRcdGNvbnNvbGUubG9nKHNoYWRlcik7XG5cdFx0XHRjb25zb2xlLmxvZyh1bmlmb3Jtcyk7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0ge1xuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0XHRzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdHVuaWZvcm1zOiB1bmlmb3Jtcyxcblx0XHRcdFx0bGlnaHRzOiB0cnVlLFxuXHRcdFx0XHRmb2c6IGZhbHNlLFxuXHRcdFx0XHRtYXA6IHRleHR1cmUsXG5cdFx0XHRcdHNpZGU6IFRIUkVFLkRvdWJsZVNpZGVcblx0XHRcdH07XG5cdFx0XHR2aWRlb01hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHBhcmFtZXRlcnMpO1xuXHRcdFx0dGhpcy5jcmVhdGVQbGFuZXMoKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlUGxhbmVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChwbGFuZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBsYW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBsYW5lc0dyb3VwLnJlbW92ZShwbGFuZXNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjZW5lLnJlbW92ZShwbGFuZXNHcm91cCk7XG5cdFx0XHRcdHBsYW5lcy5sZW5ndGggPSAwO1xuXHRcdFx0XHRwbGFuZXNHcm91cCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY29sdW1ucyA9IDI7XG5cdFx0XHR2YXIgcm93cyA9IDA7XG5cdFx0XHR2YXIgbnVtUGxhbmVzID0gdGhpcy5ndWlPcHRpb25zWydudW1QbGFuZXMnXTtcblx0XHRcdHBsYW5lc0dyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0XHQvL3BsYW5lc0dyb3VwLnBvc2l0aW9uLnNldCgwLCAtVklERU9fSEVJR0hUIC8gKG51bVBsYW5lcyAvIDIpLCAwKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGxhbmVzOyBpKyspIHtcblx0XHRcdFx0dmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgdmlkZW9NYXRlcmlhbCk7XG5cblx0XHRcdFx0dmFyIG9mZnNldFggPSBudW1QbGFuZXMgPiAxID8gMiAqIFZJREVPX1dJRFRIIC8gNCA6IDA7XG5cdFx0XHRcdHZhciBvZmZzZXRZID0gVklERU9fSEVJR0hUIC0gMjtcblx0XHRcdFx0aWYgKGkgJSBjb2x1bW5zICE9PSAwKSB7XG5cdFx0XHRcdFx0bWVzaC5wb3NpdGlvbi5zZXQoLW9mZnNldFgsIG9mZnNldFkgKiByb3dzLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbGFuZXNHcm91cC5wb3NpdGlvbi55ID0gLShvZmZzZXRZICogLjUpICogcm93cyAtIG9mZnNldFk7XG5cdFx0XHRcdFx0cm93cysrO1xuXHRcdFx0XHRcdG1lc2gucG9zaXRpb24uc2V0KG9mZnNldFgsIG9mZnNldFkgKiByb3dzLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwbGFuZXMucHVzaChtZXNoKTtcblx0XHRcdFx0cGxhbmVzR3JvdXAuYWRkKG1lc2gpO1xuXHRcdFx0fVxuXHRcdFx0c2NlbmUuYWRkKHBsYW5lc0dyb3VwKTtcblx0XHR9LFxuXG5cdFx0dGhyZWVSZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGV4dHVyZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRpZih2aWRlb01hdGVyaWFsKXtcblx0XHRcdFx0dmlkZW9NYXRlcmlhbC51bmlmb3Jtc1sndVRpbWUnXS52YWx1ZSA9IHRoaXMudXBkYXRlQ291bnRlciAvIDYwO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVDb3VudGVyKys7XG5cdFx0fVxuXG5cdH0pO1xufSk7XG5cbi8vIGV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBBcHAuU2hhZGVyVmlldzsiLCIvLyBhcHAgZGVwZW5kZW5jaWVzXG52YXIgQXBwID0gcmVxdWlyZSgnLi9hcHAvYXBwJyk7XG5cbi8vIGtpY2sgb2ZmXG5BcHAuc3RhcnQoKTsiXX0=
